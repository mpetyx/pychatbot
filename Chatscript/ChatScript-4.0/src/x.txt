#include "common.h"

int impliedIf = ALREADY_HANDLED;	// testing context of an if
unsigned int withinLoop = 0;

static char* TestIf(char* ptr,unsigned int& result)
{ //   word is a stream terminated by )
	//   if (%rand == 5 ) example of a comparison
	//   if (^QuerySubject()) example of a call or if (!QuerySubject())
	//   if ($var) example of existence
	//   if ('_3 == 5)  quoted matchvar
	//   if (1) what an else does
	char* word1 = AllocateBuffer();
	char* word2 = AllocateBuffer();
	char op[MAX_WORD_SIZE];
	unsigned int id;
	impliedIf = 1;
	blocked = true;
resume:
	ptr = ReadCompiledWord(ptr,word1);	//   the var or whatever
	bool invert = false;
	if (*word1 == '!') //   inverting, go get the actual
	{
		invert = true;
		// get the real token
		if (word1[1]) memmove(word1,word1+1,strlen(word1)); 
		else ptr = ReadCompiledWord(ptr,word1);	
	}

	ptr = ReadCompiledWord(ptr,op);		//   the test if any, or (for call or ) for closure or AND or OR
	bool call = false;
	if (*op == '(') // function call instead of a variable. but the function call might output a value which if not used, must be considered for failure
	{
		call = true;
		ptr -= strlen(word1) + 3; //   back up so output can see the fn name and space
		ChangeDepth(1,"TestIf");
		ptr = FreshOutput(ptr,word2,result,OUTPUT_ONCE|OUTPUT_KEEPSET); // word2 hold output value // skip past closing paren
		if (trace & TRACE_OUTPUT) 
		{
			if (result & ENDCODES) id = Log(STDUSERTABLOG,"If %c%s ",(invert) ? '!' : ' ',word1);
			else if (*word1 == '1' && word1[1] == 0) id = Log(STDUSERTABLOG,"else ");
			else id = Log(STDUSERTABLOG,"if %c%s ",(invert) ? '!' : ' ',word1);
		}
		ChangeDepth(-1,"TestIf");
		ptr = ReadCompiledWord(ptr,op); // find out what happens next after function call
		if (!result && IsComparison(*op)) // didnt fail and followed by a relationship op, move output as though it was the variable
		{
			 strcpy(word1,word2); 
			 call = false;	// proceed normally
		}
		else if (result) {;} // failed
		else if (!stricmp(word2,"0") || !stricmp(word2,"null")  || !stricmp(word2,"nil")) result = FAILRULE_BIT;	// treat 0 or null as failure along with actual failures
	}
		
	if (call){;} // call happened
	else if (IsComparison(*op)) //   a comparison test
	{
		ptr = ReadCompiledWord(ptr,word2);	
		result = HandleRelation(word1,op,word2,true,id);
		ptr = ReadCompiledWord(ptr,op);	//   AND, OR, or ) 
	}
	else //   existence of non-failure or any content
	{
		if (*word1 == '%' || *word1 == '_' || *word1 == '$' || *word1 == '@')
		{
			char* found;
			if (*word1 == '%') found = SystemVariable(word1,NULL);
			else if (*word1 == '_') found = wildcardCanonicalText[GetWildcardID(word1)];
			else if (*word1 == '$') found = GetUserVariable(word1);
			else found =  FACTSET_COUNT(GetSetID(word1)) ? (char*) "1" : (char*) "";
			if (trace & TRACE_OUTPUT) 
			{
				if (!*found) 
				{
					if (invert) id = Log(STDUSERTABLOG,"If !%s (null) ",word1);
					else id = Log(STDUSERTABLOG,"If %s (null) ",word1);
				}
				else 
				{
					if (invert) id = Log(STDUSERTABLOG,"If !%s (%s) ",word1,found);
					else id = Log(STDUSERTABLOG,"If %s (%s) ",word1,found);
				}
			}
			if (!*found) result = FAILRULE_BIT;
			else result = 0;
		}
		else  //  its a constant of some kind 
		{
			if (trace & TRACE_OUTPUT) 
			{
				if (result & ENDCODES) id = Log(STDUSERTABLOG,"If %c%s ",(invert) ? '!' : ' ',word1);
				else if (*word1 == '1' && word1[1] == 0) id = Log(STDUSERTABLOG,"else ");
				else id = Log(STDUSERTABLOG,"if %c%s ",(invert) ? '!' : ' ',word1);
			}
			ptr -= strlen(word1) + 3; //   back up to process the word and space
			ptr = FreshOutput(ptr,word2,result,OUTPUT_ONCE|OUTPUT_KEEPSET) + 2; //   returns on the closer and we skip to accel
		}
	}
	if (invert) result = (result & ENDCODES) ? 0 : FAILRULE_BIT; 

	if (*op == 'a') //   AND - compiler validated it
	{
		if (!(result & ENDCODES)) 
		{
			if (trace & TRACE_OUTPUT) id = Log(STDUSERLOG," AND ");
			goto resume;
			//   If he fails (result is one of ENDCODES), we fail
		}
		else 
		{
			if (trace & TRACE_OUTPUT) id = Log(STDUSERLOG," ... ");
			ptr = BalanceParen(ptr,true); //   find the end ) and skip over it to jump code, code is already fail
		}
	}
	else if (*op == 'o') //  OR
	{
		if (!(result & ENDCODES)) 
		{
			if (trace & TRACE_OUTPUT) id = Log(STDUSERLOG," ... ");
			result = 0;
			ptr = BalanceParen(ptr,true);
		}
		else 
		{
			if (trace & TRACE_OUTPUT) id = Log(STDUSERLOG," OR ");
			goto resume;
		}
	}
	blocked = false;
	FreeBuffer();
	FreeBuffer();
	if (trace & TRACE_OUTPUT &&  (result & ENDCODES)) Log(id,"%s\r\n", "FAIL-if");
	impliedIf = ALREADY_HANDLED;
	return ptr;
}

char* HandleIf(char* ptr, char* buffer,unsigned int& result)
{
	while (ALWAYS) //   do test conditions until match
	{
		//   Perform TEST condition
		ptr = TestIf(ptr+2,result); //   skip (space, returns on accelerator
						
		//   perform SUCCESS branch and then end if
		if (!(result & ENDCODES)) //   IF success
		{
			ChangeDepth(1,"HandleIf");
			if (debugger) Debugger(ENTER_IF,0,ptr);
			ChangeDepth(1,"HandleIf");
			ptr = Output(ptr+5,buffer,result); //   skip accelerator and space and { and space - returns on next useful token
			ChangeDepth(-1,"HandleIf");
			ptr += Decode(ptr);	//   offset to end of if
			if (debugger) Debugger(EXIT_IF,0,ptr);
			ChangeDepth(-1,"HandleIf");
			break;
		}
		else result = 0;		//   test result is not the IF result
	
		//   On fail, move to next test
		ptr += Decode(ptr);
		if (strncmp(ptr,"else ",5))  break; //   not an ELSE, the IF is over. Will be closing accellerator
		ptr += 5; //   skip over ELSE space, aiming at the (of the condition
	}
	return ptr;
} 

char* HandleLoop(char* ptr, char* buffer, unsigned int &result)
{
	unsigned int oldIterator = currentIterator;
	currentIterator = 0;
	char* word = AllocateBuffer();
	blocked = true;
	ptr = ReadCommandArg(ptr+2,word,result)+2; //   get the loop counter value and skip closing ) space 
	blocked = false;
	char* endofloop = ptr + (size_t) Decode(ptr);
	int counter = atoi(word);
	FreeBuffer();
	if (result & ENDCODES) return endofloop;

	++withinLoop;

	ptr += 5;	//   skip jump + space + { + space
	if (counter > 1000 || counter < 0) counter = 1000; //   LIMITED
	while (counter-- > 0)
	{
		ChangeDepth(2,"HandleLoop");
		if (debugger) Debugger(ENTER_LOOP,0,ptr);
		if (trace & TRACE_OUTPUT) Log(STDUSERTABLOG,"loop (%d)\r\n",counter+1);
		unsigned int result1;
		Output(ptr,buffer,result1,OUTPUT_LOOP);
		buffer += strlen(buffer);
		if (debugger) Debugger(EXIT_LOOP,0,0);
		ChangeDepth(-2,"HandleLoop");
		if (result1 & ENDCODES) 
		{
			result = (result1 & (ENDRULE_BIT | FAILRULE_BIT)) ? 0 : result1 & ENDCODES;  // rule level terminates only the loop
			break;//   potential failure if didnt add anything to buffer
		}
	}
	if (trace & TRACE_OUTPUT) Log(STDUSERTABLOG,"end of loop\r\n");
	--withinLoop;

	currentIterator = oldIterator;
	return endofloop;
}  

unsigned int HandleRelation(char* word1,char* op, char* word2,bool output,unsigned int& id)
{ //   word1 and word2 are RAW, ready to be evaluated.
	char* val1 = AllocateBuffer();
	char* val2 = AllocateBuffer();
	WORDP D;
	WORDP D1;
	WORDP D2;
	unsigned int result,val1Result;
	FreshOutput(word1,val1,result,OUTPUT_ONCE|OUTPUT_KEEPSET|OUTPUT_NOCOMMANUMBER); // 1st arg
	val1Result = result;
	if (word2 && *word2) FreshOutput(word2,val2,result,OUTPUT_ONCE|OUTPUT_KEEPSET|OUTPUT_NOCOMMANUMBER); // 2nd arg
	result = FAILRULE_BIT;
	if (!stricmp(val1,"null") || !stricmp(val1,"nil")) *val1 = 0;
	if (!stricmp(val2,"null") || !stricmp(val2,"nil")) *val2 = 0;
	if (!op)
	{
		if (val1Result & ENDCODES); //   explicitly failed
		else if (*val1) result = 0;	//   has some value
	}
	else if (*op == '?' || op[1] == '?') // ? and !? 
	{
		if (*word1 == '\'') ++word1; // ignore the quote since we are doing positional
		if (*word1 == '_') // try for precomputed match
		{
			unsigned int index = GetWildcardID(word1);
			index = WILDCARD_START(wildcardPosition[index]);
			D = FindWord(val2);
			if (index && D)
			{
				unsigned int junk,junk1;
				result = (GetNextSpot(D,index-1,junk,junk1) == index) ? 0 : FAILRULE_BIT;
			}
			else // laborious match
			{
				D1 = FindWord(val1);
				if (D1 && D)
				{
					NextinferMark();
					if (SetContains(MakeMeaning(D),MakeMeaning(D1))) result = 0;
				}
			}
			if (*op == '!') result = (result) ? 0 : FAILRULE_BIT;
		}
		else // laborious.
		{
			D1 = FindWord(val1);
			D2 = FindWord(val2);
			if (D1 && D2)
			{
				NextinferMark();
				if (SetContains(MakeMeaning(D2),MakeMeaning(D1))) result = 0;
			}
			if (result != 0)
			{
				char* verb = GetInfinitive(val1,true);
				if (verb && stricmp(verb,val1))
				{
					D1 = FindWord(verb);
					if (D1 && D2)
					{
						NextinferMark();
						if (SetContains(MakeMeaning(D2),MakeMeaning(D1))) result = 0;
					}
				}
			}
			if (result != 0)
			{
				char* noun = GetSingularNoun(val1,true,true);
				if (noun && stricmp(noun,val1))
				{
					D1 = FindWord(noun);
					if (D1 && D2)
					{
						NextinferMark();
						if (SetContains(MakeMeaning(D2),MakeMeaning(D1))) result = 0;
					}
				}
			}
			if (*op == '!') result = (result) ? 0 : FAILRULE_BIT;
		}
	}
	else //   boolean tests
	{
		// convert null to numeric operator for < or >  -- but not for equality
		if (!*val1 && IsDigit(*val2) && (*op == '<' || *op == '>')) strcpy(val1,"0");
		else if (!*val2 && IsDigit(*val1) && (*op == '<' || *op == '>')) strcpy(val2,"0");

		if (!IsNumberStarter(*val1) || !IsNumberStarter(*val2) ) //   non-numeric string compare - bug, can be confused if digit starts text string
		{
			char* arg1 = val1;
			char* arg2 = val2;
			if (*arg1 == '"')
			{
				size_t len = strlen(arg1);
				if (arg1[len-1] == '"') // remove STRING markers
				{
					arg1[len-1] = 0;
					++arg1;
				}
			}
			if (*arg2 == '"')
			{
				size_t len = strlen(arg2);
				if (arg2[len-1] == '"') // remove STRING markers
				{
					arg2[len-1] = 0;
					++arg2;
				}
			}			
			if (*op == '!') result = (stricmp(arg1,arg2)) ? 0 : FAILRULE_BIT;
			else if (*op == '=') result = (!stricmp(arg1,arg2)) ? 0 : FAILRULE_BIT;
			else result = FAILRULE_BIT;
		}
		//   handle float ops
		else if ((strchr(val1,'.') && val1[1]) || (strchr(val2,'.') && val2[1])) // at least one arg is float
		{
			char* comma = 0; 
			while ((comma = strchr(val1,',')))  memmove(comma,comma+1,strlen(comma+1)); // remove embedded commas
			while ((comma = strchr(val2,',')))  memmove(comma,comma+1,strlen(comma+1)); // remove embedded commas
			float v1 = (float) atof(val1);
			float v2 = (float) atof(val2);
			if (*op == '=') result = (v1 == v2) ? 0 : FAILRULE_BIT;
			else if (*op == '<') 
			{
				if (!op[1]) result =  (v1 < v2) ? 0 : FAILRULE_BIT;
				else result =  (v1 <= v2) ? 0 : FAILRULE_BIT;
			}
			else if (*op == '>') 
			{
				if (!op[1]) result =  (v1 > v2) ? 0 : FAILRULE_BIT;
				else result =  (v1 >= v2) ? 0 : FAILRULE_BIT;
			}
			else if (*op == '!') result = (v1 != v2) ? 0 : FAILRULE_BIT;
			else if (*op == '?') 
			{
				if (v1 > v2) result = 2;
				if (v1 < v2) result = 0;
				result = 1;
			}
			else result = FAILRULE_BIT;
		}
		else //   int compare
		{
			char* comma =  0; // pretty number?
			while ((comma = strchr(val1,',')))  memmove(comma,comma+1,strlen(comma+1));
			while ((comma = strchr(val2,',')))  memmove(comma,comma+1,strlen(comma+1));
			int64 v1;
			int64 v2;
			ReadInt64(val1,v1);
			ReadInt64(val2,v2);
			if (*op == '?') //   internal
			{
				if (v1 > v2) result = 2;
				else if (v1 < v2) result = 0;
				else result = 1;
			}
			else if (strchr(val1,',') && strchr(val2,',')) // comma numbers
			{
				size_t len1 = strlen(val1);
				size_t len2 = strlen(val2);
				if (len1 != len2) result = FAILRULE_BIT;
				else if (strcmp(val1,val2)) result = FAILRULE_BIT;
				else result = 0;
				if (*op == '!') result =  (result == 0) ? FAILRULE_BIT : 0;
				else if (*op != '=') ReportBug("Op not implemented for comma numbers %s",op)
			}
			else if (*op == '=') result =  (v1 == v2) ? 0 : FAILRULE_BIT;
			else if (*op == '<') 
			{
				if (!op[1]) result =  (v1 < v2) ? 0 : FAILRULE_BIT;
				else result =  (v1 <= v2) ? 0 : FAILRULE_BIT;
			}
			else if (*op == '>') 
			{
				if (!op[1]) result =  (v1 > v2) ? 0 : FAILRULE_BIT;
				else result =  (v1 >= v2) ? 0 : FAILRULE_BIT;
			}
			else if (*op == '!') result =  (v1 != v2) ? 0 : FAILRULE_BIT;
			else if (*op == '&') result =  (v1 & v2) ? 0 : FAILRULE_BIT;
			else result =  FAILRULE_BIT;
		}
	}
	if (trace & TRACE_OUTPUT && output) 
	{
		if (!stricmp(word1,val1)) 
		{
			if (*word1) Log(STDUSERTABLOG,"if %s %s ",word1,op); // no need to show value
			else Log(STDUSERTABLOG,"if null %s ",op);
		}
		else if (!*val1) Log(STDUSERTABLOG,"if  %s (null) %s ",word1,op);
		else Log(STDUSERTABLOG,"if  %s (%s) %s ",word1,val1,op);
		if (!strcmp(word2,val2)) 
		{
			if (*val2) id = Log(STDUSERLOG," %s ",word2); // no need to show value
			else id = Log(STDUSERLOG," null "); 
		}
		else if (!*val2)  id = Log(STDUSERLOG," %s (null) ",word2);
		else  id = Log(STDUSERLOG," %s (%s) ",word2,val2);
	}
	else if (trace & TRACE_PATTERN && !output) 
	{
		if (!stricmp(word1,val1))
		{
			if (*word1) Log(STDUSERLOG,"%s %s ",word1,op); // dont need to show value
			else Log(STDUSERLOG,"null %s ",op); 
		}
		else if (!*val1) Log(STDUSERTABLOG,"if  %s (null) %s  ",word1,op);
		else  Log(STDUSERLOG,"%s (%s) %s ",word1,val1,op);
		if (!(strcmp(word2,val2))) 
		{
			if (*val2)  id = Log(STDUSERLOG,"%s ",word2); // dont need to show value
			else id = Log(STDUSERLOG,"null "); 
		}
		else if (!*val2)  id = Log(STDUSERLOG," %s (null) ",word2);
		else  id = Log(STDUSERLOG," %s (%s) ",word2, val2);
	}

	FreeBuffer();
	FreeBuffer();
	return result;
}
// csocket.cpp - handles client/server behaviors  (not needed in a product)

/*
 *   C++ sockets on Unix and Windows Copyright (C) 2002 --- see HEADER file
 */

#ifdef INFORMATION
We have these threads:

1. HandleTCPClient which runs on a thread to service a particular client (as many threads as clients)
2. AcceptSockets, which is a simnple thread waiting for user connections
3. ChatbotServer, which is the sole server to be the chatbot
4. main thread, which is a simple thread that creates ChatbotServer threads as needed (if ones crash in LINUX, it can spawn a new one)

chatLock- either chatbot engine or a client controls it. It is how a client gets started and then the server is summoned

While processing chat, the client holds the clientlock and the server holds the chatlock and donelock.
The client is waiting for the donelock.
When the server finishes, he releases the donelock and waits for the clientlock.
If the client exists, server gets the donelock, then releases it and waits for the clientlock.
If the client doesnt exist anymore, he has released clientlock.

It releases the clientlock and the chatlock and tries to reacquire chatlock with flag on.
when it succeeds, it has a new client.

We have these variables :
chatbotExists - the chatbot engine is now initialized.
serverFinishedBy is what time the answer must be delivered (1 second before the memory will disappear)

#endif

#include "common.h"

bool echoServer = false;
char outputFeed[MAX_BUFFER_SIZE];

#ifdef WIN32
static bool initialized = false; // winsock init
#endif

char serverIP[100];

#ifndef DISCARDSERVER
#define DOSOCKETS 1
#endif
#ifndef DISCARDCLIENT
#define DOSOCKETS 1
#endif
#ifndef DISCARDTCPOPEN
#define DOSOCKETS 1
#endif

#ifdef DOSOCKETS

// CODE below here is from PRACTICAL SOCKETS, needed for either a server or a client

//   SocketException Code

SocketException::SocketException(const string &message, bool inclSysMsg)
  throw() : userMessage(message) {
  if (inclSysMsg) {
    userMessage.append(": ");
    userMessage.append(strerror(errno));
  }
}

SocketException::~SocketException() throw() {}
const char *SocketException::what() const throw() { return userMessage.c_str();}

//   Function to fill in address structure given an address and port
static void fillAddr(const string &address, unsigned short port, sockaddr_in &addr) {
  memset(&addr, 0, sizeof(addr));  //   Zero out address structure
  addr.sin_family = AF_INET;       //   Internet address
  hostent *host;  //   Resolve name
  if ((host = gethostbyname(address.c_str())) == NULL)  throw SocketException("Failed to resolve name (gethostbyname())");
  addr.sin_addr.s_addr = *((unsigned long *) host->h_addr_list[0]);
  addr.sin_port = htons(port);     //   Assign port in network byte order
}

//   Socket Code
#define MAKEWORDX(a, b)      ((unsigned short)(((BYTE)(((DWORD_PTR)(a)) & 0xff)) | ((unsigned short)((BYTE)(((DWORD_PTR)(b)) & 0xff))) << 8))

CSocket::CSocket(int type, int protocol) throw(SocketException) {
  #ifdef WIN32
    if (!initialized) {
      WSADATA wsaData;
      unsigned short wVersionRequested = MAKEWORDX(2, 0);              //   Request WinSock v2.0
      if (WSAStartup(wVersionRequested, &wsaData) != 0) throw SocketException("Unable to load WinSock DLL");  //   Load WinSock DLL
      initialized = true;
    }
  #endif

  //   Make a new socket
  if ((sockDesc = socket(PF_INET, type, protocol)) < 0)  throw SocketException("Socket creation failed (socket())", true);
}

CSocket::CSocket(int sockDesc) {this->sockDesc = sockDesc;}

CSocket::~CSocket() {
  #ifdef WIN32
    ::closesocket(sockDesc);
  #else
    ::close(sockDesc);
  #endif
  sockDesc = -1;
}

string CSocket::getLocalAddress() throw(SocketException) {
  sockaddr_in addr;
  unsigned int addr_len = sizeof(addr);
  if (getsockname(sockDesc, (sockaddr *) &addr, (socklen_t *) &addr_len) < 0)  throw SocketException("Fetch of local address failed (getsockname())", true);
  return inet_ntoa(addr.sin_addr);
}

unsigned short CSocket::getLocalPort() throw(SocketException) {
  sockaddr_in addr;
  unsigned int addr_len = sizeof(addr);
  if (getsockname(sockDesc, (sockaddr *) &addr, (socklen_t *) &addr_len) < 0)  throw SocketException("Fetch of local port failed (getsockname())", true);
  return ntohs(addr.sin_port);
}

void CSocket::setLocalPort(unsigned short localPort) throw(SocketException) {
#ifdef WIN32
    if (!initialized) 
	{
      WORD wVersionRequested;
      WSADATA wsaData;

      wVersionRequested = MAKEWORD(2, 0);              // Request WinSock v2.0
      if (WSAStartup(wVersionRequested, &wsaData) != 0) {  // Load WinSock DLL
        throw SocketException("Unable to load WinSock DLL");
      }
      initialized = true;
    }
  #endif

	int on = 1;
#ifdef WIN32
	setsockopt(sockDesc, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof(on));
#else
	setsockopt(sockDesc, SOL_SOCKET, SO_REUSEADDR, (void*) &on, sizeof(on));
#endif
	
	//   Bind the socket to its port
	sockaddr_in localAddr;
	memset(&localAddr, 0, sizeof(localAddr));
	localAddr.sin_family = AF_INET;
	localAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	localAddr.sin_port = htons(localPort);
	if (bind(sockDesc, (sockaddr *) &localAddr, sizeof(sockaddr_in)) < 0) throw SocketException("Set of local port failed (bind())", true);
}

void CSocket::setLocalAddressAndPort(const string &localAddress,
    unsigned short localPort) throw(SocketException) {
	//   Get the address of the requested host
	sockaddr_in localAddr;
	fillAddr(localAddress, localPort, localAddr);
	int on = 1;
#ifdef WIN32
	setsockopt(sockDesc, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof(on));
#else
	setsockopt(sockDesc, SOL_SOCKET, SO_REUSEADDR, (void*) &on, sizeof(on));
#endif
	if (bind(sockDesc, (sockaddr *) &localAddr, sizeof(sockaddr_in)) < 0)  throw SocketException("Set of local address and port failed (bind())", true);
}

void CSocket::cleanUp() throw(SocketException) {
  #ifdef WIN32
    if (WSACleanup() != 0)  throw SocketException("WSACleanup() failed");
  #endif
}

unsigned short CSocket::resolveService(const string &service,
                                      const string &protocol) {
  struct servent *serv;        /* Structure containing service information */
  if ((serv = getservbyname(service.c_str(), protocol.c_str())) == NULL) return (unsigned short) atoi(service.c_str());  /* Service is port number */
  else return ntohs(serv->s_port);    /* Found port (network byte order) by name */
}

//   CommunicatingSocket Code

CommunicatingSocket::CommunicatingSocket(int type, int protocol)  throw(SocketException) : CSocket(type, protocol) {
}

CommunicatingSocket::CommunicatingSocket(int newConnSD) : CSocket(newConnSD) {
}

void CommunicatingSocket::connect(const string &foreignAddress,unsigned short foreignPort) throw(SocketException) {
  //   Get the address of the requested host
  sockaddr_in destAddr;
  fillAddr(foreignAddress, foreignPort, destAddr);

  //   Try to connect to the given port
  if (::connect(sockDesc, (sockaddr *) &destAddr, sizeof(destAddr)) < 0)   throw SocketException("Connect failed (connect())", true);
}

void CommunicatingSocket::send(const void *buffer, int bufferLen) throw(SocketException) {
  if (::send(sockDesc, (raw_type *) buffer, bufferLen, 0) < 0)  throw SocketException("Send failed (send())", true);
}

int CommunicatingSocket::recv(void *buffer, int bufferLen) throw(SocketException) {
  int rtn;
  if ((rtn = ::recv(sockDesc, (raw_type *) buffer, bufferLen, 0)) < 0)  throw SocketException("Received failed (recv())", true);
  return rtn;
}

string CommunicatingSocket::getForeignAddress()  throw(SocketException) {
  sockaddr_in addr;
  unsigned int addr_len = sizeof(addr);
  if (getpeername(sockDesc, (sockaddr *) &addr,(socklen_t *) &addr_len) < 0)  throw SocketException("Fetch of foreign address failed (getpeername())", true);
  return inet_ntoa(addr.sin_addr);
}

unsigned short CommunicatingSocket::getForeignPort() throw(SocketException) {
  sockaddr_in addr;
  unsigned int addr_len = sizeof(addr);
  if (getpeername(sockDesc, (sockaddr *) &addr, (socklen_t *) &addr_len) < 0)  throw SocketException("Fetch of foreign port failed (getpeername())", true);
  return ntohs(addr.sin_port);
}

//   TCPSocket Code

TCPSocket::TCPSocket() throw(SocketException) : CommunicatingSocket(SOCK_STREAM, IPPROTO_TCP) {
}

TCPSocket::TCPSocket(const string &foreignAddress, unsigned short foreignPort) throw(SocketException) : CommunicatingSocket(SOCK_STREAM, IPPROTO_TCP) {
  connect(foreignAddress, foreignPort);
}

TCPSocket::TCPSocket(int newConnSD) : CommunicatingSocket(newConnSD) {
}

//   TCPServerSocket Code

TCPServerSocket::TCPServerSocket(unsigned short localPort, int queueLen) throw(SocketException) : CSocket(SOCK_STREAM, IPPROTO_TCP) {
  setLocalPort(localPort);
  setListen(queueLen);
}

TCPServerSocket::TCPServerSocket(const string &localAddress, unsigned short localPort, int queueLen) throw(SocketException) : CSocket(SOCK_STREAM, IPPROTO_TCP) {
  setLocalAddressAndPort(localAddress, localPort);
  setListen(queueLen);
}

TCPSocket *TCPServerSocket::accept() throw(SocketException) {
  int newConnSD;
  if ((newConnSD = ::accept(sockDesc, NULL, 0)) < 0)  throw SocketException("Accept failed (accept())", true);
  return new TCPSocket(newConnSD);
}

void TCPServerSocket::setListen(int queueLen) throw(SocketException) {
  if (listen(sockDesc, queueLen) < 0)  throw SocketException("Set listening socket failed (listen())", true);
}

#endif

#ifndef DISCARDCLIENT

void Client(char* login)// test client for a server
{
	printf("\r\n\r\n** Client launched\r\n");
	char* data = AllocateBuffer();
	char* from = login;
	char* separator = strchr(from,':'); // login is username  or  username:botname
	char* bot;
	if (separator)
	{
		*separator = 0;
		bot = separator + 1;
	}
	else bot = from + strlen(from);	// just a 0
	sprintf(logFilename,"log-%s.txt",from);

	// message to server is 3 strings-   username, botname, null (start conversation) or message
	char* ptr = data;
	strcpy(ptr,from);
	ptr += strlen(ptr) + 1;
	strcpy(ptr,bot);
	ptr += strlen(ptr) + 1;
	echo = 1;
	*ptr = 0; // null message - start conversation
	while (ALWAYS)
	{
		try 
		{
			size_t len = (ptr-data) + 1 + strlen(ptr);
			TCPSocket *sock = new TCPSocket(serverIP, (unsigned short)port);
			sock->send(data, len );
			printf("Sent data to port %d\r\n",port);

			int bytesReceived = 1;              // Bytes read on each recv()
			int totalBytesReceived = 0;         // Total bytes read
			char* base = ptr;
			while (bytesReceived > 0) 
			{
				// Receive up to the buffer size bytes from the sender
				bytesReceived = sock->recv(base, MAX_WORD_SIZE);
				totalBytesReceived += bytesReceived;
				base += bytesReceived;
				printf("Received %d bytes\r\n",bytesReceived);
			}
			delete(sock);
			*base = 0;
			printf("Received response: %s\r\n",ptr);

			// chatbot replies this
			Log(STDUSERLOG,"%s",ptr);

			// we say that  until :exit
			printf("\r\n>    ");
			ReadALine(ptr,stdin);
			if (!stricmp(ptr,":exit")) break;
		}
		catch(SocketException e) { myexit("failed to connect to server\r\n");}
	}
}
#endif

#ifndef DISCARDSERVER

#define SERVERTRANSERSIZE 10000 // no more than 10K coming in
#ifdef WIN32
  #pragma warning(push,1)
  #pragma warning(disable: 4290) 
#endif
#include <cstdio>
#include <errno.h>  
using namespace std;

static TCPServerSocket* serverSocket = NULL;

unsigned int serverFinishedBy = 0; // server must complete by this or not bother

// buffers used to send in and out of chatbot
static char inputFeed[INPUT_BUFFER_SIZE];

static char* clientBuffer;			//   current client spot input was and output goes
static bool chatWanted = false;		//  client is still expecting answer (has not timed out/canceled)
static bool chatbotExists = false;	//	has chatbot engine been set up and ready to go?
static int pendingClients = 0;          // number of clients waiting for server to handle them

static void* MainChatbotServer();
static void* HandleTCPClient(void *sock1);
static void* AcceptSockets(void*);
static unsigned int errorCount = 0;
static time_t lastCrash = 0;
static int loadid = 0;

clock_t startServerTime;

#ifndef WIN32 // for LINUX
#include <pthread.h> 
#include <signal.h> 
pthread_t chatThread;
static pthread_mutex_t chatLock = PTHREAD_MUTEX_INITIALIZER;	//   access lock to shared chatbot processor 
static pthread_mutex_t logLock = PTHREAD_MUTEX_INITIALIZER;		//   right to use log file output
static pthread_mutex_t testLock = PTHREAD_MUTEX_INITIALIZER;	//   right to use test memory
static pthread_cond_t  server_var   = PTHREAD_COND_INITIALIZER; // client ready for server to proceed
static pthread_cond_t  server_done_var   = PTHREAD_COND_INITIALIZER;	// server ready for clint to take data

#else // for WINDOWS
#include <winsock.h>    
HANDLE  hChatLockMutex;    
int     ThreadNr;     
CRITICAL_SECTION LogCriticalSection; 
CRITICAL_SECTION TestCriticalSection; 
#endif

void* RegressLoad(void* junk)// test load for a server
{
	FILE* in = fopen("REGRESS/bigregress.txt","rb");
	if (!in) return 0;
	
	char buffer[8000];
	printf("\r\n\r\n** Load %d launched\r\n",++loadid);
	char data[MAX_WORD_SIZE];
	char from[100];
	sprintf(from,"%d",loadid);
	char* bot = "";
	sprintf(logFilename,"log-%s.txt",from);
	unsigned int msg = 0;
	unsigned int volleys = 0;
	unsigned int longVolleys = 0;
	unsigned int xlongVolleys = 0;

	int maxTime = 0;
	int cycleTime = 0;
	int currentCycleTime = 0;
	int avgTime = 0;

	// message to server is 3 strings-   username, botname, null (start conversation) or message
	echo = 1;
	char* ptr = data;
	strcpy(ptr,from);
	ptr += strlen(ptr) + 1;
	strcpy(ptr,bot);
	ptr += strlen(ptr) + 1;
	*buffer = 0;
	int counter = 0;
	while (1)
	{
		if (!ReadALine(revertBuffer+1,in,INPUT_BUFFER_SIZE)) break; // end of input
		// when reading from file, see if line is empty or comment
		char word[MAX_WORD_SIZE];
		ReadCompiledWord(revertBuffer+1,word);
		if (!*word || *word == '#' || *word == ':') continue;
		strcpy(ptr,revertBuffer+1);
		try 
		{
			size_t len = (ptr-data) + 1 + strlen(ptr);
			++volleys;
			clock_t start_time = ElapsedMilliseconds();

			TCPSocket *sock = new TCPSocket(serverIP, port);
			sock->send(data, len );
	
			int bytesReceived = 1;              // Bytes read on each recv()
			int totalBytesReceived = 0;         // Total bytes read
			char* base = ptr;
			while (bytesReceived > 0) 
			{
				// Receive up to the buffer size bytes from the sender
				bytesReceived = sock->recv(base, MAX_WORD_SIZE);
				totalBytesReceived += bytesReceived;
				base += bytesReceived;
			}
			clock_t end_time = ElapsedMilliseconds();
	
			delete(sock);
			*base = 0;
			int diff = end_time - start_time;
			if (diff > maxTime) maxTime = diff;
			if ( diff > 2000) ++longVolleys;
			if (diff > 5000) ++ xlongVolleys;
			currentCycleTime += diff;
			// chatbot replies this
		//	printf("real:%d avg:%d max:%d volley:%d 2slong:%d 5slong:%d %s => %s\r\n",diff,avgTime,maxTime,volleys,longVolleys,xlongVolleys,ptr,base);
		}
		catch(SocketException e) { myexit("failed to connect to server\r\n");}
		if (++counter == 100) 
		{
			counter = 0;
			cycleTime = currentCycleTime;
			currentCycleTime = 0;
			avgTime = cycleTime / 100;
			printf("From: %s avg:%d max:%d volley:%d 2slong:%d 5slong:%d\r\n",from,avgTime,maxTime,volleys,longVolleys,xlongVolleys);
		}
		else msg++;
	}
	return 0;
}

#ifndef EVSERVER
static void Crash()
{
    time_t now = time(0);
    unsigned int delay = (unsigned int) difftime(now,lastCrash);
    if (delay > 180) errorCount = 0; //   3 minutes delay is fine
    lastCrash = now;
    ++errorCount;
	if (errorCount > 6) myexit("too many crashes in a row"); //   too many crashes in a row, let it reboot from scratch
#ifndef WIN32
	//   clear chat thread if it crashed
	if (chatThread == pthread_self()) 
    {
		if (!chatbotExists ) myexit("chatbot server doesn't exist anymore");
        chatbotExists = false;
        chatWanted = false;
        pthread_mutex_unlock(&chatLock); 
    }
#endif
	longjmp(scriptJump[SERVER_RECOVERY],1);
}

#ifdef __MACH__
int pthread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec *abs_timeout)
{
	int result;
	struct timespec ts1;
	do
	{
		result = pthread_mutex_trylock(mutex);
		if (result == EBUSY)
		{
			timespec ts;
			ts.tv_sec = 0;
			ts.tv_sec = 10000000;

			/* Sleep for 10,000,000 nanoseconds before trying again. */
			int status = -1;
			while (status == -1) status = nanosleep(&ts, &ts);
		}
		else break;
		clock_get_mactime(ts1);
	}
	while (result != 0 and (abs_timeout->tv_sec == 0 ||  abs_timeout->tv_sec > ts1.tv_sec )); // if we pass to new second

	return result;
}
#endif 

// LINUX/MAC SERVER
#ifndef WIN32

void GetLogLock()  //LINUX
{
	pthread_mutex_lock(&logLock); 
}

void ReleaseLogLock()  //LINUX
{
	pthread_mutex_unlock(&logLock); 
}

void GetTestLock() //LINUX
{
	pthread_mutex_lock(&testLock); 
}

void ReleaseTestLock()  //LINUX
{
	pthread_mutex_unlock(&testLock); 
}

static bool ClientGetChatLock()  //LINUX
{
    int rc = pthread_mutex_lock(&chatLock);
    if (rc != 0 ) return false;	// we timed out
    return true;
}

static bool ClientWaitForServer(char* data,char* msg,unsigned long& timeout) //LINUX
{
	timeout = GetFutureSeconds(10);
	serverFinishedBy = timeout - 1;
	
    pendingClients++;
	pthread_cond_signal( &server_var ); // let server know he is needed
	int rc = pthread_cond_wait(&server_done_var, &chatLock);

     // error, timeout etc.
     bool rv = true;
     if (rc != 0) rv = false;  // mutex already unlocked
     else if (*data != 0)  rv = false;
     pthread_mutex_unlock(&chatLock);
	return rv;
}

static void LaunchClient(void* junk) // accepts incoming connections from users  //LINUX
{
	pthread_t clientThread;     
	pthread_attr_t attr; 
    pthread_attr_init(&attr); 
	pthread_attr_setdetachstate(&attr,  PTHREAD_CREATE_DETACHED);
	int val = pthread_create(&clientThread,&attr,HandleTCPClient,(void*)junk);
	int x;
	if ( val != 0)
	{
		 switch(val)
		 {
			case EAGAIN: 
			  x = sysconf( _SC_THREAD_THREADS_MAX );
			  printf("create thread failed EAGAIN limit: %d \r\n",(int)x);   
			  break;
			case EPERM:  printf("create thread failed EPERM \r\n");   break;
			case EINVAL:  printf("create thread failed EINVAL \r\n");   break;
			default:  printf("create thread failed default \r\n");   break;
		 }
	 }
}

//   use sigaction instead of signal -- bug

//   we really only expect the chatbot thread to crash, when it does, the chatLock will be under its control
void AnsiSignalMapperHandler(int sigNumber) 
{
    signal(-1, AnsiSignalMapperHandler); 
    Crash();
}

void fpViolationHandler(int sigNumber) 
{
    Crash();
}

void SegmentFaultHandler(int sigNumber) 
{
    Crash();
}

static void* ChatbotServer(void* junk)
{
	//   get initial control over the mutex so we can start. Any client grabbing it will be disappointed since chatbotExists = false, and will relinquish.
	MainChatbotServer();
	return NULL;
}

static void ServerStartup()  //LINUX
{
	pthread_mutex_lock(&chatLock);   //   get initial control over the mutex so we can start - now locked by us. Any client grabbing it will be disappointed since chatbotExists = false
}

static void ServerGetChatLock()  //LINUX
{
	while (pendingClients == 0) //   dont exit unless someone actually wanted us
	{
		pthread_cond_wait( &server_var, &chatLock ); // wait for someone to signal the server var...
	}
}

void InternetServer()  //LINUX
{
	// set error handlers
  //BUG  signal(-1, AnsiSignalMapperHandler);  
    
	struct sigaction action; 
    memset(&action, 0, sizeof(action)); 
   //BUG  sigemptyset(&action.sa_mask); 

    action.sa_flags = 0; 
    action.sa_handler = fpViolationHandler; 
  //BUG   sigaction(SIGFPE,&action,NULL); 
    action.sa_handler = SegmentFaultHandler; 
//BUG     sigaction(SIGSEGV,&action,NULL); 

    //   thread to accept incoming connections, doesnt need much stack
    pthread_t socketThread;     
	pthread_attr_t attr; 
    pthread_attr_init(&attr); 
	//pthread_attr_setdetachstate(&attr,  PTHREAD_CREATE_DETACHED);
	pthread_create(&socketThread, &attr, AcceptSockets, (void*) NULL);   

    //  we merely loop to create chatbot services. If it dies, spawn another and try again
    while (1)
    {
        pthread_create(&chatThread, &attr, ChatbotServer, (void*) NULL);  
        void* status; 
        pthread_join(chatThread, &status); 
        if (!status) break; //   chatbot thread exit (0= requested exit - other means it crashed
		Log(SERVERLOG,"Spawning new chatserver\r\n");
     }
	myexit("end of internet server");
}
#endif  // end LINUX

#ifdef WIN32
 
void GetLogLock()
{
	if (!quitting) EnterCriticalSection(&LogCriticalSection);
}

void ReleaseLogLock()
{
	if (!quitting) LeaveCriticalSection(&LogCriticalSection);
}

void GetTestLock()
{
	if (!quitting) EnterCriticalSection(&TestCriticalSection);
}

void ReleaseTestLock()
{
	if (!quitting) LeaveCriticalSection(&TestCriticalSection);
}

static bool ClientGetChatLock()
{
	// wait to get attention of chatbot server
	DWORD dwWaitResult;
	DWORD time = GetTickCount();
	while ((GetTickCount()-time)  < 100000) // loop to get control over chatbot server 
    {
		dwWaitResult = WaitForSingleObject(hChatLockMutex,100); // try and return after 100 ms
        // we now know he is ready, he released the lock, unless it is lying around foolishly
		if (dwWaitResult == WAIT_TIMEOUT) continue; // we didnt get the lock
        else if (!chatbotExists || chatWanted) ReleaseMutex(hChatLockMutex); // not really ready
        else return true;
    }
	return false;
}

static bool ClientWaitForServer(char* data,char* msg,unsigned long& timeout) // windows
{
	bool result;
	DWORD startTime = GetTickCount();
	timeout = startTime + (10 * 1000);
	serverFinishedBy = timeout - 1000;

	ReleaseMutex(hChatLockMutex); // chatbot server can start processing my request now
	while (1) // loop to get control over chatbot server - timeout if takes too long
	{
		Sleep(10);
		GetTestLock();
		if (*data == 0) // he answered us, he will turn off chatWanted himself
		{
			result = true;
			break;
		}
		// he hasnt answered us yet, so chatWanted must still be true
		if ( GetTickCount() >= timeout) // give up
		{
			chatWanted = result = false;	// indicate we no longer want the answer
			break;
		}
		ReleaseTestLock();
	}

	ReleaseTestLock();
	
	return result; // timed out - he can't write any data to us now
}

static void LaunchClient(void* sock) 
{
	_beginthread((void (__cdecl *)(void *)) HandleTCPClient,0,sock);
}

static void ServerStartup()
{
	WaitForSingleObject( hChatLockMutex, INFINITE );
	//   get initial control over the mutex so we can start - now locked by us. Any client grabbing it will be disappointed since chatbotExists = false
}

static void ServerGetChatLock()
{
	chatWanted = false;		
    while (!chatWanted) //   dont exit unless someone actually wanted us
    {
		ReleaseMutex(hChatLockMutex);
 		WaitForSingleObject( hChatLockMutex, INFINITE );
        //wait forever til somebody has something for us - we may busy spin here waiting for chatWanted to go true
	}

	// we have the chatlock and someone wants server
}

void PrepareServer()
{
	InitializeCriticalSection(&LogCriticalSection ); 
	InitializeCriticalSection(&TestCriticalSection ) ;
}

void InternetServer()
{
	_beginthread((void (__cdecl *)(void *) )AcceptSockets,0,0);	// the thread that does accepts... spinning off clients
	MainChatbotServer();  // run the server from the main thread
	CloseHandle( hChatLockMutex );
	DeleteCriticalSection(&TestCriticalSection);
	DeleteCriticalSection(&LogCriticalSection);
}

#endif

static void ServerTransferDataToClient()
{
    strcpy(clientBuffer+SERVERTRANSERSIZE,outputFeed);  
    clientBuffer[sizeof(int)] = 0; // mark we are done....
#ifndef WIN32
    pendingClients--;
	pthread_cond_signal( &server_done_var ); // let client know we are done
#endif
}

static void* AcceptSockets(void*) // accepts incoming connections from users
{
   try {
        while(1)
        {  
            char* time = GetTimeInfo()+SKIPWEEKDAY;
            TCPSocket *sock = serverSocket->accept();
			LaunchClient((void*)sock);
         }
	} catch (SocketException &e) {printf("accept busy\r\n"); ReportBug("***Accept busy\r\n")}
    myexit("end of internet server");
	return NULL;
}

static void* Done(TCPSocket * sock,char* memory)
{
	try{
 		char* output = memory+SERVERTRANSERSIZE;
		size_t len = strlen(output);
		if (len)  sock->send(output, len);
	}
	catch(...) {ReportBug("sending failed\r\n");}
	delete sock;
	free(memory);
	return NULL;
}

static void* HandleTCPClient(void *sock1)  // individual client, data on STACK... might overflow... // WINDOWS + LINUX
{
	clock_t starttime = ElapsedMilliseconds(); 
	char* memory = (char*) malloc(MAX_BUFFER_SIZE+2); // our data in 1st chunk, his reply info in 2nd
	if (!memory) return NULL; // ignore him if we run out of memory
	char* output = memory+SERVERTRANSERSIZE;
	*output = 0;
	char* buffer = memory + sizeof(unsigned int); // reserve the id of the fileread buffer
	*((unsigned int*)memory) = 0; // unused user cache buffer id... we can't preread unthreadsafe.
	TCPSocket *sock = (TCPSocket*) sock1;
	char IP[20];
	*IP = 0;
    try {
        strcpy(buffer,sock->getForeignAddress().c_str());	// get IP address
		strcpy(IP,buffer);
		buffer += strlen(buffer) + 1;				// use this space after IP for messaging
    } catch (SocketException e)
	{ 
		ReportBug("Socket errx") cerr << "Unable to get port" << endl;
		return Done(sock,memory);
	}
	char timeout = ' ';

	char userName[500];
	*userName = 0;
	char* user;
	char* bot;
	char* msg;
	// A user name with a . in front of it means tie it with IP address so it remains unique 
	try{
		char* p = buffer; // current end of content
		int len = 0;
		int strs = 0;
		user = buffer;
		char* at = buffer; // where we read a string starting at
		while (strs < 3) // read until you get 3 c strings... java sometimes sends 1 char, then the rest... tedious
		{
			unsigned int len1 = sock->recv(p, SERVERTRANSERSIZE-50); // leave ip address in front alone
			if (len1 <= 0)  // error
			{
				if (len1 < 0) 
				{
					ReportBug("TCP recv from %s returned error: %d\n", sock->getForeignAddress().c_str(), errno);
					Log(SERVERLOG,"TCP recv from %s returned error: %d\n", sock->getForeignAddress().c_str(), errno);
				}
				else 
				{
					ReportBug("TCP %s closed connection prematurely\n", sock->getForeignAddress().c_str());
					Log(SERVERLOG,"TCP %s closed connection prematurely\n", sock->getForeignAddress().c_str());
				}
				delete sock;
				free(memory);
				return NULL;
			} 

			// break apart the data into its 3 strings
			len += len1; // total read in so far
			p += len1; // actual end of read buffer
			*p = 0; // force extra string end at end of buffer
			char* nul = p; // just a loop starter
			while (nul && strs < 3) // find nulls in data
			{
				nul = strchr(at,0);	// find a 0 string terminator
				if (nul >= p) break; // at end of data, doesnt count
				if (nul) // found one - we have a string we can process
				{
					++strs;
					if (strs == 1) bot = nul + 1; // where bot will start
					else if (strs == 2) msg = nul + 1; // where message will start
					else if (strs == 3) memset(nul+1,0,3); // insure excess clear
					at = nul+1;
				}
			}
		}
		if (!*user)
		{
			if (*bot == '1' && bot[1] == 0) // echo test to prove server running (generates no log traces)
			{
				strcpy(output,"1");
				return Done(sock,memory);
			}

			ReportBug("%s %s bot: %s msg: %s  NO USER ID \r\n",IP,GetTimeInfo()+SKIPWEEKDAY,bot,msg)
			strcpy(output,"[you have no user id]\r\n"); 
			return Done(sock,memory);
		}

		strcpy(userName,user);

		// Request load of user data

		// wait to get attention of chatbot server, timeout if doesnt come soon enough
		bool ready = ClientGetChatLock(); // client gets chatlock  ...
		if (!ready)  // if it takes to long waiting to get server attn, give up
		{
 			PartialLogin(userName,memory); // sets LOG file so we record his messages
			switch(random(4))
			{
				case 0: strcpy(output,"Hey, sorry. Had to answer the phone. What was I saying?"); break;
				case 1: strcpy(output,"Hey, sorry. There was a salesman at the door. Where were we?"); break;
				case 2: strcpy(output,"Hey, sorry. Got distracted. What did you say?"); break;
				case 3: strcpy(output,"Hey, sorry. What did you say?"); break;
			}
			Log(STDUSERLOG,"Timeout waiting for service: %s  =>  %s\r\n",msg,output);
			return Done(sock,memory);
		}

	  } catch (...)  
	  {
			ReportBug("***%s client presocket failed %s\r\n",IP,GetTimeInfo()+SKIPWEEKDAY)
 			return Done(sock,memory);
	  }

	 clock_t serverstarttime = ElapsedMilliseconds(); 

	 // we currently own the lock,
	 unsigned long endWait = 0;
     bool success = true;
	 try{
 		chatWanted = true;	// indicate we want the chatbot server - no other client can get chatLock while this is true
		clientBuffer = memory; 
		// if we get the server, endWait will be set to when we should give up

                // waits on signal for server
                // releases lock or give up on timeout
                success = ClientWaitForServer(memory+sizeof(int),msg,endWait);
		if (!success)
		{
			timeout = '*';
			switch(random(4))
			{
				case 0: strcpy(output,"Hey, sorry. Had to answer the phone. What was I saying?"); break;
				case 1: strcpy(output,"Hey, sorry. There was a salesman at the door. Where were we?"); break;
				case 2: strcpy(output,"Hey, sorry. Got distracted. What did you say?"); break;
				case 3: strcpy(output,"Hey, sorry. What did you say?"); break;
			}
		}
		size_t len = strlen(output);
		if (len) sock->send(output, len);
} catch (...)  {
		printf("client socket fail\r\n");
		ReportBug("***%s client socket failed %s \r\n",IP,GetTimeInfo()+SKIPWEEKDAY)}

	delete sock;
	char* date = GetTimeInfo()+SKIPWEEKDAY;
	date[15] = 0;	// suppress year
	clock_t endtime = ElapsedMilliseconds(); 
	if (!serverLog);
	else if (*msg)
		Log(SERVERLOG,"%c %s %s/%s %s time:%d/%d msg: %d %s  =>  %s   <=\n",
			timeout,IP,user,bot,date,
			(int)(endtime - starttime),(int)(endtime - serverstarttime),
			inputCount,msg,output);
	else Log(SERVERLOG,"%c %s %s/%s %s start %d =>  %s   <=\n", timeout,IP,user,bot,date,inputCount,output);
	
	// do not delete memory til after server would have given up
	free(memory);
#ifndef WIN32
	pthread_exit(0);
#endif
	return NULL;
}
	
void GrabPort() // enable server port if you can... if not, we cannot run. 
{
    try {
        if (interfaceKind.length() == 0) {
            serverSocket = new TCPServerSocket(port);
        } else {
            serverSocket = new TCPServerSocket(interfaceKind, port);
        }
    }
    catch (SocketException &e) {printf("busy port %d\r\n",port) ; exit(1);}
	echo = 1;
	server = true;
 
#ifdef WIN32
	hChatLockMutex = CreateMutex( NULL, FALSE, NULL );   
#endif
}

void StallTest(bool startTest,char* label)
{
	static  clock_t start;
	if (startTest) start = ElapsedMilliseconds();
	else
	{
		clock_t now = ElapsedMilliseconds();
		if ((now-start) > 40) 
			printf("%d %s\r\n",(unsigned int)(now-start),label);
		//else printf("ok %d %s\r\n",now-start,label);
	}
}

static void* MainChatbotServer()
{
	sprintf(serverLogfileName,"LOGS/serverlog%d.txt",port);
	ServerStartup(); //   get initial control over the mutex so we can start. - on linux if thread dies, we must reacquire here 
	// we now own the chatlock
	clock_t lastTime = ElapsedMilliseconds(); 

	if (setjmp(scriptJump[SERVER_RECOVERY])) // crashes come back to here
	{
		printf("***Server exception\r\n");
		ReportBug("***Server exception\r\n")
#ifdef WIN32
		char* bad = GetUserVariable("$crashmsg");
		if (*bad) strcpy(outputFeed,bad);
		else strcpy(outputFeed,"Hey, sorry. I forgot what I was thinking about.");
		ServerTransferDataToClient();
#endif
		ResetBuffers(); //   in the event of a trapped bug, return here, we will still own the chatlock
	}
    chatbotExists = true;   //  if a client can get the chatlock now, he will be happy
	Log(SERVERLOG,"Server ready\r\n");
	printf("Server ready: %s\r\n",serverLogfileName);
#ifdef WIN32
 _try { // catch crashes in windows
#endif
	int counter = 0;
	while (1)
	{
		if (quitting) 
			return NULL; 
		ServerGetChatLock();
		startServerTime = ElapsedMilliseconds(); 

		// chatlock mutex controls whether server is processing data or client can hand server data.
		// That we now have it means a client has data for us.
		// we own the chatLock again from here on so no new client can try to pass in data. 
		// CLIENT has passed server in globals:  clientBuffer (ip,user,bot,message)
		// We will send back his answer in clientBuffer, overwriting it.
		char user[MAX_WORD_SIZE];
		char bot[MAX_WORD_SIZE];
		char* ip = clientBuffer + sizeof(unsigned int); // skip fileread data buffer id(not used)
		char* ptr = ip;
		// incoming is 4 strings together:  ip, username, botname, message
		ptr += strlen(ip) + 1;	// ptr to username
		strcpy(user,ptr); // allow user var to be overwriteable, hence a copy
		ptr += strlen(ptr) + 1; // ptr to botname
		strcpy(bot,ptr);
		ptr += strlen(ptr) + 1; // ptr to message
		size_t test = strlen(ptr);
		if (test >= INPUT_BUFFER_SIZE) strcpy(inputFeed,"too much data");
		else strcpy(inputFeed,ptr); // xfer user message to our incoming feed
		echo = false;

		PerformChat(user,bot,inputFeed,ip,outputFeed);	// this takes however long it takes, exclusive control of chatbot.
		ServerTransferDataToClient();
	}
#ifdef WIN32
		}_except (true) {ReportBug("Server exception\r\n") Crash();}
#endif
	return NULL;
}

#endif /* EVSERVER */

#endif
#include "common.h"

bool blocked = false;  // debugger NOT allowed to do/see inside a pattern match itself.

#ifndef DISCARDTESTING
#define MAX_DEBUG_LEVELS 200
#define MAX_BREAK_TOPICS 10
static int level = 0;			// globalDepth associated with this debug level
static unsigned int doing = 0;			// behavior we want debugger to be doing
static unsigned int lastRuleTopic = 0;	// topic we gave command from, whose rules we should enter
static unsigned int lastCommand = 0;
static unsigned int action = 0;
static unsigned int debugTrace = 0;
static char* output = 0;				// current place in output execution system should stop at
static char kind = 0;					// kind of current debug level (rule, topic, loop, etc)
static char* call;						// name of function being called
static char oldKind[MAX_DEBUG_LEVELS];
static unsigned int oldDoing[MAX_DEBUG_LEVELS];
static char* oldCall[MAX_DEBUG_LEVELS];
static int oldLevel[MAX_DEBUG_LEVELS];
static unsigned int oldAction[MAX_DEBUG_LEVELS];
static unsigned int oldRuleTopic[MAX_DEBUG_LEVELS];
static bool displayed[MAX_DEBUG_LEVELS];
static char* oldOutput[MAX_DEBUG_LEVELS];
static unsigned int oldIndex = 0;
static char* lastOutput;
int out2level = -2;					// what deeper levels we should run silently

// transient run til values
static unsigned int transientBreakTopic = 0;
static unsigned int transientBreakRuleID = 0;
static unsigned int transientBreakRuleTopic = 0;
static char* transientBreakRule = NULL;

// breakpoints data
static char* breakRules[MAX_BREAK_TOPICS];
static unsigned int breakRuleID[MAX_BREAK_TOPICS];
static unsigned int breakRuleTopic[MAX_BREAK_TOPICS];
static unsigned int breakRuleIndex = 0;
static unsigned int breakTopics[MAX_BREAK_TOPICS];
static unsigned int breakTopicIndex = 0;
#endif

static bool refreshTopic = false;		// when we exit a topic, do we need to tell user topic we return to

void IndentDebug()
{
	if (refreshTopic) // never say resuming to a top level topic
	{
		refreshTopic = false;
		Log(STDDEBUGLOG,"Debug resuming %s:\r\n",GetTopicName(currentTopicID));
	}
	Log(STDDEBUGLOG,"Debug: ");
	int count = globalDepth;
	while (count-- > 0) Log(STDDEBUGLOG," ");
}

void DebugHeader(char* msg)
{
	bool oldEcho = echo;
	echo = true;
	Log(STDUSERLOG,"\r\nDebugging %s:\r\n",msg);
	echo = oldEcho;
	Debugger(ENTER_DEBUGGER); 
}

#ifndef DISCARDTESTING
static void PushDebugLevel(unsigned int what,char type)
{
	++oldIndex;
	oldDoing[oldIndex] = doing;
	oldCall[oldIndex] = call;
	oldLevel[oldIndex] = level;
	oldRuleTopic[oldIndex] = lastRuleTopic;
	oldAction[oldIndex] = action;
	oldOutput[oldIndex] = output;
	oldKind[oldIndex] = kind;
	displayed[oldIndex] = false;		// default this level has no exit display needed
	level = globalDepth;
	doing = what;
	output = NULL;
	kind = type;
}

static void PopDebugLevel()
{
	if (!oldIndex) return;
	level = oldLevel[oldIndex];
	doing = oldDoing[oldIndex];
	lastRuleTopic = oldRuleTopic[oldIndex];
	output = oldOutput[oldIndex];
	call = oldCall[oldIndex];
	kind = oldKind[oldIndex];
	action = oldAction[oldIndex];
	--oldIndex;
}

char* ReadOutput(char* ptr,char* buffer) // locate next output fragment to display (that will be executed)
{
	char next[MAX_WORD_SIZE];
	char* hold;
	*buffer = 0;
	char* out = buffer;
	while (*ptr != ENDUNIT) // not end of data
	{
		ptr = ReadCompiledWord(ptr,out); // move token 
		char* copied = out;
		out += strlen(out);
		strcpy(out," ");
		++out;
		*out = 0;
		hold = ReadCompiledWord(ptr,next); // and the token after that?
		if (IsAlphaOrDigit(*copied)) // simple output word was copied
		{
			if (!*next || !IsAlphaOrDigit(*next)) break; //  followed by something else simple
		}
		else if (*buffer == ':' && buffer[1]) // testing command occupies the rest always
		{
			char* end = strchr(ptr,ENDUNIT);
			if (end)
			{
				strncpy(out,ptr,end-ptr);
				out += end-ptr;
				*out = 0;
			}
			ptr = NULL;
			break;
		}
		else if (*buffer == '^' && *next == '(') // function call
		{
			char* end = BalanceParen(ptr+1); // function call args
			strncpy(out,ptr,end-ptr);
			out += end-ptr;
			*out = 0;
			ptr = end;
			break;
		}
		else if (*buffer == '$' || *buffer == '%' || (*buffer == '@' && IsDigit(buffer[1])) || (*buffer == '_' && IsDigit(buffer[1]))  ) // user or system variable or factset or match variable
		{
			if (*next != '=' && next[1] != '=') break; // not an assignment statement
			while (hold) // read op, value pairs
			{
				strcpy(out,next); // transfer assignment op or arithmetic op 
				out += strlen(out);
				strcpy(out," ");
				++out;
				ptr = ReadCompiledWord(hold,next); // read value
				strcpy(out,next); // transfer value
				out += strlen(out);
			
				// if value is a function call, get the whole call
				if (*next == '^' && *ptr == '(')
				{
					char* end = BalanceParen(ptr+1); // function call args
					strncpy(out,ptr,end-ptr);
					out += end-ptr;
					*out = 0;
					ptr = end;
				}

				strcpy(out," ");
				++out;
				if (*ptr != ENDUNIT) // more to rule
				{
					hold = ReadCompiledWord(ptr,next); // is there more to assign
					if (IsArithmeticOperator(next)) continue; // need to swallow op and value pair
				}
				break;
			}
			break;
		}
		else if (*buffer == '[') // choice area
		{
			//   find closing ]
			char* end = ptr-1;
			while (ALWAYS) 
			{
				end = strchr(end+1,']'); // find a closing ] 
				if (!end) break; // failed
				if (*(end-1) != '\\') break; // ignore literal \[
			}
			if (end) // found end of a [] pair
			{
				++end;
				strncpy(out,ptr,end-ptr);
				out += end-ptr;
				*out = 0;
				ptr = end + 1;
				if (*ptr != '[') break; // end of choice zone
			}
		}
		else break;
	}
	if (!stricmp(buffer,"^^loop ( -1 ) "))  strcpy(buffer,"^^loop ( ) ");	// shorter notation
	return ptr;
}

#ifndef WIN32
char getch() // direct character input read (no buffering)
{ 
	char buf = 0; 
	struct termios old = {0}; 
	if (tcgetattr(0, &old) < 0) perror("tcsetattr()"); 
	old.c_lflag &= ~ICANON; 
	old.c_lflag &= ~ECHO; 
	old.c_cc[VMIN] = 1; 
	old.c_cc[VTIME] = 0; 
	if (tcsetattr(0, TCSANOW, &old) < 0) perror("tcsetattr ICANON"); 
	if (read(0, &buf, 1) < 0) perror ("read()"); 
	old.c_lflag |= ICANON; 
	old.c_lflag |= ECHO; 
	if (tcsetattr(0, TCSADRAIN, &old) < 0) perror ("tcsetattr ~ICANON"); 
	return (buf); 
}
#endif

static unsigned int GetDebuggerResumeCommand() // returns what to do to resume the level
{
	char word[MAX_WORD_SIZE];
	unsigned int command = 0;
	// interactive user control here
	char input[1000];
	*input = 0;
	char* ptr = input;
	Log(STDDEBUGLOG," ?: ");
	while (ALWAYS)
	{
		int x;
#ifdef WIN32
		if (!_kbhit()) continue;

		x = _getch();
		if (x == 0xE0) // arrow commands
		{
			x = _getch(); // assuming numlock off
			if (x == 0x50)  command = 'i'; // down  IN
			else if (x == 0x4b) command = 's'; // left  Go to completion
			else if (x == 0x4d)  command = 'o'; // right -- step over
			else if (x == 0x48) command = 'u';  // up -- step out
			return command;
		}
#else
		x = getch();
		if (x == 0x1b) // arrow commands via ESC
		{
			x = getch(); 
			if (x == 0x5b) x = getch(); 
			if (x == 0x42) command = 'i'; // down  IN
			else if (x == 0x44) command = 's'; // left  STOP
			else if (x == 0x43)  command = 'o'; // right -- step over
			else if (x == 0x41) command = 'u';  // up -- step out
			return command;
		}
#endif
		if (x == '\r' || x == '\n') // end of normal input
		{
			char* line = SkipWhitespace(input);
			if (*input == ':') Command(line,NULL); // command
			else if ((*input == 'b' || *input == 'g') && (input[1] == ' ' || !input[1])) // topic or rule breakpoint or transient breakpoint
			{
				line = input + 1;
				while (line && *line)
				{
					line = ReadCompiledWord(line,word);
					char* dot = strchr(word,'.');
					if (!dot && *word == '~') // topic
					{
						unsigned int topic = FindTopicIDByName(word);
						unsigned int i;
						for (i = 0; i < breakTopicIndex; ++i)
						{
							if (breakTopics[i] == topic) break;
						}
						if (!topic) Log(STDDEBUGLOG,"Topic %s not found\r\n",word);
						else if (i < breakTopicIndex){;} // already  in list
						else if (*input == 'g') 
						{
							transientBreakTopic = topic;
							return 'g';
						}
						else breakTopics[breakTopicIndex++] = topic;
						if (breakTopicIndex >= 10) --breakTopicIndex;
					}
					else
					{
						char* rule;
						int id;
						bool fulllabel = false;
						bool crosstopic = false;
						unsigned int topic;
						if (IsDigit(dot[1])) rule = GetRuleTag(topic,id,word);
						else rule = GetLabelledRule(topic,word,"",fulllabel,crosstopic,id);
						unsigned int i;
						for (i = 0; i < breakRuleIndex; ++i)
						{
							if (breakRules[i] == rule) break;
						}
						if (!rule) Log(STDDEBUGLOG,"Rule %s not found\r\n",word);
						else if (i < breakRuleIndex){;} // already  in list
						else if (*input == 'g') 
						{
							transientBreakRuleID = id;
							transientBreakRuleTopic = topic;
							transientBreakRule = rule;
							return 'g';
						}
						else 
						{
							breakRuleID[breakRuleIndex] = id;
							breakRuleTopic[breakRuleIndex] = topic;
							breakRules[breakRuleIndex] = rule;
							breakRuleIndex++;
						}
						if (breakRuleIndex >= 10) --breakRuleIndex;
					}
				}
				if (*input != 'g') x = 'l'; // list breakpoints
				else return 'g';
				Log(STDDEBUGLOG,"\r\n");
			}
			else if (*input == 'd' && input[1] == ' ') // delete topic breakpoint
			{
				line = input+2;
				while (line && *line)
				{
					line = ReadCompiledWord(line,word);
					line = ReadCompiledWord(line,word);
					char* dot = strchr(word,'.');
					if (!dot) // topic
					{
						unsigned int topic = FindTopicIDByName(word);
						if (!topic) Log(STDDEBUGLOG,"Topic %s not found\r\n",word);
						else 
						{
							for (unsigned int i = 0; i < breakTopicIndex; ++i)
							{
								if (breakTopics[i] == topic) 
								{
									memmove(breakTopics+i,breakTopics+i+1,sizeof(int) * (breakTopicIndex-i));
									--breakTopicIndex;
									break;
								}
							}
						}
					}
					else
					{
						char* rule;
						int id;
						bool fulllabel = false;
						bool crosstopic = false;
						unsigned int topic;
						if (IsDigit(dot[1])) rule = GetRuleTag(topic,id,word);
						else rule = GetLabelledRule(topic,word,"",fulllabel,crosstopic,id);
						unsigned int i;
						for (i = 0; i < breakRuleIndex; ++i)
						{
							if (breakRules[i] == rule) break;
						}
						if (!rule) Log(STDDEBUGLOG,"Rule %s not found\r\n",word);
						else 
						{
							for (unsigned int i = 0; i < breakRuleIndex; ++i)
							{
								if (breakRules[i] == rule) 
								{
									memmove(breakRules+i,breakRules+i+1,sizeof(char*) * (breakRuleIndex-i));
									memmove(breakRuleTopic+i,breakRuleTopic+i+1,sizeof(unsigned int) * (breakRuleIndex-i));
									memmove(breakRuleID+i,breakRuleID+i+1,sizeof(unsigned int) * (breakRuleIndex-i));
									--breakRuleIndex;
									break;
								}
							}
						}
 					}
				}
				x = 'l';
				Log(STDDEBUGLOG,"\r\n");
			}
			else x = 0;
			*input = 0;
		}

		if (!*input && x == 't')
		{
			debugTrace ^= TOPIC_TRACE;
			if (debugTrace & TOPIC_TRACE) Log(STDDEBUGLOG,"trace topics\r\n ?: ");
			else Log(STDDEBUGLOG,"untrace topics\r\n ?: ");
		}
		else if (!*input && x == 'r') 
		{
			debugTrace ^= RULE_TRACE;
			if (debugTrace & RULE_TRACE) Log(STDDEBUGLOG,"trace rules\r\n ?: ");
			else  Log(STDDEBUGLOG,"untrace rules\r\n ?: ");
		}
		else if (!*input && x == 'm') 
		{
			debugTrace |= RULE_MATCH;
			return 'm';
		}
		else if (!*input && x == 'x') 
		{
			return 'x';
		}	
		else if (!*input && x == 'h')
		{
			Log(STDDEBUGLOG,"Commands: \r\n");
			Log(STDDEBUGLOG,"  h (help) - list the commands\r\n");
			Log(STDDEBUGLOG," down-arrow (step in) - go logically deeper. Topic into rule, rule into output, output into subtopic\r\n");
			Log(STDDEBUGLOG," right-arrow (step over) - complete current unit (topic, rule, output fragment)\r\n");
			Log(STDDEBUGLOG," up-arrow (step out) - if topic or rule, finish topic. If output, finish rule.\r\n"); 
			Log(STDDEBUGLOG," left-arrow (run to completion) - run to completion or until stopped by a break.\r\n");
			Log(STDDEBUGLOG,"  b (set breaks) followed by list of topic names and/or rule tags or labels and ENTER\r\n");
			Log(STDDEBUGLOG,"  d (delete topic breaks) followed by list of topic names and/or rule tags or labels and ENTER\r\n");
			Log(STDDEBUGLOG,"  g (go til) followed by a topic names and/or rule tag or label and ENTER or just ENTER\r\n");
			Log(STDDEBUGLOG,"  m (run to match) execute rules til one matches\r\n");
			Log(STDDEBUGLOG,"  l (list breaks) - shows current topic breakpoints and rule breakpoints set\r\n");
			Log(STDDEBUGLOG,"  r (rule trace) - turn on/off rule entry trace\r\n");
			Log(STDDEBUGLOG,"  t (topic trace) - turn on/off topic entry/exit trace\r\n");
			Log(STDDEBUGLOG,"  w (where am I) - display state of topics within\r\n ?: ");
			Log(STDDEBUGLOG,"  x (exit debugging)\r\n");
		}
		else if (!*input && x == 'l') // list breakpoints
		{
			Log(STDDEBUGLOG,"\r\nBreak topics: " );
			for (unsigned int i = 0; i < breakTopicIndex; ++i) Log(STDDEBUGLOG,"%s ",GetTopicName(breakTopics[i]));
			Log(STDDEBUGLOG,"\r\n");
			Log(STDDEBUGLOG,"Break rules: " );
			for (unsigned int i = 0; i < breakRuleIndex; ++i) 
			{
				char label[MAX_WORD_SIZE];
				GetLabel(breakRules[i],label);
				Log(STDDEBUGLOG,"%s.%d.%d (%s) ",GetTopicName(breakRuleTopic[i]),TOPLEVELID(breakRuleID[i]),REJOINDERID(breakRuleID[i]));
			}
			Log(STDDEBUGLOG,"\r\n");
			Log(STDDEBUGLOG," ?: ");
			ptr = input;
			*ptr = 0;
		}
		else if (!*input && x == 'w') // show topic control stack
		{
			Log(STDDEBUGLOG,"topic nesting:\r\n");
			unsigned int count = 6;
			while (count--) Log(STDDEBUGLOG,"  ");	// indent for main topic
			Log(STDDEBUGLOG,"%s     <--\r\n",GetTopicName(currentTopicID));
			for (unsigned int i = topicIndex; i >= 2; --i)
			{
				unsigned int count = 6;
				while (count--) Log(STDDEBUGLOG,"  ");	// indent
				Log(STDDEBUGLOG,"%s\r\n",GetTopicName(topicStack[i]));
			}
			Log(STDDEBUGLOG," ?: ");
		}
		else if (x == 8) // do backspace
		{
			if (ptr != input)
			{
				*--ptr = 0;
				Log(STDDEBUGLOG,"\r\n ?: %s",input);
			}
		}
		else 
		{
			*ptr++ = (char) x;
			*ptr = 0;
			Log(STDDEBUGLOG,"%c",x);
		}
	}

	return command;
}

static void ExecuteResume(unsigned int command)
{
	lastCommand = command;
	if (command == 'o') // step over current thingy
	{
		Log(STDDEBUGLOG," step over\r\n");
		out2level = 0;
	}
	else if (command == 'x') // exit
	{
		Log(STDDEBUGLOG," exit debugger\r\n");
		debugger = false;
	}
	else if (command == 's') // run to completion
	{
		Log(STDDEBUGLOG," run\r\n");
		doing = lastCommand = OUT2TOPIC; 
		out2level = -1;
	}
	else if (command == 'g' || command == 'm')
	{
		if (command == 'm')  Log(STDDEBUGLOG," run til match\r\n");
		else  Log(STDDEBUGLOG," go\r\n");
		doing = TOPIC_LEVEL;
		out2level = -1;
	}
	else if (command == 'u') // up 
	{
		Log(STDDEBUGLOG," step out\r\n");
		if (doing == OUTPUT_LEVEL) // but traces need to be a separate flag
		{
			out2level = level - 1;
			if (kind == 'l') doing = lastCommand = OUT2LOOP; // complete the loop body
			else if (kind == 'i') doing =  lastCommand = OUT2IF; // complete the if body
			else if (kind == 'c') doing =  lastCommand = OUT2CALL; // complete the call
			else if (oldKind[oldIndex] == 'x') doing =  lastCommand = OUT2REUSE; // complete the reuse
			else if (kind == 'r') 
			{
				doing = lastCommand =  OUT2RULE; // complete the rule
				out2level = level;
			}
		}
		else if (doing == RULE_LEVEL) 
		{
			unsigned int i = oldIndex;
			doing = lastCommand = OUT2TOPIC; // run til this topic is exited
			if (kind == 't') out2level = level - 1;  // before his level
			else if (oldKind[oldIndex] == 'y')
			{
				doing =  lastCommand = OUT2REFINE;// complete the refine
				out2level = level - 1;
			}
			else
			{
				while (--i)
				{
					if (oldKind[i] == 't')
					{
						out2level = oldLevel[i+1] - 1; // before his level
						break;
					}
				}
			}
		}
		else if (doing == TOPIC_LEVEL)
		{
			out2level = level - 1;	 // before current level
		}
	}
	else if (command == 'i') // step in current thingy
	{
		Log(STDDEBUGLOG," step in\r\n");
		if (kind == 't') // a topic
		{
			lastRuleTopic = currentTopicID; // allow rules from what will come after this topic level (the rule level)
			doing = RULE_LEVEL;
		}
		else if (doing == RULE_LEVEL || doing == OUTPUT_LEVEL) doing = OUTPUT_LEVEL;
	}
}

#endif

void Debugger(int code,unsigned int result,char* at)
{
#ifndef DISCARDTESTING

	// reasons to do nothing
	if (blocked) return; // performing a pre-match on a rule or inside a match
	if (code == PARSING_OUTPUT && (lastCommand == OUT2RULE || doing != OUTPUT_LEVEL || (out2level >= -1 && globalDepth > out2level))) return;	// waiting til we get back to a topic
	if (code == ENTER_RULE_OUTPUT)  return;

	// simple endings of a debug level
	if (code == EXIT_REUSE_TOPIC || code == EXIT_REFINE || code == EXIT_LOOP || code == EXIT_RULE || code == EXIT_IF || code == EXIT_CALL) // simple terminations of scope
	{
		if (code == EXIT_RULE && lastCommand == OUT2RULE)
		{
			if (level == out2level)
			{
				lastCommand = 0;
				out2level = -2;
				doing = RULE_LEVEL;
			}
		}
		else if (code == EXIT_LOOP && lastCommand == OUT2LOOP)
		{
			if (level == out2level)
			{
				lastCommand = 0;
				out2level = -2;
				doing = OUTPUT_LEVEL;
			}
		}
		else if (code == EXIT_IF && lastCommand == OUT2IF)
		{
			if (level == out2level)
			{
				lastCommand = 0;
				out2level = -2;
				doing = OUTPUT_LEVEL;
			}
		}
		else if (code == EXIT_REFINE && lastCommand == OUT2REFINE)
		{
			if (level == out2level)
			{
				lastCommand = 0;
				out2level = -2;
				doing = OUTPUT_LEVEL;
			}
		}
		else if (code == EXIT_CALL && lastCommand == OUT2CALL)
		{
			if (out2level) call = 0;
			if (level == out2level)
			{
				lastCommand = 0;
				out2level = -2;
				doing = OUTPUT_LEVEL;
			}
		}

		PopDebugLevel();
		return;
	}
	else if (code == EXIT_TOPIC)
	{
		output = NULL;
		if (displayed[oldIndex]) // did we show entry?
		{
			IndentDebug();
			Log(STDDEBUGLOG,"exit %s result: %s responses: %d\r\n",GetTopicName(currentTopicID),ResultCode(result),responseIndex);
			if (!(debugTrace & (TOPIC_TRACE | RULE_MATCH)) && globalDepth > 1) refreshTopic = true; // top level topics dont trigger resume on their successors
		}
		PopDebugLevel();
		if (out2level >= 0 && level <= out2level) // wanting to exit this topic
		{
			out2level = -2;
			doing = RULE_LEVEL; // return to rule level that called us
		}
		return;
	}
	else if (code == EXIT_RULE_OUTPUT) 
	{
		if (doing == OUTPUT_LEVEL) doing = RULE_LEVEL; // drop out of this detail
		return;
	}

	// simple ENTERINGS of a debug level
	if (code == ENTER_DEBUGGER)
	{
		// clear the world in preparation for the 1st topic (the prepass)
		oldDoing[oldIndex] = 0;
		oldLevel[oldIndex] = 0;
		displayed[oldIndex] = 0;
		if (out2level != -1) 
		{
			out2level = -2;
			debugTrace = 0;
			transientBreakTopic = 0;
			transientBreakRuleID = 0;
			transientBreakRuleTopic = 0;
			transientBreakRule = NULL;
			lastCommand = 0;
			breakRuleIndex = 0;
			breakTopicIndex = 0;
		}
		refreshTopic = false;
		doing = START_LEVEL;
		level = globalDepth;
		oldIndex = 0;
		debugger = true;
		return;
	}
	else if (code == ENTER_TOPIC) // entering a topic is a major event
	{
		bool breakAtTopic = false;
		if (currentTopicID == transientBreakTopic)  // 'g' command
		{
			transientBreakTopic = 0;
			breakAtTopic = true;
		}
		for (unsigned int i = 0; i < breakTopicIndex; ++i) 
		{
			if (breakTopics[i] == currentTopicID) breakAtTopic = true;
		}
		if (breakAtTopic) 	out2level = -2;

		PushDebugLevel(doing,'t'); // note for when we leave this level

		// we should pass thru this blindly if executing RULE_LEVEL or RULE_TRACE or didnt enter via an "in" command (unless its a breakpoint)
		// we should show it if TOPIC_TRACE, breakpoint, executing "in" from an OUTPUT_LEVEL, doing a START_LEVEL, 
		if (debugTrace && !breakAtTopic) 
		{
			IndentDebug();
			Log(STDDEBUGLOG,"at %s\r\n",GetTopicName(currentTopicID));
			displayed[oldIndex] = true;
		}

		// things we can be doing: START_LEVEL  TOPIC_LEVEL  RULE_LEVEL  OUTPUT_LEVEL  TOPIC_TRACE  RULE_TRACE 5
		if (breakAtTopic) 
		{
			IndentDebug();
			Log(STDDEBUGLOG,"break at %s\r\n",GetTopicName(currentTopicID));
			displayed[oldIndex] = true;
			debugTrace |= TOPIC_TRACE; 
		}
		else if (out2level >= -1 && globalDepth > out2level) return;	// waiting til we get back to a topic
		else if (doing == START_LEVEL) // start to 1st topic
		{
			IndentDebug();
			Log(STDDEBUGLOG,"at %s\r\n",GetTopicName(currentTopicID));
			displayed[oldIndex] = true;
			doing = TOPIC_LEVEL;
		}
		else if (doing == TOPIC_LEVEL)
		{
			// you can be here by stepping in from an output_level or because you are just stepping over/out from a TOPIC_LEVEL
			if (lastCommand == 'i' && !displayed[oldIndex])
			{
				IndentDebug();
				Log(STDDEBUGLOG,"at %s\r\n",GetTopicName(currentTopicID));
				displayed[oldIndex] = true;
			}
		}
		else if (doing == OUTPUT_LEVEL) // if stepping over ignore, if stepping in then stop
		{
			if (lastCommand == 'i')
			{
				if (!displayed[oldIndex])
				{
					IndentDebug();
					Log(STDDEBUGLOG,"at %s\r\n",GetTopicName(currentTopicID));
					displayed[oldIndex] = true;
				}
				output = NULL;
				doing = TOPIC_LEVEL;
			}
		}
		else return;
	}
	else if (code == ENTER_REUSE_TOPIC) // special level for a reuse change of topic
	{
		PushDebugLevel(doing,'x');
		if (out2level >= -1 && globalDepth > out2level) return;	// waiting til we get back to a topic
		if (doing != OUTPUT_LEVEL && doing != RULE_LEVEL && !(debugTrace & RULE_TRACE)) return;	// output_level can end up here by doing ^refine or can step over or in a rule, ending at next rule 
		if (lastCommand != 'i') return;	// only visible on step in

		IndentDebug();
		Log(STDDEBUGLOG," ^reuse %s\r\n",GetTopicName(currentTopicID));
		displayed[oldIndex] = true;
		lastRuleTopic = currentTopicID;	// this is now the level that issued the rule, we continue in it for now.
		doing = RULE_LEVEL;
		return;
	}
	else if (code == ENTER_LOOP)
	{
		PushDebugLevel(doing,'l'); // note for when we leave this level
		if (debugTrace & (RULE_TRACE | TOPIC_TRACE)) return;
		if (out2level >= -1 && globalDepth > out2level) return;	// waiting til we get back to a topic
		if (lastCommand != 'i') return;	// only visible on step in
	
		if (doing != OUTPUT_LEVEL && doing != RULE_LEVEL && !(debugTrace & RULE_TRACE) ) return;	// output_level can end up here by doing ^refine or can step over or in a rule, ending at next rule 
		if (currentTopicID != lastRuleTopic) return;	// not in the topic issuing the command ... but REUSE can use any topic so it has special commands to set it up
		lastRuleTopic = currentTopicID;	// see rules of loop next
		action = 0;
		output = at;
		doing = OUTPUT_LEVEL;
		return;
	}
	else if (code == ENTER_IF)
	{
		PushDebugLevel(doing,'i'); // note for when we leave this level
		if (!(debugTrace & RULE_TRACE)) return;
		if (out2level >= -1 && globalDepth > out2level) return;	// waiting til we get back to a topic
		if (lastCommand != 'i') return;	// only visible on step in
	
		if (doing != OUTPUT_LEVEL && doing != RULE_LEVEL && !(debugTrace & RULE_TRACE)) return;	// output_level can end up here by doing ^refine or can step over or in a rule, ending at next rule 
		if (currentTopicID != lastRuleTopic) return;	// not in the topic issuing the command ... but REUSE can use any topic so it has special commands to set it up
		lastRuleTopic = currentTopicID;	// see rules of loop next
		action = 0;
		output = at; // show only rules AFTER this
		doing = OUTPUT_LEVEL;
		return;
	}
	else if (code == ENTER_CALL)
	{
		PushDebugLevel(doing,'c'); // note for when we leave this level
		if (debugTrace & (RULE_TRACE | TOPIC_TRACE)) return;
		if (out2level >= -1 && globalDepth > out2level) return;	// waiting til we get back to a topic
		if (lastCommand != 'i') return;	// only visible on step in
	
		if (doing != OUTPUT_LEVEL && doing != RULE_LEVEL && !(debugTrace & RULE_TRACE)) return;	// output_level can end up here by doing ^refine or can step over or in a rule, ending at next rule 
		if (currentTopicID != lastRuleTopic) return;	// not in the topic issuing the command ... but REUSE can use any topic so it has special commands to set it up
		lastRuleTopic = currentTopicID;	// see rules of loop next
		action = 0;
		call = lastOutput;
		output = at; // show only rules AFTER this
		doing = OUTPUT_LEVEL;
		return;
	}
	else if (code == ENTER_REFINE)
	{
		PushDebugLevel(doing,'y'); // note for when we leave this level
		if (debugTrace & (RULE_TRACE | TOPIC_TRACE)) return;
		if (out2level >= -1 && globalDepth > out2level) return;	// waiting til we get back to a topic
		if (lastCommand != 'i') return;	// only visible on step in

		if (doing != OUTPUT_LEVEL && doing != RULE_LEVEL && !(debugTrace & RULE_TRACE)) return;	// output_level can end up here by doing ^refine or can step over or in a rule, ending at next rule 
		if (currentTopicID != lastRuleTopic) return;	// not in the topic issuing the command ... but REUSE can use any topic so it has special commands to set it up
		lastRuleTopic = currentTopicID;
		doing = RULE_LEVEL;
		return;	// see rules of refine
	}
	else if (code == ENTER_RULE)
	{
		bool breakAtRule = false;
		if (transientBreakRule == currentRule) // 'g' transient breakpoint
		{
			breakAtRule = true;
			transientBreakRule = NULL;
		}
		if (code == ENTER_RULE) // BUG-- what about reuse access to rule output??
		{
			for (unsigned int i = 0; i < breakRuleIndex; ++i) 
			{
				if (breakRules[i] == currentRule) breakAtRule = true;
			}
		}
		if (breakAtRule) 	out2level = -2;

		PushDebugLevel(doing,'r'); // note for when we leave this level
		action = 0;
		// things we can be doing: START_LEVEL  TOPIC_LEVEL  RULE_LEVEL  OUTPUT_LEVEL  TOPIC_TRACE  5

		if (breakAtRule || debugTrace & (RULE_TRACE | RULE_MATCH)) {;}
		else if (out2level >= -1 && globalDepth > out2level) return;	// waiting til we get back to a topic
		else if (doing != OUTPUT_LEVEL && doing != RULE_LEVEL && !(debugTrace & RULE_TRACE)) return;	// output_level can end up here by doing ^refine or can step over or in a rule, ending at next rule 
		else if (lastRuleTopic && currentTopicID != lastRuleTopic) return;	// not in the topic issuing the command ... but REUSE can use any topic so it has special commands to set it up
		
		lastRuleTopic = currentTopicID;	// this level started a rule we cared about
		doing = RULE_LEVEL;
		if (output && *output == ENDUNIT && doing == OUTPUT_LEVEL) // was doing a prior output, which ended, close it out
		{
			output = NULL;
		}

		char pattern[MAX_WORD_SIZE];
		GetPattern(currentRule,NULL,pattern);
		unsigned int gap = 0;
		unsigned int wildcardSelector = 0;
		wildcardIndex = 0;  //   reset wildcard allocation on top-level pattern match
		unsigned int junk;
		blocked = true;
		bool match = (!*pattern) ? true : Match(pattern+2,0,0,'(',true,gap,wildcardSelector,junk,junk) != 0; 
		blocked = false;
		char matches = (match) ? '+' : '-';
		level = globalDepth;
		if (breakAtRule) 
		{
			IndentDebug();
			char label[MAX_WORD_SIZE];
			GetPattern(currentRule,label,NULL);
			Log(STDDEBUGLOG,"   break at %c %s.%d.%d (%s) %s\r\n",matches,GetTopicName(currentTopicID),TOPLEVELID(currentRuleID),REJOINDERID(currentRuleID),label,ShowRule(currentRule));
			doing = RULE_LEVEL;
		}
		else if (debugTrace &RULE_MATCH && !match && !(debugTrace & RULE_TRACE)) return;
		else 
		{
			IndentDebug();
			if (REJOINDERID(currentRuleID)) Log(STDDEBUGLOG,"   %c %s.%d.%d %s\r\n",matches,GetTopicName(currentTopicID),TOPLEVELID(currentRuleID),REJOINDERID(currentRuleID),ShowRule(currentRule));
			else Log(STDDEBUGLOG,"   %c %s.%d    %s\r\n",matches,GetTopicName(currentTopicID),TOPLEVELID(currentRuleID),ShowRule(currentRule));
		
			if (doing == OUTPUT_LEVEL) doing = RULE_LEVEL; // change mode on new rule
		}

		if (debugTrace & RULE_MATCH && match) debugTrace ^= RULE_MATCH;	 // stop on all matching rules
		else if (debugTrace & RULE_TRACE) return;
		else if (out2level >= -1 && globalDepth > out2level) return;	// waiting til we get back to a topic
		else if (doing != OUTPUT_LEVEL && doing != RULE_LEVEL && !(debugTrace & RULE_TRACE)) return;	// output_level can end up here by doing ^refine or can step over or in a rule, ending at next rule 
		else if (lastRuleTopic && currentTopicID != lastRuleTopic) return;	// not in the topic issuing the command ... but REUSE can use any topic so it has special commands to set it up

		output = 0; // no output yet
	}
	else if (code == PARSING_OUTPUT && doing == OUTPUT_LEVEL) // show the piece we are at IF its a call
	{
		if (!output) at = GetPattern(currentRule,NULL,NULL);
		else if (at < output) return;	// just execute it, we've displayed it
		char word[MAX_WORD_SIZE];
		output = ReadOutput(at,word);
		lastOutput = at;
		++action;
		IndentDebug();
		unsigned int n = strlen(GetTopicName(currentTopicID));
		while (--n) Log(STDDEBUGLOG," ");
		if (kind != 'i'  && kind != 'l' && kind != 'c') Log(STDDEBUGLOG,"      %d.%d act %d    %s\r\n",TOPLEVELID(currentRuleID),REJOINDERID(currentRuleID),action,word);
		else if (call)
		{
			char name[MAX_WORD_SIZE];
			ReadCompiledWord(call,name);
			Log(STDDEBUGLOG,"         %s act %d    %s\r\n",name,action,word);
		}
		else if (kind == 'l') Log(STDDEBUGLOG,"      LOOP act %d    %s\r\n",action,word);
		else if (kind == 'i') Log(STDDEBUGLOG,"      IF act %d    %s\r\n",action,word);
		else Log(STDDEBUGLOG,"         act %d    %s\r\n",action,word);
	}

	ExecuteResume(GetDebuggerResumeCommand());

#endif
}
#include "common.h"

#ifdef INFORMATION

This file covers routines that create and access a "dictionary entry" (WORDP) and the "meaning" of words (MEANING).

The dictionary acts as the central hash mechanism for accessing various kinds of data.

The dictionary consists of data imported from WORDNET 3.0 (copyright notice at end of file) + augmentations + system and script pseudo-words.

A word also gets the WordNet meaning ontology (->meanings & ->meaningCount). The definition of meaning in WordNet 
is words that are synonyms in some particular context. Such a collection in WordNet is called a synset. 

Since words can have multiple meanings (and be multiple parts of speech), the flags of a word are a summary
of all of the properties it might have and it has a list of entries called "meanings". Each entry is a MEANING 
and points to the circular list, one of which marks the word you land at as the synset head. 
 This is referred to as the "master" meaning and has the gloss (definition) of the meaning. The meaning list of a master node points back to 
all the real words which comprise it.

Since WordNet has an ontology, its synsets are hooked to other synsets in various relations, particular that
of parent and child. ChatScript represents these as facts. The hierarchy relation uses the verb "is" and
has the child as subject and the parent as object. Such a fact runs from the master entries, not any of the actual 
word entries. So to see if "dog" is an "animal", you could walk every meaning list of the word animal and
mark the master nodes they point at. Then you would search every meaning of dog, jumping to the master nodes,
then look at facts with the master node as subject and the verb "is" and walk up to the object. If the object is 
marked, you are there. Otherwise you take that object node as subject and continue walking up. Eventually you arrive at
a marked node or run out at the top of the tree.

Some words DO NOT have a master node. Their meaning is defined to be themselves (things like pronouns or determiners), so
their meaning value for a meaning merely points to themselves.
The meaning system is established by building the dictionary and NEVER changes thereafter by chatbot execution.
New words can transiently enter the dictionary for various purposes, but they will not have "meanings".

A MEANING is a reference to a specific meaning of a specific word. It is an index into the dictionary 
(identifying the word) and an index into that words meaning list (identifying the specific meaning).
An meaning list index of 0 refers to all meanings of the word. A meaning index of 0 can also be type restricted
so that it only refers to noun, verb, adjective, or adverb meanings of the word.

Since there are only two words in WordNet with more than 63 meanings (break and cut) we limit all words to having no
more than 63 meanings by discarding the excess meanings. Since meanings are stored most important first,
these are no big loss. This leaves room for the 5 essential type flags used for restricting a generic meaning.

Space for dictionary words, strings, and the meanings of words come from a common pool. Dictionary words are
allocated linearly forward in the pool, while strings and meanings are allocated linearly backwards. Thus
all dictionary entries are indexable as a giant array.

The dictionary separately stores uppercase and lowercase forms of the same words (since they have different meanings).
There is only one uppercase form stored, so United and UnItED would be saved as one entry. The system will have
to decide which case a user intended, since they may not have bothered to capitalize a proper noun, or they 
may have shouted a lowercase noun, and a noun at the start of the sentence could be either proper or not.

Dictionary words are hashed as lower case, but if the word has an upper case letter it will be stored
in the adjacent higher bucket. Words of the basic system are stored in their appropriate hash bucket.
After the basic system is read in, the dictionary is frozen. This means it remembers the spots the allocation
pointers are at for the dictionary and string space and is using mark-release memory management.

Words created on the fly (after a freeze) by interacting with a user are always stored in bucket 0. 
This allows the system to instantly discard them when the interaction has been processed merey by 
zeroing bucket 0. The string space and dictionary space allocated to those on-the-fly words are merely 
"released" back to the values at the time of dictionary freeze.

We mark sysnet entries with the word & meaning number & POS of word in the dictionary entry. The POS not used explicitly by lots of the system
but is needed when seeing the dictionary definitions (:word) and if one wants to use pos-restricted meanings in a match or in keywords.

#endif

#define HASH_EXTRA		2					// +1 for being 1-based and +1 for having uppercase bump

bool buildDictionary = false;				// indicate when building a dictionary
char dictionaryTimeStamp[20];		// indicate when dictionary was built
char language[40];							// indicate current language used

static unsigned int rawWords = 0;	

static unsigned char* writePtr;				// used for binary dictionary writes

// memory data
#define MAX_STRING_SPACE 30000000  // transient string space
unsigned long maxHashBuckets = MAX_HASH_BUCKETS;
bool setMaxHashBuckets = false;
unsigned long maxDictEntries = MAX_ENTRIES;
unsigned long maxStringBytes = MAX_STRING_SPACE;
unsigned int userTopicStoreSize,userTableSize; // memory used which we will display
char livedata[500];		// where is the livedata folder

MEANING posMeanings[64];				// concept associated with propertyFlags of WORDs
MEANING sysMeanings[64];				// concept associated with systemFlags of WORDs

bool fullDictionary = true;				// we have a big master dictionary, not a mini dictionary

// start and ends of space allocations
WORDP dictionaryBase = 0;			// base of allocated space that encompasses dictionary, string space, and meanings
WORDP dictionaryFree;				// current next dict space available going forward (not a valid entry)
char* stringBase;					// start of string space (runs backward)
char* stringFree;					// current free string ptr

// return-to values after WordNet loaded, before topic system loaded
WORDP dictionaryPreBuild0;
static char* stringSpacePreBuild0 = 0;
// wordnetFacts

// return-to values after build0 topic data loaded, before build1 topic data loaded
WORDP dictionaryPreBuild1;
static char* stringSpacePrebuild1;
// build0Facts 
	
// return-to values after build1 loaded, before user is loaded
WORDP dictionaryLocked;
FACT* factLocked;
char* stringLocked;

// format of word looked up
uint64 verbFormat;
uint64 nounFormat;
uint64 adjectiveFormat;
uint64 adverbFormat;

// dictionary ptrs for these words
WORDP Dplacenumber;
WORDP Dpropername;
MEANING Mphrase;
MEANING MabsolutePhrase;
MEANING MtimePhrase;
WORDP Dclause;
WORDP Dverbal;
WORDP Dmalename,Dfemalename,Dhumanname;
WORDP Dtime;
WORDP Dunknown;
WORDP Dchild,Dadult;
MEANING Mchatoutput;
MEANING Mburst;
MEANING Mpending;
MEANING Mkeywordtopics;
MEANING Mmoney;
MEANING Mintersect;
MEANING MconceptComment;
MEANING MgambitTopics;
MEANING MadjectiveNoun;
MEANING Mnumber;
WORDP Dpronoun;
WORDP DunknownWord;

// language indirect code so can implement different languages
char* (*P_GetAdjectiveBase)(char*, bool) = NULL;   
char* (*P_GetAdverbBase)(char*,bool) = NULL;
char* (*P_GetPastTense)(char*) = NULL;
char* (*P_GetPastParticiple)(char*) = NULL;
char* (*P_GetPresentParticiple)(char*) = NULL;
char* (*P_GetThirdPerson)(char*) = NULL;
char* (*P_GetInfinitive)(char*,bool) = NULL;
char* (*P_GetSingularNoun)(char*,bool,bool) = NULL;
char* (*P_GetPluralNoun)(WORDP) = NULL;
void (*P_TagIt)() = NULL;
void (*P_SetSentenceTense)(unsigned int start, unsigned int end) = NULL;
	
static char* predefinedSets[] = //  some internally mapped concepts not including emotions from LIVEDATA/interjections
{
	"~mainsubject","~mainverb","~mainobject","~mainindirectobject",
	"~subject2","~verb2","~object2","~indirectobject2",
	"~appositive","~subjectcomplement","~objectcomplement","~address",
    "~repeatme","~repeatinput1","~repeatinput2","~repeatinput3","~repeatinput4","~repeatinput5","~repeatinput6",
    NULL
};

char* UseDictionaryFile(char* name)
{
	static char junk[100];
	if (!*language) sprintf(junk,"DICT/%s",name);
	else if (!name) sprintf(junk,"DICT/%s",language);
	else sprintf(junk,"DICT/%s/%s",language,name);
	return junk;
}

unsigned char BitCount(uint64 n)  
{  
	unsigned char count = 0;  
    while (n)  
	{  
       count++;  
       n &= (n - 1);  
    }  
    return count;  
 } 

WORDP GetSubstitute(WORDP D)
{
	return (D && D->internalBits & HAS_SUBSTITUTE)  ?  D->w.substitutes : 0;
}

void BuildShortDictionaryBase();

static void ClearDictionaryFiles()
{
	char buffer[MAX_BUFFER_SIZE];
	fclose(fopen(UseDictionaryFile("other.txt"),"wt")); //   create but empty file
    unsigned int i;
	for (i = 'a'; i <= 'z'; ++i)
	{
		sprintf(buffer,"%c.txt",i);
		fclose(fopen(UseDictionaryFile(buffer),"wt")); //   create but empty file
	}
	for (i = '0'; i <= '9'; ++i)
	{
		sprintf(buffer,"%c.txt",i);
		fclose(fopen(UseDictionaryFile(buffer),"wt")); //   create but empty file
	}
}

void BuildDictionary(char* label)
{
	buildDictionary = true;
	int miniDict = 0;
	char word[MAX_WORD_SIZE];
	char lang[MAX_WORD_SIZE];
	strcpy(lang,"ENGLISH");
	char* ptr = ReadCompiledWord(label,word);
	bool makeBaseList = false;
	if (!stricmp(word,"wordnet")) // the FULL wordnet dictionary w/o synset removal
	{
		miniDict = -1;
		ReadCompiledWord(ptr,word);
	}
	else if (!stricmp(word,"short")) // a mini dictionary
	{
		ReadCompiledWord(ptr,word);
		if (!stricmp(word,"init")) 
		{
			makeBaseList = true;
			fclose(fopen("RAWDICT/basicwordlist.txt","wb"));
		}
		miniDict = 1;
		strcpy(lang,"mini");
		maxHashBuckets = 10000;
		setMaxHashBuckets = true;
	}

	// insure language subdirectory exists
#ifdef WIN32
	_mkdir(UseDictionaryFile(NULL));
#else 
	mkdir(UseDictionaryFile(NULL), 0777); 
#endif
		
	if (*lang) MakeUpperCopy(language,lang); // localized version of dict. otherwise its of the current language

	InitFacts(); 
	InitDictionary();
	LoadRawDictionary(miniDict); 
	if (miniDict) StoreWord("minidict"); // mark it as a mini dictionary

	// dictionary has been built now
	printf("Dumping dictionary\r\n");
	ClearDictionaryFiles();
	WalkDictionary(WriteDictionary);
	if (makeBaseList) BuildShortDictionaryBase(); // write out the basic dictionary
	NoteLanguage(); // set default is most recent built dictionary

 	remove(UseDictionaryFile("dict.bin")); // invalidate cache of dictionary, forcing binary rebuild later
    WriteFacts(FopenUTF8Write(UseDictionaryFile("facts.txt")),factBase); 
	sprintf(logFilename,"USERS/build_log.txt"); // all data logged here by default
	FILE* out = FopenUTF8Write(logFilename);
	if (out) fclose(out);
	printf("dictionary dump complete %d\r\n",miniDict);

    echo = true;
	buildDictionary = false;
	CreateSystem();
}

void InitDictionary()
{
	// read what the default dictionary wants as hash if parameter didnt set it
	if (!setMaxHashBuckets)
	{
		FILE* in = FopenStaticReadOnly(UseDictionaryFile("dict.bin")); 
		if (in) 
		{
			maxHashBuckets = Read32(in); // bucket size used by dictionary file
			fclose(in);
		}
	}

	dictionaryLocked = 0;
	userTopicStoreSize = userCacheCount * userCacheSize; //  minimum cache spot
	userTopicStoreSize /= 64;
	userTopicStoreSize = (userTopicStoreSize * 64) + 64;
	
	//   dictionary and meanings and strings share space, running from opposite ends of a common pool
	size_t size = sizeof(WORDENTRY) * maxDictEntries;
	size += maxStringBytes;
	size /= sizeof(WORDENTRY);
	size = (size * sizeof(WORDENTRY)) + sizeof(WORDENTRY);
	size /= 64;
	size = (size * 64) + 64; // 64 bit align both ends
	// on FUTURE startups (not 1st) the userCacheCount has been preserved while the rest of the system is reloaded
	if ( dictionaryBase == 0) // 1st startup allocation -- not needed on a reload
	{
		userTableSize = userCacheCount * 3 * sizeof(unsigned int);
		userTableSize /= 64;
		userTableSize = (userTableSize * 64) + 64; // 64 bit align both ends
		InitCache((unsigned int)size);
		dictionaryBase = (WORDP) (cacheBase + userTopicStoreSize + userTableSize);
	}
	memset(dictionaryBase,0,size);
	dictionaryFree =  dictionaryBase + maxHashBuckets + HASH_EXTRA ;		//   prededicate hash space within the dictionary itself
	stringBase = stringFree = ((char*)dictionaryBase) + size;				//   the end of the allocated space

	//   The bucket list is threaded thru WORDP nodes, and consists of indexes, not addresses.

	dictionaryPreBuild0 = 0;				// in initial dictionary
	build0Facts = wordnetFacts = factFree;	// last fact in dictionary 
}

char* AllocateString(char* word,size_t len,bool align64,bool clear)
{ //   string allocation moves BACKWARDS from end of dictionary space (as do meanings)
	if (len == 0) len = strlen(word);
	if (word) ++len;	// null terminate string

	//   always allocate on word boundary (since we share with meaning space)
	unsigned int allocate = ((len + 3) / 4) * 4;

	stringFree -= allocate;
 	if (align64) // force 64bit alignment alignment
	{
		uint64 base = (uint64) stringFree;
		base &= 0xFFFFFFFFFFFFFFC0ULL;
		stringFree = (char*) base;
	}
	char* newword =  stringFree;
    if (stringFree <= (char*) dictionaryFree) 
    {
		stringFree += allocate - 4; 
		static bool failed = false;
		if (!failed)
		{
			ReportBug("Out of transient string space")
			failed = true;
			return 0;
		}
        len = 2;
#ifndef WIN32
		myexit("no more transient string space");
#endif
    }
    if (word) 
	{
		memcpy(newword,word,--len);
		newword[len] = 0;
	}
	else if (clear) memset(newword,0,len);
    return newword;
}

void AddInternalFlag(WORDP D, uint64 flag)
{
	if (flag && flag != D->internalBits)
	{
		if (D < dictionaryLocked)
			return;
		D->internalBits |= (unsigned int) flag;
	}
}

void RemoveInternalFlag(WORDP D,unsigned int flag)
{
	D->internalBits &= -1 ^ flag;
}

void AddSystemFlag(WORDP D, uint64 flag)
{
	if (flag && flag != D->systemFlags)
	{
		if (D < dictionaryLocked)
			return;
		D->systemFlags |= flag;
	}
}

void RemoveSystemFlag(WORDP D, uint64 flags)
{
	D->systemFlags &= -1LL ^ flags;
}

void AddProperty(WORDP D, uint64 flag)
{
	if (flag && flag != D->properties)
	{
		if (D < dictionaryLocked)
			return;
		D->properties |= flag;
	}
}

void RemoveProperty(WORDP D, uint64 flags)
{
	D->properties &= -1LL ^ flags;
}

char* GetCanonical(WORDP D)
{
	if (!D->extensions) return NULL;
	unsigned int x = AccessCanonical(D);
	if (!x) return NULL;
	WORDP X = Meaning2Word(x);
	return  X->word;
}

WORDP FindWord(const char* word, int len,uint64 caseAllowed) 
{
	if (word == NULL || *word == 0) return NULL;
	uint64 fullhash = Hashit((unsigned char*) word,(!len) ? 100000 : len); //   sets hasUpperCharacters and hasUTF8Characters 
	unsigned int hash  = (fullhash % maxHashBuckets) + 1; // mod by the size of the table
	if (caseAllowed & LOWERCASE_LOOKUP){;}
	else if (*word == '%' || *word == '$' || *word == '~'  || *word == '^') caseAllowed = LOWERCASE_LOOKUP; // these are always lower case
	else if (hasUpperCharacters || (caseAllowed & UPPERCASE_LOOKUP)) ++hash;

	// you can search on upper or lower specifically (not both) or primary or secondary or both

	//   normal or fixed case bucket
	WORDP D;
	if (caseAllowed & (PRIMARY_CASE_ALLOWED|LOWERCASE_LOOKUP|UPPERCASE_LOOKUP))
	{
		D = dictionaryBase + hash;
		while (D != dictionaryBase)
		{
			if (fullhash == D->hash)
			{
				// if (!strnicmp(D->word,word,len))  
					return D;
				// int xx = 0;
			}
			D = dictionaryBase + GETNEXTNODE(D);
		}
	}

    //    alternate case bucket
	if (caseAllowed & SECONDARY_CASE_ALLOWED) 
	{
		D = dictionaryBase + hash + ((hasUpperCharacters) ? -1 : 1);
		while (D != dictionaryBase)
		{
			if (fullhash == D->hash)
			{
				// if (!strnicmp(D->word,word,len))  
					return D;
				// int xx = 0;
			}
			D = dictionaryBase + GETNEXTNODE(D);
		}
	}

    return NULL;
}

static WORDP AllocateEntry()
{
	WORDP  D = dictionaryFree++; 
	if (Word2Index(D) >= maxDictEntries)
	{
		ReportBug("used up all dict nodes\r\n")
		myexit("used up all dict nodes");
	}
    memset(D,0,sizeof(WORDENTRY));
	return D;
}

WORDP StoreWord(int val) // create a number word
{
	char value[MAX_WORD_SIZE];
	sprintf(value,"%d",val);
	return StoreWord(value);
}

WORDP StoreWord(char* word, uint64 properties, uint64 flags)
{
	WORDP D = StoreWord(word,properties);
	AddSystemFlag(D,flags);
	return D;
}

WORDP StoreWord(char* word, uint64 properties)
{
	if (!server) // servers dont want long lists of bugs from strange inputs
	{
		if (!*word) //   we require something 
		{
			ReportBug("entering null word to dictionary")
			return StoreWord("badword");
		}
	}
	if (!*word) return StoreWord("badword"); //   we require something

	unsigned int n = 0;
	bool lowercase = false;

	//   make all words normalized with no blanks in them.
	if (*word == '"' || *word == '_') {;} // dont change any quoted things or things beginning with _ (we use them in facts for a "missing" value) or user var names
	else if (*word == '%' || *word == '$' || *word == '~'  || *word == '^') lowercase = true; // these are always lower case
	else if (!(properties & (AS_IS|PUNCTUATION))) 
	{
		n = BurstWord(word,0);
		word = JoinWords(n); //   when reading in the dictionary, BurstWord depends on it already being in, so just use the literal text here
	}
	properties &= -1 ^ AS_IS;
	size_t len = strlen(word);
	uint64 fullhash = Hashit((unsigned char*)word,len); //   this sets hasUpperCharacters as well if needed
	unsigned int hash = (fullhash % maxHashBuckets) + 1; //   mod the size of the table (saving 0 to mean no pointer and reserving an end upper case bucket)
	if (hasUpperCharacters)
	{
		if (lowercase) hasUpperCharacters = false;
		else if (!lowercase)  ++hash;
	}
	WORDP base = dictionaryBase + hash;
 
	//   locate spot existing entry goes
    WORDP D = base; 
	while (D != dictionaryBase)
    {
 		if (fullhash == D->hash)
		{
		//	if (!strnicmp(D->word,word,len))
		//	{
				AddProperty(D,properties);
				return D;
		//	}
	//		int xx = 0;
		}
		D = dictionaryBase + GETNEXTNODE(D);
    }  

    //   not found, add entry 
	char* wordx = AllocateString(word,len); 
    if (!wordx) return NULL;

	if (base->word == 0 && !dictionaryPreBuild0) D = base; // add into hash zone initial dictionary entries (nothing allocated here yet)
	else  
	{
		D = AllocateEntry();
		if ((char*)D >= stringFree)  myexit("out of dictionary space");
		D->nextNode = GETNEXTNODE(base);
		base->nextNode &= MULTIHEADERBITS;
		base->nextNode |= D - dictionaryBase;
	}
	// fill in data on word
    D->word = wordx; 
    AddProperty(D,properties);
	if (properties & PART_OF_SPEECH && n > 1) //   make composite real words auto find in input -- dont header a concept name
	{
		WORDP X = StoreWord(JoinWords(1));		// create the 1-word header
		if (n > GETMULTIWORDHEADER(X)) SETMULTIWORDHEADER(X,n);	//   mark it can go this far for an idiom
	}
	if (hasUTF8Characters) AddInternalFlag(D,UTF8);
	if (hasUpperCharacters) AddInternalFlag(D,UPPERCASE_HASH);
	D->hash = fullhash;
	D->length = (unsigned short) len;
    return D;
}

//   insert entry into a circular list, initializing if need be
void AddCircularEntry(WORDP base, unsigned int field,WORDP entry)
{
	if (!base) return;
	PrepareConjugates(base);
	PrepareConjugates(entry);

	//   verify item to be added not already in circular list of this kind - dont add if it is
	char* con = Index2String(entry->extensions);
	MEANING* mean = (MEANING*) con;
	if (!mean[field]) 
	{
		char* conb = Index2String(base->extensions);
		MEANING* meanb = (MEANING*) conb;
		if (!meanb[field]) meanb[field] = MakeMeaning(base); // if set base not initialized, make it loop to self
		mean[field] = meanb[field];
		meanb[field] = MakeMeaning(entry);
	}
	else printf("%s already on circular list of %s\r\n",entry->word, base->word);
}

void WalkDictionary(DICTIONARY_FUNCTION func,uint64 data)
{
    for (WORDP D = dictionaryBase+1; D < dictionaryFree; ++D) 
	{
		if (D->word) (func)(D,data); 
	}
}

void DeleteDictionaryEntry(WORDP D)
{
	unsigned int hash = (D->hash % maxHashBuckets) + 1; 
	if (D->internalBits & UPPERCASE_HASH) ++hash;
	WORDP base = dictionaryBase + hash;
	base->nextNode &= MULTIHEADERBITS;
	base->nextNode |= GETNEXTNODE(D); //   remove entry from buckets
}

void ReturnToFreeze() 
{ 
	if (!dictionaryLocked)
	{
		 ReturnDictionaryToWordNet();
		 return;
	}
	unsigned int copy = xrefCount;
	if (ruleStats) 
	{
		bool oldecho = echo;
		echo = true;
		static unsigned int maxRules = 0;
		static unsigned int maxDict = 0;
		static unsigned int maxText = 0;
		static unsigned int maxFact = 0;
		static unsigned int maxXref = 0;
		unsigned int dictUsed = dictionaryFree - dictionaryLocked;
		if (dictUsed > maxDict) maxDict = dictUsed;
		unsigned int factUsed = factFree - factLocked;
		if (factUsed > maxFact) maxFact = factUsed;
		unsigned int textUsed = stringLocked - stringFree;
		if (textUsed > maxText) maxText = textUsed;
		if (ruleCount > maxRules) maxRules = ruleCount;
		if (xrefCount > maxXref) maxXref = xrefCount;
		Log(STDUSERLOG,"used: rules=%d dict=%d fact=%d text=%d mark=%d\r\n",ruleCount,dictUsed,factUsed,textUsed,xrefCount);
		Log(STDUSERLOG,"      maxrules=%d  maxdict=%d maxfact=%d  maxtext=%d maxxref=%d\r\n",maxRules,maxDict,maxFact,maxText,maxXref);
		echo = oldecho;
		ruleCount = 0;
		xrefCount = 0;
	}		
	ClearUserVariables();
	ClearWhereInSentence(true);
	FreeTemps(); // temps allocated out of string space can disappear now after erasing from dict. THEN can release DICT and strings.
	ResetFactSystem();
	while (dictionaryFree > dictionaryLocked) DeleteDictionaryEntry(--dictionaryFree); //   remove entry from buckets
    stringFree = stringLocked; 
	// system doesnt track changes to properties after freeze
}

void WordnetLockDictionary() // dictionary before build0 layer 
{
    dictionaryPreBuild0 = dictionaryFree;		
	stringSpacePreBuild0 = stringFree;		//   mark point for mark release
	build0Facts = wordnetFacts = factFree;

#ifndef DISCARDSCRIPTCOMPILER
	// memorize dictionary values for backup to pre build locations :build0 operations (reseting word to dictionary state)
	FILE* out1 = fopen("TMP/prebuild0","wb");
	if (!out1)  ReportBug("Cant generate tmp backups of dict values. Guessing folder isn't writeable.")
	else
	{
		for (WORDP D = dictionaryBase+1; D < dictionaryFree; ++D) 
		{
			Write64(D->properties,out1);
			Write64(D->systemFlags,out1);
			unsigned char head = GETMULTIWORDHEADER(D);
			fwrite(&head,1,1,out1);
		}
		fclose(out1);
	}
#endif
}

void ReturnDictionaryToWordNet() // drop all non-fact memeory allocated after the wordnet freeze
{
	ClearWhereInSentence(true);
	FreeTemps(); // temps allocated out of string space can disappear now after erasing from dict. THEN can release DICT and strings.
	while (factFree > wordnetFacts) FreeFact(factFree--); // restore to end of dictionary load
	while (dictionaryFree > dictionaryPreBuild0) DeleteDictionaryEntry(--dictionaryFree); // remove entry from buckets
    stringFree = stringSpacePreBuild0;
#ifndef DISCARDSCRIPTCOMPILER
	FILE* in = fopen("TMP/prebuild0","rb");
	if (in)
	{
		for (WORDP D = dictionaryBase+1; D < dictionaryFree; ++D) 
		{
			D->properties = Read64(in);
			D->systemFlags = Read64(in);
			unsigned char c;
			int n = fread(&c,1,1,in);
			if (n != 1) myexit("bad return to wordnet");
			SETMULTIWORDHEADER(D,c);
		}
		fclose(in);
	}
#endif
	dictionaryLocked = 0;
}

void Build0LockDictionary() // dictionary after build0 and before build1 layers 
{
    dictionaryPreBuild1 = dictionaryFree;		
	stringSpacePrebuild1 = stringFree;	
    build0Facts = factFree; 
#ifndef DISCARDSCRIPTCOMPILER
	FILE* out = fopen("TMP/prebuild1","wb");
	if (out)
	{
		for (WORDP D = dictionaryBase+1; D < dictionaryPreBuild1; ++D) 
		{
			fwrite(&D->properties,1,8,out); 
			fwrite(&D->systemFlags,1,8,out); 
			unsigned char head = GETMULTIWORDHEADER(D);
			fwrite(&head,1,1,out);
		}
		fclose(out);
	}
#endif
}

void ReturnDictionaryToBuild0() 
{
	while (factFree > build0Facts) FreeFact(factFree--); //   restore back to facts alone
	while (dictionaryFree > dictionaryPreBuild1) DeleteDictionaryEntry(--dictionaryFree); //   remove entry from buckets
    stringFree = stringSpacePrebuild1;
#ifndef DISCARDSCRIPTCOMPILER
	FILE* in = fopen("TMP/prebuild1","rb");
	if (in)
	{
		for (WORDP D = dictionaryBase+1; D < dictionaryFree; ++D) 
		{
			fread(&D->properties,1,8,in); 
			fread(&D->systemFlags,1,8,in); 
			unsigned char c;
			int n = fread(&c,1,1,in);
			if (n != 1) myexit("bad return to build0");
			SETMULTIWORDHEADER(D,c);
		}
		fclose(in);
	}
#endif

	// canonical map in layer 1 is now garbage- 
	dictionaryLocked = 0;
}

void FreezeBasicData()
{
	WORDP D = dictionaryBase - 1;
	while (++D < dictionaryFree)
	{
		if (D->properties & (PART_OF_SPEECH|TAG_TEST)) AddInternalFlag(D, BASE_DEFINED); // word has known pos meanings before entering user volley
	}
    dictionaryLocked = dictionaryFree;		
	stringLocked = stringFree;		
    factLocked = factFree; 
}

void CloseDictionary()
{
	CloseTextUtilities();
	dictionaryBase = NULL;
	CloseCache(); // actual memory space of the dictionary
}

static void Write8(unsigned int val, FILE* out)
{
	unsigned char x[1];
	x[0] = val & 0x000000ff;
	if (out) fwrite(x,1,1,out);
	else *writePtr++ = *x;
}

static void Write16(unsigned int val, FILE* out)
{
	unsigned char x[2];
	x[0] = val & 0x000000ff;
	x[1] = (val >> 8) & 0x000000ff;
	if (out) fwrite(x,1,2,out);
	else 
	{
		memcpy(writePtr,(unsigned char*)x,2);
		writePtr += 2;
	}
}

void Write24(unsigned int val, FILE* out)
{
	unsigned char x[3];
	x[0] = val & 0x000000ff;
	x[1] = (val >> 8) & 0x000000ff;
	x[2] = (val >> 16) & 0x000000ff;
	if (out) fwrite(x,1,3,out);
	else 
	{
		memcpy(writePtr,(unsigned char*)x,3);
		writePtr += 3;
	}
}

void Write32(unsigned int val, FILE* out)
{
	unsigned char x[4];
	x[0] = val & 0x000000ff;
	x[1] = (val >> 8) & 0x000000ff;
	x[2] = (val >> 16) & 0x000000ff;
	x[3] = (val >> 24) & 0x000000ff;
	if (out) fwrite(x,1,4,out);
	else 
	{
		memcpy(writePtr,(unsigned char*)x,4);
		writePtr += 4;
	}
}

void Write64(uint64 val, FILE* out)
{
	unsigned char x[8];
	x[0] = val & 0x000000ff;
	x[1] = (val >> 8) & 0x000000ff;
	x[2] = (val >> 16) & 0x000000ff;
	x[3] = (val >> 24) & 0x000000ff;
	x[4] = (val >> 32) & 0x000000ff;
	x[5] = (val >> 40) & 0x000000ff;
	x[6] = (val >> 48) & 0x000000ff;
	x[7] = (val >> 56) & 0x000000ff;
	if (out) fwrite(x,1,8,out);
	else 
	{
		memcpy(writePtr,(unsigned char*)x,8);
		writePtr += 8;
	}
}

void WriteDWord(WORDP ptr, FILE* out)
{
	unsigned int val = (ptr) ? Word2Index(ptr) : 0;
	unsigned char x[3];
	x[0] = val & 0x000000ff;
	x[1] = (val >> 8) & 0x000000ff;
	x[2] = (val >> 16) & 0x000000ff;
	if (out) fwrite(x,1,3,out);
	else 
	{
		memcpy(writePtr,(unsigned char*)x,3);
		writePtr += 3;
	}
}

static void WriteString(char* str, FILE* out)
{
	if (!str || !*str) Write16(0,out);
	else
	{
		size_t len = strlen(str);
		Write16(len,out);
		if (out) fwrite(str,1,len+1,out);
		else
		{
			memcpy(writePtr,(unsigned char*)str,len+1);
			writePtr += len+1;
		}
	}
}

static void WriteBinaryEntry(WORDP D, FILE* out)
{
	unsigned char c;
	writePtr = (unsigned char*)(readBuffer+2); // reserve size space
	if (!D->word) // empty entry
	{
		c = 0;
		WriteString((char*)&c,0);
		unsigned int len = writePtr-(unsigned char*)readBuffer;
		*readBuffer = (unsigned char)(len >> 8);
		readBuffer[1] = (unsigned char)(len & 0x00ff);
		fwrite(readBuffer,1,len,out);
		return;
	}

	WriteString(D->word,0);
	unsigned int bits = 0;
	if (GETMULTIWORDHEADER(D)) bits |= 1 << 0;
	if (GetTense(D)) bits |= 1 << 1;
	if (GetPlural(D)) bits |= 1 << 2;
	if (GetComparison(D)) bits |= 1 << 3;
	if (GetMeaningCount(D)) bits |= 1 << 4;
	if (GetGlossCount(D)) bits |= 1 << 5;
	if (D->systemFlags | D->properties) bits |= 1 << 6;
	if (D->internalBits) bits |= 1 << 7;
	Write8(bits,0);

	if (D->properties || D->systemFlags) 
	{
		Write64(D->properties,0);
		Write64(D->systemFlags,0);
	}
	if (D->internalBits) Write32(D->internalBits,0);
	if (D->internalBits & DEFINES) Write32(D->inferMark,0); // store invert value for some things
	Write24(D->nextNode,0); 

	if (GETMULTIWORDHEADER(D))
	{
		c = (unsigned char)GETMULTIWORDHEADER(D);
		Write8(c,0); //   limit 255 no problem
	}
	if (GetTense(D)) Write32(MakeMeaning(GetTense(D)),0);
	if (GetPlural(D)) Write32(MakeMeaning(GetPlural(D)),0);
	if (GetComparison(D)) Write32(MakeMeaning(GetComparison(D)),0);
	if (GetMeaningCount(D)) 
	{
		unsigned char c = (unsigned char)GetMeaningCount(D);
		Write8(c,0);  //   limit 255 no problem
		for (unsigned int i = 1; i <= GetMeaningCount(D); ++i) Write32(GetMeaning(D,i),0);
	}
	if (GetGlossCount(D)) 
	{
		unsigned char c = (unsigned char)GetGlossCount(D);
		Write8(c,0); //   limit 255 no problem
		for (unsigned int i = 1; i <= GetGlossCount(D); ++i) 
		{
			Write8(D->w.glosses[i] >> 24,0);
			WriteString(Index2String(D->w.glosses[i] & 0x00ffffff),0);
		}
	}
	Write8('0',0);
	unsigned int len = writePtr - (unsigned char*) readBuffer;
	*readBuffer = (unsigned char)(len >> 8);
	readBuffer[1] = (unsigned char)(len & 0x00ff);
	fwrite(readBuffer,1,len,out);
}

void WriteBinaryDictionary()
{
	FILE* out = fopen(UseDictionaryFile("dict.bin"),"wb");
	if (!out) return;
	Write32(maxHashBuckets,out); // bucket size used
	WORDP D = dictionaryBase;
	while (++D < dictionaryFree) WriteBinaryEntry(D,out);
	char x[2];
	x[0] = x[1] = 0;
	fwrite(x,1,2,out); //   end marker for synchronization
	// add datestamp
	strcpy(dictionaryTimeStamp, GetMyTime(time(0)));
	fwrite(dictionaryTimeStamp,1,20,out);
	fclose(out);
	printf("binary dictionary %ld written\r\n",(long int)(dictionaryFree - dictionaryBase));
}

static unsigned char Read8(FILE* in) 
{
	if (in)
	{
		unsigned char x[1];
		return (fread(x,1,1,in) != 1) ? 0 : (*x);
	}
	else return *writePtr++;
}

static unsigned short Read16(FILE* in) 
{
	if (in)
	{
		unsigned char x[2];
		return (fread(x,1,2,in) != 2) ? 0 : ((*x) | (x[1]<<8));
	}
	else 
	{
		unsigned int n = *writePtr++;
		return (unsigned short)(n | (*writePtr++ << 8));
	}
}

static unsigned int Read24(FILE* in)
{
	if (in)
	{
		unsigned char x[3];
		if (fread(x,1,3,in) != 3) return 0;
		return (*x) | ((x[1]<<8) | (x[2]<<16));
	}
	else
	{
		unsigned int n = *writePtr++;
		n |= (*writePtr++ << 8);
		return n | (*writePtr++ << 16);
	}
}
  
unsigned int Read32(FILE* in)
{
	if (in)
	{
		unsigned char x[4];
		if (fread(x,1,4,in) != 4) return 0;
		unsigned int x3 = x[3];
		x3 <<= 24;
		return (*x) | (x[1]<<8) | (x[2]<<16) | x3 ;
	}
	else
	{
		unsigned int n = *writePtr++;
		n |= (*writePtr++ << 8);
		n |= (*writePtr++ << 16);
		return n | (*writePtr++ << 24);
	}
}

uint64 Read64(FILE* in)
{
	if (in)
	{
		unsigned char x[8];
		if (fread(x,1,8,in) != 8) return 0;
		unsigned int x1,x2,x3,x4,x5,x6,x7,x8;
		x1 = x[0]; 
		x2 = x[1];
		x3 = x[2];
		x4 = x[3];
		x5 = x[4];
		x6 = x[5];
		x7 = x[6];
		x8 = x[7];
		uint64 a = x1 | (x2<<8) | (x3<<16) | (x4<<24);
		uint64 b = x5 | (x6<<8) | (x7<<16) | (x8<<24);
		b <<= 16;
		b <<= 16;
		a |= b;
		return a;
	}
	else
	{
		unsigned int n = *writePtr++;
		n |= (*writePtr++ << 8);
		n |= (*writePtr++ << 16);
		n |= (*writePtr++ << 24);

		unsigned int n1 = *writePtr++;
		n1 |= (*writePtr++ << 8);
		n1 |= (*writePtr++ << 16);
		n1 |= (*writePtr++ << 24);

		uint64 ans = n1;
		ans <<= 16;
		ans <<= 16;
		return n | ans ;
	}
}

WORDP ReadDWord(FILE* in)
{
	if (in)
	{
		unsigned char x[3];
		if (fread(x,1,3,in) != 3) return 0;
		return Index2Word((x[0]) + (x[1]<<8) + (x[2]<<16));
	}
	else
	{
		unsigned int n = *writePtr++;
		n |= (*writePtr++ << 8);
		n |= (*writePtr++ << 16);
		return Index2Word(n);
	}
}

static char* ReadString(FILE* in)
{
	unsigned int len = Read16(in);
	if (!len) return NULL;
	char* str;
	if (in)
	{
		char* buffer = AllocateBuffer();
		if (fread(buffer,1,len+1,in) != len+1) return NULL;
		str = AllocateString(buffer,len);
		FreeBuffer();
	}
	else 
	{
		str = AllocateString((char*)writePtr,len);
		writePtr += len + 1;
	}
	return str;
}

static WORDP ReadBinaryEntry(FILE* in)
{
	writePtr = (unsigned char*) readBuffer;
	unsigned int len = fread(writePtr,1,2,in);
	if (writePtr[0] == 0 && writePtr[1] == 0) return NULL;	//   normal ending in synch
	len = (writePtr[0] << 8 ) | writePtr[1];
	writePtr += 2;
	if (fread(writePtr,1,len-2,in) != len-2) myexit("bad binary dict entry"); // swallow entry

	unsigned int nameLen = *writePtr | (writePtr[1] << 8); // peek ahead
	WORDP D = AllocateEntry();
	char* name = ReadString(0);
	if (!name)  return D;
	D->word = name;
	D->length = (unsigned short)nameLen;
	echo = true;
	unsigned int bits = Read8(0);

    if (bits & ( 1 << 6)) 
	{
		D->properties = Read64(0);
		D->systemFlags = Read64(0);
	}
	if (bits & ( 1 << 7)) D->internalBits = Read32(0);
	if (D->internalBits & DEFINES) D->inferMark =  Read32(0); // xref 

	D->hash = Hashit((unsigned char*)name,nameLen);
	D->nextNode = Read24(0); 

	if (bits & (1 << 0)) 
	{
		unsigned char c = Read8(0);
		SETMULTIWORDHEADER(D,c);
	}
	if (bits & (1 << 1)) SetTense(D,Read32(0));
	if (bits & (1 << 2)) SetPlural(D,Read32(0));
	if (bits & (1 << 3)) SetComparison(D,Read32(0));
	if (bits & (1 << 4)) 
	{
		unsigned char c = Read8(0);
		unsigned int size = (c+1) * sizeof(MEANING);
		MEANING* meanings = (MEANING*) AllocateString(NULL,size); 
		memset(meanings,0,size); 
		D->meanings =  String2Index((char*)meanings);
		GetMeaning(D,0) = c;
		for (unsigned int i = 1; i <= c; ++i)  
		{
			GetMeaning(D,i) = Read32(0);
			if (GetMeaning(D,i) == 0)
			{
				ReportBug("binary entry meaning is null %s",name)
				myexit("null meaning for binary dict entry");
			}
		}
	}
	if (bits & (1 << 5)) // glosses
	{
		unsigned char c = Read8(0);
		unsigned int size = (c+1) * sizeof(MEANING);
		MEANING* glosses = (MEANING*) AllocateString(NULL,size); 
		memset(glosses,0,size); 
		glosses[0] = c;
		D->w.glosses =  glosses;
		for (unsigned int i = 1; i <= c; ++i)  
		{
			unsigned int index = Read8(0);
			char* string = ReadString(0);
			D->w.glosses[i] = String2Index(string) | (index << 24);
		}
		AddInternalFlag(D,HAS_GLOSS);
	}
	if (Read8(0) != '0')
	{
		printf("Bad Binary Dictionary entry, rebuild the binary dictionary %s\r\n",name);
		myexit("bad binary entry rebuilding");
	}
	return D;
}

bool ReadBinaryDictionary() 
{
	FILE* in = FopenStaticReadOnly(UseDictionaryFile("dict.bin")); 
	if (!in) return false;
	unsigned int size = Read32(in); // bucket size used
	if (size != maxHashBuckets) // if size has changed, rewrite binary dictionary
	{
		ReportBug("Binary dictionary uses hash=%d but system is using %d -- rebuilding binary dictionary\r\n",size,maxHashBuckets)
		return false;
	}
	dictionaryFree = dictionaryBase + 1;
	while (ReadBinaryEntry(in));
	unsigned int len = fread(dictionaryTimeStamp,1,20,in);
	fclose(in);
	return true;
}

void WriteDictionaryFlags(WORDP D, FILE* out)
{
	if (D->internalBits & DEFINES) return; // they dont need explaining, loaded before us
	uint64 properties = D->properties;
	uint64 bit = START_BIT;	
	while (properties)
	{
		if (properties & bit)
		{
			properties ^= bit;
			char* label = FindNameByValue(bit);
			fprintf(out,"%s ",label);
		}
		bit >>= 1;
	}

	properties = D->systemFlags;
	bit = START_BIT;
	while (properties)
	{
		if (properties & bit)
		{
			char* label = NULL;
			if (bit & ESSENTIAL_FLAGS)
			{
				if (bit & NOUN) label = "posdefault:NOUN";
				else if (bit & VERB) label = "posdefault:VERB";
				else if (bit & ADJECTIVE) label = "posdefault:ADJECTIVE";
				else if (bit & ADVERB) label = "posdefault:ADVERB";
				else if (bit & PREPOSITION) label = "posdefault:PREPOSITION";
			}
			else if (bit & (TOPIC | PATTERN_WORD)) label = NULL;			// internal marker or transient script compiler flag
			else label = FindName2ByValue(bit);
			properties ^= bit;
			if (label) fprintf(out,"%s ",label);
		}
		bit >>= 1;
	}
}

char* GetGloss(WORDP D,unsigned int index)
{
	index = GetGlossIndex(D,index);
	return (!index) ? 0 : (char*) Index2String(D->w.glosses[index] & 0x00ffffff);
}

unsigned int GetGlossIndex(WORDP D,unsigned int index)
{
	unsigned int count = GetGlossCount(D);
	if (!count) return 0;
	MEANING* glosses = D->w.glosses;
	for (unsigned int i = 1; i <= count; ++i)
	{
		if (GlossIndex(glosses[i]) == index) return i;
	}
	return 0;
}

static void WriteDictionaryReference(char* label,WORDP D,FILE* out)
{
    if (!D) return; 
	if (D->internalBits & DELETED_MARK) return;	// ignore bad links
    fprintf(out,"%s=%s ",label,D->word);
}

void WriteDictionary(WORDP D,uint64 data)
{
	if (D->internalBits & DELETED_MARK) return;
	if (*D->word == '$' && D->word[1]) return;	// var never and money never, but let $ punctuation through
	RemoveInternalFlag(D,(unsigned int)(-1 ^ (UTF8|UPPERCASE_HASH|DEFINES|HAS_GLOSS)));  // keep only these

	// choose appropriate subfile
	char c = toLowercaseData[(unsigned char) *D->word]; 
	char name[40];
	if (IsDigit(c)) sprintf(name,"%c.txt",c); //   main real dictionary
    else if (!IsLowerCase(c)) sprintf(name,"other.txt"); //   main real dictionary
    else sprintf(name,"%c.txt",c);//   main real dictionary
    FILE* out = FopenUTF8WriteAppend(UseDictionaryFile(name));

	//   write out the basics (name meaningcount idiomcount)
	fprintf(out," %s ( ",D->word);
	unsigned int count = GetMeaningCount(D);
	if (count) fprintf(out,"meanings=%d ",count);

	// check valid glosses (sometimes we have troubles that SHOULD have been found earlier)
	unsigned int ngloss = 0;
	for (unsigned int i = 1; i <= count; ++i)
	{
		if (GetGloss(D,i)) ++ngloss;
	}
	if (ngloss) fprintf(out,"glosses=%d ",ngloss);
	if (ngloss != GetGlossCount(D))
	{
		ReportBug("Bad gloss count for %s\r\n",D->word);
	}

	//   now do the dictionary bits into english
	WriteDictionaryFlags(D,out);
 	fprintf(out,") ");

	//   these must have valuable ->properties on them
	WriteDictionaryReference("conjugate",GetTense(D),out);
	WriteDictionaryReference("plural",GetPlural(D),out);
	WriteDictionaryReference("comparative",GetComparison(D),out);

	//   show the meanings, with illustrative gloss
		
	fprintf(out,"\r\n");

	//   now dump the meanings and their glosses
	for (unsigned int i = 1; i <= count; ++i)
	{
		MEANING M = GetMeaning(D,i);
		fprintf(out,"    %s ", WriteMeaning(M,true)); 
		if (M & SYNSET_MARKER) //   facts for this will be OUR facts
		{
			M = MakeMeaning(D,i) | (M & TYPE_RESTRICTION);
			FACT* F = GetSubjectHead(D);
			while (F)
			{
				if ( M == F->subject) // show up path as information only
				{
					fprintf(out,"(%s) ",WriteMeaning(F->object));
					break;
				}
				F = GetSubjectNext(F);
			}
			if (!F) 
			{
				if ((M & TYPE_RESTRICTION) != NOUN); // we dont believe wordnets other hierarchies.
				else if (Meaning2Word(GetMeaning(D,i)) == D) fprintf(out,"(%s) ",WriteMeaning(GetMeaning(D,i))); // was already a self master
				else fprintf(out,"() "); // show we dont recognize it...
			}
		}
		char* gloss =  GetGloss(D,i);
		if (gloss == NULL) gloss = "";
		fprintf(out,"%s\r\n",gloss);
	}
 
    fclose(out);
}

char* ReadDictionaryFlags(WORDP D, char* ptr,unsigned int* meaningcount, unsigned int * glosscount)
{
	char junk[MAX_WORD_SIZE];
	ptr = ReadCompiledWord(ptr,junk);
	uint64 properties = 0;
	uint64 flags = 0;
	while (*junk && *junk != ')' )		//   read until closing paren
	{
		if (!strncmp(junk,"meanings=",9)) 
		{
			if (meaningcount) *meaningcount = atoi(junk+9);
		}
		else if (!strncmp(junk,"glosses=",8)) 
		{
			if (glosscount) *glosscount = atoi(junk+8);
		}
		else if (!strncmp(junk,"#=",2));
		else if (!strcmp(junk,"posdefault:NOUN")) flags |= NOUN;
		else if (!strcmp(junk,"posdefault:VERB")) flags |= VERB;
		else if (!strcmp(junk,"posdefault:ADJECTIVE")) flags |= ADJECTIVE;
		else if (!strcmp(junk,"posdefault:ADVERB")) flags |= ADVERB;
		else if (!strcmp(junk,"posdefault:PREPOSITION")) flags |= PREPOSITION;
		else 
		{
			uint64 val = FindValueByName(junk);
			if (val) properties |= val;
			else
			{
				val = FindValue2ByName(junk);
				if (val) flags |= val;
			}
		}
		ptr = ReadCompiledWord(ptr,junk);
	}
	if (!(D->internalBits & DEFINES)) 
	{
		AddProperty(D,properties); // dont override existing define value
		AddSystemFlag(D,flags);
	}
	return ptr;
}

MEANING AddGloss(WORDP D,char* glossy,unsigned int index) // only a synset head can have a gloss
{ 
	//   cannot add gloss to entries before the freeze (space will free up when transient space chopped back but pointers will be bad).
	//   If some dictionary words cannot add after the fact, none should
	if (dictionaryLocked) return 0;
#ifndef NOGLOSS
	MEANING gloss = String2Index(glossy) | (index << 24);
	MEANING* glosses = D->w.glosses;
	//   if we run out of room, reallocate gloss space double in size (ignore the hole in memory)
	unsigned int oldCount = GetGlossCount(D);

	//prove we dont already have this here
	for (unsigned int i = 1; i <= oldCount; ++i) if (glosses[i] == gloss) return gloss;

	unsigned int count = oldCount + 1;  
	if (!(count & oldCount)) //   new count has no bits in common with old count, is a new power of 2
	{
		unsigned int size =  (count<<1) * sizeof(MEANING);
		glosses = (MEANING*) AllocateString(NULL,size); 
		memset(glosses,0,size); //   just to be purist
		memcpy(glosses+1,D->w.glosses+1,oldCount * sizeof(MEANING));
		D->w.glosses =  glosses;
		AddInternalFlag(D,HAS_GLOSS);
	}
	*glosses = count;
	return glosses[count] = gloss;
#else
	return 0;
#endif
}

MEANING AddTypedMeaning(WORDP D,unsigned int type)
{
	unsigned int count = 1 + GetMeaningCount(D);
	MEANING M =  MakeTypedMeaning(D,count, SYNSET_MARKER | type);
	return AddMeaning(D,M);
}

MEANING AddMeaning(WORDP D,MEANING M)
{ //   worst case wordnet meaning count = 75 (break)
	//   meaning is 1-based (0 means generic)
	//   cannot add meaning to entries before the freeze (space will free up when transient space chopped back but pointers will be bad).
	//   If some dictionary words cannot add after the fact, none should
	//   Meanings disambiguate multiple POS per word. User not likely to be able to add words that have
	//   multiple parts of speech.
	if (dictionaryLocked) return 0;
	//   no meaning given, use self with meaning one
	if (!(((ulong_t)M) & MAX_DICTIONARY)) M |= MakeMeaning(D,(1 + GetMeaningCount(D))) | SYNSET_MARKER;
	//   meanings[0] is always the count of existing meanings
	//   Actual space available is always a power of 2.
	MEANING* meanings = GetMeanings(D);
	//   if we run out of room, reallocate meaning space double in size (ignore the hole in memory)
	unsigned int oldCount = GetMeaningCount(D);
	if (oldCount == MAX_MEANING) return 0; // refuse more -- (break and cut)

	//prove we dont already have this here
	for (unsigned int i = 1; i <= oldCount; ++i) 
	{
		if (meanings[i] == M) return M;
		if (M & PREPOSITION && meanings[i] & PREPOSITION) return meanings[i]; // ignore any duplicate prep entries
	}

	unsigned int count = oldCount + 1;  
	if (!(count & oldCount)) //   new count has no bits in common with old count, is a new power of 2
	{
		unsigned int size =  (count<<1) * sizeof(MEANING);
		meanings = (MEANING*) AllocateString(NULL,size); 
		memset(meanings,0,size); //   just to be purist
		memcpy(meanings+1,&GetMeaning(D,1),oldCount * sizeof(MEANING));
		D->meanings =  String2Index((char*)meanings);
	}
	meanings[0] = count;
	return meanings[count] = M;
}

MEANING GetMaster(MEANING T)
{ //   for a specific meaning return node that is master or return general node if all fails.
	if (!T) return 0;
    WORDP D = Meaning2Word(T);
    unsigned int index = Meaning2Index(T);
	if (!GetMeaningCount(D)) return MakeMeaning(D,index); // has none, all erased
	if (index > GetMeaningCount(D))
	{
		ReportBug("Bad meaning index %s %d",D->word,index)
		return MakeMeaning(D,0);
	}
	if (index == 0) return T;
	MEANING old = T;
	MEANING at = GetMeanings(D)[index];
	unsigned int n = 0;
	while (!(at & SYNSET_MARKER)) // find the correct ptr to return. The marked ptr means OUR dict entry is master, not that the ptr points to.
	{
		old = at;
		WORDP X = Meaning2Word(at);
		unsigned int ind = Meaning2Index(at);
		if (ind > GetMeaningCount(X)) 
		{
			ReportBug("syset master failure %s",X->word)
			return old;
		}
		at = GetMeanings(X)[ind];
		if (++n >= 20) break; // force an end arbitrarily
	}
    return old & SIMPLEMEANING; // never return the type flags or synset marker -- FindChild loop wont want them nor will fact creation.
}

void RemoveMeaning(MEANING M, MEANING M1)
{
	M1 &= STDMEANING; 
	
	//   remove meaning and keep only valid main POS values (may not have a synset ptr when its irregular conjugation or such)
	WORDP D = Meaning2Word(M);
	for (unsigned int i = 1; i <= GetMeaningCount(D); ++i)
	{
		if ((GetMeaning(D,i) & STDMEANING) == M1) // he points to ourself
		{
			GetMeaning(D,i) = 0;
			unsigned int g = GetGlossIndex(D,i);
			if (g) D->w.glosses[g] = 0; // kill the gloss also if any
		}
	}
}

MEANING ReadMeaning(char* word,bool create,bool precreated)
{// be wary of multiple deletes of same word in low-to-high-order
	char hold[MAX_WORD_SIZE];
	if (*word == '\\' && word[1] && !word[2])  strcpy(hold,word+1);	//   special single made safe, like \[  or \*
	else strcpy(hold,word);
	word = hold;

	unsigned int flags = 0;
	unsigned int index = 0;

	char* at = (*word != '~') ? strchr(word,'~') : NULL; 
	if (at && *word != '"' ) // beware of topics or other things, dont lose them. we want xxx~n (one character) or  xxx~digits  or xxx~23n
	{
		if (IsDigit(at[1]))  // number starter  at~3  or   at~3n
		{
			index = atoi(at+1);
			char* p = at;
			while (IsDigit(*++p)); // find end
			if (*p == 'n') flags = NOUN;
			else if (*p == 'v') flags = VERB;
			else if (*p == 'a') flags = ADJECTIVE;
			else if (*p == 'b') flags = ADVERB;
			if (*p == 'z' ||  (*p && p[1] == 'z')) flags |= SYNSET_MARKER; 
			*at = 0; // drop the tail
		}
		if (index == 0) //   at~nz
		{
			if (at[2] && at[2] != ' ' && at[2] != 'z'){;} // insure flag only the last character - write meaning can write multiple types, but only for internal display. externally only 1 type at a time is allowed to be input
			else if (at[1] == 'n') flags = NOUN;
			else if (at[1] == 'v') flags = VERB;
			else if (at[1] == 'a') flags = ADJECTIVE;
			else if (at[1] == 'b') flags = ADVERB;
			if (at[1] == 'z' || at[2] == 'z') flags |= SYNSET_MARKER;
			if (flags) *at = 0;
		}
	}
	if (*word == '"') 
	{
		if (!precreated) 
		{
			strcpy(hold,JoinWords(BurstWord(word,CONTRACTIONS)));
			word = hold;
		}
		else if (word[1] == FUNCTIONSTRING) {;} // compiled script string
		else // some other quoted thing, strip off the quotes, becomes raw text
		{
			if (!word[1]) return (MEANING)0;	 // just a " is bad
			strcpy(hold,word+1); // the system should already have this correct if reading a file. dont burst and rejoin
			size_t len = strlen(hold);
			hold[len-1] = 0;	// remove ending dq
			word = hold; // hereinafter, this fact will be written out as `xxxx` instead
		}
	}
	if (!*word) return 0;
	WORDP D = (create) ? StoreWord(word,AS_IS) : FindWord(word,0,PRIMARY_CASE_ALLOWED);
    return (!D)  ? (MEANING)0 :  (MakeMeaning(D,index) | flags);
}

bool ReadDictionary(char* file)
{
	char junk[MAX_WORD_SIZE];
	char word[MAX_WORD_SIZE];
	char* ptr;
    char* equal;
	FILE* in = FopenReadOnly(file); // text dictionary file
	if (!in) return false;
	while (ReadALine(readBuffer,in))
	{
		ptr = ReadCompiledWord(readBuffer,word); // word
		if (!*word) continue;
		ptr = ReadCompiledWord(ptr,junk);	//   read open paren
		if (*junk != '(') ReportBug("bad dictionary alignment")
		WORDP D = StoreWord(word,AS_IS);
		++rawWords;
		if (stricmp(D->word,word)) ReportBug("Dictionary read does not match original %s %s\r\n",D->word,word)
		unsigned int meaningCount = 0;
		unsigned int glossCount = 0;
		ptr = ReadDictionaryFlags(D,ptr,&meaningCount,&glossCount);

		//   precreate meanings...

		//   read cross-reference attribute ptrs
		while (*ptr)		//   read until closing paren
		{
			ptr = ReadCompiledWord(ptr,word);
			if (!*word) break;
			equal = strchr(word,'=');
			*equal++ = 0;
			if (!strcmp(word,"conjugate")) { SetTense(D,MakeMeaning(StoreWord(equal)));}
			else if (!strcmp(word,"plural")) {SetPlural(D,MakeMeaning(StoreWord(equal)));}
			else if (!strcmp(word,"comparative")) { SetComparison(D,MakeMeaning(StoreWord(equal)));}
		}

		//   directly create meanings, since we know the size-- no meanings may be added after this
		if (meaningCount)
		{
			MEANING* meanings = (MEANING*) AllocateString(NULL,(meaningCount+1) * sizeof(MEANING),false,true); 
			meanings[0]= meaningCount;
			D->meanings =  String2Index((char*)meanings);

			unsigned int glossIndex = 0;
			//   directly create gloss space, since we know the size-- no glosses may be added after this
			if (glossCount)
			{
				MEANING* glosses = (MEANING*) AllocateString(NULL,(glossCount+1) * sizeof(MEANING),false,true); 
				glosses[0] = glossCount;
				D->w.glosses =  glosses;
				AddInternalFlag(D,HAS_GLOSS);
			}
			for (unsigned int i = 1; i <= meaningCount; ++i) //   read each meaning
			{
				ReadALine(readBuffer,in);
				char* ptr = ReadCompiledWord(readBuffer,junk);
				GetMeaning(D,i) = ReadMeaning(junk,true,true);
				if (*ptr == '(') ptr = strchr(ptr,')') + 2; // point after the )
				if (glossCount && *ptr && GetMeaning(D,i) & SYNSET_MARKER) 
					D->w.glosses[++glossIndex] =  String2Index(AllocateString(ptr)) + (i << 24);
			}
			if (glossIndex != glossCount)
			{
				ReportBug("Gloss not matching count %s",D->word);
				myexit("bad gloss count");
			}
		}
	}
	fclose(in);
	return true;
}

MEANING MakeTypedMeaning(WORDP x, unsigned int y, unsigned int flags)
{
	return (!x) ? 0 : (((MEANING)(Word2Index(x) + (((unsigned int)y) << INDEX_OFFSET))) | flags);
}

MEANING MakeMeaning(WORDP x, unsigned int y) //   compose a meaning
{
    return (!x) ? 0 : (((MEANING)(Word2Index(x) + (((unsigned int)y) << INDEX_OFFSET))));
}

WORDP Meaning2Word(MEANING x) //   convert meaning to its dictionary entry
{
    WORDP D = (!x) ? NULL : Index2Word((((ulong_t)x) & MAX_DICTIONARY)); 
	return D;
}

unsigned int GetMeaningType(MEANING T)
{
    if (T == 0) return 0;
	WORDP D = Meaning2Word(T);
    unsigned int index = Meaning2Index(T);
	if (index) T = GetMeaning(D,index); //   change to synset head for specific meaning
	else if (T & TYPE_RESTRICTION) return T & TYPE_RESTRICTION; //   generic word type it must be
	D = Meaning2Word(T);
	return (unsigned int) (D->properties & PART_OF_SPEECH);
}

MEANING FindSynsetParent(MEANING T,unsigned int which) //  presume we are at the master, next wordnet
{
    WORDP D = Meaning2Word(T);
    unsigned int index = Meaning2Index(T);
    FACT* F = GetSubjectHead(D); //   facts involving word 
	unsigned int count = 0;
    while (F)
    {
        FACT* at = F;
        F = GetSubjectNext(F);
        if (at->verb == Mis) // wordnet meaning
		{
			//   prove indexes mate up
			if (index && index != Meaning2Index(at->subject)) continue; // must match generic or specific precisely
			if (count++ == which) return at->object; //   next set/class in line
		}
    }
    return 0;
}

MEANING FindSetParent(MEANING T,int n) //   next set parent
{
    WORDP D = Meaning2Word(T);
    unsigned int index = Meaning2Index(T);
    FACT* F = GetSubjectHead(D); //   facts involving word 
    while (F)
    {
        FACT* at = F;
		F = GetSubjectNext(F);
        if (!(at->verb == Mmember)) continue;
        
		//   prove indexes mate up
		unsigned int localIndex = Meaning2Index(at->subject); //   what fact says
        if (index != localIndex) continue; //   must match generic or specific precisely

        if (--n == 0)  return at->object; // next set/class in line
    }
    return 0;
}

char* WriteMeaning(MEANING T,bool withPos)
{
	if (!T) return "";
    WORDP D = Meaning2Word(T);

	if ((T & MEANING_BASE) == T) return D->word; 

	//   need to annotate the value
    static char mybuffer[150];
	strcpy(mybuffer,D->word); 
	char* at = mybuffer + strlen(mybuffer);
   
	//   index 
	unsigned int index = Meaning2Index(T);
	if (index > 9) 
	{
		*at++ = '~';
		*at++ = (char)((index / 10) + '0');
		*at++ = (char)((index % 10) + '0');
	}
	else if (index)
	{
		*at++ = '~';
		*at++ = (char)(index + '0');
	}

	if (withPos)
	{
		if ((T & TYPE_RESTRICTION) && !index) *at++ = '~';	// pos marker needed on generic
		if (T & NOUN) *at++ = 'n'; 
		else if (T & VERB) *at++ = 'v'; 
		else if (T & ADJECTIVE) *at++ = 'a';
		else if (T & ADVERB) *at++ = 'b';
	}
	if (T & SYNSET_MARKER) *at++ = 'z';
	*at = 0;
    return mybuffer;
}

void NoteLanguage()
{
	FILE* out = fopen("language.txt","wb"); 
	fprintf(out,"%s\r\n",language); // current default language
	fclose(out);
}

static void ReadSubstitutes(char* name,unsigned int fileFlag)
{
	char file[MAX_WORD_SIZE];
	sprintf(file,"%s/%s",livedata,name);
    char original[MAX_WORD_SIZE];
    char replacement[MAX_WORD_SIZE];
    FILE* in = FopenReadOnly(file); // substitutes
    if (!in) return;
    while (ReadALine(readBuffer,in) != 0) 
    {
        if (*readBuffer == '#' || *readBuffer == 0) continue;
        char* ptr = ReadCompiledWord(readBuffer,original); //   original phrase
		
        if (*original == 0 || *original == '#') continue;
		//   replacement can be multiple words joined by + and treated as a single entry.  
		ptr = ReadCompiledWord(ptr,replacement);    //   replacement phrase
		WORDP D = FindWord(original,0,PRIMARY_CASE_ALLOWED);	//   do we know original already?
		if (D && D->internalBits & HAS_SUBSTITUTE)
		{
			if (!compiling) Log(STDUSERLOG,"Currently have a substitute for %s in %s\r\n",original,readBuffer);
			continue;
		}
		D = StoreWord(original,AS_IS); //   original word
		AddInternalFlag(D,fileFlag|HAS_SUBSTITUTE);
		RemoveInternalFlag(D,HAS_GLOSS); // no longer usable as that
		D->w.substitutes = NULL;
		if (GetPlural(D))  SetPlural(D,0);
		if (GetComparison(D))  SetComparison(D,0);
		if (GetTense(D)) SetTense(D,0);

		unsigned int n = BurstWord(D->word);
		char wd[MAX_WORD_SIZE];
		strcpy(wd,JoinWords(1));
		// now determine the multiword headerness...
		char* word = wd;
		if (*word == '<') ++word;		// do not show the < starter for lookup
		size_t len = strlen(word);
		if (len > 1 && word[len-1] == '>')  word[len-1] = 0;	// do not show the > on the starter for lookup
		WORDP E = StoreWord(word);		// create the 1-word header
		if (n > GETMULTIWORDHEADER(E)) SETMULTIWORDHEADER(E,n);	//   mark it can go this far for an idiom

		WORDP S = NULL;
		if (replacement[0] != 0 && replacement[0] != '#') 	//   with no substitute, it will just erase itself
		{
			if (strchr(replacement,'_'))
				printf("Warning-- substitution replacement %s of %s in %s at line %d has _ in it\r\n",replacement,original,name,currentFileLine);
			D->w.substitutes = S = StoreWord(replacement,AS_IS,SUBSTITUTE_RECIPIENT);  //   the valid word

			// for the emotions (like ~emoyes) we want to be able to reverse access, so make them a member of the set
			if (*S->word == '~') CreateFact(MakeMeaning(D),Mmember,MakeMeaning(S));
		}

        //   if original has hyphens, replace as single words also. Note burst form for initial marking will be the same
        bool hadHyphen = false;
		char copy[MAX_WORD_SIZE];
		strcpy(copy,original);
        ptr = copy;
        while (*++ptr) // replace all alphabetic hypens using _
        {
            if (*ptr == '-' && IsAlpha(ptr[1])) 
            {
                *ptr = '_';
                hadHyphen = true;
            }
        }
        if (hadHyphen) 
        {
			D = FindWord(copy);	//   do we know original already?
			if (D && D->internalBits & HAS_SUBSTITUTE)
			{
				ReportBug("Already have a substitute for %s of %s",original,readBuffer)
				continue;
			}
	
			D = StoreWord(copy,0);
			AddInternalFlag(D,fileFlag|HAS_SUBSTITUTE);
 			D->w.substitutes = S;
 			RemoveInternalFlag(D,HAS_GLOSS); // no longer usable as that
			if (GetPlural(D)) SetPlural(D,0);
			if (GetComparison(D)) SetComparison(D,0);
			if (GetTense(D)) SetTense(D,0);
       }
	}
    fclose(in);
}

void ReadWordsOf(char* name,uint64 mark)
{
	char file[MAX_WORD_SIZE];
	sprintf(file,"%s/%s",livedata,name);
    char word[MAX_WORD_SIZE];
    FILE* in = FopenReadOnly(file); // scriptcompile nonwords allowed OR lowercase title words
    if (!in) return;
    while (ReadALine(readBuffer,in) != 0) 
    {
        char* ptr = ReadCompiledWord(readBuffer,word); 
        if (*word != 0 && *word != '#') 
		{
			WORDP D = StoreWord(word,mark); 
			ReadCompiledWord(ptr,word);
			if (!stricmp(word,"FOREIGN_WORD")) AddProperty(D,FOREIGN_WORD);
		}

	}
    fclose(in);
}

static void ReadCanonicals(char* name)
{
	char file[MAX_WORD_SIZE];
	sprintf(file,"%s/%s",livedata,name);
    char original[MAX_WORD_SIZE];
    char replacement[MAX_WORD_SIZE];
    FILE* in = FopenReadOnly(file); // canonicals
    if (!in) return;
    while (ReadALine(readBuffer,in) != 0) 
    {
        if (*readBuffer == '#' || *readBuffer == 0) continue;

        char* ptr = ReadCompiledWord(readBuffer,original); //   original phrase
        if (*original == 0 || *original == '#') continue;
        ptr = ReadCompiledWord(ptr,replacement);    //   replacement word
		WORDP X = FindWord("do");
		WORDP D = StoreWord(original);
		WORDP R = StoreWord(replacement);
		SetCanonical(D,MakeMeaning(R));
	}
    fclose(in);
}

void ReadAbbreviations(char* name)
{
	char file[MAX_WORD_SIZE];
	sprintf(file,"%s/%s",livedata,name);
    char word[MAX_WORD_SIZE];
    FILE* in = FopenReadOnly(file);
    if (!in) return;
    while (ReadALine(readBuffer,in) != 0) 
    {
		ReadCompiledWord(readBuffer,word); 
		if (*word != 0 && *word != '#')  
		{
			WORDP D = StoreWord(word,0,KINDERGARTEN);
			RemoveInternalFlag(D,DELETED_MARK);
		}
	}
    fclose(in);
}

void ReadQueryLabels(char* name)
{
	char file[MAX_WORD_SIZE];
	sprintf(file,"%s/%s",livedata,name);
 
    char word[MAX_WORD_SIZE];
    FILE* in = FopenReadOnly(file); // queries
    if (!in) return;
    while (ReadALine(readBuffer,in) != 0) 
    {
        if (*readBuffer == '#' ||  *readBuffer == 0) continue;
        char* ptr = ReadCompiledWord(readBuffer,word);    // the name or query: name
        if (*word == 0) continue;
		if (!stricmp(word,"query:")) ptr = ReadCompiledWord(ptr,word); 

		ptr = SkipWhitespace(ptr); // in case excess blanks before control string
        WORDP D = StoreWord(word,0);
		AddInternalFlag(D, QUERY_KIND);
		char* at = strchr(ptr,' '); // in case has blanks after control string
		if (at) *at = 0;
 	    D->w.userValue = AllocateString(ptr);    
    }
    fclose(in);
}

void ReadLivePosData()
{
	// read pos rules of english langauge
	uint64 xdata[MAX_POS_RULES * MAX_TAG_FIELDS];
	char*  xcommentsData[MAX_POS_RULES];
	data = xdata;
	commentsData = xcommentsData;
	tagRuleCount = 0;
	char word[MAX_WORD_SIZE];
	sprintf(word,"%s/ENGLISH",livedata);
	WalkDirectory(word,ReadPosPatterns,0);
	tags = (uint64*)AllocateString((char*) xdata,tagRuleCount * MAX_TAG_FIELDS * sizeof(uint64),true,false);
	comments = 0;
	bool haveComments = true;
#ifdef IOS // applications dont want comments
	haveComments = false;
#endif
#ifdef NOMAIN
	haveComments = false;
#endif
	if (haveComments) comments = (char**)AllocateString((char*) xcommentsData,tagRuleCount * sizeof(char*));
}

void ReadLiveData()
{
	ReadSubstitutes("systemessentials.txt",ESSENTIALS_FILE);
	ReadSubstitutes("substitutes.txt",SUBSTITUTIONS_FILE);
	ReadSubstitutes("contractions.txt",CONTRACTIONS_FILE);
	ReadSubstitutes("interjections.txt",INTERJECTIONS_FILE);
	ReadSubstitutes("british.txt",BRITISH_FILE);
	ReadSubstitutes("spellfix.txt",SPELLING_FILE);
	ReadSubstitutes("texting.txt",TEXTING_FILE);
	ReadSubstitutes("private.txt",PRIVATE_FILE);
	ReadCanonicals("canonical.txt");
	ReadQueryLabels("queries.txt");
	ReadWordsOf("lowercaseTitles.txt",LOWERCASE_TITLE);
}

static bool ReadAsciiDictionary()
{
    char buffer[50];
	unsigned int n = 0;
	bool found = false;
	rawWords = 0;
	for (char i = '0'; i <= '9'; ++i)
	{
		sprintf(buffer,"%c.txt",i);
		if (!ReadDictionary(UseDictionaryFile(buffer))) ++n;
		else found = true;
	}
	for (char i = 'a'; i <= 'z'; ++i)
	{
		sprintf(buffer,"%c.txt",i);
		if (!ReadDictionary(UseDictionaryFile(buffer))) ++n;
		else found = true;
	}
	if (!ReadDictionary(UseDictionaryFile("other.txt"))) ++n;
	else found = true;
	if (n) printf("Missing %d word files\r\n",n);
	printf("read %d raw words\r\n",rawWords);
	return found;
}

void VerifyEntries(WORDP D,uint64 junk) // prove meanings have synset heads and major kinds have subkinds
{
	if (D->internalBits & (DELETED_MARK|WORDNET_ID) || D->internalBits & DEFINES) return;

	if (D->properties & VERB && !(D->properties & VERB_TENSES)) ReportBug("Verb %s lacks tenses\r\n",D->word);
	if (D->properties & NOUN && !(D->properties & NOUN_BITS)) ReportBug("Noun %s lacks subkind\r\n",D->word);
	if (D->properties & ADVERB && !(D->properties & ADVERB_BITS)) ReportBug("Adverb %s lacks subkind\r\n",D->word);
	if (D->properties & ADJECTIVE && !(D->properties & ADJECTIVE_BITS)) ReportBug("Adjective %s lacks subkind\r\n",D->word);

	unsigned int count = GetMeaningCount(D);
	for(unsigned int i = 1; i <= count; ++i)
	{
		MEANING M = GetMeanings(D)[i]; // what we point to in synset land
		if (!M)
		{
			ReportBug("Has no meaning %s %d\r\n",D->word,i)
			return;
		}
		WORDP X = Meaning2Word(M);
		unsigned int index = Meaning2Index(M);
		if (index > GetMeaningCount(X)) 
			ReportBug("Has meaning index too high %s.%d points to %s.%d but limit is %d\r\n",D->word,i,X->word,index, GetMeaningCount(X))
			
		// can we find the master meaning for this meaning?
		MEANING at = M;
		unsigned int n = 0;
		while (!(at & SYNSET_MARKER)) // find the correct ptr to return as master
		{
			WORDP X = Meaning2Word(at);
			if (X->internalBits & DELETED_MARK) ReportBug("Synset goes to dead word %s",X->word)
			unsigned int ind = Meaning2Index(at);
			if (ind > GetMeaningCount(X)) 
			{
				ReportBug("syset master failure %s",X->word)
				return;
			}
			at = GetMeanings(X)[ind];
			if (++n >= MAX_SYNLOOP) 
			{
				ReportBug("syset master loop overflow %s",X->word)
				return;
			}
		}
	}

	// verify glosses match up legal
	unsigned int glossCount = GetGlossCount(D);
	for (unsigned int x = 1; x <= glossCount; ++x)
	{
		if (GlossIndex(D->w.glosses[x]) > count)
		{
			ReportBug("Gloss out of range for gloss %d   %s~%d with count only  %d\r\n",x,D->word,GlossIndex(D->w.glosses[x]),count);
			D->w.glosses[x] = 0;	// bad ref
		}
	}

	count = GetMeaningCount(D);
	unsigned int synsetHeads;
	for (unsigned int i = 1; i <= count; ++i)
	{
		synsetHeads = 0;
		unsigned int counter = 0;
		MEANING M = GetMeaning(D,i);
		WORDP X = Meaning2Word(M);
		unsigned int index = Meaning2Index(M);
		if (M & SYNSET_MARKER);
		else while (X != D) // run til we loop once back to this entry, counting synset heads we see
		{
			if (X->internalBits & DELETED_MARK)
			{
				ReportBug("Synset references dead entry %s word: %s meaning: %d\r\n",X->word,D->word,i)
				break;
			}
			if (M & SYNSET_MARKER) ++synsetHeads; // prior was a synset head
			index = Meaning2Index(M);
			if (index == 0) break; // generic pointer
			if (!GetMeanings(X))
			{
				M = 0;
				ReportBug("Missing synsets for %s word: %s meaning: %d\r\n",X->word,D->word,i)
				break;
			}
			if (GetMeaningCount(X) < index)
			{
				ReportBug("Missing synset index %s %s\r\n",X->word,D->word)
				break;
			}
			M = GetMeaning(X,index);
			X = Meaning2Word(M);
			if (++counter > MAX_SYNLOOP) break; // in case of trouble
		}
		if (M & SYNSET_MARKER) ++synsetHeads; // prior was a synset head
		if (synsetHeads != 1 || counter > MAX_SYNLOOP) 
			ReportBug("Bad synset list %s heads: %d count: %d\r\n",D->word,synsetHeads,counter)
	}
	if (GetTense(D)) 
	{
		WORDP E = GetTense(D);
		while (E != D)
		{
			if (!E)
			{
				ReportBug("Missing conjugation %s \r\n",D->word)
				break;
			}
			if (E->internalBits & DELETED_MARK)
			{
				ReportBug("Deleted conjucation %s %s \r\n",D->word,E->word)
				break;
			}
			E = GetTense(E);
		}
	}
	if (GetPlural(D)) 
	{
		WORDP E = GetPlural(D);
		while (E != D)
		{
			if (!E)
			{
				ReportBug("Missing plurality %s \r\n",D->word)
				break;
			}
			if (E->internalBits & DELETED_MARK)
			{
				ReportBug("Deleted plurality %s %s \r\n",D->word,E->word)
				break;
			}
			E = GetPlural(E);
		}
	}
	if (GetComparison(D)) 
	{
		WORDP E = GetComparison(D);
		while (E != D)
		{
			if (!E)
			{
				ReportBug("Missing comparison %s \r\n",D->word)
				break;
			}
			if (E->internalBits & DELETED_MARK)
			{
				ReportBug("Deleted comparison %s %s \r\n",D->word,E->word)
				break;
			}
			E = GetComparison(E);
		}
	}

	// anything with a singular noun meaning should have an uplink
	if (D->properties & NOUN_SINGULAR && GetMeanings(D) && buildDictionary)
	{
		unsigned int count = GetMeaningCount(D);
		for (unsigned int i = 1; i <= count; ++i)
		{
			if (! (GetMeaning(D,i) & NOUN)) continue;

			// might be just a "more noun" word
			WORDP X = Meaning2Word(GetMeaning(D,i));
			if (X == D) continue; // points to self is good enough

			MEANING M = GetMaster(GetMeaning(D,i));
			X = Meaning2Word(M);
			FACT* F = GetSubjectHead(X);
			while (F)
			{
				if (F->subject == M && F->verb == Mis && !(F->flags & FACTDEAD)) break;
				F = GetSubjectNext(F);
			}

			if (!F && !(D->internalBits & UPPERCASE_HASH)) 
				Log(STDUSERLOG,"Meaning %d of %s with master %s missing uplink IS\r\n",i,D->word,WriteMeaning(M));
		}
	}
}

void LoadDictionary()
{
	if (!ReadBinaryDictionary()) //   if binary form not there or wrong hash, use text form (slower)
	{
		AcquireDefines("src/dictionarySystem.h"); //   get dictionary defines (must occur before loop that decodes properties into sets (below)
		ReadAbbreviations("abbreviations.txt"); // needed for burst/tokenizing
		if (ReadAsciiDictionary())
		{
			*currentFilename = 0;
			WalkDictionary(VerifyEntries); // prove good before writeout
			remove(UseDictionaryFile("facts.bin")); // insure no erroneous binary of facts
			remove(UseDictionaryFile("dict.bin")); 
			WriteBinaryDictionary(); //   store the faster read form of dictionary
		}
	}
	else  
	{
		ReadAbbreviations("abbreviations.txt"); // needed for burst/tokenizing - a change in this file will require rebuilds of topic data
	}
	*currentFilename = 0;
	fullDictionary = (!stricmp(language,"ENGLISH")) || (dictionaryFree-dictionaryBase) > 170000; // a lot of words are defined, must be a full dictionary.
	InitFactWords(); 
}

#define BUILDCONCEPT(name,word) {name = StoreWord(word,0,CONCEPT);}

void ExtendDictionary()
{
	Mburst = MakeMeaning(StoreWord("^burst"));
	Mchatoutput = MakeMeaning(StoreWord("chatoutput"));
	MconceptComment = MakeMeaning(StoreWord("^concept"));
	MgambitTopics = MakeMeaning(StoreWord("^gambittopics"));
	Mintersect = MakeMeaning(StoreWord("^intersect"));
	Mkeywordtopics = MakeMeaning(StoreWord("^keywordtopics"));
 	Mmoney = MakeMeaning(StoreWord("~moneynumber",0,CONCEPT));
	Mnumber = MakeMeaning(StoreWord("~number",0,CONCEPT));
	MadjectiveNoun  = MakeMeaning(StoreWord("~adjectivenoun",0,CONCEPT));
	Mpending = MakeMeaning(StoreWord("^pending"));
	DunknownWord  = StoreWord("unknown-word");

	// generic concepts the engine marks automatically
	BUILDCONCEPT(Dadult,"~adultword");
	BUILDCONCEPT(Dchild,"~childword");
	BUILDCONCEPT(Dfemalename,"~femalename"); 
	BUILDCONCEPT(Dhumanname,"~humanname"); 
	BUILDCONCEPT(Dmalename,"~malename"); 
    BUILDCONCEPT(Dplacenumber,"~placenumber"); 
	BUILDCONCEPT(Dpronoun,"~pronoun");
	BUILDCONCEPT(Dpropername,"~propername"); 
	Mphrase = MakeMeaning(StoreWord("~phrase",0,CONCEPT));
	MabsolutePhrase = MakeMeaning(StoreWord("~absolutephrase",0,CONCEPT));
	MtimePhrase = MakeMeaning(StoreWord("~timeephrase",0,CONCEPT));
	BUILDCONCEPT(Dclause,"~clause"); 
	BUILDCONCEPT(Dverbal,"~verbal"); 
	BUILDCONCEPT(Dtime,"~timeword"); 
	BUILDCONCEPT(Dunknown,"~unknownword"); 
	// predefine builtin sets with no engine variables
	unsigned int i = 0;
	char* ptr;
	while ((ptr = predefinedSets[i++]) != 0) StoreWord(ptr,0,CONCEPT);
}

char* FindCanonical(char* word, unsigned int i,bool notNew)
{
	uint64 controls = PRIMARY_CASE_ALLOWED;
    WORDP D = FindWord(word,0,PRIMARY_CASE_ALLOWED);
	if (i == 1)
	{
		WORDP S = FindWord(word,0,SECONDARY_CASE_ALLOWED);
		if (S && IsLowerCase(*S->word))  D = S;
	}
    if (D && !buildDictionary) 
	{
		char* answer = GetCanonical(D);
		if (answer) return answer; //   special canonical form (various pronouns typically)
	}

    //    numbers - use digit form
	char* number;
    if (IsNumber(word))
    {
        char word1[MAX_WORD_SIZE];
        if (strchr(word,'.') || strlen(word) > 9)  //   big numbers need float
        {
            float y;
			if (*word == '$') y = (float)atof(word+1);
			else y = (float)atof(word);
            int x = (int)y;
            if (((float) x) == y) sprintf(word1,"%d",x); //   use int where you can
            else sprintf(word1,"%.2f",atof(word)); 
        }
		else if (GetCurrency(word,number)) sprintf(word1,"%d",atoi(number));
#ifdef WIN32
        else sprintf(word1,"%I64d",Convert2Integer(word)); // integer
#else
        else sprintf(word1,"%lld",Convert2Integer(word)); // integer
#endif
        WORDP N = StoreWord(word1,ADJECTIVE|NOUN|ADJECTIVE_NUMBER|NOUN_NUMBER); // digit format cannot be ordinal
		return N->word;
    }
 
	// before seeing if canoncial can come from verb, see if it is from a known noun.  "cavities" shouldnt create cavity as a verb
	char* noun = NULL;
	size_t len = strlen(word);
	if (word[len-1] == 's') noun = GetSingularNoun(word,true,true); // do we already KNOW this as a an extension of a noun

    //   VERB
    char* verb = GetInfinitive(word,(noun) ? true : notNew);
    if (verb) 
    {
        WORDP V = FindWord(verb,0,controls);
        verb = (V) ? V->word : NULL;
    }
	if (verb) return verb; //   we prefer verb base-- gerunds are nouns and verbs for which we want the verb

    //   NOUN
    noun = GetSingularNoun(word,true,notNew);
    if (noun) 
    {
        WORDP  N = FindWord(noun,0,controls);
        noun = (N) ? N->word : NULL;
    }
	if (noun) return noun;
    
	//   ADJECTIVE
    char* adjective = GetAdjectiveBase(word,(noun) ? false : notNew);
    if (adjective) 
    {
        WORDP A = FindWord(adjective,0,controls);
        adjective = (A) ? A->word : NULL;
    }
	if (adjective) return adjective;
 
	//   ADVERB
    char* adverb = GetAdverbBase(word,(noun) ? false : notNew);
    if (adverb) 
    {
        WORDP A = FindWord(adverb,0,controls);
        adverb = (A) ? A->word : NULL;
    }
	if (adverb) return adverb;

	return (D && D->properties & PART_OF_SPEECH) ? D->word : NULL;
}

bool IsHelper(char* word)
{
    WORDP D = FindWord(word,0,tokenControl & STRICT_CASING ? PRIMARY_CASE_ALLOWED : 0);
    return (D && D->properties & (AUX_VERB|AUX_VERB_BITS) );
}

bool IsFutureHelper(char* word)
{
	WORDP D = FindWord(word,0,tokenControl & STRICT_CASING ? PRIMARY_CASE_ALLOWED : 0);
    return (D &&  D->properties & AUX_VERB_FUTURE);
}    
	
bool IsPresentHelper(char* word)
{
	WORDP D = FindWord(word,0,tokenControl & STRICT_CASING ? PRIMARY_CASE_ALLOWED : 0);
	return (D && D->properties & AUX_VERB && D->properties & (VERB_PRESENT | VERB_PRESENT_3PS | AUX_VERB_PRESENT));
}

bool IsPastHelper(char* word)
{
	WORDP D = FindWord(word,0,tokenControl & STRICT_CASING ? PRIMARY_CASE_ALLOWED : 0);
    return (D && D->properties & AUX_VERB && D->properties & (AUX_VERB_PAST | VERB_PAST));
}

void DumpDictionaryEntry(char* word,unsigned int limit)
{
	char name[MAX_WORD_SIZE];
	strcpy(name,word);
	MEANING M = ReadMeaning(word,false,true);
	unsigned int index = Meaning2Index(M);
	WORDP D = Meaning2Word(M);
	if (D && IS_NEW_WORD(D) && (*D->word != '~' || *D->word == '$'  || *D->word == '^')) D = 0;	// debugging may have forced this to store, its not in base system
	if (limit == 0) limit = 5; // default
	Log(STDUSERLOG,"\r\n%s: ",name);

	uint64 properties = (D) ? D->properties : 0;
	uint64 sysflags = (D) ? D->systemFlags : 0;
	uint64 cansysflags =  0;
	uint64 bit = START_BIT;	
	while (bit)
	{
		if (properties & bit) Log(STDUSERLOG,"%s ",FindNameByValue(bit));
		bit >>= 1;
	}

	WORDP entry = NULL;
	WORDP canonical = NULL;
	char* tilde = strchr(name+1,'~');
	wordStarts[0] = "";
	wordStarts[2] = "";
	posValues[0] = 0;
	posValues[1] = 0;
	posValues[2] = 0;
	wordStarts[1] = word;
	if (tilde && IsDigit(tilde[1])) *tilde = 0;	// turn off specificity
	uint64 inferredProperties = (name[0] != '~' && name[0] != '^') ? GetPosData(1,name,entry,canonical,sysflags,cansysflags) : 0; 
	if (entry) D = entry;
	bit = START_BIT;
	bool extended = false;
	while (bit)
	{
		if (inferredProperties & bit)
		{
			if (!(properties & bit)) // bits beyond what was directly known in dictionary before
			{
				if (!extended) Log(STDUSERLOG," Implied: ");
				extended = true;
				char* label = FindNameByValue(bit);
				Log(STDUSERLOG,"%s ",label);
			}
		}
		bit >>= 1;
	}

	bit = START_BIT;
	bool once = true;
	while (bit)
	{
		if (sysflags & bit)
		{
			char word[MAX_WORD_SIZE];
			if (bit & ESSENTIAL_FLAGS) 
			{
				if (once) Log(STDUSERLOG," POS-tiebreak: ");
				once = false;
				Log(STDUSERLOG,"%s ",FindNameByValue(bit));
			}
			else Log(STDUSERLOG,"%s ",MakeLowerCopy(word,FindName2ByValue(bit)));
		}
		bit >>= 1;
	}

	if (canonical) Log(STDUSERLOG," canonical: %s ",canonical->word);
#ifndef DISCARDTESTING
	unsigned int basestamp = inferMark;
#endif
	NextinferMark();
#ifndef DISCARDTESTING
	if (sysflags & CONCEPT  && !(D->systemFlags & TOPIC)) Log(STDUSERLOG,"concept (%d members) ",CountSet(D,basestamp));
#endif
	if (!D) return;
	if (D->internalBits & HAS_SUBSTITUTE) 
	{
		Log(STDUSERLOG,"substitute=");
		if (GetSubstitute(D)) Log(STDUSERLOG,"%s ",GetSubstitute(D)->word); 
		else Log(STDUSERLOG,"  ");
	}
	if (D->systemFlags & FUNCTION_NAME) 
	{
		char* kind = "";
		if ((D->systemFlags & FUNCTION_BITS) == IS_OUTPUT_MACRO) kind = (char*)"output";
		else if ((D->systemFlags & FUNCTION_BITS) ==  IS_TABLE_MACRO) kind = (char*) "table";
		else if ((D->systemFlags & FUNCTION_BITS) ==  IS_PATTERN_MACRO) kind = (char*)"pattern";
		else if ((D->systemFlags & FUNCTION_BITS) ==  IS_PLAN_MACRO) kind = (char*) "plan";
		else if ((D->systemFlags & FUNCTION_BITS) ==  (IS_PATTERN_MACRO | IS_OUTPUT_MACRO)) kind = (char*) "dual";
		if (D->x.codeIndex && (D->systemFlags & FUNCTION_BITS) !=  IS_PLAN_MACRO) Log(STDUSERLOG,"systemfunction %d", D->x.codeIndex);
		else Log(STDUSERLOG,"user %s function %s ",kind,D->w.fndefinition+1); // 1st byte is argument count
	}
	if (*D->word == '%') Log(STDUSERLOG,"systemvar ");
	if (*D->word == '$')
	{
		char* val = GetUserVariable(D->word);
		Log(STDUSERLOG,"VariableValue= \"%s\" ",val);
	}
	Log(STDUSERLOG,"\r\n");

	if (GetTense(D)) 
	{
		Log(STDUSERLOG,"  conjugationLoop= ");
		WORDP E = GetTense(D);
		while (E != D)
		{
			Log(STDUSERLOG,"-> %s ",E->word);
			E = GetTense(E);
		}
		Log(STDUSERLOG,"\r\n");
	}
	if (GetPlural(D)) 
	{
		Log(STDUSERLOG,"  pluralLoop= ");
		WORDP E = GetPlural(D);
		while (E != D)
		{
			Log(STDUSERLOG,"-> %s ",E->word);
			E = GetPlural(E);
		}
		Log(STDUSERLOG,"\r\n");
	}
	if (GetComparison(D)) 
	{
		Log(STDUSERLOG,"  comparativeLoop= ");
		WORDP E = GetComparison(D);
		while (E != D)
		{
			Log(STDUSERLOG,"-> %s ",E->word);
			E = GetComparison(E);
		}
		Log(STDUSERLOG,"\r\n");
	}
	
	// find special parser mark values of word
	WORDP X = FindWord("~special_english_attributes");
	if (X)
	{
		SetParserMarks(X,true);
		bool heading = false;

		// mark the words now -- they must be direct members of marked sets
		FACT* F = GetSubjectHead(D);
		while (F)
		{
			if (F->verb == Mmember)
			{
				WORDP Y = Meaning2Word(F->object);
				if (Y->properties & AS_IS) 
				{
					if (!heading)
					{
						Log(STDUSERLOG,"ParserMarks: ");
						heading = true;
					}
					Log(STDUSERLOG,"%s ",Y->word);
				}
			}
			F = GetSubjectNext(F);
		}
		if (heading) Log(STDUSERLOG,"\r\n\r\n");
		else Log(STDUSERLOG,"\r\n");
		SetParserMarks(X,false);
	}

	//   now dump the meanings
	unsigned int count = GetMeaningCount(D);
	for (unsigned int i = 1; i <= count; ++i)
	{
		if (index && i != index) continue;
		MEANING M = GetMeaning(D,i);
		char* gloss;
		MEANING master = GetMaster(M);
		gloss = GetGloss(Meaning2Word(master),Meaning2Index(master));

		if (!gloss) gloss = "";
		Log(STDUSERLOG," %d: %s %s\r\n",i,WriteMeaning(M & STDMEANING,true),gloss);

		M = GetMeaning(D,i) & STDMEANING;
		bool did = false;
		while (Meaning2Word(M) != D)
		{
			if (!did) 
			{
				did = true;
				Log(STDUSERLOG,"    synonyms: ");
			}
			MEANING next = GetMeaning(Meaning2Word(M),Meaning2Index(M));
			if (next & SYNSET_MARKER) Log(STDUSERLOG," *%s ",WriteMeaning(M));	// mark us as master for display
			else Log(STDUSERLOG," %s ",WriteMeaning(M)); 
			M = next & STDMEANING;
		}
		if (!did) Log(STDUSERLOG,"    synonyms: ");
 		if (GetMeaning(D,i) & SYNSET_MARKER) Log(STDUSERLOG," *%s ",WriteMeaning(M)); 
		else Log(STDUSERLOG," %s ",WriteMeaning(M)); 
		Log(STDUSERLOG,"\r\n"); //   header for this list
	}

	if (D->inferMark) Log(STDUSERLOG,"Istamp- %d\r\n",D->inferMark);
	if (GETMULTIWORDHEADER(D)) Log(STDUSERLOG,"MultiWordHeader length: %d\r\n",GETMULTIWORDHEADER(D));

	// show concept/topic members
	FACT* F = GetSubjectHead(D);
	Log(STDUSERLOG,"Direct Sets: ");
	while (F)
	{
		if (index && Meaning2Index(F->subject) && Meaning2Index(F->subject) != index ){;} // wrong path member
		if (F->verb == Mmember) Log(STDUSERLOG,"%s ",Meaning2Word(F->object)->word);
		F = GetSubjectNext(F);
	}
	Log(STDUSERLOG,"\r\n");

	char* buffer = AllocateBuffer();
	Log(STDUSERLOG,"Facts:\r\n");

	count = 0;
	F = GetSubjectHead(D);
	while (F)
	{
		if (F->verb != Mis && F->verb != Mmember) // non-structural facts
		{
			Log(STDUSERLOG,"  %s",WriteFact(F,false,buffer,false,true));
			if (++count >= limit) break;
		}
		F = GetSubjectNext(F);
	}

	F = GetVerbHead(D);
	count = limit;
	while (F)
	{
		if (F->verb != Mmember && F->verb != Mis)
		{
			Log(STDUSERLOG,"  %s",WriteFact(F,false,buffer,false,true));
			if (++count >= limit) break;
		}
		F = GetVerbNext(F);
	}
	
	F = GetObjectHead(D);
	count = 0;
	while (F)
	{
		if (F->verb != Mmember && F->verb != Mis)
		{
			Log(STDUSERLOG,"  %s\r\n",WriteFact(F,false,buffer,false,true));
			if (++count >= limit) break;
		}
		F = GetObjectNext(F);
	}
	Log(STDUSERLOG,"Index: %d\r\n",Word2Index(D));

	FreeBuffer();
}

#ifdef COPYRIGHT

Per use of the WordNet dictionary data....

 This software and database is being provided to you, the LICENSEE, by  
  2 Princeton University under the following license.  By obtaining, using  
  3 and/or copying this software and database, you agree that you have  
  4 read, understood, and will comply with these terms and conditions.:  
  5   
  6 Permission to use, copy, modify and distribute this software and  
  7 database and its documentation for any purpose and without fee or  
  8 royalty is hereby granted, provided that you agree to comply with  
  9 the following copyright notice and statements, including the disclaimer,  
  10 and that the same appear on ALL copies of the software, database and  
  11 documentation, including modifications that you make for internal  
  12 use or for distribution.  
  13   
  14 WordNet 3.0 Copyright 2006 by Princeton University.  All rights reserved.  
  15   
  16 THIS SOFTWARE AND DATABASE IS PROVIDED "AS IS" AND PRINCETON  
  17 UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR  
  18 IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PRINCETON  
  19 UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES OF MERCHANT-  
  20 ABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE  
  21 OF THE LICENSED SOFTWARE, DATABASE OR DOCUMENTATION WILL NOT  
  22 INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR  
  23 OTHER RIGHTS.  
  24   
  25 The name of Princeton University or Princeton may not be used in  
  26 advertising or publicity pertaining to distribution of the software  
  27 and/or database.  Title to copyright in this software, database and  
  28 any associated documentation shall at all times remain with  
  29 Princeton University and LICENSEE agrees to preserve same.  
#endif

#include "common.h"

unsigned int posTiming;

typedef struct EndingInfo 
{
	char* word;	
	uint64 properties;
	uint64 flags;
} EndingInfo;
	
EndingInfo noun2[] = 
{
	{"th",NOUN|NOUN_SINGULAR}, 
	{"ar",NOUN|NOUN_SINGULAR}, 
	{"ty",NOUN|NOUN_SINGULAR}, 
	{"et",NOUN|NOUN_SINGULAR}, 
	{"or",NOUN|NOUN_SINGULAR}, 
	{"al",NOUN|NOUN_SINGULAR}, 
	{"er",NOUN|NOUN_SINGULAR}, 
	{"ee",NOUN|NOUN_SINGULAR}, 
	{"id",NOUN|NOUN_SINGULAR}, 
	{"cy",NOUN|NOUN_SINGULAR}, 
	{0},
};

EndingInfo noun3[] = 
{
	{"ory",NOUN|NOUN_SINGULAR}, 
	{"ant",NOUN|NOUN_SINGULAR}, 
	{"eer",NOUN|NOUN_SINGULAR}, 
	{"log",NOUN|NOUN_SINGULAR}, 
	{"oma",NOUN|NOUN_SINGULAR}, 
	{"dom",NOUN|NOUN_SINGULAR}, 
	{"ard",NOUN|NOUN_SINGULAR}, 
	{"ide",NOUN|NOUN_SINGULAR}, 
	{"oma",NOUN|NOUN_SINGULAR}, 
	{"ity",NOUN|NOUN_SINGULAR}, 
	{"ist",NOUN|NOUN_SINGULAR}, 
	{"ism",NOUN|NOUN_SINGULAR}, 
	{"ing",NOUN|NOUN_SINGULAR}, 
	{"gon",NOUN|NOUN_SINGULAR}, 
	{"gam",NOUN|NOUN_SINGULAR}, 
	{"ese",NOUN|NOUN_SINGULAR}, 
	{"ure",NOUN|NOUN_SINGULAR}, 
	{"acy",NOUN|NOUN_SINGULAR}, 
	{"age",NOUN|NOUN_SINGULAR}, 
	{"ade",NOUN|NOUN_SINGULAR}, 
	{"ery",NOUN|NOUN_SINGULAR}, 
	{"ary",NOUN|NOUN_SINGULAR}, 
	{"let",NOUN|NOUN_SINGULAR}, 
	{"ess",NOUN|NOUN_SINGULAR}, 
	{"ice",NOUN|NOUN_SINGULAR}, 
	{"ice",NOUN|NOUN_SINGULAR}, 
	{"ine",NOUN|NOUN_SINGULAR}, 
	{"ent",NOUN|NOUN_SINGULAR}, 
	{"ion",NOUN|NOUN_SINGULAR}, 
	{"oid",NOUN|NOUN_SINGULAR}, 
	{"ite",NOUN|NOUN_SINGULAR}, 
	{0},
};
EndingInfo noun4[] = 
{
	{"tion",NOUN|NOUN_SINGULAR}, 
	{"ment",NOUN|NOUN_SINGULAR}, 
	{"emia",NOUN|NOUN_SINGULAR}, 
	{"opsy",NOUN|NOUN_SINGULAR}, 
	{"itis",NOUN|NOUN_SINGULAR}, 
	{"opia",NOUN|NOUN_SINGULAR}, 
	{"hood",NOUN|NOUN_SINGULAR}, 
	{"ness",NOUN|NOUN_SINGULAR}, 
	{"logy",NOUN|NOUN_SINGULAR}, 
	{"ette",NOUN|NOUN_SINGULAR}, 
	{"cide",NOUN|NOUN_SINGULAR}, 
	{"sion",NOUN|NOUN_SINGULAR}, 
	{"ling",NOUN|NOUN_SINGULAR}, 
	{"cule",NOUN|NOUN_SINGULAR}, 
	{"osis",NOUN|NOUN_SINGULAR}, 
	{"esis",NOUN|NOUN_SINGULAR}, 
	{"ware",NOUN|NOUN_SINGULAR}, 
	{"tude",NOUN|NOUN_SINGULAR}, 
	{"cian",NOUN|NOUN_SINGULAR}, 
	{"ency",NOUN|NOUN_SINGULAR}, 
	{"ence",NOUN|NOUN_SINGULAR}, 
	{"ancy",NOUN|NOUN_SINGULAR}, 
	{"ance",NOUN|NOUN_SINGULAR}, 
	{"tome",NOUN|NOUN_SINGULAR}, 
	{"tomy",NOUN|NOUN_SINGULAR}, 
	{"crat",NOUN|NOUN_SINGULAR}, 
	{"ship",NOUN|NOUN_SINGULAR}, 
	{"pnea",NOUN|NOUN_SINGULAR}, 
	{"path",NOUN|NOUN_SINGULAR}, 
	{"gamy",NOUN|NOUN_SINGULAR}, 
	{"onym",NOUN|NOUN_SINGULAR}, 
	{"icle",NOUN|NOUN_SINGULAR}, 
	{"wise",NOUN|NOUN_SINGULAR}, 
	{0},
};
EndingInfo noun5[] = 
{
	{"cracy",NOUN|NOUN_SINGULAR}, 
	{"scope",NOUN|NOUN_SINGULAR}, 
	{"scopy",NOUN|NOUN_SINGULAR}, 
	{"ocity",NOUN|NOUN_SINGULAR}, 
	{"acity",NOUN|NOUN_SINGULAR}, 
	{"loger",NOUN|NOUN_SINGULAR}, 
	{"ation",NOUN|NOUN_SINGULAR}, 
	{"arian",NOUN|NOUN_SINGULAR}, 
	{"ology",NOUN|NOUN_SINGULAR}, 
	{"algia",NOUN|NOUN_SINGULAR}, 
	{"sophy",NOUN|NOUN_SINGULAR}, 
	{"cycle",NOUN|NOUN_SINGULAR}, 
	{"orium",NOUN|NOUN_SINGULAR}, 
	{"arium",NOUN|NOUN_SINGULAR}, 
	{"phone",NOUN|NOUN_SINGULAR}, 
	{"iasis",NOUN|NOUN_SINGULAR}, 
	{"pathy",NOUN|NOUN_SINGULAR}, 
	{"phile",NOUN|NOUN_SINGULAR}, 
	{"phyte",NOUN|NOUN_SINGULAR}, 
	{"otomy",NOUN|NOUN_SINGULAR}, 
	{0},
};
EndingInfo noun6[] = 
{
	{"bility",NOUN|NOUN_SINGULAR}, 
	{"script",NOUN|NOUN_SINGULAR}, 
	{"phobia",NOUN|NOUN_SINGULAR}, 
	{"iatric",NOUN|NOUN_SINGULAR}, 
	{"logist",NOUN|NOUN_SINGULAR}, 
	{"oholic",NOUN|NOUN_SINGULAR}, 
	{"aholic",NOUN|NOUN_SINGULAR}, 
	{"plegia",NOUN|NOUN_SINGULAR}, 
	{"plegic",NOUN|NOUN_SINGULAR}, 
	{"ostomy",NOUN|NOUN_SINGULAR}, 
	{"ectomy",NOUN|NOUN_SINGULAR}, 
	{"trophy",NOUN|NOUN_SINGULAR}, 
	{"escent",NOUN|NOUN_SINGULAR}, 
	{0},
};
EndingInfo noun7[] = 
{
	{"escence",NOUN|NOUN_SINGULAR}, 
	{"ization",NOUN|NOUN_SINGULAR}, 
	{0},
};

	
EndingInfo verb5[] = 
{
	{"scribe",VERB|VERB_INFINITIVE|VERB_PRESENT}, 
	{0},
};
EndingInfo verb4[] = 
{
	{"sect",VERB|VERB_INFINITIVE|VERB_PRESENT}, 
	{0},
};
EndingInfo verb3[] = 
{
	{"ise",VERB|VERB_INFINITIVE|VERB_PRESENT}, 
	{"ize",VERB|VERB_INFINITIVE|VERB_PRESENT}, 
	{"ify",VERB|VERB_INFINITIVE|VERB_PRESENT}, 
	{"ate",VERB|VERB_INFINITIVE|VERB_PRESENT}, 
	{0},
};
EndingInfo verb2[] = 
{
	{"en",VERB|VERB_INFINITIVE|VERB_PRESENT}, 
	{"er",VERB|VERB_INFINITIVE|VERB_PRESENT}, 
	{"fy",VERB|VERB_INFINITIVE|VERB_PRESENT}, 
	{0},
};

EndingInfo adverb5[] = 
{
	{"wards",ADVERB|ADVERB_NORMAL,0}, 
	{0},
};

EndingInfo adverb4[] = 
{
	{"wise",ADVERB|ADVERB_NORMAL,0}, 
	{"ward",ADVERB|ADVERB_NORMAL,0}, 
	{0},
};
EndingInfo adverb3[] = 
{
	{"ily",ADVERB|ADVERB_NORMAL,0}, 
	{"bly",ADVERB|ADVERB_NORMAL,0}, 
	{0},
};
EndingInfo adverb2[] = 
{
	{"ly",ADVERB|ADVERB_NORMAL,0}, 
	{0},
};


EndingInfo adjective7[] = 
{
	{"iferous",ADJECTIVE|ADJECTIVE_NORMAL,0}, // comprised of
	{0},
};
EndingInfo adjective6[] = 
{
	{"escent",ADJECTIVE|ADJECTIVE_NORMAL,0},
	{0},
};
EndingInfo adjective5[] = 
{
	{"ative",ADJECTIVE|ADJECTIVE_NORMAL,0}, // tending toward
	{"esque",ADJECTIVE|ADJECTIVE_NORMAL,0},
	{"-free",ADJECTIVE|ADJECTIVE_NORMAL,0}, 
	{"gonal",ADJECTIVE|ADJECTIVE_NORMAL,0}, 
	{"gonic",ADJECTIVE|ADJECTIVE_NORMAL,0}, // angle
	{"proof",ADJECTIVE|ADJECTIVE_NORMAL,0}, 
	{"sophic",ADJECTIVE|ADJECTIVE_NORMAL,0}, // knowledge
	{"esque",ADJECTIVE|ADJECTIVE_NORMAL,0}, // in the style of
	{0},
};
EndingInfo adjective4[] = 
{
		{"less",ADJECTIVE|ADJECTIVE_NORMAL,0}, // without
		{"etic",ADJECTIVE|ADJECTIVE_NORMAL,0}, // relating to
		{"_out",ADJECTIVE|ADJECTIVE_NORMAL,0}, // relating to
		{"ular",ADJECTIVE|ADJECTIVE_NORMAL,0}, // relating to
		{"uous",ADJECTIVE|ADJECTIVE_NORMAL,0}, // characterized by
		{"ical",ADJECTIVE|ADJECTIVE_NORMAL,0}, // pertaining to
		{"-off",ADJECTIVE|ADJECTIVE_NORMAL,0}, // capable of being
		{"ious",ADJECTIVE|ADJECTIVE_NORMAL,0}, // characterized by
		{"able",ADJECTIVE|ADJECTIVE_NORMAL,0}, // capable of being
		{"ible",ADJECTIVE|ADJECTIVE_NORMAL,0}, // capable of being
		{"like",ADJECTIVE|ADJECTIVE_NORMAL,0}, // resembling
		{"some",ADJECTIVE|ADJECTIVE_NORMAL,0}, // characterized by
		{"ward",ADJECTIVE|ADJECTIVE_NORMAL,0}, // direction of
		{"wise",ADJECTIVE|ADJECTIVE_NORMAL,0}, // direction of
	{0},
};
EndingInfo adjective3[] = 
{
		{"ial",ADJECTIVE|ADJECTIVE_NORMAL,0}, // relating to
		{"oid",ADJECTIVE|ADJECTIVE_NORMAL,0}, // shape of
		{"ble",ADJECTIVE|ADJECTIVE_NORMAL,0}, // able to
		{"ous",ADJECTIVE|ADJECTIVE_NORMAL,0}, // characterized by
		{"ive",ADJECTIVE|ADJECTIVE_NORMAL,0}, // having the nature of
		{"ate",ADJECTIVE|ADJECTIVE_NORMAL,0}, // quality of
		{"ful",ADJECTIVE|ADJECTIVE_NORMAL,0}, // quality of
		{"ful",ADJECTIVE|ADJECTIVE_NORMAL,0}, // notable for
		{"ese",ADJECTIVE|ADJECTIVE_NORMAL,0}, // relating to a place
		{"fic",ADJECTIVE|ADJECTIVE_NORMAL,0}, 
		{"ant",ADJECTIVE|ADJECTIVE_NORMAL,0}, // inclined to
		{"ent",ADJECTIVE|ADJECTIVE_NORMAL,0}, // one who causes
		{"ern",ADJECTIVE|ADJECTIVE_NORMAL,0}, // quality of
		{"ian",ADJECTIVE|ADJECTIVE_NORMAL,0}, // relating to
		{"ile",ADJECTIVE|ADJECTIVE_NORMAL,0}, // relating to
		{"_to",ADJECTIVE|ADJECTIVE_PARTICIPLE,0}, // to
		{"_of",ADJECTIVE|ADJECTIVE_PARTICIPLE,0}, // of
		{"ing",ADJECTIVE|ADJECTIVE_PARTICIPLE,0},  // verb present participle as adjective  // BUG adjectiveFormat = ADJECTIVE_PARTICIPLE;
		{"ied",ADJECTIVE|ADJECTIVE_PARTICIPLE,0}, // verb past participle as adjective
		{"ine",ADJECTIVE|ADJECTIVE_NORMAL,0}, // relating to
		{"ual",ADJECTIVE|ADJECTIVE_NORMAL,0}, // gradual
	{0},
};
EndingInfo adjective2[] = 
{
		{"ic",ADJECTIVE|ADJECTIVE_NORMAL,0},  // pertaining to
		{"ar",ADJECTIVE|ADJECTIVE_NORMAL,0},  // relating to
		{"ac",ADJECTIVE|ADJECTIVE_NORMAL,0},  // pertaining to
		{"al",ADJECTIVE|ADJECTIVE_NORMAL,0},  // pertaining to
		{"en",ADJECTIVE|ADJECTIVE_NORMAL,0}, 
		{"an",ADJECTIVE|ADJECTIVE_NORMAL,0}, // relating to
	{0},
};
EndingInfo adjective1[] = 
{
		{"y",ADJECTIVE|ADJECTIVE_NORMAL,0}, 
	{0},
};

uint64 GetPosData(unsigned int at, char* original,WORDP &entry,WORDP &canonical,uint64& sysflags,uint64 &cansysflags,bool firstTry,bool nogenerate,unsigned int start) // case sensitive, may add word to dictionary, will not augment flags of existing words
{ // this is not allowed to write properties/systemflags/internalbits if the word is preexisting
	if (start == 0) start = 1;
	uint64 properties = 0;
	sysflags = cansysflags = 0;
	canonical = 0;
	entry = FindWord(original,0,PRIMARY_CASE_ALLOWED);

	///////////// PUNCTUATION

	if (*original == '-' && original[start] == '-' && !original[start+1])  // -- mdash equivalent WSJ
	{
		entry = canonical = StoreWord(original,PUNCTUATION);
		return PUNCTUATION;
	}
	if (*original == '.')
	{
		if (!original[start] || !strcmp(original,"..."))  // periods we NORMALLY kill off  .   and ...
		{
			entry = canonical = StoreWord(original,PUNCTUATION);
			return PUNCTUATION;
		}
	}

	///////////// URL WEBLINKS
	if (IsUrl(original,0)) 
	{
		properties = NOUN|NOUN_SINGULAR;
		entry = canonical = StoreWord(original,properties,WEB_URL); 
		cansysflags = sysflags = WEB_URL;
		return properties;
	}


	///////// WORD REWRITES particularly from pennbank tokenization
	
	if (IsUpperCase(*original) && firstTry) // someone capitalized things we think of as ordinary.
	{
		WORDP check = FindWord(original,0,LOWERCASE_LOOKUP);
		if (check && check->properties & (PREPOSITION|DETERMINER_BITS|CONJUNCTION_BITS|PRONOUN_BITS|POSSESSIVE_BITS)) 
		{
			entry =  canonical = FindWord(original,0,LOWERCASE_LOOKUP); //force lower case pronoun, dont want "His" as plural of HI nor thi's
			wordStarts[at] = entry->word;
			original = entry->word;
		}
	}

	if (*original == '@' && !original[1])
	{
		strcpy(original,"at");
		entry = canonical = FindWord(original,0,PRIMARY_CASE_ALLOWED);
		original = entry->word; 
	}

	if (!stricmp(original,"His") || !stricmp(original,"This")  || !stricmp(original,"Then"))
	{
		entry =  canonical = FindWord(original,0,LOWERCASE_LOOKUP); //force lower case pronoun, dont want "His" as plural of HI nor thi's
		wordStarts[at] = entry->word;
		original = entry->word;
	}
	if (!stricmp(original,"yes") )
	{
		entry =  canonical = FindWord(original,0,LOWERCASE_LOOKUP); //force lower case pronoun, dont want "yes" to be Y's
		wordStarts[at] = entry->word;
		original = entry->word;
	}

	if (!stricmp(original,"ca") &&  !stricmp(wordStarts[at+1],"not"))
	{
		entry = canonical = FindWord("can",0,LOWERCASE_LOOKUP); // casing irrelevant with not after it was "can't" split by pennbank to ca n't
		wordStarts[at] = entry->word;
		original = entry->word;
	}

	if (!stricmp(original,"wo") &&  !stricmp(wordStarts[at+1],"not"))
	{
		entry = canonical = FindWord("will",0,LOWERCASE_LOOKUP); // casing irrelevant with not after it was "can't" split by pennbank to ca n't
		cansysflags = sysflags = entry->systemFlags; // probably nothing here
		wordStarts[at] = entry->word;
		original = entry->word;
	}

	if (!stricmp(original,"n'") )
	{
		entry = canonical = FindWord("and",0,LOWERCASE_LOOKUP);
		wordStarts[at] = entry->word;
		original = entry->word;
	}

	// compute length NOW after possible changes to original
	size_t len = strlen(original);

	// ILLEGAL STUFF that our tokenization wouldn't provide
	if (len > 2 && original[len-2] == '\'')  // "it's  and other illegal words"
	{
		canonical = entry = StoreWord(original,0);
		cansysflags = sysflags = entry->systemFlags; // probably nothing here
		return 0;
	}
	
	// hyphenated word which is number on one side:   Cray-3  3-second
	char* hyphen = strchr(original,'-');

	// numeric words
	if (IsDigit(*original) || IsDigit(original[1]))
	{
		// DATE IN 2 DIGIT OR 4 DIGIT NOTATION
		char word[MAX_WORD_SIZE];
		*word = 0;
		// 4digit year 1990 and year range 1950s and 1950's
		if (IsDigit(*original)  && IsDigit(original[2]) && IsDigit(original[3])  &&
			(!original[4] || (original[4] == 's' && !original[5]) || (original[4] == '\'' && original[5] == 's' && !original[6] ))) sprintf(word,"%d",atoi(original));
		//  2digit year and range '40 and '40s
		if (*original == '\'' && IsDigit(original[2]) &&
			(!original[3] || (original[3] == 's' && !original[4]) || (original[3] == '\'' && original[4] == 's' && !original[5] ))) sprintf(word,"%d",atoi(original+1));
		if (*word)
		{
			properties = NOUN|NOUN_NUMBER|ADJECTIVE|ADJECTIVE_NUMBER;
			entry = StoreWord(original,properties,TIMEWORD);
			canonical = StoreWord(word,properties,TIMEWORD);
			sysflags = entry->systemFlags | TIMEWORD;
			cansysflags = canonical->systemFlags | TIMEWORD;
			return properties;
		}
	
		// handle time like 4:30
		if (len < 6 && IsDigit(original[len-1]) && (original[1] == ':' || original[2] == ':')) // 18:32
		{
			properties = NOUN|NOUN_NUMBER|ADJECTIVE|ADJECTIVE_NUMBER;
			entry = canonical = StoreWord(original,properties); // 18:32
			return properties;
		}

		// handle number range data like 120:129 
		char* at = original;
		int colon = 0;
		while (*++at && (IsDigit(*at)|| *at == ':')) 
		{
			if (*at == ':') ++colon;
		}
		if (!*at && colon == 1) // was completely digits and a single colon
		{
			properties = NOUN|NOUN_NUMBER|ADJECTIVE|ADJECTIVE_NUMBER;
			entry = canonical = StoreWord(original,properties); 
			return properties;
		}

		// mark numeric fractions
		char* fraction = strchr(original,'/');
		if (fraction)
		{
			char number[MAX_WORD_SIZE];
			strcpy(number,original);
			number[fraction-original] = 0;
			if (IsNumber(number) && IsNumber(fraction+1))
			{
				int x = atoi(number);
				int y = atoi(fraction+1);
				float val = (float)((float)x / (float)y);
				sprintf(number,"%2.2f",val);
				properties = ADJECTIVE|NOUN|ADJECTIVE_NUMBER|NOUN_NUMBER;
				if (!entry) entry = StoreWord(original,properties);
				canonical = FindWord(number,0,PRIMARY_CASE_ALLOWED);
				if (canonical) properties |= canonical->properties;
				else canonical = StoreWord(number,properties);
				sysflags = entry->systemFlags;
				cansysflags = entry->systemFlags;
				return properties;
			}
		}
	}
	unsigned int kind = IsNumber(original);
	if (kind) // penn numbers as words do not go to change their entry value
	{
		if (kind != ROMAN_NUMBER) MakeLowerCase(original);
		entry = StoreWord(original);
		char number[MAX_WORD_SIZE];
		char* value;
		uint64 baseflags = (entry) ? entry->properties : 0;
		if (kind == PLACE_NUMBER)
		{
			sprintf(number,"%d",(int)Convert2Integer(original));
			sysflags |= ORDINAL;
			properties = ADVERB|ADVERB_NORMAL|ADJECTIVE|ADJECTIVE_NUMBER|NOUN|NOUN_NUMBER| (baseflags & TAG_TEST); // place numbers all all potential adverbs:  "*first, he wept"  but not in front of an adjective or noun, only as verb effect
		}
		else if (kind == FRACTION_NUMBER) // word fraction
		{
			char* br = hyphen;
			if (!br) br = strchr(original,'_');
			char c = *br;
			*br = 0;
			int64 val1 = Convert2Integer(original);
			int64 val2 = Convert2Integer(br+1);
			float val = (float)((float)val1 / (float)val2);
			sprintf(number,"%2.2f",val );
			properties = ADJECTIVE|NOUN|ADJECTIVE_NUMBER|NOUN_NUMBER;
			*br = c;
			entry = StoreWord(original,properties);
			canonical = StoreWord(number,properties);
			properties |= canonical->properties;
			sysflags = entry->systemFlags;
			cansysflags = canonical->systemFlags;
			return properties;
		}
		else if (kind == CURRENCY_NUMBER) // money
		{
			GetCurrency(original,value);
			int64 n = Convert2Integer(value);
			float fn = (float)atof(value);
			if ((float)n == fn) 
			{
#ifdef WIN32
				sprintf(number,"%I64d",n); 
#else
				sprintf(number,"%lld",n); 
#endif
			}
			else if (strchr(value,'.')) sprintf(number,"%2.2f",fn);
			else 
			{
#ifdef WIN32
				sprintf(number,"%I64d",n); 
#else
				sprintf(number,"%lld",n); 
#endif
			}
			properties = NOUN|NOUN_NUMBER;
		}
		else
		{
			if (strchr(original,'.')) sprintf(number,"%2.2f",atof(original));
			else 
			{
				int64 val = Convert2Integer(original);
				if (val < 1000000000 && val >  -1000000000)
				{
					int smallval = (int) val;
					sprintf(number,"%d",smallval);
				}
				else
				{
#ifdef WIN32
					sprintf(number,"%I64d",val);	
#else
					sprintf(number,"%lld",val);	
#endif
				}
			
			}
			properties = ADJECTIVE|NOUN|ADJECTIVE_NUMBER|NOUN_NUMBER;
		}
		canonical = StoreWord(number,properties,sysflags);
		cansysflags |= sysflags;

		// other data already existing on the number

		if (entry->properties & PART_OF_SPEECH) 
		{
			uint64 val = entry->properties; // numbers we "know" in some form should be as we know them. like "once" is adverb and adjective, not cardinal noun
			if (entry->properties & NOUN && !(entry->properties & NOUN_BITS)) // we dont know its typing other than as noun... figure it out
			{
				if (IsUpperCase(*entry->word)) val |= NOUN_PROPER_SINGULAR;
				else val |= NOUN_SINGULAR;
			}
			if (val & ADJECTIVE_NORMAL) // change over to known number
			{
				properties ^= ADJECTIVE_NORMAL;
				properties |= ADJECTIVE_NUMBER|ADJECTIVE;
			}
			if (val & NOUN_SINGULAR) // change over to known number
			{
				properties ^= NOUN_SINGULAR;
				properties |= NOUN_NUMBER|NOUN;
				if (tokenControl & TOKEN_AS_IS) canonical = entry;
			}
			if (val & ADVERB_BITS) 
			{
				properties |= entry->properties & (ADVERB_NORMAL|ADVERB);
				if (tokenControl & TOKEN_AS_IS) canonical = entry;
			}
			if (val & PREPOSITION) 
			{
				properties |= PREPOSITION; // like "once"
				if (tokenControl & TOKEN_AS_IS) canonical = entry;
			}
			if (val & PRONOUN_BITS)  // in Penntags this is CD always but "no one is" is NN or PRP
			{
				properties |= entry->properties & PRONOUN_BITS;
				//if (at > 1 && !stricmp(wordStarts[at-1],"no"))
				//{
					//properties |= val & PRONOUN_BITS; // like "one"
					if (tokenControl & TOKEN_AS_IS) canonical = entry;
				//}
			}
			if (val & VERB) 
			{
				properties |= entry->properties & ( VERB_TENSES | VERB); // like "once"
				if (tokenControl & TOKEN_AS_IS) canonical = FindWord(GetInfinitive(original,false),0,LOWERCASE_LOOKUP);
			}
			if (val & POSSESSIVE && tokenControl & TOKEN_AS_IS && !stricmp(original,"'s") && at > start) // internal expand of "it 's" and "What 's" and capitalization failures that contractions.txt wouldn't have handled 
			{
				properties |= AUX_BE | POSSESSIVE | VERB_PRESENT_3PS | VERB;
				entry = FindWord("'s",0,PRIMARY_CASE_ALLOWED);
			}
		}
		entry = StoreWord(original,properties);
		sysflags |= entry->systemFlags;
		cansysflags |= canonical->systemFlags;
		return properties;
	}
		
	// check for ANY digit in the word when not a hypenated word like 100-year
	char* b = original;
	if (!hyphen) while (*b)
	{
		if (IsDigit(*b++)) // Sept.30 
		{
			properties = NOUN|NOUN_NUMBER|ADJECTIVE|ADJECTIVE_NUMBER;
			canonical = entry = StoreWord(original,properties,MODEL_NUMBER|TIMEWORD);
			sysflags = cansysflags = entry->systemFlags;
			sysflags |= MODEL_NUMBER|TIMEWORD;
			cansysflags |= MODEL_NUMBER|TIMEWORD;
			return properties;
		}
	}
	
	// use forced canonical?
	if (!canonical && entry)
	{
		WORDP E = entry;
		char* canon = GetCanonical(E );
		if (canon) canonical = StoreWord(canon);
	}
	
	if (entry && entry->properties & (PART_OF_SPEECH|TAG_TEST|PUNCTUATION)) // we know this usefully already
	{
		properties |= entry->properties;
		sysflags |= entry->systemFlags;
		if (properties & VERB_PAST)
		{
			char* participle = GetPastParticiple(GetInfinitive(original,true));
			if (participle && !strcmp(participle,original)) properties |= VERB_PAST_PARTICIPLE; // wordnet exceptions doesnt bother to list both
		}
		char* canon = GetCanonical(entry);
		canonical = (canon) ? FindWord(canon,0,PRIMARY_CASE_ALLOWED) : NULL;
		if (canonical) cansysflags = canonical->systemFlags;

		// possessive pronoun-determiner like my is always a determiner, not a pronoun. 
		if (entry->properties & (COMMA | PUNCTUATION | PAREN | QUOTE | POSSESSIVE | PUNCTUATION)) return properties;
	}
	bool known = (entry) ? ((entry->properties & PART_OF_SPEECH)  != 0) : false;
	bool preknown = known;

	/////// WHETHER OR NOT WE KNOW THE WORD, IT MIGHT BE ALSO SOME OTHER WORD IN ALTERED FORM (like plural noun or comparative adjective)

	if (!(properties & VERB_TENSES)) // could it be a verb we dont know directly (even if we know the word)
	{
		char* verb =  GetInfinitive(original,true); 
		if (verb)  // inifinitive will be different from original or we would already have found the word
		{
			known = true;
			properties |= VERB | verbFormat;
			if (verbFormat & VERB_PAST) // possible shared form with participle
			{
				char* pastparticiple = GetPastParticiple(verb);
				if (pastparticiple && !strcmp(pastparticiple,original)) properties |= VERB_PAST_PARTICIPLE;
			}
			entry = StoreWord(original,properties);
			canonical =  FindWord(verb,0,PRIMARY_CASE_ALLOWED); // we prefer verb as canonical form
		}
	}
	
	if (!(properties & (NOUN_BITS|PRONOUN_BITS))) // could it be plural noun we dont know directly -- eg dogs or the plural of a singular we know differently-- "arms is both singular and plural" - avoid pronouns like "his" or "hers"
	{
		if (original[len-1] == 's')
		{
			char* noun = GetSingularNoun(original,true,true);
			if (noun && strcmp(noun,original)) 
			{
				entry = StoreWord(original,NOUN);
				uint64 which = (entry->internalBits & UPPERCASE_HASH) ? NOUN_PROPER_PLURAL : NOUN_PLURAL;
				AddProperty(entry,which);
				properties |= NOUN|which;
				if (!canonical) canonical = FindWord(noun,0,PRIMARY_CASE_ALLOWED); // 2ndary preference for canonical is noun
			}
		}
	}

	if (!(properties & ADJECTIVE_BITS)) // could it be comparative adjective we werent recognizing even if we know the word
	{
		if (original[len-1] == 'r' && original[len-2] == 'e')
		{
			char* adjective = GetAdjectiveBase(original,true);
			if (adjective && strcmp(adjective,original)) 
			{
				WORDP D = StoreWord(original,ADJECTIVE|ADJECTIVE_NORMAL);
				if (!entry) entry = D;
				properties |= ADJECTIVE|ADJECTIVE_NORMAL;
				if (!canonical) canonical = FindWord(adjective,0,PRIMARY_CASE_ALLOWED); 
				sysflags |= adjectiveFormat;
			}
		}
		else if (original[len-1] == 't' && original[len-2] == 's'  && original[len-3] == 'e')
		{
			char* adjective = GetAdjectiveBase(original,true);
			if (adjective && strcmp(adjective,original)) 
			{
				WORDP D = StoreWord(original,ADJECTIVE|ADJECTIVE_NORMAL);
				if (!entry) entry = D;
				properties |= ADJECTIVE|ADJECTIVE_NORMAL;
				if (!canonical) canonical = FindWord(adjective,0,PRIMARY_CASE_ALLOWED); 
				sysflags |= adjectiveFormat;
			}
		}
	}

	if (!(properties & ADVERB_BITS)) // could it be comparative adverb even if we know the word
	{
		if (original[len-1] == 'r' && original[len-2] == 'e')
		{
			char* adverb = GetAdverbBase(original,true);
			if (adverb && strcmp(adverb,original)) 
			{
				WORDP D = StoreWord(original,ADVERB|ADVERB_NORMAL);
				if (!entry) entry = D;
				properties |= ADVERB|ADVERB_NORMAL;
				if (!canonical) canonical = FindWord(adverb,0,PRIMARY_CASE_ALLOWED); 
				sysflags |= adverbFormat;
			}
		}
		else if (original[len-1] == 't' && original[len-2] == 's'  && original[len-3] == 'e')
		{
			char* adverb = GetAdverbBase(original,true);
			if (adverb && strcmp(adverb,original)) 
			{
				WORDP D = StoreWord(original,ADVERB|ADVERB_NORMAL);
				if (!entry) entry = D;
				properties |= ADVERB|ADVERB_NORMAL;
				if (!canonical) canonical = FindWord(adverb,0,PRIMARY_CASE_ALLOWED); 
				sysflags |= adverbFormat;
			}
		}
	}

	// DETERMINE CANONICAL OF A KNOWN WORD
	if (!canonical && !IS_NEW_WORD(entry)) // we dont know the word and didn't interpolate it from noun or verb advanced forms (cannot get canonical of word created this volley)
	{
		if (properties & (VERB|NOUN_GERUND)) canonical = FindWord(GetInfinitive(original,true),0,PRIMARY_CASE_ALLOWED); // verb or known gerund (ing) or noun plural (s) which might be a verb instead
		
		if (properties & NOUN) // EVEN if we do know it... flies is a singular and needs canonical for fly BUG
		{
			char* singular = GetSingularNoun(original,true,true);
			// even if it is a noun, if it ends in s and the root is also a noun, make it plural as well (e.g., rooms)
			if (original[len-1] == 's' && singular && stricmp(singular,original)) 
			{
				known = true;
				properties |= NOUN_PLURAL;
			}
			if (!canonical) canonical = FindWord(singular,0,PRIMARY_CASE_ALLOWED);
		}

		if (!canonical) canonical = FindWord(GetAdjectiveBase(original,true),0,PRIMARY_CASE_ALLOWED);

		if (properties & (ADJECTIVE_NORMAL|ADVERB_NORMAL)) // some kind of known adjective or adverb
		{
			char* adjective;
			char* adverb;
			if (hyphen) // could prefix or postfix be comparative adjective or adverb so entire word inherits that?
			{
				*hyphen = 0;
				char word[MAX_WORD_SIZE];
				WORDP X = FindWord(original,0,LOWERCASE_LOOKUP);
				if (X && X->properties & ADJECTIVE_NORMAL) // front part is known adjective
				{
					adjective = GetAdjectiveBase(original,true); 
					if (strcmp(adjective,original)) // base is not the same
					{
						if (!canonical) 
						{
							sprintf(word,"%s-%s",adjective,hyphen+1);
							canonical = StoreWord(word,ADJECTIVE_NORMAL|ADJECTIVE);
						}
						sysflags |= adjectiveFormat;
					}
				}
				else
				{
					WORDP Y = FindWord(hyphen+1,0,LOWERCASE_LOOKUP);
					if (Y  && Y ->properties & ADJECTIVE_NORMAL) // back part is known adjective
					{
						adjective = GetAdjectiveBase(hyphen+1,true); 
						if (strcmp(adjective,hyphen+1)) // base is not the same
						{
							if (!canonical) 
							{
								sprintf(word,"%s-%s",original,adjective);
								canonical = StoreWord(word,ADJECTIVE_NORMAL|ADJECTIVE);
							}
							sysflags |= adjectiveFormat;
						}
					}
				}
				if (X && X->properties & ADVERB_NORMAL) // front part is known adverb
				{
					adverb = GetAdverbBase(original,true); 
					if (strcmp(adverb,original)) // base is not the same
					{
						if (!canonical)
						{
							sprintf(word,"%s-%s",adverb,hyphen+1);
							canonical = StoreWord(word,ADVERB_NORMAL|ADVERB);
						}
						sysflags |= adverbFormat;
					}
				}
				else
				{
					WORDP Y = FindWord(hyphen+1,0,LOWERCASE_LOOKUP);
					if (Y && Y->properties & ADVERB_NORMAL) // back part is known adjective
					{
						adverb = GetAdverbBase(hyphen+1,true); 
						if (strcmp(adverb,hyphen+1)) // base is not the same
						{
							if (!canonical) 
							{
								sprintf(word,"%s-%s",original,adverb);
								canonical = StoreWord(word,ADVERB_NORMAL|ADVERB);
							}
							sysflags |= adverbFormat;
						}
					}
				}
				*hyphen = '-';
			}
		}
		else if (!canonical && properties & (NOUN_SINGULAR | NOUN_PROPER_SINGULAR)) canonical = entry;
	}
	if (preknown && !canonical) canonical = entry; //  for all others

	// A WORD WE NEVER KNEW - figure it out
	if (!preknown) // if we didnt know the original word, then even if we've found noun/verb forms of it, we need to test other options
	{
		// process by know parts of speech or potential parts of speech
		if (!(properties & NOUN)) // could it be a noun but not already known as a known (eg noun_gerund from verb)
		{
			char* noun = GetSingularNoun(original,true,true); 
			if (noun) 
			{
				known = true;
				properties |= NOUN | nounFormat;
				entry = StoreWord(original,0);
				if (!canonical || !stricmp(canonical->word,original)) canonical = FindWord(noun,0,PRIMARY_CASE_ALLOWED);
			}
		}
		if (!(properties & ADJECTIVE)) 
		{
			char* adjective = GetAdjectiveBase(original,true); 
			if (!adjective && hyphen && !strcmp(original+len-3,"ing")) // some kind of verb ing formation which can be adjective particple
			{
				*hyphen = 0;
				char word[MAX_WORD_SIZE];
				WORDP X = FindWord(original,0,LOWERCASE_LOOKUP);
				if (X && X->properties & ADJECTIVE_NORMAL)
				{
					adjective = GetAdjectiveBase(original,true); 
					if (adjective && strcmp(adjective,original)) // base is not the same
					{
						sprintf(word,"%s-%s",adjective,hyphen+1);
						canonical = StoreWord(word,ADJECTIVE_NORMAL|ADJECTIVE);
					}
				}
				*hyphen = '-';
			}
			if (!adjective && hyphen) // third-highest
			{
				adjective = GetAdjectiveBase(hyphen+1,true);
				if (adjective && strcmp(hyphen+1,adjective)) // base is not the same
				{
					char word[MAX_WORD_SIZE];
					sprintf(word,"%s-%s",original,adjective);
					canonical = StoreWord(word,ADJECTIVE_NORMAL|ADJECTIVE);
					sysflags |= adjectiveFormat;
				}
			}
			if (adjective && hyphen) 
			{
				known = true;
				properties |= ADJECTIVE|ADJECTIVE_NORMAL;
				entry = StoreWord(original,0,adjectiveFormat);
				sysflags |= adjectiveFormat;
				if (!canonical) canonical = entry;
			}
		}
		if (!(properties & ADVERB)) 
		{
			char* adverb = GetAdverbBase(original,true); 
			if (!canonical && adverb) canonical = FindWord(adverb,0,PRIMARY_CASE_ALLOWED);
			if (!adverb && hyphen) 
			{
				adverb = GetAdverbBase(hyphen+1,true);
				if (adverb && strcmp(hyphen+1,adverb)) // base is not the same
				{
					char word[MAX_WORD_SIZE];
					sprintf(word,"%s-%s",original,adverb);
					canonical = StoreWord(word,ADJECTIVE_NORMAL|ADJECTIVE);
					sysflags |= adverbFormat;
				}
			}
			if (adverb && hyphen)  
			{
				known = true;
				properties |= ADVERB|ADVERB_NORMAL;
				entry = StoreWord(original,0,adverbFormat);
				sysflags |= adverbFormat;
				if (!canonical) canonical = FindWord(adverb,0,PRIMARY_CASE_ALLOWED);
			}
		}
		
		if (hyphen) // unknown hypenated words even when going to base
		{
			WORDP X;
			// co-author   could be noun with front stuff in addition
			char* noun = GetSingularNoun(original,true,true);
			if (!noun) // since we actually know the base, we are not trying to interpolate
			{
				noun = GetSingularNoun(hyphen+1,true,true);
				if (noun)
				{
					X = FindWord(noun,0,PRIMARY_CASE_ALLOWED);
					if (X) properties |= X->properties & (NOUN|NOUN_BITS);
				}
			}
			char* verb = GetInfinitive(hyphen+1,true);
			if (verb)
			{
				X = FindWord(verb,0,PRIMARY_CASE_ALLOWED);
				if (X)  properties |= X->properties & (VERB|VERB_TENSES);
			}

			if (!properties) // since we recognize no component of the hypen, try as number stuff
			{
				*hyphen = 0;
				if (IsDigit(*original) || IsDigit(hyphen[1]) ||  IsNumber(original) || IsNumber(hyphen+1))
				{
					char word[MAX_WORD_SIZE];
					int64 n;
					n = Convert2Integer((IsNumber(original) || IsDigit(*original)) ? original : (hyphen+1));
					#ifdef WIN32
					sprintf(word,"%I64d",n); 
#else
					sprintf(word,"%lld",n); 
#endif
					*hyphen = '-';
					properties = NOUN|NOUN_NUMBER|ADJECTIVE|ADJECTIVE_NUMBER;
					entry = StoreWord(original,properties,TIMEWORD|MODEL_NUMBER);
					canonical = StoreWord(word,properties,TIMEWORD|MODEL_NUMBER);
					sysflags |= MODEL_NUMBER | TIMEWORD;
					cansysflags |= MODEL_NUMBER|TIMEWORD;
					return properties;
				}
				*hyphen = '-';
			}
		}
	}

	// fill in supplemental flags
	if (properties & NOUN && !(properties & NOUN_BITS))
	{
		if (entry->internalBits & UPPERCASE_HASH) properties |= NOUN_PROPER_SINGULAR;
		else properties |= NOUN_SINGULAR;
	}
	if (canonical && entry) entry->systemFlags |= canonical->systemFlags & AGE_LEARNED; // copy age data across
	else if (IS_NEW_WORD(entry)) canonical = DunknownWord;

	if (properties){;}
	else if (tokenControl & ONLY_LOWERCASE) {;}
	else if (tokenControl & STRICT_CASING && at != start && *wordStarts[at-1] != ':'){;} // can start a sentence after a colon (like newspaper headings
	else 
	{
#ifndef NOPOSPARSER
		// we will NOT allow capitalization shift on 1st word if it appears to be part of proper noun, unless its a simple finite word potentially
		WORDP X = (at == start) ? FindWord(wordStarts[at],0,LOWERCASE_LOOKUP) : NULL;
		if (X)
		{
			if (!IsUpperCase(*wordStarts[at+1]) || !wordStarts[at+1][1] || !wordStarts[at+1][2]) X = NULL; // next word is not big enough upper case
			else
			{
				WORDP Y = FindWord(wordStarts[at+1],0,UPPERCASE_LOOKUP);
				if (Y && Y->properties & (NOUN_TITLE_OF_ADDRESS|NOUN_FIRSTNAME)) X = NULL;	// first name wont have stuff before it
				else if (X->properties & ADVERB_BITS && !(X->properties & ADJECTIVE_BITS)) X = NULL; // adverb wont likely head a name
				else if (X->properties & (DETERMINER_BITS|VERB_INFINITIVE|PRONOUN_BITS|CONJUNCTION_BITS)) X = NULL; // nor will these
			}
		}

		if (X) {;}	// probable proper name started
		else if (firstTry ) // auto try for opposite case if we dont recognize the word
		{
			char alternate[MAX_WORD_SIZE];
			if (IsUpperCase(*original)) MakeLowerCopy(alternate,original);
			else MakeUpperCopy(alternate,original);
			WORDP D1,D2;
			uint64 flags1 = GetPosData(at,alternate,D1,D2,sysflags,cansysflags,false,nogenerate,start);
			if (flags1) 
			{
				wordStarts[at] = D1->word;
				entry = D1;
				canonical = D2;
				return flags1;
			}
		}
#else
		if ( IsUpperCase(*original)) // dont recognize this, see if we know  lower case if this was upper case
		{
			WORDP D = FindWord(original,0,LOWERCASE_LOOKUP);
			if (D) return GetPosData(at,D->word,entry,canonical,sysflags,cansysflags,false,nogenerate);
		}
#endif
	}

	// we still dont know this word, go generic if its lower and upper not known
	char word[MAX_WORD_SIZE];
	strcpy(word,original);
	word[len-1] = 0; // word w/o trailing s if any
	if (nogenerate){;}
	else if (!firstTry) {;} // this is second attempt
	else if (!properties && firstTry) 
	{
		size_t len = strlen(original);
		if (IsUpperCase(*original) || IsUpperCase(original[1]) || IsUpperCase(original[2]) ) // default it noun upper case
		{
			properties |= (original[len-1] == 's') ? NOUN_PROPER_PLURAL : NOUN_PROPER_SINGULAR;
			entry = StoreWord(original,0);
		}
		else // was lower case
		{
			properties |= (original[len-1] == 's') ? (NOUN_PLURAL|NOUN_SINGULAR) : NOUN_SINGULAR;
			entry = StoreWord(original,0);
		}
		properties |= NOUN;

		// default everything else
		bool mixed = (entry->internalBits & UPPERCASE_HASH) ? true : false;
		for (unsigned int i = 0; i < len; ++i) 
		{
			if (!IsAlpha(original[i]) && original[i] != '-' && original[i] != '_') 
			{
				mixed = true; // has non alpha in it
				break;
			}
		}
		if (!mixed) // could be ANYTHING
		{
			properties |= VERB | VERB_PRESENT | VERB_INFINITIVE |  ADJECTIVE | ADJECTIVE_NORMAL | ADVERB | ADVERB_NORMAL;
			if (properties & VERB)
			{
				if (!strcmp(original+len-2,"ed")) properties |= VERB_PAST | VERB_PAST_PARTICIPLE;
				if (original[len-1] == 's') properties |= VERB_PRESENT_3PS;
			}
			if (ProbableAdjective(original,len)) 
			{
				AddSystemFlag(entry,ADJECTIVE); // probable decode
				sysflags |= ADJECTIVE;
			}
			if (ProbableAdverb(original,len)) 
			{
				AddSystemFlag(entry,ADVERB);		 // probable decode
				sysflags |= ADVERB;
			}
			if (ProbableNoun(original,len)) 
			{
				AddSystemFlag(entry,NOUN);			// probable decode
				sysflags |= NOUN;
			}
			uint64 vflags = ProbableVerb(original,len);
			if (vflags ) 
			{
				AddSystemFlag(entry,VERB);			// probable decode
				sysflags |= VERB;
				properties &= -1 ^ VERB_TENSES;			// remove default tenses
				properties |= vflags;					// go with projected tenses
			}
		}

		// treat all hypenated words as adjectives "bone-headed"
		canonical = DunknownWord;
	}
	if (!entry) 
	{
		entry = StoreWord(original,properties);	 // nothing found (not allowed alternative)
		canonical = DunknownWord;
	}
	if (!canonical) canonical = entry;
	AddProperty(entry,properties);
	// interpolate singular normal nouns to adjective_noun EXCEPT qword nouns like "why"
	//if (properties & (NOUN_SINGULAR|NOUN_PLURAL) && !(entry->properties & QWORD) && !strchr(entry->word,'_')) flags |= ADJECTIVE_NOUN; // proper names also when followed by ' and 's  merge to be adjective nouns  
	//if (properties & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL) && *wordStarts[at+1] == '\'' && (wordStarts[at+1][1] == 0 || wordStarts[at+1][1] == 's')) flags |= ADJECTIVE_NOUN; 
	//if (properties & NOUN_PROPER_SINGULAR && !(tokenControl & TOKEN_AS_IS)) flags |= ADJECTIVE_NOUN; // could be before "*US president"

	if (properties & VERB_INFINITIVE) properties |= NOUN_INFINITIVE;
	if (properties & (VERB_PRESENT_PARTICIPLE|VERB_PAST_PARTICIPLE)) properties |= ADJECTIVE_PARTICIPLE|ADJECTIVE;
	if (properties & VERB_PRESENT_PARTICIPLE) properties |= NOUN_GERUND|NOUN;
	if (*entry->word == '~' || *entry->word == '^' || *entry->word == '$') canonical = entry;	// not unknown, is self
	cansysflags |= canonical->systemFlags;
	sysflags |= entry->systemFlags;
	return properties;
}

void English_SetSentenceTense(unsigned int start, unsigned int end)
{
	uint64 aux[25];
	unsigned int auxIndex = 0;
	uint64 mainverbTense = 0;
	unsigned int mainVerb = 0;
	unsigned int mainSubject = 0;
	memset(aux,0,25 * sizeof(uint64));
	unsigned int defaultTense = 0;

	// command?
	unsigned int i;
	for (i = start; i <= end; ++i)
    {
		if (ignoreWord[i]) continue;
		if (roles[i] & (MAINOBJECT|MAINSUBJECT|MAINVERB)) break;
	}
	if (!stricmp(wordStarts[start],"why"))
	{
		tokenFlags |= QUESTIONMARK; 
		if (posValues[start+1] & VERB_INFINITIVE || posValues[start+2] & VERB_INFINITIVE) tokenFlags |= IMPLIED_YOU;
	}
	else if (roles[i] & MAINVERB && posValues[i] & VERB_INFINITIVE) tokenFlags |= COMMANDMARK|IMPLIED_YOU;

	// determine sentence tense when not past from verb using aux (may pick wrong aux)
	for (unsigned int i = start; i <= end; ++i)
    {
		if (ignoreWord[i]) continue;
		if (roles[i] & MAINSUBJECT) mainSubject = i;

		bool notclauseverbal = true;
#ifndef DISCARDPARSER
		if (roles[i] & MAINVERB) 
		{
			mainverbTense = posValues[i] & VERB_TENSES;
			mainVerb = i;
			if (!(tokenFlags & FUTURE) && posValues[i] & (VERB_PAST_PARTICIPLE|VERB_PAST) && !(tokenFlags & PRESENT)) tokenFlags |= PAST; // "what are you interested in"
			else if (!(tokenFlags & FUTURE) && posValues[i] & (VERB_PRESENT|VERB_PRESENT_3PS)) defaultTense = PRESENT;
		}
		// if not parsing but are postagging
		if (!mainverbTense && !roles[i] && posValues[i] & VERB_TENSES) 
		{
			mainverbTense = posValues[i] & VERB_TENSES;
			mainVerb = i;
			if (!(tokenFlags & FUTURE) && posValues[i] & (VERB_PAST_PARTICIPLE|VERB_PAST)) tokenFlags |= PAST;
			else if (!(tokenFlags & FUTURE) && posValues[i] & (VERB_PRESENT|VERB_PRESENT_3PS)) defaultTense = PRESENT;
		}
		if (clauses[i] || verbals[i]) notclauseverbal = false;

#endif

		if (posValues[i] & AUX_VERB_BITS && notclauseverbal)
		{
			aux[auxIndex] = originalLower[i] ? (originalLower[i]->properties & (AUX_VERB_BITS | VERB_TENSES)) : 0;	// pattern of aux

			// question? 
			if (i == start && !(tokenControl & NO_INFER_QUESTION) ) tokenFlags |= QUESTIONMARK;
			if (defaultTense){;}
			else if (aux[auxIndex] & AUX_BE)
			{
				if (aux[auxIndex]  & (VERB_PRESENT|VERB_PRESENT_3PS)) tokenFlags |= PRESENT;
				else if (aux[auxIndex]  & (VERB_PAST | VERB_PAST_PARTICIPLE)) tokenFlags |= PAST;
			}
			else if (aux[auxIndex]  & AUX_VERB_FUTURE ) tokenFlags |= FUTURE;
			else if (aux[auxIndex]  & AUX_VERB_PAST) tokenFlags |= PAST;
			auxIndex++;
			if (auxIndex > 20) break;
		}
	}
	if (!auxIndex && canonicalLower[start] && !stricmp(canonicalLower[start]->word,"be") && !(tokenControl & NO_INFER_QUESTION)) tokenFlags |= QUESTIONMARK;  // are you a bank teller
	if ( canonicalLower[start] && canonicalLower[start]->properties & QWORD && canonicalLower[start+1] && canonicalLower[start+1]->properties & AUX_VERB_BITS  && !(tokenControl & NO_INFER_QUESTION))   tokenFlags |= QUESTIONMARK;  // what are you doing?  what will you do?
	else if ( posValues[start] & PREPOSITION && canonicalLower[start+1] && canonicalLower[start+1]->properties & QWORD && canonicalLower[start+2] && canonicalLower[start+2]->properties & AUX_VERB_BITS  && !(tokenControl & NO_INFER_QUESTION))   tokenFlags |= QUESTIONMARK;  // what are you doing?  what will you do?

#ifdef INFORMATION
	Active tenses:  have + past participle makes things perfect  --		 be + present particicple makes things continuous
		1. present
			a. simple
			b. perfect - I have/has + past participle
			c. continuous - I am + present participle
			d. perfect continuous - I have been + present participle
		2.  past
			a. simple
			b. perfect - I had + past participle
			c. continuous - I was + present participle
			d. perfect continuous - I had been + present participle
		3. future
			a: simple - I will + infinitive or  I am going_to + infinitive
			b. perfect - I will have + past participle 
			c. continuous - I will be + present participle
			d. perfect continuous - I will have been + present participle
	Passive tenses:  be + past participle makes things passive
		1. present
			a. simple - I am  + past participle
			b. perfect - I have/has + been + past participle
			c. continuous - I am + being + past participle
			d. perfect continuous - I have been + being + past participle
		2.  past
			a. simple - I was + past participle
			b. perfect - I had + been + past participle
			c. continuous - I was +  being + past participle
			d. perfect continuous - I had been + being + past participle
		3. future
			a: simple - I will + be + past participle  or  I am going_to + be + past participle
			b. perfect - I will have + been + past participle 
			c. continuous - I will be + past participle
			d. perfect continuous - I will have been + being + past participle
#endif

	if (auxIndex)
	{
		// special future "I am going to swim"
		if (*aux & (VERB_PRESENT|VERB_PRESENT_3PS) && *aux & AUX_BE && auxIndex == 1 && mainverbTense == VERB_PRESENT_PARTICIPLE && !stricmp(wordStarts[mainVerb],"going") && posValues[mainVerb+1] == TO_INFINITIVE)  tokenFlags |= FUTURE;
		else if (aux[auxIndex-1] & AUX_HAVE && mainverbTense & VERB_PAST_PARTICIPLE) 
		{
			if (*aux & (VERB_PRESENT|VERB_PRESENT_3PS)) 
			{
				tokenFlags |= PRESENT_PERFECT|PAST; 
				if (tokenFlags & PRESENT)  tokenFlags ^= (PRESENT|PERFECT);
			}
			else tokenFlags |= PERFECT; 
		}
		else if (aux[auxIndex-1] & AUX_BE && mainverbTense & VERB_PRESENT_PARTICIPLE) tokenFlags |= CONTINUOUS; 

		// compute passive
		if ((aux[auxIndex-1] & AUX_BE || (canonicalLower[auxIndex-1] && !stricmp(canonicalLower[auxIndex-1]->word,"get"))) && mainverbTense & VERB_PAST_PARTICIPLE) // "he is lost" "he got lost"
		{
			tokenFlags |= PASSIVE;
			if (aux[auxIndex-1] & VERB_PRESENT_PARTICIPLE)  tokenFlags |= CONTINUOUS;	// being xxx
		}
		
		if (*aux & AUX_HAVE && aux[auxIndex-1] & AUX_BE && mainverbTense & VERB_PRESENT_PARTICIPLE) 
		{
				tokenFlags |= PERFECT;	// I have/had been xxx
		}
		if (aux[1] & AUX_HAVE && aux[auxIndex-1] & AUX_BE && mainverbTense & VERB_PRESENT_PARTICIPLE) 
		{
				tokenFlags |= PERFECT;	// I will have/had been xxx
		}
		if (*aux & AUX_VERB_FUTURE)  
		{
			tokenFlags |= FUTURE;
			if (mainverbTense & VERB_PRESENT_PARTICIPLE && aux[auxIndex-1] & AUX_BE && aux[auxIndex-1] & VERB_INFINITIVE) tokenFlags |= CONTINUOUS;	// be painting
		}
		else if (*aux & (AUX_VERB_PAST | VERB_PAST))  tokenFlags |= PAST; 
		if (tokenFlags & PERFECT && !(tokenFlags & FUTURE)) 
		{
				tokenFlags |= PAST; // WE CAN NOT LET PRESENT PERFECT STAND, we need it to be in the past! "we have had sex"
		}
		else if (!(tokenFlags & (PAST|FUTURE))) tokenFlags |= PRESENT; 
	}
	else if (defaultTense) tokenFlags |=  defaultTense;
	else if (!(tokenFlags & (PRESENT|PAST|FUTURE))) tokenFlags |= PRESENT; 

	if (!(tokenFlags & IMPLIED_YOU) && (!mainSubject | !mainVerb) ) tokenFlags  |= NOT_SENTENCE;
}

static char* MakePastTense(char* original,WORDP D,bool participle)
{
	static char buffer[MAX_WORD_SIZE];
	char word[MAX_WORD_SIZE];
	strcpy(word,original);
	if (*original == '-' || *original == '_') return NULL;	// protection

    //   check for multiword behavoir. Always change the 1st word only
    char* at =  strchr(word,'_'); 
	if (!at) at = strchr(word,'-');
    if (at && at[1])
    {
		int cnt = BurstWord(word,HYPHENS);
		char trial[MAX_WORD_SIZE];
        char words[10][MAX_WORD_SIZE];
		unsigned int lens[10];
		char separators[10];
		if (cnt > 9) return NULL;
		int len = 0;
		for (int i = 0; i < cnt; ++i) //   get its components
		{
			strcpy(words[i],GetBurstWord(i));
			lens[i] = strlen(words[i]);
			len += lens[i];
			separators[i] = word[len++];
		}
		for (int i = 0; i < cnt; ++i)
		{
			if (D && (D->systemFlags & (VERB_CONJUGATE1|VERB_CONJUGATE2|VERB_CONJUGATE3)))
			{
				if (D->systemFlags & VERB_CONJUGATE1 && i != 0) continue;
				if (D->systemFlags & VERB_CONJUGATE2 && i != 1) continue;
				if (D->systemFlags & VERB_CONJUGATE3 && i != 2) continue;
			}
			// even if not verb, we will interpolate: "slob_around" doesnt have slob as a verb - faff_about doesnt even have "faff" as a word
			char* inf;
			inf = (participle) ? (char*) GetPastParticiple(words[i]) : (char*) GetPastTense(words[i]);
			if (!inf) continue;
			*trial = 0;
			char* at1 = trial;
			for (int j = 0; j < cnt; ++j) //   rebuild word
			{
				if (j == i)
				{
					strcpy(at1,inf);
					at1 += strlen(inf);
					*at1++ = separators[j];
				}
				else
				{
					strcpy(at1,words[j]);
					at1 += lens[j];
					*at1++ = separators[j];
				}
			}
			strcpy(buffer,trial);
			return buffer;
		}
	}

    strcpy(buffer,word);
    size_t len = strlen(buffer);
    if (buffer[len-1] == 'e') strcat(buffer,"d");
    else if (!(IsVowel(buffer[len-1]) || buffer[len-1] == 'y' ) && IsVowel(buffer[len-2]) && len > 2 && !IsVowel(buffer[len-3])) 
    {
        char lets[2];
        lets[0] = buffer[len-1];
        lets[1] = 0;
        strcat(buffer,lets); 
        strcat(buffer,"ed");
    }
    else if (buffer[len-1] == 'y' && !IsVowel(buffer[len-2])) 
    {
        buffer[len-1] = 'i';
        strcat(buffer,"ed");
    }   
    else strcat(buffer,"ed");
    return buffer; 
}

char* English_GetPastTense(char* original)
{
    WORDP D = FindWord(original,0,LOWERCASE_LOOKUP);
    if (D && D->properties & VERB && GetTense(D)) //   die is both regular and irregular?
    {
        int n = 9;
        while (--n && D)
        {
            if (D->properties & VERB_PAST) return D->word; //   might be an alternate present tense moved to main
            D = GetTense(D); //   known irregular
        }
    }
	return MakePastTense(original,D,false);
}

char* English_GetPastParticiple(char* word)
{
	if (!word) return NULL;
    WORDP D = FindWord(word,0,LOWERCASE_LOOKUP);
    if (D && D->properties & VERB && GetTense(D) ) 
    {
        int n = 9;
        while (--n && D)
        {
            if (D->properties & VERB_PAST_PARTICIPLE) return D->word; //   might be an alternate present tense moved to main
            D = GetTense(D); //   known irregular
        }
   }
   return MakePastTense(word,D,true);
}

char* English_GetPresentParticiple(char* word)
{
    static char buffer[MAX_WORD_SIZE];
    WORDP D = FindWord(word,0,LOWERCASE_LOOKUP);
    if (D && D->properties & VERB && GetTense(D) ) 
    {//   born (past) -> bore (a past and a present) -> bear 
        int n = 9;
        while (--n && D) //   we have to cycle all the conjugations past and present of to be
        {
            if (D->properties &  VERB_PRESENT_PARTICIPLE) return D->word; 
            D = GetTense(D); //   known irregular
        }
    }
    
    strcpy(buffer,word);
    size_t len = strlen(buffer);
    char* inf = GetInfinitive(word,false);
    if (!inf) return 0;

    if (buffer[len-1] == 'g' && buffer[len-2] == 'n' && buffer[len-3] == 'i' && (!inf || stricmp(inf,word))) return word;   //   ISNT participle though it has ing ending (unless its base is "ing", like "swing"

    //   check for multiword behavoir. Always change the 1st word only
    char* at =  strchr(word,'_'); 
	if (!at) at = strchr(word,'-');
    if (at)
    {
		int cnt = BurstWord(word,HYPHENS);
		char trial[MAX_WORD_SIZE];
        char words[10][MAX_WORD_SIZE];
		int lens[10];
		char separators[10];
		if (cnt > 9) return NULL;
		int len = 0;
		for (int i = 0; i < cnt; ++i) //   get its components
		{
			strcpy(words[i],GetBurstWord(i));
			lens[i] = strlen(words[i]);
			len += lens[i];
			separators[i] = word[len++];
		}
		for (int i = 0; i < cnt; ++i)
		{
			if (D && (D->systemFlags & (VERB_CONJUGATE1|VERB_CONJUGATE2|VERB_CONJUGATE3)))
			{
				if (D->systemFlags & VERB_CONJUGATE1 && i != 0) continue;
				if (D->systemFlags & VERB_CONJUGATE2 && i != 1) continue;
				if (D->systemFlags & VERB_CONJUGATE3 && i != 2) continue;
			}
			WORDP E = FindWord(words[i],0,LOWERCASE_LOOKUP);
			if (!E || !(E->properties & VERB)) continue;
			char* inf = GetPresentParticiple(words[i]); //   is this word an infinitive?
			if (!inf) continue;
			*trial = 0;
			char* at = trial;
			for (int j = 0; j < cnt; ++j) //   rebuild word
			{
				if (j == i)
				{
					strcpy(at,inf);
					at += strlen(inf);
					*at++ = separators[j];
				}
				else
				{
					strcpy(at,words[j]);
					at += lens[j];
					*at++ = separators[j];
				}
			}
			strcpy(buffer,trial);
			return buffer;
		}
	}


    strcpy(buffer,inf); //   get the real infinitive

    if (!stricmp(buffer,"be"));
    else if (buffer[len-1] == 'h' || buffer[len-1] == 'w' ||  buffer[len-1] == 'x' ||  buffer[len-1] == 'y'); //   no doubling w,x,y h, 
    else if (buffer[len-2] == 'i' && buffer[len-1] == 'e') //   ie goes to ying
    {
        buffer[len-2] = 'y';
        buffer[len-1] = 0;
    }
    else if (buffer[len-1] == 'e' && !IsVowel(buffer[len-2]) ) //   drop ending Ce  unless -nge (to keep the j sound) 
    {
        if (buffer[len-2] == 'g' && buffer[len-3] == 'n');
        else buffer[len-1] = 0; 
    }
    else if (buffer[len-1] == 'c' ) //   add k after final c
    {
        buffer[len-1] = 'k'; 
        buffer[len] = 0;
    }
   //   double consonant 
    else if (!IsVowel(buffer[len-1]) && IsVowel(buffer[len-2]) && (!IsVowel(buffer[len-3]) || (buffer[len-3] == 'u' && buffer[len-4] == 'q'))) //   qu sounds like consonant w
    {
        char* base = GetInfinitive(word,false);
        WORDP D = FindWord(base,0,LOWERCASE_LOOKUP);
        if (D && D->properties & VERB && GetTense(D) ) 
        {
            int n = 9;
            while (--n && D)
            {
                if (D->properties & VERB_PAST) 
                {
                    unsigned int len = D->length;
                    if (D->word[len-1] != 'd' || D->word[len-2] != 'e' || len < 5) break; 
                    if (IsVowel(D->word[len-3])) break; //   we ONLY want to see if a final consonant is doubled. other things would just confuse us
                    strcpy(buffer,D->word);
                    buffer[len-2] = 0;      //   drop ed
                    strcat(buffer,"ing");   //   add ing
                    return buffer; 
                }
                D = GetTense(D); //   known irregular
            }
            if (!n) ReportBug("verb loop") //   complain ONLY if we didnt find a past tense
        }

        char lets[2];
        lets[0] = buffer[len-1];
        lets[1] = 0;
        strcat(buffer,lets);    //   double consonant
    }
    strcat(buffer,"ing");
    return buffer; 
}

uint64 ProbableVerb(char* original, unsigned int len)
{
	char word[MAX_WORD_SIZE];
	if (len == 0) len = strlen(original);
	strncpy(word,original,len);
	word[len] = 0;
	
	char* hyphen = strchr(original,'-');
	if (hyphen)
	{
		WORDP X = FindWord(hyphen+1,0,PRIMARY_CASE_ALLOWED);
		if (X && X->properties & VERB) return X->properties & (VERB_TENSES|VERB);
		char* verb = GetInfinitive(hyphen+1,false);
		if (verb) return VERB | verbFormat;
		uint64 flags = ProbableVerb(hyphen+1,len - (hyphen-original+1));
		if (flags) return flags;
	}

	char* item;
	char* test;
	int i;
	if (len >= 8) // word of 3 + suffix of 5
	{
		test = word+len-5;
		i = -1;
		while ((item = verb5[++i].word)) if (!stricmp(test,item)) return verb5[i].properties;
	}	
	if (len >= 7) // word of 3 + suffix of 4
	{
		test = word+len-4;
		i = -1;
		while ((item = verb4[++i].word)) if (!stricmp(test,item)) return verb4[i].properties;
	}
	if (len >= 6) // word of 3 + suffix of 3
	{
		test = word+len-3;
		i = -1;
		while ((item = verb3[++i].word)) if (!stricmp(test,item)) return verb3[i].properties;
	}
	if (len >= 5) // word of 3 + suffix of 2
	{
		test = word+len-2;
		i = -1;
		while ((item = verb2[++i].word)) if (!stricmp(test,item)) return verb2[i].properties;
	}
	return 0;
}

static char* InferVerb(char* original, unsigned int len)
{
	char word[MAX_WORD_SIZE];
	if (len == 0) len = strlen(original);
	strncpy(word,original,len);
	word[len] = 0;
	uint64 flags = ProbableVerb(original,len);
	if (flags) return StoreWord(word,flags)->word;
	return NULL;
}

char* English_GetThirdPerson(char* word)
{
    if (!word || !*word) return NULL;
    size_t len = strlen(word);
    if (len == 0) return NULL;
    WORDP D = FindWord(word,len,LOWERCASE_LOOKUP);
	if (!D || (D->properties & VERB) == 0) return NULL; 

    if (D && D->properties & VERB_PRESENT_3PS)  return D->word; 

    if (D && D->properties & VERB && GetTense(D) ) 
    {//   born (past) -> bore (a past and a present) -> bear 
		unsigned int n = 10;
        while (--n && D) //   scan all the conjugations 
        {
            if (D->properties & VERB_PRESENT_3PS) return D->word; 
            D = GetTense(D); //   known irregular
        }
    }

	static char result[MAX_WORD_SIZE];
	strcpy(result,word);
	strcat(result,"s");
	return result;
}

char* English_GetInfinitive(char* word, bool nonew)
{
	uint64 controls = tokenControl & STRICT_CASING ? PRIMARY_CASE_ALLOWED : LOWERCASE_LOOKUP;
	verbFormat = 0;	//   secondary answer- std infinitive or unknown
    if (!word || !*word) return NULL;
    size_t len = strlen(word);
    if (len == 0) return NULL;
    WORDP D = FindWord(word,len,controls);
    if (D && D->properties & VERB_INFINITIVE) 
	{
		verbFormat = VERB_INFINITIVE;  // fall  (fell) conflict
		return D->word; //    infinitive value
	}

    if (D && D->properties & VERB && GetTense(D) ) 
    {//   born (past) -> bore (a past and a present) -> bear 
		if (D->properties & VERB_PRESENT_PARTICIPLE) verbFormat = VERB_PRESENT_PARTICIPLE;
		else if (D->properties & (VERB_PAST|VERB_PAST_PARTICIPLE)) 
		{
			verbFormat = 0;
			if (D->properties & VERB_PAST) verbFormat |= VERB_PAST;
			if (D->properties & VERB_PAST_PARTICIPLE) verbFormat |= VERB_PAST_PARTICIPLE|ADJECTIVE_PARTICIPLE;
		}
		else if (D->properties & (VERB_PRESENT|VERB_PRESENT_3PS)) verbFormat = VERB_PRESENT;
		unsigned int n = 10;
        while (--n && D) //   scan all the conjugations 
        {
            if (D->properties & VERB_INFINITIVE) return D->word; 
            D = GetTense(D); //   known irregular
        }
    }

	char last = word[len-1];  
    char prior = (len > 2) ? word[len-2] : 0;  //   Xs
    char prior1 = (len > 3) ? word[len-3] : 0; //   Xes
    char prior2 = (len > 4) ? word[len-4] : 0; //   Xhes
	char prior3 = (len > 5) ? word[len-5] : 0; //   Xhes

    //   check for multiword behavior. 
	int cnt = BurstWord(word,HYPHENS);
    if (cnt > 1)
    {
		char trial[MAX_WORD_SIZE];
        char words[10][MAX_WORD_SIZE];
		unsigned int lens[10];
		char separators[10];
		if (cnt > 9) return NULL;
		unsigned int len = 0;
		for (int i = 0; i < cnt; ++i) //   get its components
		{
			strcpy(words[i],GetBurstWord(i));
			lens[i] = strlen(words[i]);
			len += lens[i];
			separators[i] = word[len++];
		}
		for (int i = 0; i < cnt; ++i)
		{
			char* inf = GetInfinitive(words[i],false); //   is this word an infinitive?
			if (!inf) continue;
			*trial = 0;
			char* at = trial;
			for (int j = 0; j < cnt; ++j) //   rebuild word
			{
				if (j == i)
				{
					strcpy(at,inf);
					at += strlen(inf);
					*at++ = separators[j];
				}
				else
				{
					strcpy(at,words[j]);
					at += lens[j];
					*at++ = separators[j];
				}
			}
			WORDP E = FindWord(trial,0,controls);
			if (E && E->properties & VERB_INFINITIVE) return E->word;
		}

       return NULL;  //   not a verb
    }

    //   not known verb, try to get present tense from it
    if (last == 'd' && prior == 'e' && len > 3)   //   ed ending?
    {
		verbFormat = VERB_PAST|VERB_PAST_PARTICIPLE|ADJECTIVE_PARTICIPLE;

		// if vowel-vowel-consonant e d, prefer that
		if (len > 4 && !IsVowel(prior1) && IsVowel(prior2) && IsVowel(prior3))
		{
			D = FindWord(word,len-2,controls);    //   drop ed
 			if (D && D->properties & VERB) return D->word;
		}

		D = FindWord(word,len-1,controls);	//   drop d, on scare
		if (D && D->properties & VERB) return D->word;
        D = FindWord(word,len-2,controls);    //   drop ed
        if (D && D->properties & VERB) return D->word; //   found it
        D = FindWord(word,len-1,controls);    //   drop d
        if (D && D->properties & VERB) return D->word; //   found it
        if (prior1 == prior2  )   //   repeated consonant at end
        {
            D = FindWord(word,len-3,controls);    //   drop Xed
            if (D && D->properties & VERB) return D->word; //   found it
        }
        if (prior1 == 'i') //   ied came from y
        {
            word[len-3] = 'y'; //   change i to y
            D = FindWord(word,len-2,controls);    //   y, drop ed
            word[len-3] = 'i';
            if (D && D->properties & VERB) return D->word; //   found it
        }

		if (!buildDictionary && !nonew && !fullDictionary)
		{
			char wd[MAX_WORD_SIZE];
			strcpy(wd,word);
			if (len > 4 && !IsVowel(prior1) && IsVowel(prior2) && IsVowel(prior3))
			{
				wd[len-2] = 0;
			}
			else if (prior1 == prior2) // double last and add ed
			{
				wd[len-3] = 0;
			}
			else if (!IsVowel(prior2) && prior1 == 'i') // ied => y copied->copy
			{
				strcpy(wd+len-3,"y");
			}
			else if (!IsVowel(prior1) && IsVowel(prior2)) // Noted -> note 
			{
				wd[len-1] = 0;	// just chop off the s, leaving the e
			}
			else wd[len-2] = 0; // chop ed off
			return StoreWord(wd,VERB|VERB_PAST|VERB_PAST_PARTICIPLE|ADJECTIVE_PARTICIPLE|ADJECTIVE)->word;
		}
     }
   
    //   could this be a participle verb we dont know about?
    if (prior1 == 'i' && prior == 'n' && last == 'g' && len > 4)//   maybe verb participle
    {
        char word1[MAX_WORD_SIZE];
		verbFormat = VERB_PRESENT_PARTICIPLE;
 
        //   try removing doubled consonant
        if (len > 4 &&  word[len-4] == word[len-5])
        {
            D = FindWord(word,len-4,controls);    //   drop Xing spot consonant repeated
            if (D && D->properties & VERB) return D->word; //   found it
        }

        //   y at end, maybe came from ie
        if (word[len-4] == 'y')
        {
            strcpy(word1,word);
            word1[len-4] = 'i';
            word1[len-3] = 'e';
            word1[len-2] = 0;
            D = FindWord(word1,len-2,controls);    //   drop ing but add ie
            if (D && D->properties & VERB) return D->word; //   found it
        }

        //   two consonants at end, see if raw word is good priority over e added form
        if (len > 4 && !IsVowel(word[len-4]) && !IsVowel(word[len-5])) 
        {
            D = FindWord(word,len-3,controls);    //   drop ing
            if (D && D->properties & VERB) return D->word; //   found it
        }

        //   otherwise try stem with e after it
        strcpy(word1,word);
        word1[len-3] = 'e';
        word1[len-2] = 0;
        D = FindWord(word1,len-2,controls);    //   drop ing and put back 'e'
        if (D && D->properties & VERB) return D->word; //   found it

        //   simple ing added to word
        D = FindWord(word,len-3,controls);    //   drop ing
        if (D && D->properties & VERB) return D->word; //   found it

		if (!buildDictionary && !nonew)
		{
			char wd[MAX_WORD_SIZE];
			strcpy(wd,word);
			if (prior3 == prior2) // double last and add ing like swimming => swim
			{
				wd[len-4] = 0;
			}
			else wd[len-3] = 0; // chop ing off
			return StoreWord(wd,VERB|VERB_PRESENT_PARTICIPLE|NOUN_GERUND|NOUN)->word;
		}
	}
    //   ies from y
    if (prior1 == 'i' && prior == 'e' && last == 's' && len > 4)//   maybe verb participle
    {
 		verbFormat = VERB_PRESENT_3PS;
        char word1[MAX_WORD_SIZE];
        strcpy(word1,word);
        word1[len-3] = 'y';
        word1[len-2] = 0;
        D = FindWord(word1,len-2,controls);    //   drop ing, add e
        if (D && D->properties & VERB) return D->word; //   found it
	}

     //   unknown singular verb
    if (last == 's' && len > 3 && prior != 'u' && prior != '\'') // but should not be "us" ending (adjectives)
    {
 		verbFormat = VERB_PRESENT_3PS;
        D = FindWord(word,len-1,controls);    //   drop s
        if (D && D->properties & VERB && D->properties & VERB_INFINITIVE) return D->word; //   found it
		if (D && D->properties & NOUN) return NULL; //   dont move bees to be
        else if (prior == 'e')
        {
            D = FindWord(word,len-2,controls);    //   drop es
            if (D && D->properties & VERB) return D->word; //   found it
        }

		if (!buildDictionary && !nonew)
		{
			char wd[MAX_WORD_SIZE];
			strcpy(wd,word);
			if ( prior == 'e' && prior1 == 'i') // was toadies  from toady
			{
				strcpy(wd+len-3,"y");
			}
			else wd[len-1] = 0; // chop off tail s
			return StoreWord(wd,VERB_PRESENT_3PS|VERB|NOUN|NOUN_SINGULAR)->word;
		}
   }

    if (IsHelper(word)) 
	{
		verbFormat = 0;
		return word;
	}
	if ( nonew || buildDictionary ) return NULL;
	verbFormat = VERB_INFINITIVE;
	return InferVerb(word,len);
}

char* English_GetPluralNoun(WORDP noun)
{
	if (!noun) return NULL;
    if (noun->properties & NOUN_PLURAL) return noun->word; 
    WORDP plural = GetPlural(noun);
	if (noun->properties & (NOUN_SINGULAR|NOUN_PROPER_SINGULAR)) 
    {
        if (plural) return plural->word;
        static char word[MAX_WORD_SIZE];
		unsigned int len = noun->length;
		char end = noun->word[len-1];
		char before = (len > 1) ? (noun->word[len-2]) : 0;
		if (end == 's') sprintf(word,"%ses",noun->word); // glass -> glasses
		else if (end == 'h' && (before == 'c' || before == 's')) sprintf(word,"%ses",noun->word); // witch -> witches
		else if ( end == 'o' && !IsVowel(before)) sprintf(word,"%ses",noun->word); // hero -> heroes>
		else if ( end == 'y' && !IsVowel(before)) // cherry -> cherries
		{
			if (IsUpperCase(*noun->word)) sprintf(word,"%ss",noun->word); // Germany->Germanys
			else
			{
				strncpy(word,noun->word,len-1);
				strcpy(word+len-1,"ies"); 
			}
		}
		else sprintf(word,"%ss",noun->word);
        return word;
    }
    return noun->word;
}

static char* InferNoun(char* original,unsigned int len) // from suffix might it be singular noun? If so, enter into dictionary
{
	if (len == 0) len = strlen(original);
	char word[MAX_WORD_SIZE];
	strncpy(word,original,len);
	word[len] = 0;
	uint64 flags = ProbableNoun(original,len);

	// ings (plural of a gerund like paintings)
	if (len > 6 && !stricmp(word+len-4,"ings"))
	{
		StoreWord(word,NOUN|NOUN_PLURAL);
		word[len-1] = 0;
		return StoreWord(word,NOUN|NOUN_SINGULAR)->word; // return the singular form
	}
		
	// ves (plural form)
	if (len > 4 && !strcmp(word+len-3,"ves") && IsVowel(word[len-4])) // knife
	{
		//Plurals of words that end in -f or -fe usually change the f sound to a v sound and add s or -es.
		word[len-3] = 'f';
		char* singular = GetSingularNoun(word,false,false);
		if (singular && !stricmp(singular,word)) 
		{
			nounFormat = NOUN_PLURAL;
			return StoreWord(singular,NOUN|NOUN_SINGULAR)->word;
		}
		word[len-2] = 'e';
		singular = GetSingularNoun(word,false,true);
		if (singular && !stricmp(singular,word)) 
		{
			nounFormat = NOUN_PLURAL;
			return StoreWord(singular,NOUN|NOUN_SINGULAR)->word;
		}
	}

	if (flags) return StoreWord(word,flags)->word;

	if (strchr(word,'_')) return NULL;		// dont apply suffix to multiple word stuff

	if (IsUpperCase(*word)) return StoreWord(word,NOUN|NOUN_PROPER_SINGULAR)->word;

	// if word is an abbreviation it is a noun (proper if uppcase)
	if (strchr(word,'.')) return StoreWord(word,NOUN|NOUN_SINGULAR)->word;

	// hypenated word check word at end
	char* hypen = strchr(word+1,'-');
	if ( hypen && len > 2)
	{
		char* stem = GetSingularNoun(word+1,true,false);
		if (stem && !stricmp(stem,word+1)) return StoreWord(word,NOUN|NOUN_SINGULAR)->word;
		if (stem)
		{
			strcpy(word+1,stem);
			return StoreWord(word,NOUN|NOUN_SINGULAR)->word;
		}
	}
	return NULL;
}

uint64 ProbableNoun(char* original,unsigned int len) // from suffix might it be singular noun? 
{
	if (len == 0) len = strlen(original);
	char word[MAX_WORD_SIZE];
	strncpy(word,original,len);
	word[len] = 0;

	char* hyphen = strchr(original,'-');
	if (hyphen)
	{
		WORDP X = FindWord(hyphen+1,0,PRIMARY_CASE_ALLOWED);
		if (X && X->properties & NOUN) return X->properties & (NOUN_BITS|NOUN);
		uint64 flags = ProbableNoun(hyphen+1,len - (hyphen-original+1));
		if (flags) return flags;
	}
	
	char* item;
	char* test;
	int i;
	if (len >= 10) // word of 3 + suffix of 7
	{
		test = word+len-7;
		i = -1;
		while ((item = noun7[++i].word)) if (!stricmp(test,item)) return noun7[i].properties;
	}	
	if (len >= 9) // word of 3 + suffix of 6
	{
		test = word+len-6;
		i = -1;
		while ((item = noun6[++i].word)) if (!stricmp(test,item)) return noun6[i].properties;
	}	
	if (len >= 8) // word of 3 + suffix of 5
	{
		test = word+len-5;
		i = -1;
		while ((item = noun5[++i].word)) if (!stricmp(test,item)) return noun5[i].properties;
	}	
	if (len >= 7) // word of 3 + suffix of 4
	{
		test = word+len-4;
		i = -1;
		while ((item = noun4[++i].word)) if (!stricmp(test,item)) return noun4[i].properties;
	}
	if (len >= 6) // word of 3 + suffix of 3
	{
		test = word+len-3;
		i = -1;
		while ((item = noun3[++i].word)) if (!stricmp(test,item)) return noun3[i].properties;
	}
	if (len >= 5) // word of 3 + suffix of 2
	{
		test = word+len-2;
		i = -1;
		while ((item = noun2[++i].word)) if (!stricmp(test,item)) return noun2[i].properties;
	}

	// ings (plural of a gerund like paintings)
	if (len > 6 && !stricmp(word+len-4,"ings")) return NOUN|NOUN_SINGULAR;
		
	// ves (plural form)
	if (len > 4 && !strcmp(word+len-3,"ves") && IsVowel(word[len-4])) return NOUN|NOUN_PLURAL; // knife

	return 0;
}

char* English_GetSingularNoun(char* word, bool initial, bool nonew)
{ 
	uint64 controls = PRIMARY_CASE_ALLOWED;
	nounFormat = 0;
    if (!word) return NULL;
    size_t len = strlen(word);
    if (len == 0) return NULL;
    WORDP D = FindWord(word,0,controls);
	nounFormat = NOUN_SINGULAR;
	if (D && D->properties & NOUN_PROPER_SINGULAR) //   is already singular
	{
		nounFormat = NOUN_PROPER_SINGULAR;
		return D->word;
	}

    //   we know the noun and its plural, use singular
    if (D && D->properties & (NOUN_SINGULAR|NOUN_PROPER_SINGULAR|NOUN_NUMBER)) //   is already singular
    {
		nounFormat = D->properties & (NOUN_SINGULAR|NOUN_PROPER_SINGULAR|NOUN_NUMBER);
		if (word[len-1] == 's') // even if singular, if simpler exists, use that. Eg.,  military "arms"  vs "arm" the part
		{
			if (nonew)
			{
				WORDP E = FindWord(word,len-1,controls);
				if  (E && E->properties & NOUN) return E->word;
			}
			char* sing = InferNoun(word,len);
			if (sing) return sing;
		}

        //   HOWEVER, some singulars are plurals--- words has its own meaning as well
        unsigned int len = D->length;
        if (len > 4 && D->word[len-1] == 's')
        {
            WORDP F = FindWord(D->word,len-1,controls);
            if (F && F->properties & NOUN)  return F->word;  
        }
        return D->word; 
    }
	WORDP plural = (D) ? GetPlural(D) : NULL;
    if (D  && D->properties & NOUN_PLURAL && plural) 
	{
		nounFormat = NOUN_PLURAL;
		return plural->word; //   get singular form from plural noun
	}

	if (D && D->properties & NOUN && !(D->properties & NOUN_PLURAL) && !(D->properties & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL))) return D->word; //   unmarked as plural, it must be singular unless its a name
    if (!D && IsNumber(word))  return word;
	if (D && D->properties & AUX_VERB) return NULL; // avoid "is" or "was" as plural noun

	// check known from plural s or es
	if (len > 2 && word[len-1] == 's')
	{
		char mod[MAX_WORD_SIZE];
		strcpy(mod,word);
		mod[len-1] = 0;
		char* singular = GetSingularNoun(mod,false,true);
		nounFormat = (IsUpperCase(*word)) ? NOUN_PROPER_PLURAL : NOUN_PLURAL; // would fail on iPhones BUG
		uint64 format = nounFormat; // would fail on iPhones BUG
		if (singular) return singular; // take off s is correct
		if (len > 3 && word[len-2] == 'e' && (word[len-3] == 'x' || word[len-3] == 's' || word[len-3] == 'h' || IsVowel(word[len-3]) )) // es is rarely addable (not from james) ,  tornado  and fish minus fox  allow it
		{
			mod[len-2] = 0;
			singular = GetSingularNoun(mod,false,true);
			nounFormat = format;
			if (singular) return singular; // take off es is correct
			//With words that end in a consonant and a y, you'll need to change the y to an i and add es
			if (len > 4 && mod[len-3] == 'i' && !IsVowel(mod[len-4]))
			{
				mod[len-3] = 'y';
				singular = GetSingularNoun(mod,false,true);
				nounFormat = format;
				if (singular) return singular; // take off ies is correct, change to y
			}

			//Plurals of words that end in -f or -fe usually change the f sound to a v sound and add s or -es.
			if (len > 4 && mod[len-3] == 'v')
			{
				mod[len-3] = 'f';
				singular = GetSingularNoun(mod,false,true);
				nounFormat = format;
				if (singular) return singular; // take off ves is correct, change to f
				mod[len-2] = 'e';
				singular = GetSingularNoun(mod,false,true);
				nounFormat = format;
				if (singular) return singular; // take off ves is correct, change to fe
			}
		}
	}
	if ( nonew || buildDictionary ) return NULL;

	nounFormat = (IsUpperCase(*word)) ? NOUN_PROPER_SINGULAR : NOUN_SINGULAR;
	return InferNoun(word,len);
}


static char* InferAdverb(char* original, unsigned int len) // might it be adverb based on suffix? if so, enter into dictionary
{
	char word[MAX_WORD_SIZE];
	if (len == 0) len = strlen(original);
	strncpy(word,original,len);
	word[len] = 0;
	uint64 flags = ProbableAdverb(original,len);
	
	//est
	if (len > 4 && !strcmp(word+len-3,"est"))
	{
		adjectiveFormat = MOST_FORM;
		WORDP E = StoreWord(word,ADVERB|ADVERB_NORMAL,MOST_FORM);
		WORDP base = E;
		if (word[len-3] == word[len-4])  // doubled consonant
		{
			char word1[MAX_WORD_SIZE];
			strcpy(word1,word);
			word1[len-2] = 0;
			base =  StoreWord(word,ADVERB|ADVERB_NORMAL,0);
			SetComparison(E,MakeMeaning(base));
			SetComparison(base,MakeMeaning(E));
		}
		return base->word;
	}
	//er
	if (len > 4 && !strcmp(word+len-2,"er")  )
	{
		adjectiveFormat = MORE_FORM;
		WORDP E = StoreWord(word,ADVERB|ADVERB_NORMAL,MORE_FORM);
		WORDP base = E;
		if (word[len-3] == word[len-4]) 
		{
			char word1[MAX_WORD_SIZE];
			strcpy(word1,word);
			word1[len-2] = 0;
			base =  StoreWord(word,ADVERB,0);
			SetComparison(E,MakeMeaning(base));
			SetComparison(base,MakeMeaning(E));
		}
		return base->word;
	}
	if (flags) return StoreWord(word,flags)->word;

	return NULL;
}

uint64 ProbableAdverb(char* original, unsigned int len) // might it be adverb based on suffix? 
{
	char word[MAX_WORD_SIZE];
	if (len == 0) len = strlen(original);
	strncpy(word,original,len);
	word[len] = 0;
	
	char* hyphen = strchr(original,'-');
	if (hyphen)
	{
		WORDP X = FindWord(hyphen+1,0,PRIMARY_CASE_ALLOWED);
		if (X && X->properties & ADVERB) return X->properties & (ADVERB_BITS|ADVERB);
		uint64 flags = ProbableVerb(hyphen+1,len - (hyphen-original+1));
		if (flags) return flags;
	}


	char* item;
	char* test;
	int i;
	if (len >= 8) // word of 3 + suffix of 5
	{
		test = word+len-5;
		i = -1;
		while ((item = adverb5[++i].word)) if (!stricmp(test,item)) return adverb5[i].properties;
	}
	if (len >= 7) // word of 3 + suffix of 4
	{
		test = word+len-4;
		i = -1;
		while ((item = adverb4[++i].word)) if (!stricmp(test,item)) return adverb4[i].properties;
	}
	if (len >= 6) // word of 3 + suffix of 3
	{
		test = word+len-3;
		i = -1;
		while ((item = adverb3[++i].word)) if (!stricmp(test,item)) return adverb3[i].properties;
	}
	if (len >= 5) // word of 3 + suffix of 2
	{
		test = word+len-2;
		i = -1;
		while ((item = adverb2[++i].word)) if (!stricmp(test,item)) return adverb2[i].properties;
	}

	//est
	if (len > 4 && !strcmp(word+len-3,"est")) return ADVERB|ADVERB_NORMAL;
	//er
	if (len > 4 && !strcmp(word+len-2,"er")  ) return ADVERB|ADVERB_NORMAL;
	return 0;
}

char* English_GetAdverbBase(char* word, bool nonew)
{
	uint64 controls = tokenControl & STRICT_CASING ? PRIMARY_CASE_ALLOWED : LOWERCASE_LOOKUP;
 	adverbFormat = 0;
    if (!word) return NULL;
	if (IsUpperCase(*word)) return NULL; // not as proper
    size_t len = strlen(word);
    if (len == 0) return NULL;
    char lastc = word[len-1];  
    char priorc = (len > 2) ? word[len-2] : 0; 
    char prior2c = (len > 3) ? word[len-3] : 0; 
    WORDP D = FindWord(word,0,controls);
	adverbFormat = 0;
    if (D && D->properties &  QWORD) return D->word; //   we know it as is
	if (D && D->properties & ADVERB_NORMAL && !(D->systemFlags & (MORE_FORM|MOST_FORM) )) return D->word; //   we know it as is

	if (D && D->properties & ADVERB)
    {
        int n = 5;
		WORDP original = D;
        while (--n  && D)
        {
            D = GetComparison(D);
            if (D && !(D->systemFlags & (MORE_FORM|MOST_FORM))) 
			{
				if (original->systemFlags & MORE_FORM) adjectiveFormat = MOST_FORM;
				else if (original->systemFlags & MOST_FORM) adjectiveFormat = MOST_FORM;
				return D->word;
			}
        }
    }
 
    if (len > 4 && priorc == 'l' && lastc == 'y')
    {
		char form[MAX_WORD_SIZE];
        D = FindWord(word,len-2,controls); // rapidly
        if (D && D->properties & (VERB|ADJECTIVE)) return D->word;
		if (prior2c == 'i')
		{
			D = FindWord(word,len-3,controls); // lustily
			if (D && D->properties & (VERB|ADJECTIVE)) return D->word;
			// if y changed to i, change it back
			strcpy(form,word);
			form[len-3] = 'y';
			form[len-2] = 0;
			D = FindWord(word,len-2,controls); // happily  from happy
			if (D && D->properties & (VERB|ADJECTIVE)) return D->word;
		}
		// try terrible -> terribly
		strcpy(form,word);
		form[len-1] = 'e';
 		D = FindWord(word,len-2,controls); // happily  from happy
		if (D && D->properties & (VERB|ADJECTIVE)) return D->word;
    }
	if (len >= 5 && priorc == 'e' && lastc == 'r')
    {
        D = FindWord(word,len-2,controls);
        if (D && D->properties & ADVERB) 
		{
			adverbFormat = MORE_FORM;
			return D->word;
		}
    }
	if (len > 5 && prior2c == 'e' && priorc == 's' && lastc == 't')
    {
        D = FindWord(word,len-3,controls);
        if (D && D->properties & ADVERB) 
		{
			adverbFormat = MOST_FORM;
			return D->word;
		}
    }
	if ( nonew || buildDictionary) return NULL;
	
	return InferAdverb(word,len);
}


static char* InferAdjective(char* original, unsigned int len) // might it be adjective based on suffix? If so, enter into dictionary
{
	char word[MAX_WORD_SIZE];
	if (len == 0) len = strlen(original);
	strncpy(word,original,len);
	word[len] = 0;

	// est -  comparative
	if (len >= 4 &&  !strcmp(word+len-3,"est")  )
	{
		adjectiveFormat = MOST_FORM;
		WORDP E = StoreWord(word,ADJECTIVE|ADJECTIVE_NORMAL,MOST_FORM);
		WORDP base = E;
		if (word[len-4] == word[len-5]) 
		{
			char word1[MAX_WORD_SIZE];
			strcpy(word1,word);
			word1[len-3] = 0;
			base =  StoreWord(word,ADJECTIVE|ADJECTIVE_NORMAL,0);
			SetComparison(E,MakeMeaning(base));
			SetComparison(base,MakeMeaning(E));
		}
		
		return base->word;
	}

	// er -  comparative
	if (len >= 4 &&  !strcmp(word+len-2,"er")  )
	{
		adjectiveFormat = MORE_FORM;
		WORDP E = StoreWord(word,ADJECTIVE|ADJECTIVE_NORMAL,MORE_FORM);
		WORDP base = E;
		if (word[len-3] == word[len-4]) 
		{
			char word1[MAX_WORD_SIZE];
			strcpy(word1,word);
			word1[len-2] = 0;
			base =  StoreWord(word,ADJECTIVE|ADJECTIVE_NORMAL,0);
			SetComparison(E,MakeMeaning(base));
			SetComparison(base,MakeMeaning(E));
		}
		return base->word;
	}
	
	uint64 flags = ProbableAdjective(original,len);
	if (flags) return StoreWord(word,flags)->word;

	return 0;
}

uint64 ProbableAdjective(char* original, unsigned int len) // probable adjective based on suffix?
{
	char word[MAX_WORD_SIZE];
	if (len == 0) len = strlen(original);
	strncpy(word,original,len);
	word[len] = 0;
		
	char* hyphen = strchr(original,'-');
	if (hyphen)
	{
		WORDP X = FindWord(hyphen+1,0,PRIMARY_CASE_ALLOWED);
		if (X && X->properties & ADJECTIVE) return X->properties & (ADJECTIVE_BITS|ADJECTIVE);
		uint64 flags = ProbableVerb(hyphen+1,len - (hyphen-original+1));
		if (flags) return flags;

		if (!strcmp(hyphen,"-looking" )) return ADJECTIVE|ADJECTIVE_NORMAL; // good-looking gross-looking
		if (!strcmp(hyphen,"-old" )) return ADJECTIVE|ADJECTIVE_NORMAL; // centuries-old
	}

	int i;
	char* test;
	char* item;
	if (len >= 10) // word of 3 + suffix of 7
	{
		test = word+len-7;
		i = -1;
		while ((item = adjective7[++i].word)) if (!stricmp(test,item)) return adjective7[i].properties;
	}
	if (len >= 9) // word of 3 + suffix of 6
	{
		test = word+len-6;
		i = -1;
		while ((item = adjective6[++i].word)) if (!stricmp(test,item)) return adjective6[i].properties;
	}
	if (len >= 8) // word of 3 + suffix of 5
	{
		test = word+len-5;
		i = -1;
		while ((item = adjective5[++i].word)) if (!stricmp(test,item)) return adjective5[i].properties;
	}
	if (len >= 7) // word of 3 + suffix of 4
	{
		test = word+len-4;
		i = -1;
		while ((item = adjective4[++i].word)) if (!stricmp(test,item)) return adjective4[i].properties;
	}
	if (len >= 6) // word of 3 + suffix of 3
	{
		test = word+len-3;
		i = -1;
		while ((item = adjective3[++i].word)) if (!stricmp(test,item)) return adjective3[i].properties;
	}
	if (len >= 5) // word of 3 + suffix of 2
	{
		test = word+len-2;
		i = -1;
		while ((item = adjective2[++i].word)) if (!stricmp(test,item)) return adjective2[i].properties;
	}
	if (len >= 4) // word of 3 + suffix of 1
	{
		test = word+len-1;
		i = -1;
		while ((item = adjective1[++i].word)) if (!stricmp(test,item)) return adjective1[i].properties;
	}

	// est -  comparative
	if (len >= 4 &&  !strcmp(word+len-3,"est")  ) return ADJECTIVE|ADJECTIVE_NORMAL;

	// er -  comparative
	if (len >= 4 &&  !strcmp(word+len-2,"er")  ) return ADJECTIVE|ADJECTIVE_NORMAL;

	return 0;
}


char* English_GetAdjectiveBase(char* word, bool nonew)
{
	uint64 controls = tokenControl & STRICT_CASING ? PRIMARY_CASE_ALLOWED : LOWERCASE_LOOKUP;
	adjectiveFormat = 0;
    size_t len = strlen(word);
    if (len == 0) return NULL;
    WORDP D = FindWord(word,0,controls);
	char lastc = word[len-1];  
    char priorc = (len > 2) ? word[len-2] : 0;  //   Xs
    char priorc1 = (len > 3) ? word[len-3] : 0; //   Xes
    char priorc2 = (len > 4) ? word[len-4] : 0; //   Xhes
    char priorc3 = (len > 5) ? word[len-5] : 0; //   Xgest
 
    if (D && D->properties & ADJECTIVE && !(D->systemFlags & (MORE_FORM|MOST_FORM)))
	{
		adjectiveFormat = 0;
		return D->word; //   already base
	}
    if (D && D->properties & ADJECTIVE)
    {
        int n = 5;
		WORDP original = D;
        while (--n  && D)
        {
            D = GetComparison(D);
            if (D && !(D->systemFlags & (MORE_FORM|MOST_FORM))) // this is the base
			{
				if (original->systemFlags & MORE_FORM) adjectiveFormat = MORE_FORM;
				else if (original->systemFlags & MOST_FORM) adjectiveFormat = MOST_FORM;
				return D->word;
			}
        }
    }
 
    //   see if composite
    char composite[MAX_WORD_SIZE];
    strcpy(composite,word);
    char* hyphen = strchr(composite+1,'-');
    if (hyphen)
    {
        hyphen -= 4;
		char* althyphen = (hyphen - composite) + word;
        if (hyphen[2] == 'e' && hyphen[3] == 'r') //   lower-density?
        {
            strcpy(hyphen+2,althyphen+4); //   remove er
            char* answer = GetAdjectiveBase(composite,false);
            if (answer) return answer;
        }
        if (hyphen[1] == 'e' && hyphen[2] == 's' && hyphen[2] == 't' ) //   lowest-density?
        {
            strcpy(hyphen+1,althyphen+4); //   remove est
            char* answer = GetAdjectiveBase(composite,false);
            if (answer) return answer;
        }
    }

    if (len > 4 && priorc == 'e' && lastc == 'r') //   more
    {
		 adjectiveFormat = MORE_FORM;
         D = FindWord(word,len-2,controls);
         if (D && D->properties & ADJECTIVE) return D->word; //   drop er
         D = FindWord(word,len-1,controls);
         if (D && D->properties & ADJECTIVE) return D->word; //   drop e (already ended in e)

         if (priorc1 == priorc2  )  
         {
            D = FindWord(word,len-3,controls);
            if (D && D->properties & ADJECTIVE) return D->word; //   drop Xer
         }
         if (priorc1 == 'i') //   changed y to ier?
         {
            word[len-3] = 'y';
            D = FindWord(word,len-2,controls);
            word[len-3] = 'i';
            if (D && D->properties & ADJECTIVE) return D->word; //   drop Xer
          }
	}  
	else if (len > 5 && priorc1 == 'e' &&  priorc == 's' && lastc == 't') //   most
    {
		adjectiveFormat = MOST_FORM;
        D = FindWord(word,len-3,controls);//   drop est
        if (D && D->properties & ADJECTIVE) return D->word; 
        D = FindWord(word,len-2,controls);//   drop st (already ended in e)
        if (D && D->properties & ADJECTIVE) return D->word; 
        if (priorc2 == priorc3  )   
        {
             D = FindWord(word,len-4,controls);//   drop Xest
             if (D && D->properties & ADJECTIVE) return D->word; 
        }
        if (priorc2 == 'i') //   changed y to iest
        {
             word[len-4] = 'y';
             D = FindWord(word,len-3,controls); //   drop est
             word[len-4] = 'i';
             if (D && D->properties & ADJECTIVE) return D->word; 
        }   
    }
	if ( nonew || buildDictionary) return NULL;
	
	return InferAdjective(word,len);
}
#include "common.h"

extern unsigned int tagRuleCount;

static bool reverseWords = false;
#define MAINLEVEL 1

static WORDP firstAux = NULL;
bool ApplyRules();
static void Tags(char* buffer, unsigned int i);
static bool ProcessOmittedClause(unsigned int verb1,bool &changed) ;

static unsigned char startStack[MAX_CLAUSES];  // where we began this level
static unsigned char subjectStack[MAX_CLAUSES];  // the subject found for this level of sentence piece (tied to roleIndex)
static unsigned char auxVerbStack[MAX_CLAUSES];	// most recent aux for this level
unsigned char verbStack[MAX_CLAUSES];  // the verb found for this level of sentence piece (tied to roleIndex)
unsigned int needRoles[MAX_CLAUSES]; // what we seek in direct object land or verb land at currnet level of main/phrase/clause
unsigned int roleIndex;
static unsigned int currentMainVerb = 0;
static unsigned int currentVerb2 = 0;

#define UNKNOWN_CONSTRAINT 2
#define NO_FIELD_INCREMENT 3

#ifdef INFORMATION
A rule consists of 4 64bit values, representing 4 comparator words (result uses one of them also), and a uint64 control word
The control word represents 6 bytes (describing how to interpret the 4 patterns and result), and a 1-byte offset locator to orient the pattern
The result is to either discard named bits or to restrict to named bits on the PRIMARY location, using the bits of the primary include...

A std rule has 4 tests it can consult, anchored around a starting word. A big rule uses a 2nd rule as a continuation, to see 4 more tests.
basic/0:  		6-CONTROL_OP	3-CONTROL_FLAGS		PART2_BIT		1-GUESS_BIT		2-RESULT_INDEX	48-PATTERN_BITS 
value1:  		6-CONTROL_OP	3-CONTROL_FLAGS		KEEP_BIT	    ----------------3-OFFSET_SHIFT	48-PATTERN_BITS
value2:  		6-CONTROL_OP	3-CONTROL_FLAGS		REVERSE_BIT 	1-GUESS_BIT		1-?		        48-PATTERN_BITS
value3: 		6-CONTROL_OP	3-CONTROL_FLAGS		TRACE_BIT		1-GUESS_BIT		2-?	PART1_BIT	48-PATTERN_BITS

The pattern component identies what std word properties are to be checked for from D->properties.
Result (1st field) indicates which test has the word whose bits we want to modify.
Offset_shift (2nd field) indicates where first test word is relative to base word (+ or -)
Control flags are: SKIP, STAY, NOT. 
The control_op  specifies what test to perform on that field.

Rules are executed in forward order only, so later rules can presume earlier rules have already processed appropriately.

# should cardinal adjectives be under DETERMINER and not ADJECTIVE?
# the word HOME is wonderfully overloaded as noun,verb,adjective,adverb for testing

# TRACE on start of a rule result allows you to watch it
# NOGUESS		# do no guessing
# INVERTWORDS	# test sentence words in opposite order
# ENABLE_STATS	# GUESS2 will use statistics to choose meanings
# ENABLE_BASE	# GUESS3 will use the default value of word types (not needed in our test suite yet)

# HAS = any bit matching (could be only bit it has)
# IS = bits from this collection match and no other bits are left over
# !IS will fail if result is ambiguous so it may or may not be.
# INCLUDE = has one or more of these bits AND has other bits -- DO NOT ! this, must be the ONLY field which also has * on it
# -- beware of using !IS (should use HAS) because it will match while still ambiguous
# A pattern should have only one "include", the bits you are deciding to keep or discard. Other places should use IS or HAS.

# SKIP takes a test and a value set.  But it AUTOMATICALLY skips over every phrase or clause already marked

# START, END check location of this word relative to sentence start and end
# ISORIGINAL = is this  word
# ISCANONICAL = is this root word
# ISMEMBER = is canonical word a direct member of this set
# HASPROPERTY = check for systemflag presence of PRONOUN_SINGULAR, OTHER_PLURAL. absence means nothing but presence is important so dont use ! (defined for determiner and pronoun)
# START = this is just before 1st word of sentence
# ENDSWITH - matches the characters given
# ISQUESTION aux or qword - sentence begins with possible aux verb or question word
# 0 = no bits
# ! inverts test
# STAY = dont move to next sentence word yet
# x means control/bits not used

# reverse means going backwards... Before the word still has offset -1 (means actually after the word)

# actions: DISCARD, KEEP, can also put GUESS, GUESS1, GUESS2, GUESS3 and TEST on the result or DISABLE
# the current position should always be tested as INCLUDE, because it should have too many bits. and this must be that fields first test (to set result bits)
# tests with HAS mean it may or may not have been fully resolved yet, you are making a heuristic guess

# adjectives cant end sentence UNLESS object of a be-type verb
# try to make rules self-standing, not merely a default happening after a prior rule fails to fire
# rules should be independent of each other and the order they are run in. Periodically test inverse order of rules by saying "INVERTRULES" before the first rule.

# top level parts of speech are: 
# PREDETERMINER DETERMINER NOUN_BITS VERB_TENSES AUX_VERB_BITS ADJECTIVE_BITS ADVERB_BITS PREPOSITION CONJUNCTION_COORDINATE CONJUNCTION_SUBORDINATE
# THERE_EXISTENTIAL TO_INFINITIVE PRONOUN_BITS POSSESSIVE_BITS COMMA PAREN PARTICLE NOUN_INFINITIVE

#endif

uint64* data;
char** commentsData;

static void DropLevel();

// zone data is transient per call to assignroles
#define ZONE_LIMIT 25
static unsigned char zoneBoundary[ZONE_LIMIT];	 // where commas are
static unsigned int	 zoneData[ZONE_LIMIT];		// what can be found in a zone - noun before verb, verb, noun after verb
static unsigned char zoneMember[MAX_SENTENCE_LENGTH];
static unsigned int zoneIndex;			
static int predicateZone; // where is main verb found
static unsigned int currentZone;
static unsigned int ambiguous;
static bool ResolveByStatistic(unsigned int i,bool &changed);
static void WordIdioms();

#ifdef JUNK
Subject complements are after linking verbs. We label noun complements as direct objects and adjective complements as subject_complement.
Object complements follow a direct object and is noun-like or adjective-like- "The convention named him President" -- not appositive?  verb takes object complement.???
	"The clown got the children *excited"
Verb complement is direct or indirect object of verb. 
	Additionally some verbs expect object complements which are directly nouns, eg FACTITIVE_NOUN_VERB "we elected him *president" which has an omitted "as"  - we elected him as president
	Some verbs expect object complements to be adjectives. eg FACTITIVE_ADJECTIVE_VERB  "we made him *happy"
	Some verbs expect object complements to be infinitive eg CAUSAL_TOINFINITIVE_VERB or VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE  "we want him to go"
			if (parseFlags[i] & (FACTITIVE_ADJECTIVE_VERB|FACTITIVE_NOUN_VERB))  needRoles[roleIndex] |= OBJECT_COMPLEMENT; //

Two nouns in a row:
1. appositive (renaming a noun after - "my *dog *Bob") - can be on any noun
2. Adjectival noun ("*bank *teller") - can be on any noun
3. indirectobject/directobject ("I gave *Bob the *ball") - expected by verb
4. object object-complement ("the convention named *Bob *President" ) expected by verb 
5. omitted clause starter?

To Infinitives verbals can be nouns, postnominal adjectives, or adverb. Cannot be appositive.
1. postnominal adjective:  "her plan to subsidize him was sound"
2. object - "she wanted to raise taxes"
3. subject- "to watch is fun"
4. adverb - "he went to college to study math"

parentheitical infinitive:  to sum up, I worked

adjective_noun 

How do you tell postnominal adjective from adverb--  
can postnominal adjective NOT follow object of a phrase?  
But "it is time to go" or "that was a sight to see"

//  ~factitive_adjective_Verbs take object complement adjective after direct object noun
// ~factitive_noun_verbs take object complement noun after direct object noun
// ~adjectivecomplement_taking_noun_infinitive adjectives can take a noun to infinitive after them as adjective "I was able to go"

Basic main sentence requirements on verb are:
	mainverb
	mainverb subjectcomplement (linking verbs like "be" take noun or adjective as subject complement though we label noun as direct object and adjective as subject complement)
	mainverb directobject  (directobject can be noun, to-infinitve, infinitive, as well as clause, depending on verb)
	mainverb indirectobject directobject
	mainverb directobject objectcomplement (objectcomplement can be noun, infinitive, adjective depending on verb)
#endif

static char* tagOps [] = 
{
	"?","HAS","IS","INCLUDE","ISORIGINAL","POSITION","ISCANONICAL","ISMEMBER","RESETLOCATION","HAS2VERBS",
	"CANONLYBE","HASPROPERTY","HASALLPROPERTIES","ENDSWITH","ORIGINALVALUE","HASCANONICALPROPERTY","ISQWORD","ISQUESTION","ISABSTRACT","NONEAFTER",
	"NONEBEFORE","POSSIBLEUNDETERMINEDNOUN","PARSEMARK","PRIORCANONICAL", // 23
	"PROBABLEPARTICLE",
	"PRIORTOLESSVERB","?","HOWSTART",
};
	
unsigned char bitCounts[MAX_SENTENCE_LENGTH]; // number of tags still to resolve in this word position
int lastClause = 0; 
int lastVerbal = 0;
int lastPhrase = 0;
int lastConjunction = 0;
void InitEnglishParser();
static bool idiomed = false;

unsigned char quotationInProgress = 0;

static void DumpCrossReference(unsigned int start, unsigned int end)
{
	Log(STDUSERLOG,"Xref: ");
	for (unsigned int i = start; i <= end; ++i)
	{
		Log(STDUSERLOG,"%d:%s",i,wordStarts[i]);
		if (crossReference[i]) Log(STDUSERLOG," >%d",crossReference[i]);
		if (indirectObjectRef[i]) Log(STDUSERLOG," i%d",indirectObjectRef[i]);
		if (objectRef[i]) Log(STDUSERLOG," o%d",objectRef[i]);
		if (complementRef[i]) Log(STDUSERLOG," c%d",complementRef[i]);
		Log(STDUSERLOG,"   ");
	}
	Log(STDUSERLOG,"\r\n");
	Log(STDUSERLOG,"Fragments: ");
	for (unsigned int i = start; i <= end; ++i)
	{
		Log(STDUSERLOG,"%d:%s",i,wordStarts[i]);
		if (phrases[i]) Log(STDUSERLOG," p%x",phrases[i]);
		if (verbals[i]) Log(STDUSERLOG," v%x",verbals[i]);
		if (clauses[i]) Log(STDUSERLOG," c%x",clauses[i]);
		Log(STDUSERLOG,"   ");
	}
	Log(STDUSERLOG,"\r\n");
}

static void SetCanonicalValue(unsigned int start,unsigned int end)
{
	// convert to uppercase proper name from common singular at start if appropriate (lacks determiner or adjective and isnt mass noun)
	if (posValues[start] == NOUN_SINGULAR && !(originalLower[start] && originalLower[start]->properties & NOUN_MASS)) // Bear went home vs Mommy went home
	{
		char word[MAX_WORD_SIZE];
		strcpy(word,wordStarts[start]);
		*word = toUppercaseData[*word];
		canonicalUpper[start] = originalUpper[start] = StoreWord(word,NOUN|NOUN_PROPER_SINGULAR);
		canonicalLower[start] = originalLower[start] = 0;
		posValues[start] = NOUN_PROPER_SINGULAR;
		if (trace) Log(STDUSERLOG,"Force start to be proper name %s",word);
		wordCanonical[start] = wordStarts[start] = originalUpper[start]->word;
	}

	// now set canonical lowercase forms
	for (unsigned int i = start; i <= end; ++i)
    {
		if (ignoreWord[i]) continue;

		char* original =  wordStarts[i];
		WORDP can = canonicalLower[i];
		if (originalLower[i]) original = originalLower[i]->word;
		uint64 pos = posValues[i] & (TAG_TEST|PART_OF_SPEECH);
		if (!pos && !(*original == '~')) posValues[i] = pos = NOUN;		// default it back to something
		WORDP D = FindWord(original);
		char* canon =  (D) ? GetCanonical(D) : NULL;
		if (posValues[i] & (DETERMINER| IDIOM) && original[1] == 0)  // treat "a" as not a letter A
		{
			canon = NULL;
			canonicalLower[i] = originalLower[i];
		}
		// a word like "won" has noun, verb, adjective meanings. We prefer a canonical that's different from the original
		if (canon && IsUpperCase(*canon)) canonicalUpper[i] = FindWord(canon);
		else if (canon) canonicalLower[i] = FindWord(canon);
		else if (pos & NUMBER_BITS); // must occur before verbs and nouns, since "second" is a verb and a noun
		else if (pos & (VERB_TENSES | NOUN_GERUND | NOUN_INFINITIVE|ADJECTIVE_PARTICIPLE) ) 
		{
			canonicalLower[i] = FindWord(GetInfinitive(original,false));
		}
		else if (pos & (NOUN_BITS - NOUN_GERUND)  || (canonicalLower[i] && !stricmp(canonicalLower[i]->word,original))) 
		{
			if (pos & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL) && canonicalUpper[i] && canonicalUpper[i]->properties & NOUN) // can it be upper case interpretation?
			{
				// if ONLY upper case interpretation
				if (!(pos & (VERB_TENSES|NOUN_SINGULAR|NOUN_PLURAL|ADJECTIVE_NOUN)) && !canonicalLower[i]) 
				{
					original = wordStarts[i] = canonicalUpper[i]->word; // make it upper case
					originalLower[i] = canonicalLower[i] = 0;	// blow away any lower meaning
				}
			}
			if (canonicalLower[i] && canonicalLower[i]->properties & (DETERMINER|NUMBER_BITS));
			else if (IsAlpha(*original) &&  canonicalLower[i] && !strcmp(canonicalLower[i]->word,"unknown-word"));	// keep unknown-ness
			else if (pos & NOUN_BITS && !canonicalUpper[i]) canonicalLower[i] = FindWord(GetSingularNoun(original,true,false));
		}
		else if (pos & (ADJECTIVE_BITS - ADJECTIVE_PARTICIPLE - ADJECTIVE_NOUN) || (canonicalLower[i] && !stricmp(canonicalLower[i]->word,original))) 
		{
			if (canonicalLower[i] && canonicalLower[i]->properties & NUMBER_BITS);
			else canonicalLower[i] = FindWord(GetAdjectiveBase(original,false));

			// for adjectives that are verbs, like married, go canonical to the verb if adjective is unchanged
			if (canonicalLower[i] && !strcmp(canonicalLower[i]->word,original))
			{
				char* infinitive = GetInfinitive(original,false);
				if (infinitive) canonicalLower[i] = FindWord(infinitive);
			}
		}
		else if (pos & ADVERB_BITS || (canonicalLower[i] && !stricmp(canonicalLower[i]->word,original))) 
		{
			if (canonicalLower[i] && canonicalLower[i]->properties & NUMBER_BITS);
			else canonicalLower[i] = FindWord(GetAdverbBase(original,false));
			// for adverbs that are adjectives, like faster, go canonical to the adjective if adverb is unchanged
			if (canonicalLower[i] && !strcmp(canonicalLower[i]->word,original))
			{
				char* adjective = GetAdjectiveBase(original,false);
				if (adjective) canonicalLower[i] = FindWord(adjective);
			}
		}
		else if (pos & (PRONOUN_BITS|CONJUNCTION_BITS|PREPOSITION|DETERMINER_BITS|PUNCTUATION|COMMA|PAREN)) canonicalLower[i] = FindWord(original);
		else if (*original == '~') canonicalLower[i] = FindWord(original);
		else if (!IsAlpha(*original)) canonicalLower[i] = FindWord(original);

		if (can == DunknownWord) // restore unknown word status
		{
			if (IsUpperCase(*original)) canonicalUpper[i] = can;
			else canonicalLower[i] = can;
		}
		
		if (canonicalLower[i]) wordCanonical[i] = canonicalLower[i]->word;
		else if (canonicalUpper[i]) wordCanonical[i] = canonicalUpper[i]->word;
		else wordCanonical[i] = wordStarts[i];
	}
	SetSentenceTense(start,end);
}

static char* PosBits(uint64 bits, char* buff)
{
	while (bits)  // shows lowest order bits first
	{  
		uint64 oldbits = bits;
		bits &= (bits - 1); 
  		strcat(buff," ");
		strcat(buff,FindNameByValue(oldbits ^ bits));
	}  
	return buff;
}

static char* PropertyBits(uint64 bits, char* buff)
{
	while (bits)  // shows lowest order bits first
	{  
		uint64 oldbits = bits;
		bits &= (bits - 1); 
  		strcat(buff," ");
		strcat(buff,FindName2ByValue(oldbits ^ bits));
	}  
	return buff;
}
static bool LimitValues(unsigned int i, uint64 bits,char* msg,bool& changed)
{
	uint64 old = posValues[i];
	posValues[i] &= bits;
	char buff[MAX_WORD_SIZE];
	if (old != posValues[i])
	{
		int oldcount = bitCounts[i];
		changed = true;
		if (posValues[i] == 0) // shrank to nothing
		{
			if (bits & ADJECTIVE_NOUN) // special insertion of adjective_noun
			{
				posValues[i] = ADJECTIVE_NOUN;
				allOriginalWordBits[i] |= ADJECTIVE_NOUN;
			}
			else if (!bits) posValues[i] = allOriginalWordBits[i] & TAG_TEST;
			else posValues[i] = bits & allOriginalWordBits[i] & TAG_TEST; // back up to what it COULD have been originally that we will now accept
			if (trace & TRACE_POS)
			{
				*buff = 0;
				PosBits(posValues[i],buff);
				Log(STDUSERLOG,"Limit recovery  \"%s\"(%d) %s -> %s\r\n",wordStarts[i],i,msg,buff);
			}
		}
		bitCounts[i] = BitCount(posValues[i]);

		if (bitCounts[i] == 1 && oldcount != 1) --ambiguous;	
		else if (bitCounts[i] > 1 && oldcount == 1) ++ambiguous;
		else if (bitCounts[i] == 0) // couldnt return to old??? 
		{
			if (trace & TRACE_POS) Log(STDUSERLOG,"Limit recovery  error %s %d \r\n",wordStarts[i],i);
			ambiguous = 1000; // cannot be fixed
			return false;
		}

		if (trace & TRACE_POS) 
		{
			*buff = 0;
			PosBits(posValues[i],buff);
			Log(STDUSERLOG,"Limit \"%s\"(%d) %s -> %s\r\n",wordStarts[i],i,msg,buff);
		}
		return true;
	}
	return false;
}

static void PerformPosTag(unsigned int start, unsigned int end)
{
	if (start > end) 
	{
		wordCanonical[end] = wordStarts[end];
		canonicalUpper[end] = canonicalLower[end] = 0;
		canonicalLower[end] = originalLower[end] = StoreWord(wordStarts[end]); // have something
		return;
	}
	startSentence = start;
	endSentence = end;
	// initialize the words with whatever pos they MIGHT be, from dictionary as well as what might be inferred
    for (unsigned int i = start; i <= end; ++i)
    {
		if (ignoreWord[i]) continue;
		char* original =  wordStarts[i];
		WORDP entry;
		WORDP canonical;
		uint64 sysflags = 0;
		uint64 cansysflags = 0;
		uint64 flags = GetPosData(i,original,entry,canonical,sysflags,cansysflags,true,false,start); // flags will be potentially beyond what is stored on the word itself (like noun_gerund) but not adjective_noun
		if (!canonical) canonical = entry;
		if (entry->internalBits & UPPERCASE_HASH && !(flags & PRONOUN_BITS)) // treat I as lower case original
		{
			originalUpper[i] = entry;
			canonicalUpper[i] = canonical;
		}
		else
		{
			originalLower[i] = entry;
			canonicalLower[i] = canonical;
		}
		if (flags & POSSESSIVE && *entry->word == '\'') // is this a possessive quotemark or a QUOTE?
		{
			size_t len = (i > start) ? strlen(wordStarts[i-1]) : 0;
			if (posValues[i-1] & NORMAL_NOUN_BITS){;} // it can be possessive after a noun
			else if (!len || wordStarts[i-1][len-1] != 's')  
			{
				if (stricmp(wordStarts[i-1],"he") && stricmp(wordStarts[i-1],"they") && stricmp(wordStarts[i-1],"it") && stricmp(wordStarts[i-1],"hers")) 
				{
					flags = QUOTE;	// change from possessive to QUOTE if word before it does not end in s or is not it, he, they,hers
				}
			}
		}
		posValues[i] = flags;
		if (originalLower[i]) lcSysFlags[i] = sysflags; // from lower case
		canSysFlags[i] = cansysflags;
		if (entry->properties & PART_OF_SPEECH) ++knownWords; // known as lower or upper
		if (*wordStarts[i] == '~') posValues[i] = 0;	// interjection
	}

	 // get all possible flags first and backfix PRONOUN followed by ' Possessive as PRONOUN_POSSESSIVE
	for (unsigned int i = start; i <= end; ++i)
	{
		if (ignoreWord[i]) continue;
		if (posValues[i+1] & POSSESSIVE && posValues[i] & PRONOUN_SUBJECT) posValues[i] = PRONOUN_POSSESSIVE; // his became he '  
		allOriginalWordBits[i] = posValues[i];	// for words to know what was possible
		posValues[i] &= TAG_TEST;  // only the bits we care about for pos tagging
		// generator's going down... rewrite here
		if (posValues[i] & POSSESSIVE && wordStarts[i][1] && posValues[i-1] & NOUN_SINGULAR && posValues[i+1] & VERB_PRESENT_PARTICIPLE && bitCounts[i+1] == 1)
		{
			wordStarts[i] = "is";
			originalLower[i] = FindWord(wordStarts[i]);
			posValues[i] = AUX_VERB|AUX_VERB_PRESENT;
			canonicalLower[i] = FindWord("be");
		}
	}

	if (tokenControl & NO_IMPERATIVE && posValues[start] & VERB_TENSES && posValues[start+1] & NOUN_BITS)
	{
		WORDP imperative = FindWord("~legal_imperatives");
		unsigned int i = startSentence;
		if (!stricmp(wordStarts[startSentence],"please")) ++i;
		if (canonicalLower[i] && SetContains(MakeMeaning(imperative),MakeMeaning(canonicalLower[i]))){;}
		else posValues[i] &= -1 ^ (VERB_TENSES|VERB);	// no command sentence starts
	}
	if (tokenControl & NO_VERB)
	{
		WORDP imperative = FindWord("~legal_imperatives");
		// block other verbs as well..
		for (unsigned int i = start+1; i <= end; ++i)
		{
			if (ignoreWord[i]) continue;
			if ( posValues[i] & VERB_TENSES && posValues[i] & NOUN_BITS && !(posValues[startSentence] & VERB_PRESENT_PARTICIPLE))
			{
				if (SetContains(MakeMeaning(imperative),MakeMeaning(canonicalLower[i])));
				else posValues[i] &= -1 ^ VERB_TENSES;	
			}
		}
	}

#ifdef WIN32
	unsigned int startTime = 0;
	if (prepareMode == POSTIME_MODE) startTime = GetTickCount();
#endif

	// process sentence zones
	for (unsigned int i = start; i <= end; ++i) 
	{
		if (ignoreWord[i]) continue;
		bitCounts[i] = BitCount(posValues[i]);
	}
#ifndef DISCARDPARSER
	// mark the values of the words
	WORDP D = FindWord("~special_english_attributes");
	if (D)
	{
		SetParserMarks(D,true);

		// mark the words now -- they must be direct members of marked sets
		for (unsigned int i = start; i <= end; ++i)
		{
			if (ignoreWord[i]) continue;
			if (!canonicalLower[i]) continue;
			FACT* F = GetSubjectHead(canonicalLower[i]); // need to use ORIGINAL lower when looking at "left" as adjective
			while (F)
			{
				if (F->verb == Mmember)
				{
					WORDP X = Meaning2Word(F->object);
					if (X->properties & AS_IS) parseFlags[i] |= X->inferMark;
				}
				F = GetSubjectNext(F);
			}
			if (!originalLower[i]) continue;
			F = GetSubjectHead(originalLower[i]); // need to use ORIGINAL lower when looking at "left" as adjective (not verb)
			while (F)
			{
				if (F->verb == Mmember)
				{
					WORDP X = Meaning2Word(F->object);
					if (X->properties & AS_IS) parseFlags[i] |= X->inferMark;
				}
				F = GetSubjectNext(F);
			}
			if (parseFlags[i] & CAUSAL_DIRECTINFINITIVE_VERB ) canSysFlags[i] |= VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE; //  "I made john *run"  now under systemflag  (object_complement)
			if (parseFlags[i] & CAUSAL_TOINFINITIVE_VERB ) canSysFlags[i] |= VERB_TAKES_INDIRECT_THEN_TOINFINITIVE; //   "I defy john to *run"  now under systemflag  (object_complement)
		}
		SetParserMarks(D,false);
	}
#endif

	// "After hitting Sue, who is  the one person that I love among all the people I know who can walk, the ball struck a tree."
	subjectStack[MAINLEVEL] = verbStack[MAINLEVEL] = auxVerbStack[MAINLEVEL] = 0;

	// mark quotes
	if (start > 2 && *wordStarts[start-1] == '"') // ended with a quote now starting something else
	{
		if (parseFlags[start] & QUOTEABLE_VERB) // absorb quote reference into sentence
		{
			bool changed = false;
			LimitValues(start,VERB_TENSES,"quotable verb start",changed);
			--start;
			--startSentence;
			// quote will already be tagged since we process quotes first
		}
	}
	else if (end < wordCount && *wordStarts[end+1] == '"') // ended with a quote now starting something else
	{
		++end;
		++endSentence;
		// quote will already be tagged since we process quotes first
	}
	idiomed = false;
	if (!ApplyRules()) 
		tokenFlags |= FAULTY_PARSE;
#ifdef WIN32
	if (prepareMode == POSTIME_MODE) posTiming += GetTickCount() - startTime;
#endif

	unsigned int foreign = 0;
	for (unsigned int i = start; i <= end; ++i) 
	{
		if (ignoreWord[i]) continue;
		if (posValues[i] & FOREIGN_WORD && !(posValues[i] & PART_OF_SPEECH)) foreign *= 10;
	}
	bool noparse = false;
	if (foreign > 20 &&  (foreign  / (endSentence-startSentence)) >= 5) 
	{
		noparse = true;
		tokenFlags |= FOREIGN_TOKENS;
	}
	
	if (!noparse) SetCanonicalValue(start,end); // dont process with gesture data intruding

	if (trace & TRACE_PREPARE || prepareMode == PREPARE_MODE) 
	{
		DumpCrossReference(start,end);
		Log(STDUSERLOG,"%s",DumpAnalysis(start,end,posValues,"Tagged POS",false,true));
		DumpSentence(start,end);
	}
}

static unsigned int ProcessQuotation(unsigned int i,char starter)
{
	// start a quoted zone (or end one)
	if (*wordStarts[i] == starter)
	{
		posValues[i] = PUNCTUATION;
		bitCounts[i] = 1;
		ignoreWord[i] = 1;
		wordCanonical[i] = wordStarts[i];
		canonicalLower[i] = originalLower[i] = FindWord(wordStarts[i]);
		if (quotationInProgress) 
		{
			quotationInProgress = false;
			return i;
		}
	}
	unsigned int j = i;
	while (++j <= wordCount) // end found?
	{
		if (*wordStarts[j] == starter) // matching end 
		{
			posValues[j] = PUNCTUATION;
			bitCounts[j] = 1;
			ignoreWord[j] = 1;
			wordCanonical[j] = wordStarts[i];
			canonicalLower[j] = originalLower[j] = FindWord(wordStarts[j]);
			break;
		}
	}
	if (j > wordCount) j = wordCount;	// force back onto sentence
	if (*wordStarts[j] == starter) // we found a matching close
	{
		if (tokenControl & TOKEN_AS_IS) quotationInProgress = 0;
		if ((j - i) < 2 && *wordStarts[i] == starter)  // single word covered in new quote
		{
			return j;	// only 2 words - he quoted some word pair or word + punctuation "I called him "roly."
		}
		if ((j - i) < 3  && *wordStarts[i] == starter && (*wordStarts[j-1] == '.' || *wordStarts[j-1] == '?' || *wordStarts[j-1] == '!' ))  // single word covered plus punctuation in new quote
		{
			return j;	// only 2 words - he quoted some word pair or word + punctuation "I called him "roly."
		}
	}
	tokenFlags &= -1 ^ SENTENCE_TOKENFLAGS; // reset results bits
	if (*wordStarts[j] != starter && tokenControl & TOKEN_AS_IS) quotationInProgress = starter; // maintain quotation state
	tokenFlags |= QUOTATION;
	PerformPosTag((*wordStarts[i] == starter) ? (i+1) : i,(*wordStarts[j] == starter) ? (j-1) : j); // do this zone
	while (j >= i) ignoreWord[j--] = 1; // will be ignored later
	return i;
}

static void FakeTag()
{
	unsigned int i;
	for (i = 1; i <= wordCount; ++i)
	{
		wordCanonical[i] = wordStarts[i];
		canonicalLower[i] = originalLower[i] = StoreWord(wordStarts[i]);
		canonicalUpper[i] = originalUpper[i] = 0;
	}
}

void English_TagIt() // get the set of all possible tags. Parse if one can to reduce this set and determine word roles
{

#ifndef DISCARDPARSER
	InitEnglishParser();
#endif

	memset(originalLower,0,sizeof(WORDP)*(wordCount+2));
	memset(originalUpper,0,sizeof(WORDP)*(wordCount+2));
	memset(canonicalLower,0,sizeof(WORDP)*(wordCount+2));
	memset(canonicalUpper,0,sizeof(uint64)*(wordCount+2));
	memset(bitCounts,0,sizeof(unsigned int)*(wordCount+2));
	memset(posValues,0,sizeof(uint64)*(wordCount+2));
	memset(allOriginalWordBits,0,sizeof(uint64)*(wordCount+2));
	memset(lcSysFlags,0,sizeof(uint64)*(wordCount+2));
	memset(canSysFlags,0,sizeof(uint64)*(wordCount+2));
	memset(coordinates,0,wordCount+4);
	memset(crossReference,0,wordCount+4);
	memset(ignoreWord,0,wordCount+4);

	unsigned char wasLower[MAX_SENTENCE_LENGTH];

	wordStarts[0] = wordStarts[wordCount+1] = "";
	knownWords = 0;
	unsigned int i;

	// count words beginning lowercase and note which ones
	lowercaseWords = 0;
	for (i = 1; i <= wordCount; ++i)
	{
		if (IsLowerCase(*wordStarts[i])) 
		{
			++lowercaseWords; 
			wasLower[i] = 1;
		}
		else wasLower[i] = 0;
	}
	
	// default in case we dont find anything
	startSentence = 1;
	endSentence = wordCount;
	
	if (*wordStarts[1] == '[' && *wordStarts[wordCount] == ']') // no out-of-band parsetagging
	{
		FakeTag();
		return;	
	}
	else if (prepareMode == POS_MODE || prepareMode == POSVERIFY_MODE){;} // told to try regardless
	else if (tokenControl & DO_PARSE ) {;} // pos tag at a minimum
	else 
	{
		FakeTag();
		return;	// no out-of-band parsetagging
	}

	// handle quoted areas
	unsigned char starter = 0;
	for (i = 1; i <= wordCount; ++i)
	{
		if (ignoreWord[i]) continue;
		if (*wordStarts[i] == '"') 
		{
			starter = *wordStarts[i];
			i = ProcessQuotation(i,starter); // start a quoted zone
		}
		else if (quotationInProgress) i = ProcessQuotation(i,quotationInProgress);
		else if (*wordStarts[i] == '\'' && !wordStarts[i][1]) // quote as in POS or quote as in quotation?
		{
			size_t len = (i > 1 && !ignoreWord[i-1]) ? strlen(wordStarts[i-1]) : 0;
			if (!len || wordStarts[i-1][len-1] != 's')  // single or composite
			{
				if (!stricmp(wordStarts[i-1],"he") || !stricmp(wordStarts[i-1],"they") || !stricmp(wordStarts[i-1],"it") || !stricmp(wordStarts[i-1],"hers")) continue;
			}
			else continue; // normal
			starter = *wordStarts[i];
			i = ProcessQuotation(i,starter); // start a quoted zone
		}
	}

	// handle regular area
	for (i = 1; i <= wordCount; ++i)
	{
		if (ignoreWord[i]) continue; // not start of real sentence
		unsigned int j;
		unsigned int end = wordCount;
		// last part of sentence
		for (j = wordCount; j > i; --j) // find an end
		{	
			if (!ignoreWord[j]) break;
		}
		if (j < wordCount && *wordStarts[j+1] == '"' && wasLower[j+1]) ++j;	// merge quote into current sentence since obvious intention. OTHERWISE it is a new sentence
		end = j;

		// bug - make a noun out of 1st quote if part of sentence...
		tokenFlags &= -1 ^ SENTENCE_TOKENFLAGS; // reset results bits
		PerformPosTag(i,end); // do this zone
		i = end;
	}
}

void ReadPosPatterns(char* file,uint64 junk)
{
	char word[MAX_WORD_SIZE];
	FILE* in = FopenReadOnly(file);
	if (!in) return;
	uint64 val;
	uint64 flags = 0;
	uint64 v = 0;
	uint64 offsetValue;
	uint64* dataptr;
	char comment[MAX_WORD_SIZE];
	while (ReadALine(readBuffer,in)) // read new rule or comments
	{
		char* ptr = ReadCompiledWord(readBuffer,word);
		if (!*word) continue;
		if (*word == '#' ) 
		{
			strcpy(comment,readBuffer);
			continue;
		}
		if (!stricmp(word,"INVERTWORDS")) // run sentences backwards
		{
			reverseWords = true;
			continue;
		}

		int c = 0;
		int offset;
		bool reverse = false;
		unsigned int limit = MAX_TAG_FIELDS;
		bool big = false;

		dataptr = data + (tagRuleCount * MAX_TAG_FIELDS);
		uint64* base = dataptr;
		memset(base,0,sizeof(uint64) * 8);	// clear all potential rule info for a double rule
		bool skipped = false;

		if (!stricmp(word,"TRACE"))
		{
			base[3] |= TRACE_BIT;
			ptr = ReadCompiledWord(ptr,word);
		}
		bool backwards = false;

		if (!stricmp(word,"reverse"))
		{
			reverse = true;
			backwards = true;
			ptr = ReadCompiledWord(ptr,word);
			c = 0;
			if (!IsDigit(word[0]) && word[0] != '-')
			{
				printf("Missing reverse offset  %s rule: %d comment: %s\r\n",word,tagRuleCount,comment);
				return;
			}
			c = atoi(word);
			if ( c < -3 || c > 3) // 3 bits
			{
				printf("Bad offset (+-3 max)  %s rule: %d comment: %s\r\n",word,tagRuleCount,comment);
				return;
			}
		}
		else if (!IsDigit(word[0]) && word[0] != '-') continue; // not an offset start of rule
		else 
		{
			c = atoi(word);
			if ( c < -3 || c > 3) // 3 bits
			{
				printf("Bad offset (+-3 max)  %s rule: %d comment: %s\r\n",word,tagRuleCount,comment);
				return;
			}
		}
		offset = (reverse) ? (c + 1) : (c - 1); 
		offsetValue = (uint64) ((c+3) & 0x00000007); // 3 bits offset
		offsetValue <<= OFFSET_SHIFT;
		int resultIndex = -1;
		unsigned int includes = 0;
		bool doReverse = reverse;

		for (unsigned int i = 1; i <= (limit*2); ++i)
		{
			unsigned int kind = 0;
			if (reverse) 
			{
				reverse = false;
				--offset;
			}
			else ++offset;
			flags = 0;
resume:
			// read control for this field
			ptr = ReadCompiledWord(ptr,word);
			if (!*word || *word == '#')
			{
				ReadALine(readBuffer,in);
				ptr = readBuffer;
				--i;
				continue;
			}
			if (!stricmp(word,"debug"))  // just a debug label so we can stop here if we want to understand reading a rule
				goto resume;

			// LAST LINE OF PATTERN
			if (!stricmp(word,"GUESS") || !stricmp(word,"GUESS1") || !stricmp(word,"GUESS2") || !stricmp(word,"GUESS3") || 
				 !stricmp(word,"KEEP") || !stricmp(word,"DISCARD") || !stricmp(word,"DISABLE")) 
			{
				if (i < 5) while (i++ < 5) dataptr++;  // use up blank fields
				else if (i > 5 &&  i < 9) while (i++ < 9) dataptr++;  // use up blank fields
				ptr = readBuffer;
				break;
			}

			if ( i == 5) // we are moving into big pattern territory
			{
				big = true; // extended pattern
				*(dataptr-1) |= PART1_BIT; // mark last field as continuing to 8zone
			}

			if (!stricmp(word,"STAY")) 
			{ 
				if ( doReverse) ++offset;
				else --offset;
				kind |= STAY;
				goto resume;
			}
			if (!stricmp(word,"SKIP")) // cannot do wide negative offset and then SKIP to fill
			{ 
				skipped = true;
				if ( resultIndex == -1)
				{
					if (!reverse) printf("Cannot do SKIP before the primary field -- offsets are unreliable (need to use REVERSE) Rule: %d comment: %s at line %d in %s\r\n",tagRuleCount,comment,currentFileLine,currentFilename);
					else printf("Cannot do SKIP before the primary field -- offsets are unreliable Rule: %d comment: %s at line %d in %s\r\n",tagRuleCount,comment,currentFileLine,currentFilename);
					return;
				}

				if ( doReverse) ++offset;
				else --offset;
				kind |= SKIP;
				goto resume;
			}

			if (*word == 'x') val = 0; // no field to process
			else if (*word == '!')
			{
				if (!stricmp(word+1,"ROLE") || !stricmp(word+1,"NEED"))
				{
					printf("Cannot do !ROLE or !NEED Rule: %d comment: %s at line %d in %s\r\n",tagRuleCount,comment,currentFileLine,currentFilename);
					return;
				}
				if (!stricmp(word+1,"STAY"))
				{
					printf("Cannot do !STAY (move ! after STAY)  Rule: %d comment: %s at line %d in %s\r\n",tagRuleCount,comment,currentFileLine,currentFilename);
					return;
				}
				val = FindValueByName(word+1);
				if ( val == 0)
				{
					printf("Bad notted control word %s rule: %d comment: %s at line %d in %s\r\n",word,tagRuleCount,comment,currentFileLine,currentFilename);
					return;
				}

				if (!stricmp(word+1,"include") )
				{
					printf("Use !has instead of !include-  %s rule: %d comment: %s at line %d in %s\r\n",word,tagRuleCount,comment,currentFileLine,currentFilename);
					return;
				}
				kind |= NOTCONTROL;
				if (!stricmp(word+1,"start")) flags = 1;
				else if (!stricmp(word+1,"first")) flags = 1;
				else if (!stricmp(word+1,"end")) flags = 10000;
				else if (!stricmp(word+1,"last")) flags = 10000;
			}
			else
			{
				val = FindValueByName(word);
				if ( val == 0 || val > LASTCONTROL)
				{
					printf("Bad control word %s rule: %d comment: %s at line %d in %s\r\n",word,tagRuleCount,comment,currentFileLine,currentFilename);
					return;
				}
				if (!stricmp(word,"include")) ++includes;
				if (!stricmp(word,"start")) flags |= 1;
				else if (!stricmp(word,"first")) flags |= 1;
				else if (!stricmp(word,"end")) flags |= 10000;
				else if (!stricmp(word+1,"last")) flags = 10000;
			}
			flags |= val << OP_SHIFT;	// top byte
			flags |= ((uint64)kind) << CONTROL_SHIFT;
			if (i == ( MAX_TAG_FIELDS + 1)) flags |= PART2_BIT;	// big marker on 2nd
			if (flags) // there is something to test
			{
				// read flags for this field
				bool subtract = false;
				bool once = false;
				while (ALWAYS) 
				{
					ptr = ReadCompiledWord(ptr,word);
					if (!*word || *word == '#') break;	// end of flags
					uint64 baseval = flags >> OP_SHIFT;
					if (baseval == ISCANONICAL || baseval == ISORIGINAL || baseval == ENDSWITH || baseval == PRIORCANONICAL) 
					{
						if (FindValueByName(word) && stricmp(word,"not") && !once) 
						{
							printf("Did you intend to use ORIGINALVALUE for %s rule: %d %s at line %d in %s?\r\n",word,tagRuleCount,comment,currentFileLine,currentFilename);
							once = true;
						}
						v = MakeMeaning(StoreWord(word));
					}
					else if (IsDigit(word[0])) v = atoi(word); // for POSITION 
					else if (!stricmp(word,"reverse")) v = 1;	// for RESETLOCATION
					else if (!stricmp(word,"ALL")) v = TAG_TEST;
					else if ( word[0] == '-')
					{
						subtract = true;
						v = 0;
					}
					else if ( *word == '*')
					{
						if (offset != 0)
						{
							printf("INCLUDE * must be centered at 0 rule: %d comment: %s at line %d in %s\r\n",tagRuleCount,comment,currentFileLine,currentFilename);
							return;
						}
						if ( resultIndex != -1)
						{
							printf("Already have pattern result bits %s rule: %d comment: %s at line %d in %s\r\n",word,tagRuleCount,comment,currentFileLine,currentFilename);
							return;
						}
						resultIndex = i-1;
						v = 0;
					}
					else if (baseval == ISMEMBER) 
					{
						WORDP D = FindWord(word);
						v = MakeMeaning(D);
						if (!v)
						{
							printf("Failed to find set %s - POS tagger incomplete because build 0 not yet done.\r\n",word);
						}
					}
					else if (baseval == ISQUESTION)
					{
						if (!stricmp(word,"aux")) v = AUXQUESTION;
						else if (!stricmp(word,"qword")) v = QWORDQUESTION;
						else printf("Bad ISQUESTION %s\r\n",word);
					}
					else
					{
						v = FindValueByName(word);
						if ( v == 0)
						{
							v = FindValue2ByName(word);
							if (!v)
							{
								printf("Bad flag word %s rule: %d %s at line %d in %s\r\n",word,tagRuleCount,comment,currentFileLine,currentFilename);
								return;
							}
						}
						if (v & BASIC_POS && baseval != HASALLPROPERTIES && baseval != HASPROPERTY)
						{
							printf("Bad flag word overlaps BASIC bits %s rule: %d %s at line %d in %s\r\n",word,tagRuleCount,comment,currentFileLine,currentFilename);
							return;
						}
						if (baseval == IS || baseval == HAS || baseval == HASPROPERTY || baseval == CANONLYBE || baseval == PARSEMARK)
						{
							if (v & 0xFFFF000000000000ULL) printf("Bad  bits overlap control fields %s rule: %d %s at line %d in %s\r\n",word,tagRuleCount,comment,currentFileLine,currentFilename);
						}
						
						if ( subtract ) 
						{
							flags &= -1 ^ v;
							v = 0;
							subtract = false;
						}
					}
					flags |= v;
				}
			}
			if (includes > 1) 
			{
				printf("INCLUDE should only be on primary field - use HAS Rule: %d %s at line %d in %s\r\n",tagRuleCount,comment,currentFileLine,currentFilename);
				return;
			}
			if (i == 2) flags |= offsetValue;	// 2nd field gets offset shift
			*dataptr++ |= flags; 
	
			ReadALine(readBuffer,in);
			ptr = readBuffer;
		} // end of fields loop

		// now get results data
		ptr = ReadCompiledWord(ptr,word);
		if (!stricmp(word,"GUESS") || !stricmp(word,"GUESS1") || !stricmp(word,"GUESS2") || !stricmp(word,"GUESS3") || !stricmp(word,"KEEP") || !stricmp(word,"DISCARD") || !stricmp(word,"DISABLE")) {;}
		else 
		{
			printf("Too many fields before result %s: %d %s\r\n",word,tagRuleCount,comment);
			return;
		}
		if (doReverse) base[2] |=  REVERSE_BIT;
		while (ALWAYS)
		{
			if (!stricmp(word,"GUESS")) *base |= GUESS_BIT;
			else if (!stricmp(word,"GUESS1")) 
			{
				*base |= GUESS_BIT;
				base[2] |= GUESS_BIT;
			}
			else if (!stricmp(word,"GUESS2")) 
			{
				*base |= GUESS_BIT;
				base[3] |= GUESS_BIT;
			}
			else if (!stricmp(word,"GUESS3")) 
			{
				*base |= GUESS_BIT;
				base[2] |= GUESS_BIT;
				base[3] |= GUESS_BIT;
			}
			else if (!stricmp(word,"DISABLE")) base[1] =  ((uint64)HAS) << CONTROL_SHIFT; // 2nd pattern becomes HAS with 0 bits which cannot match
			else break;
			ptr = ReadCompiledWord(ptr,word);
		}
		if (!stricmp(word,"KEEP")) base[1] |= KEEP_BIT;
		else if (!stricmp(word,"DISCARD")) {;}
		else
		{
			printf("Too many fields before result? %s  rule: %d comment: %s  at line %d in %s\r\n",word,tagRuleCount,comment,currentFileLine,currentFilename);
			return;
		}
		if ( resultIndex == -1)
		{
			printf("Needs * on result bits %s rule: %d comment: %s\r\n",word,tagRuleCount,comment);
			return;
		}

		*base |= ((uint64)resultIndex) << RESULT_SHIFT;
		if (backwards && !skipped) printf("Running backwards w/o a skip? Use forwards with minus start. %d %s.   at line %d in %s \r\n",tagRuleCount,comment,currentFileLine,currentFilename);
		
		commentsData[tagRuleCount] = AllocateString(comment);
		++tagRuleCount;
		if (big) 
		{
			commentsData[tagRuleCount] = " ";
			++tagRuleCount;		// double-size rule
		}
	}
}

static char* OpDecode(uint64 field)
{
	static char buff[500];
	unsigned int control = (unsigned int) ( (field >> CONTROL_SHIFT) &0x01ff);
	strcpy(buff, (control & NOTCONTROL) ? "!" : "");

	uint64 bits = field & PATTERN_BITS;
	control >>= CTRL_SHIFT; // get the op
	strcat(buff, tagOps[control]);
	if (control == HAS || control == IS  || control == ORIGINALVALUE || control == CANONLYBE) PosBits(bits,buff);
	else if (control == POSITION)
	{
		if (bits == 1) strcat(buff," START");
		else if (bits > 100) strcat(buff," END");
	}
	else if (control == HASCANONICALPROPERTY || control == HASPROPERTY || control == HASALLPROPERTIES) PropertyBits(bits,buff);
	else if (control == ISQUESTION)
	{
		if (bits & AUXQUESTION) strcat(buff," AUX");
		if (bits & QWORDQUESTION) strcat(buff," QWORD");	// may be a question started with a question word "how are you"
	}
	else if (control == ISCANONICAL || control == ISORIGINAL)
	{
		WORDP D = Meaning2Word((unsigned int)bits);
		strcat(buff," ");
		strcat(buff,D->word);
	}
	return buff;
}

static unsigned int PriorPhrasalVerb(int particle,WORDP & D)
{// at is the particle
	char word[MAX_WORD_SIZE];
	WORDP X = NULL;
	if (particle < 2) return 0;
	char* verb = GetInfinitive(wordStarts[particle-1],true);
	char* verb2 = GetInfinitive(wordStarts[particle-2],true);
	uint64 flags = 2;
	unsigned int next = particle+1;
	
	// has object after or before?
	bool objectAfter = false;
	bool pronounAfter = false;
	bool objectBefore = false;
	bool pronounBefore = false;

	if (posValues[next] & SIGNS_OF_NOUN_BITS) objectAfter = true;
	if (posValues[next] & (PRONOUN_BITS)) pronounAfter = true;
	if (posValues[particle-1] & (PRONOUN_BITS)) pronounBefore = true;
	if (posValues[particle-1] & NOUN_BITS) objectBefore = true;

	if (posValues[particle-1] & (ADJECTIVE_PARTICIPLE|NOUN_INFINITIVE|NOUN_GERUND|VERB_TENSES) && verb) // easy particle double
	{
		sprintf(word,"%s_%s",verb,wordStarts[particle]);
		X = FindWord(word);
		if (X && X->systemFlags & PHRASAL_VERB)
		{
			flags = X->systemFlags & (SEPARABLE_PHRASAL_VERB|INSEPARABLE_PHRASAL_VERB|MUST_BE_SEPARATE_PHRASAL_VERB);
			if (flags == INSEPARABLE_PHRASAL_VERB) return particle-1; // MUST be inseparate and is
			else if (!flags) return particle-1; // can be both, so is ok.
		}
	}
	else if (posValues[particle-1] & PARTICLE && posValues[particle-2] & (ADJECTIVE_PARTICIPLE|NOUN_INFINITIVE|NOUN_GERUND|VERB_TENSES) && verb2) // easy particle triple from end (triples never embed?)
	{
		sprintf(word,"%s_%s_%s",verb2,wordStarts[particle-1],wordStarts[particle]);
		X = FindWord(word);
		if (X && X->systemFlags & PHRASAL_VERB) 
		{
			flags = X->systemFlags & (SEPARABLE_PHRASAL_VERB|INSEPARABLE_PHRASAL_VERB|MUST_BE_SEPARATE_PHRASAL_VERB);
			if (flags == INSEPARABLE_PHRASAL_VERB) return particle-2; // MUST be inseparate and is
			else if (!flags) return particle-2; // can be both, so is ok.
		}
	}
	else if (posValues[particle+1] & PARTICLE && posValues[particle-1] & (ADJECTIVE_PARTICIPLE|NOUN_INFINITIVE|NOUN_GERUND|VERB_TENSES) && verb2) // easy particle triple from middle (triples never embed? object)
	{
		sprintf(word,"%s_%s_%s",verb,wordStarts[particle],wordStarts[particle+1]);
		X = FindWord(word);
		if (X && X->systemFlags & PHRASAL_VERB) 
		{
			flags = X->systemFlags & (SEPARABLE_PHRASAL_VERB|INSEPARABLE_PHRASAL_VERB|MUST_BE_SEPARATE_PHRASAL_VERB);
			if (flags == INSEPARABLE_PHRASAL_VERB) return particle-1; // MUST be inseparate and is
			else if (!flags) return particle-1; // can be both, so is ok.
			next = particle+2;
		}
	}

	// we now assume separated particles from verb
	unsigned int at = particle - 1; // skip over noun-pronoun
	while (--at)
	{
		if (posValues[at] & VERB_TENSES) // presumed  - but wont handle dual noun like "bank teller"
		{
			break;
		}
	}
	if (!at) return 0; // not found anything

	// not immediately after "you make a fuss *over me" and no noun after
	// is it a particle phrase possible?
	verb = GetInfinitive(wordStarts[at],false);
	if (!verb) return 0;	

	sprintf(word,"%s_%s",verb,wordStarts[particle]); // look at 2-word particle
	D = FindWord(word,0,LOWERCASE_LOOKUP);
	if (!D || !(D->systemFlags & PHRASAL_VERB))  // try 3 word phrasals
	{
		sprintf(word,"%s_%s_%s",verb,wordStarts[particle-1],wordStarts[particle]); // look at 3-word particle
		D = FindWord(word,0,LOWERCASE_LOOKUP);
		if (!D || !(D->systemFlags & PHRASAL_VERB)) return 0; // is not phrasal
		if (posValues[particle-2] & (PRONOUN_BITS)) pronounBefore = true;
		if (posValues[particle-2] & NOUN_BITS) objectBefore = true;
	}

	if (D->systemFlags & VERB_TAKES_GERUND) return (posValues[particle+1] & NOUN_GERUND) ? at : 0; // "keep on singing"

	// never has both separable and non-separable on it at same time
	if ( (D->systemFlags & (SEPARABLE_PHRASAL_VERB | INSEPARABLE_PHRASAL_VERB)) == ( SEPARABLE_PHRASAL_VERB |  INSEPARABLE_PHRASAL_VERB))
	{
		ReportBug("%s has both separable and nonseparable\r\n",D->word);
	}

	if (D->systemFlags & INSEPARABLE_PHRASAL_VERB && (at-particle) != 1) return 0; // must not be separated EVER
	if (D->systemFlags & MUST_BE_SEPARATE_PHRASAL_VERB && (at-particle) == 1) return 0; // must be separated ALWAYS

	if (D->systemFlags & VERB_DIRECTOBJECT) // is there an object   after it? It can use one
	{
		if (objectBefore || objectAfter || pronounBefore) return at; // BUG doesnt handle complex noun phrases
		return 0;
	}
	else if (D->systemFlags & VERB_NOOBJECT) // wants no object
	{
		return 0; // seems there is an object there 
	}
	// cannot have pronoun object AFTER phrasal as the object: "I switched *on it" not allowed - must always be embedded
	if (pronounAfter) return 0;

	return at;
}

static int TestTag(int &i, int control, uint64 bits,int direction,bool tracex)
{
	bool notflag = false;
	static bool endwrap = false;	// allow endwrap ONLY immediately after successful end test going forward
	if (control & NOTCONTROL) notflag = true;
	bool skip = (control & SKIP) ? true : false;
	control >>= CTRL_SHIFT; // get the op
	if ( i <= 0 || (unsigned int)i > endSentence) 
	{
		if (skip) return false;	// cannot stay any longer
		// endwrap allowed
		if ((unsigned int) i > endSentence && endwrap && direction == 1) i = startSentence;
		else if ( i < (int)startSentence  && endwrap && direction == -1) i = endSentence;
		else if (control == ISQUESTION) {;}
		else if (control == PRIORCANONICAL) i = endSentence;
		else return (notflag) ? true : false;
	}
	endwrap = false;
	int answer = false;
	switch(control)
	{
		case HAS: // the bit is among those present of which there are at least 2
			answer = (posValues[i] & bits) != 0;
			break;
		case IS: // The bit is what is given --  If word is ambiguous then if fails both IS and !IS.
			if (bitCounts[i] == 1) // no ambiguity
			{
				if (posValues[i] & bits) answer = true;
			}
			else notflag = false;  // ambiguous value will be false always
			break;
		case POSITION: // FIRST LAST START END  where quotes can be ignored
			if ( bits == 1) 
			{
				if (i == (int)startSentence) answer = true;
				else if ( i == (int) (startSentence+1) && *wordStarts[startSentence] == '"') answer = true;
				if (answer & !notflag && direction == -1) endwrap = true;	// allowed to test wrap around end
			}
			else if ( bits > 100 && (unsigned int)i == endSentence) 
			{
				if (i == (int)endSentence) answer = true;
				else if ( i == (int)(endSentence-1) && *wordStarts[endSentence] == '"') answer = true;
				if (answer && !notflag && direction == 1) endwrap = true;	// allowed to test wrap around end
			}
			break;
		case ORIGINALVALUE:
			if  (allOriginalWordBits[i] & bits) answer = true;
			break;
		case ENDSWITH:
			{
				WORDP D = Meaning2Word((int)bits);
				int wordlen = strlen(wordStarts[i]) - D->length;
				answer = !stricmp(wordStarts[i] + wordlen,D->word);
			}
			break;
		case HASPROPERTY: // system properties of lower case (never care about upper case properties)
			answer = (lcSysFlags[i] & bits) != 0; 
			break;
		case HASALLPROPERTIES: // system properties of lower case (never care about upper case properties)
			answer = (lcSysFlags[i] & bits) == bits; 
			break;
		case HASCANONICALPROPERTY:
			answer = (canSysFlags[i] & bits) != 0;
			break;
		case ISABSTRACT:
			if (allOriginalWordBits[i] & NOUN_ABSTRACT) answer = true;
			break;
		case ISORIGINAL: // original word is this
		{
			WORDP X =  Meaning2Word((int)bits);
			answer = !stricmp(wordStarts[i],X->word);
			if (tracex) Log(STDUSERLOG," vs %s ",X->word);
		}
			break;
		case ISQWORD:
			if (originalLower[i] && originalLower[i]->properties & QWORD) answer = true;
			break;
		case ISCANONICAL: // canonical form of word is this (we never have canonical on upper that we care about)
		{
			WORDP X =  Meaning2Word((int)bits);
			answer =  canonicalLower[i] == X;
			if (tracex) 
				Log(STDUSERLOG," vs %s ",X->word);
		}
			break;
		case HAS2VERBS: // GLOBAL    subord conjunct will require it
			{
				int n = 0;
				for (unsigned int i = startSentence; i <= endSentence; ++i)
				{
					if (posValues[i] & VERB_TENSES) ++n;
				}
				if (n > 1) answer = NO_FIELD_INCREMENT;
			}
			break;
		case PRIORCANONICAL:
			{
				WORDP D = Meaning2Word((int)bits);
				unsigned int x = i;
				while (--x > 0)
				{
					if (canonicalLower[x] == D) 
					{
						answer = true;
						break;
					}
				}
			}
			break;
		case PROBABLEPARTICLE:
			{
				WORDP D = NULL;
				if (!stricmp(wordStarts[i],"to") && (posValues[i+1] & NOUN_INFINITIVE)) answer = false; // probably to infinitive
				else answer = PriorPhrasalVerb(i,D) ? true : false;
				break;
			}
		case POSSIBLETOLESSVERB: // allows noun infinitive
			{
				unsigned int verb = i;
				bool nonadverb = false;
				while (--verb >= startSentence)
				{
					if (posValues[verb] & VERB_TENSES)
					{
						if ( canSysFlags[verb] & VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE )
						{
							answer = true;
							break;
						}
					}
					else if (posValues[verb] & TO_INFINITIVE && !nonadverb)
					{
						answer = true;
						break;
					}
					if (!(posValues[verb] & ADVERB_BITS)) nonadverb = true;
				}
				break;
			}
		case HOWSTART:
			{
				unsigned int x = startSentence;
				if (*wordStarts[x] == '"') ++x;
				answer = !stricmp(wordStarts[x],"how");
			}
			break;
		case CANONLYBE: // has no bits we didn't mention
			if ((posValues[i] & (-1 ^ bits)) == 0) answer = true;
			break;
		case ISMEMBER: // direct member...
			{
				WORDP D = Meaning2Word((int)bits);
				FACT* F = (D) ? GetObjectHead(D) : NULL;
				MEANING M = MakeMeaning(canonicalLower[i]);
				while (F)
				{
					if (F->subject == M)
					{
						answer = true;
						break;
					}
					F = GetObjectNext(F);
				}
			}
			break;
		case INCLUDE:
			answer = posValues[i] & bits && posValues[i] & (-1LL ^ bits); // there are bits OTHER than what we are testing for
			break;
		case POSSIBLEUNDETERMINEDNOUN:
			if (allOriginalWordBits[i] & (NOUN_MASS|NOUN_NODETERMINER)) answer = true;
			break;
		case PARSEMARK:
			if (parseFlags[i] & bits) answer = true;
			break;
		case NONEAFTER: // find any of these later? dont negate.. only meaningful if NOTHING can be found
			{
				answer = true;
				unsigned int x = i;
				while (++x <= endSentence)
				{
					if (posValues[x] & bits) 
					{
						answer = false;
						break;
					}
				}
			}
			break;
		case NONEBEFORE: // find any of these earier? dont negate.. only meaningful if NOTHING can be found
			{
				answer = true;
				unsigned int x = i;
				while (--x > 0)
				{
					if (posValues[x] & bits) 
					{
						answer = false;
						break;
					}
				}
			}
			break;
		case ISQUESTION: // GLOBAL   COULD this be a question (does not insure that it is, only that it could be)
			{
				answer = false;
				if (bits & AUXQUESTION && posValues[startSentence] & AUX_VERB_BITS) answer = NO_FIELD_INCREMENT;	// MAY BE A QUESTION started by aux "did you go"
				if (bits & QWORDQUESTION && allOriginalWordBits[startSentence] & QWORD) answer = NO_FIELD_INCREMENT;	// may be a question started with a question word "how are you"
				else if (bits & QWORDQUESTION && allOriginalWordBits[startSentence+1] & QWORD && allOriginalWordBits[startSentence] & (PREPOSITION|ADVERB_BITS)) answer = NO_FIELD_INCREMENT;	// may be a question started with a question word "for whom  are you"
			}
			break;
		default: // unknown control
			return UNKNOWN_CONSTRAINT;
	}
	if (notflag) answer = !answer;
	return answer;
}

static  char* BitLabels(uint64 properties)
{
	static char buffer[MAX_WORD_SIZE];
	*buffer = 0;
	char* ptr = buffer;
	uint64 bit = START_BIT;		//   starting bit
	while (properties)
	{
		if (properties & bit)
		{
			properties ^= bit;
			char* label = FindNameByValue(bit);
			sprintf(ptr,"%s+",label);
			ptr += strlen(ptr);
		}
		bit >>= 1;
	}
	if (ptr > buffer) *--ptr = 0;
	return buffer;
}

static bool ApplyRulesToWord(unsigned int j,bool & changed,int guessAllowed)
{
	bool keep;
	int offset;
	int start;
	int direction;
	uint64* data;
	bool tracex;
	char* word = wordStarts[j];
	//  do rules to reduce flags
	for (unsigned int i = 0; i < tagRuleCount; ++i)
	{
		data = tags + (i * MAX_TAG_FIELDS);
		uint64 basic = *data;

		// reasons this rule doesnt apply
		if (basic & PART2_BIT) continue; // skip 2nd part
		
		unsigned int resultOffset = (basic >> RESULT_SHIFT) & 0x0003; 
		uint64 resultBits = data[resultOffset] & PATTERN_BITS;	// we will want to change THIS FIELD
		if (!(posValues[j] & resultBits) || !(posValues[j] & (-1LL ^ resultBits)) ) continue;		// cannot help  this- no bits in common or all bits would be kept or erased
		if (basic & GUESS_BIT) // will we consider guesses
		{
			// does rule require guessing and is it allowed --  GUESS=001  GUESS1=011 GUESS2=101  GUESS3=111
			if (!guessAllowed)  continue; // ignore all guesses 
			if (guessAllowed == 1) // GUESS1 
			{
				if (data[3] & GUESS_BIT) continue;	// guess2 and guess3 rejected
			}
			else if (guessAllowed == 2) // guess2 or guess1 allowed
			{
				if (data[3] & GUESS_BIT && data[2] & GUESS_BIT) continue; // reject guess3
			}
		}

		char* comment = (comments) ? comments[i] : NULL;
		tracex = (data[3] & TRACE_BIT) && (trace & TRACE_POS); 
		if (tracex) 
			Log(STDUSERLOG,"   => Trace rule:%d   %s (%d) %s \r\n",i,word,j,comment);
		
		unsigned int limit = (data[3] & PART1_BIT) ? (MAX_TAG_FIELDS * 2) : MAX_TAG_FIELDS;
		offset = ((data[1] >> OFFSET_SHIFT) & 0x00000007) - 3; // where to start pattern match relative to current field (3 bits)
		keep =  (data[1] & KEEP_BIT) != 0;
		direction =  (data[2] & REVERSE_BIT) ? -1 : 1;
		offset *= direction;	
		start = j + offset - direction;
		unsigned int k;
		int result;
		for (k = 0; k < limit; ++k) // test rule fields
		{
			uint64 field = data[k];
			unsigned int control = (unsigned int) ( (field >> CONTROL_SHIFT) &0x01ff);
			if (!(control & STAY)) start += direction;
			if (k == resultOffset) result = 1; // the result include is known to match if we are here
			else if (control) // if we care
			{
				if (control & SKIP) // check for any number of matches until fails.
				{
					result = TestTag(start,control,field & PATTERN_BITS,direction,tracex); // might change start to end or start of PREPOSITIONAL_PHRASE if skipping
					if (tracex) Log(STDUSERLOG,"    =%d  SKIP %s(%d) op:%s result:%d\r\n",k,wordStarts[start],start, OpDecode(field),result);
					if ( result == UNKNOWN_CONSTRAINT)
					{
						ReportBug("unknown control %d) %s Rule #%d %s\r\n",j,word,i,comment)
						result = false;
					}
					while (result) 
					{
						start += direction;
						result = TestTag(start,control,field & PATTERN_BITS,direction,tracex);
						if (tracex ) Log(STDUSERLOG,"    =%d  SKIP %s(%d)  result:%d @%s(%d)\r\n",k,wordStarts[start],start,result,wordStarts[start],start);
					}
					start -= direction; // ends on non-skip, back up so will see again
				}
				else if ((control >> CTRL_SHIFT) == RESETLOCATION)  // reset to include offset
				{
					if (field & PATTERN_BITS) direction = - direction; // flip scan direction
					start = j; // be back on the word as field
					if (tracex) Log(STDUSERLOG,"    =%d  RESETLOCATION %d\r\n",k,direction);
				}
				else
				{
					result = TestTag(start,control,field & PATTERN_BITS,direction,tracex); // might change start to end or start of PREPOSITIONAL_PHRASE if skipping
					if (tracex) Log(STDUSERLOG,"    =%d  %s(%d) op:%s result:%d\r\n",k,wordStarts[start],start,OpDecode(field),result);
					if (result == UNKNOWN_CONSTRAINT)
					{
						ReportBug("unknown control1 %d) %s Rule #%d %s\r\n",j,word,i,comment)
						result = false;
					}
					if (result == NO_FIELD_INCREMENT) start -= direction; // DONT MOVE
					if (!result) break;	// fails to match // if matches, move along. If not, just skip over this (used to align commas for example)
				}
			}
		} // end test on fields

		// pattern matched, apply change if we can
		if (k >= limit) 
		{
			if (tracex) Log(STDUSERLOG,"   <= matched\r\n");
			uint64 old = posValues[j] & ((keep) ? resultBits : ( -1LL ^ resultBits));
			if (trace & TRACE_POS && (prepareMode == POS_MODE || prepareMode == POSVERIFY_MODE || prepareMode == PENN_MODE))
			{
				char* which = (keep) ? (char*) "KEEP" : (char*)"DISCARD";
				uint64 properties = old; // old is what is kept
				if (!keep) properties = posValues[j] - old;	// what is discarded
				if (!properties) ReportBug("bad result in pos tag %s\r\n",comment) // SHOULDNT HAPPEN
					
				char* name = FindNameByValue(resultBits);
				if (!name) name = BitLabels(properties);
				Log(STDUSERLOG," %d) %s: %s %s Rule #%d %s\r\n",j,word,which,name,i,comment+1);
				char buff[MAX_WORD_SIZE];
				*buff = 0;
				PosBits(old,buff);
				Log(STDUSERLOG,"   now %s\r\n",buff);
			}

			// make the change
			posValues[j] = old;
			bitCounts[j] = BitCount(old);
			changed = true;
			if (bitCounts[j] == 1)
			{
				--ambiguous;
				return true;	// we now know
			}
		} // end result change k > limit
		else if (tracex) Log(STDUSERLOG,"   <= unmatched\r\n"); // pattern failed to match
	} // end loop on rules 
	return false;
}

static void SetIdiom(unsigned int at, unsigned end)
{
	posValues[at] = IDIOM;
	allOriginalWordBits[at] = IDIOM;
	bitCounts[at] = 1;
	crossReference[at] = (unsigned char)end;
}

static void WordIdioms(bool &changed)
{
	// "a little" can be an adverb if not preceeding a noun. in front of adjective, prep or other, it is adverb

	// manage 2-5-word idioms looking backwards - adverbs, preps, conjunction subordinate
	for (unsigned int i = startSentence; i <= endSentence; ++i)
	{
		char word[MAX_WORD_SIZE];
		WORDP D = NULL;
		unsigned int diff = i - startSentence;
		char tags[MAX_WORD_SIZE];
		int tagged = 0;
		// detect longest possible idioms first - in adverb/conjunction conflicts, try to prove out status
		if (diff > 3) // 5 word idioms
		{
			sprintf(word,"%s_%s_%s_%s_%s",wordStarts[i-4],wordStarts[i-3],wordStarts[i-2],wordStarts[i-1],wordStarts[i]);
			D = FindWord(word,0,LOWERCASE_LOOKUP);
			if (!D){;}
			else if (D->properties & (PREPOSITION|ADVERB_NORMAL|CONJUNCTION_SUBORDINATE|CONJUNCTION_COORDINATE) || D->systemFlags & CONDITIONAL_ADVERB_IDIOM)
			{
				if (!(D->systemFlags & CONDITIONAL_ADVERB_IDIOM))
				{
					if ((i-4)   == endSentence) posValues[i] = ADVERB_NORMAL;
					else if (D->properties & CONJUNCTION_BITS && !(posValues[i+1] & SIGNS_OF_NOUN_BITS) &&  !(posValues[i+2] & SIGNS_OF_NOUN_BITS) ) posValues[i] = ADVERB_NORMAL;
					else if (D->properties & CONJUNCTION_BITS && posValues[i+1] & SIGNS_OF_NOUN_BITS) posValues[i] = D->properties & (PREPOSITION|CONJUNCTION_BITS);
					else posValues[i] = D->properties & (PREPOSITION|ADVERB_NORMAL|CONJUNCTION_SUBORDINATE);
				}
				else if (!(posValues[i+1] & (TO_INFINITIVE|NOUN_BITS))) posValues[i] = ADVERB_NORMAL;	// "a lot to process" 
				else if (posValues[i+1] & ADJECTIVE_BITS && posValues[i+2] & (ADJECTIVE_BITS|NOUN_BITS)) posValues[i] = ADVERB_NORMAL;	// could be noun OR adjective, we'll guess it is adjecti
				else continue;

				tagged = 5;
			}
		}

		if (!tagged && diff > 2) // 4 word idioms
		{
			sprintf(word,"%s_%s_%s_%s",wordStarts[i-3],wordStarts[i-2],wordStarts[i-1],wordStarts[i]);
			D = FindWord(word,0,LOWERCASE_LOOKUP);
			if (!D){;}
			else if (D->properties & (PREPOSITION|ADVERB_NORMAL|CONJUNCTION_SUBORDINATE|CONJUNCTION_COORDINATE) || D->systemFlags & CONDITIONAL_ADVERB_IDIOM)
			{
				if (!(D->systemFlags & CONDITIONAL_ADVERB_IDIOM))	
				{
					if ((i-3)   == endSentence) posValues[i] = ADVERB_NORMAL;
					else if (D->properties & CONJUNCTION_BITS && !(posValues[i+1] & (NOUN_BITS|PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS)) &&  !(posValues[i+2] & (NOUN_BITS|PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS)) ) posValues[i] = ADVERB_NORMAL;
					else if (D->properties & CONJUNCTION_BITS && posValues[i+1] & (NOUN_BITS|PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS)) posValues[i] = D->properties & (PREPOSITION|CONJUNCTION_BITS);
					else posValues[i] = D->properties & (PREPOSITION|ADVERB_NORMAL|CONJUNCTION_SUBORDINATE);
				}
				else if (!(posValues[i+1] & (TO_INFINITIVE|NOUN_BITS))) posValues[i] = ADVERB_NORMAL;	// "a lot to process" 
				else if (posValues[i+1] & ADJECTIVE_BITS && posValues[i+2] & (ADJECTIVE_BITS|NOUN_BITS)) posValues[i] = ADVERB_NORMAL;	// could be noun OR adjective, we'll guess it is adjecti
				else continue;

				tagged = 4;
			}
		}

		if (!tagged && diff > 1) // 3 word idioms
		{
			sprintf(word,"%s_%s_%s",wordStarts[i-2],wordStarts[i-1],wordStarts[i]);
			D = FindWord(word,0,LOWERCASE_LOOKUP);
			if (!D){;}
			else if (D->properties & (PREPOSITION|ADVERB_NORMAL|CONJUNCTION_SUBORDINATE|CONJUNCTION_COORDINATE) || D->systemFlags & CONDITIONAL_ADVERB_IDIOM)
			{
				// can it be a brief prep phrase: "for a while"
				if (posValues[i-2] & PREPOSITION && posValues[i-1] & DETERMINER && posValues[i] & NOUN_BITS) // BUG
				{
					LimitValues(i-2,PREPOSITION,"prep phrase 3-wd idiom",changed);
					LimitValues(i-1,DETERMINER,"prep phrase  3-wd idiom",changed);
					LimitValues(i,NOUN_BITS,"prep phrase  3-wd idiom",changed);
					continue;
				}

				if (!(D->systemFlags & CONDITIONAL_ADVERB_IDIOM))	
				{
					if ((i-2)   == endSentence) posValues[i] = ADVERB_NORMAL;
					else if (D->properties & CONJUNCTION_BITS && !(posValues[i+1] & (NOUN_BITS|PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS)) &&  !(posValues[i+2] & (NOUN_BITS|PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS)) ) posValues[i] = ADVERB_NORMAL;
					else if (D->properties & CONJUNCTION_BITS && posValues[i+1] & (NOUN_BITS|PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS)) posValues[i] = D->properties & (PREPOSITION|CONJUNCTION_BITS);
					else posValues[i] = D->properties & (PREPOSITION|ADVERB_NORMAL|CONJUNCTION_SUBORDINATE);
				}
				else if (!(posValues[i+1] & (TO_INFINITIVE|NOUN_BITS))) posValues[i] = ADVERB_NORMAL;	// "a lot to process" 
				else if (posValues[i+1] & ADJECTIVE_BITS && posValues[i+2] & (ADJECTIVE_BITS|NOUN_BITS)) posValues[i] = ADVERB_NORMAL;	// could be noun OR adjective, we'll guess it is adjecti
				else continue;

				tagged = 3;
			}
		}

		if (!tagged && diff > 0) // 2 word idioms
		{
			sprintf(word,"%s_%s",wordStarts[i-1],wordStarts[i]);
			D = FindWord(word,0,LOWERCASE_LOOKUP);
			if (!D){;}
			else if (D->properties & (PREPOSITION|ADVERB_NORMAL|CONJUNCTION_SUBORDINATE|CONJUNCTION_COORDINATE) || D->systemFlags & CONDITIONAL_ADVERB_IDIOM)
			{
				if (!(D->systemFlags & CONDITIONAL_ADVERB_IDIOM))	
				{
					if ((i-1)  == endSentence) posValues[i] = ADVERB_NORMAL;
					else if (D->properties & CONJUNCTION_BITS && !(posValues[i+1] & (NOUN_BITS|PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS)) &&  !(posValues[i+2] & (NOUN_BITS|PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS)) ) posValues[i] = ADVERB_NORMAL;
					else if (D->properties & CONJUNCTION_BITS && posValues[i+1] & (NOUN_BITS|PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS)) posValues[i] = D->properties & (PREPOSITION|CONJUNCTION_BITS);
					else posValues[i] = D->properties & (PREPOSITION|ADVERB_NORMAL|CONJUNCTION_SUBORDINATE);
				}
				else if (!(posValues[i+1] & (TO_INFINITIVE|NOUN_BITS))) posValues[i] = ADVERB_NORMAL;	// "a lot to process" 
				else if (posValues[i+1] & ADJECTIVE_BITS && posValues[i+2] & (ADJECTIVE_BITS|NOUN_BITS)) posValues[i] = ADVERB_NORMAL;	// could be noun OR adjective, we'll guess it is adjecti
				else continue;

				tagged = 2;
			}
		}
		if (tagged)
		{
			allOriginalWordBits[i] = D->properties & TAG_TEST;
			canSysFlags[i] = D->systemFlags;
			*tags = 0;
			Tags(tags,i);
			if (trace & TRACE_POS)  Log(STDUSERLOG,"Word Idiom %d:%s (%s)\r\n",tagged,word,tags);
			while (--tagged) SetIdiom(i-tagged,i); 
			bitCounts[i] = BitCount(posValues[i]);
		}
	}
}

bool ApplyRules() // get the set of all possible tags.
{
	if (!tags) return true;
	if (trace & TRACE_POS && prepareMode != PREPARE_MODE) Log(STDUSERLOG,"%s",DumpAnalysis(startSentence,endSentence,posValues,"\r\nOriginal POS: ",true,true));
	roleIndex = 0;
	ambiguous = 1;
	int guessAllowed = 0;
	unsigned int pass = 0;
	unsigned int limit = 50;
	bool resolved = false;
	bool parsed = false;
	bool changed = true;
	while (changed && ambiguous) // while we have something different and something not resolved
	{
		parsed = false;
		ambiguous = 0;
		for (unsigned int i =  startSentence; i <= endSentence; ++i) if (bitCounts[i] != 1) ++ambiguous;
		++pass;
		changed = false;
		if (--limit == 0) 
		{
			ReportBug("ApplyRules overran\r\n")
			return false;
		}

		if (trace & TRACE_POS) 
			Log(STDUSERLOG,"\r\n------------- POS rules pass %d: \r\n",pass);

		// test all items in the sentence
		for (unsigned int wordIndex =  startSentence; wordIndex <= endSentence; ++wordIndex)
		{
			if (ignoreWord[wordIndex]) continue;
			unsigned int j = (reverseWords) ? (endSentence + 1 - wordIndex) : wordIndex; // test from rear of sentence forwards to prove rules are independent
			if (bitCounts[j] != 1)  
				ApplyRulesToWord(j,changed,guessAllowed);
		} // end loop on words
		
		if (ambiguous && trace & TRACE_POS && changed) Log(STDUSERLOG,"\r\n%s",DumpAnalysis(startSentence,endSentence,posValues,"POS",false,false));
		
		if (!changed && ambiguous) // no more rules changed anything and we still need help
		{
			if (trace & TRACE_POS) Log(STDUSERLOG," *** enable GUESS%d\r\n",guessAllowed);
			if (++guessAllowed < 3) changed = true; 
			
#ifndef DISCARDPARSER
			bool modified = false;
			English_ParseSentence(resolved,modified);
			if (modified) --guessAllowed; // dont advance more radical notions yet
			parsed = true;
			if (!resolved && changed) ambiguous = 1; // force it to continue
			else if (!changed && ambiguous) break; // nothing else we can do, quit
#endif
		}
	}
#ifndef DISCARDPARSER
	bool modified = false;
	if (!parsed)  English_ParseSentence(resolved,modified); 
#endif
	return resolved;
}

static void Showit(char* buffer, const char* what,uint64 bits)
{
	if (bits) strcat(buffer,"+");
	strcat(buffer,what);
}

static void ParseFlags(char* buffer, unsigned int i)
{
#ifndef DISCARDPARSER
	if (parseFlags[i] & FACTITIVE_ADJECTIVE_VERB) strcat(buffer,"factitive_adjective_verb ");
	if (parseFlags[i] & FACTITIVE_NOUN_VERB) strcat(buffer,"factitive_noun_verb ");
	if (parseFlags[i] & QUOTEABLE_VERB) strcat(buffer,"quotable_verb ");
	if (parseFlags[i] & ADJECTIVE_TAKING_NOUN_INFINITIVE) strcat(buffer,"adjective_complement_verb ");
	if (parseFlags[i] & OMITTABLE_THAT_VERB) strcat(buffer,"omittable_that_verb ");
	if (parseFlags[i] & NEGATIVE_ADVERB_STARTER) strcat(buffer,"negative_adverb_starter ");
	if (parseFlags[i] & NON_COMPLEMENT_ADJECTIVE) strcat(buffer,"non_complement_adjective ");
	if (parseFlags[i] & CONJUNCTIONS_OF_TIME) strcat(buffer,"conjunction_of_time ");
	if (parseFlags[i] & CONJUNCTIONS_OF_SPACE) strcat(buffer,"conjunction_of_space ");
	if (parseFlags[i] & CONJUNCTIONS_OF_ADVERB) strcat(buffer,"conjunction_of_adverb ");
	if (parseFlags[i] & NONDESCRIPTIVE_ADJECTIVE) strcat(buffer,"nondescriptive_adjective ");

	if (posValues[i] & VERB_TENSES) 
	{
		if (canSysFlags[i] & VERB_NOOBJECT) strcat(buffer,"noobject "); // 1 Something ----s   2 Somebody ----s
		if (canSysFlags[i] & VERB_INDIRECTOBJECT) strcat(buffer,"indirect ");
		if (canSysFlags[i] & VERB_DIRECTOBJECT) strcat(buffer,"direct "); // 8 Somebody ----s something  9 Somebody ----s somebody 20PP  Somebody ----s somebody  21PP Somebody ----s something 10 Something ----s somebody  11 Something ----s something
		if (canSysFlags[i] & VERB_TAKES_ADJECTIVE) strcat(buffer,"adjective-object "); // 7    Somebody ----s Adjective
		if (canSysFlags[i] & VERB_TAKES_TOINFINITIVE) strcat(buffer,"direct-toinfinitive "); // proto 28 "Somebody ----s to INFINITIVE"   "we agreed to plan"
		if (canSysFlags[i] & VERB_TAKES_VERBINFINITIVE) strcat(buffer,"direct-infinitive "); // proto 32, 35 "Somebody ----s INFINITIVE"   "Something ----s INFINITIVE"
		if (canSysFlags[i] & VERB_TAKES_INDIRECT_THEN_TOINFINITIVE) strcat(buffer,"direct-iobj-toinfinitive "); // proto 24  --  verbs taking to infinitive after object: "Somebody ----s somebody to INFINITIVE"  "I advise you *to go"
		if (canSysFlags[i] & VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE) strcat(buffer,"direct-iobj-verbinfinitive "); // proto 25  -  verbs that take direct infinitive after object  "Somebody ----s somebody INFINITIVE"  "i heard her sing"
		if (canSysFlags[i] & VERB_TAKES_GERUND) strcat(buffer,"gerundobj "); // 33    Somebody ----s VERB-ing
#ifdef JUNK
//x3    It is ----ing		INTRANS
//x?4    Something is ----ing PP	INTRANS
x?5    Something ----s something Adjective/Noun  (does this mean modified noun or adj?)  ADJOBJECT
x?6    Something ----s Adjective/Noun  ADJOBJECT
12    Something ----s to somebody 
13    Somebody ----s on something 
x14    Somebody ----s somebody something TRANS  (dual)
15    Somebody ----s something to somebody 
16    Somebody ----s something from somebody 
17    Somebody ----s somebody with something 
18    Somebody ----s somebody of something 
19    Somebody ----s something on somebody 
22    Somebody ----s PP 
x23    Somebody s (body part) ----s INTRANS
26    Somebody ----s that CLAUSE 
27    Somebody ----s to somebody 
29    Somebody ----s whether INFINITIVE 
30    Somebody ----s somebody into V-ing something 
31    Somebody ----s something with something 
34    It ----s that CLAUSE 
#endif	
	}
	if (posValues[i] & (NOUN_BITS|PRONOUN_BITS))
	{
		if (canSysFlags[i] & TAKES_POSTPOSITIVE_ADJECTIVE) strcat(buffer,"takepostposadj ");
		if (canSysFlags[i] & ORDINAL) strcat(buffer,"ordinal ");
	}
	if (posValues[i] & ADJECTIVE_BITS)
	{
		if (canSysFlags[i] & COMMON_PARTICIPLE_VERB) strcat(buffer,"commonparticipleverb ");
		if (canSysFlags[i] & ADJECTIVE_POSTPOSITIVE) strcat(buffer,"adjpostpositive ");
	}
	if (posValues[i] & ADVERB_BITS)
	{
		if (canSysFlags[i] & EXTENT_ADVERB) strcat(buffer,"extendadv ");
	}
	if (posValues[i] & CONJUNCTION_SUBORDINATE)
	{
		if (canSysFlags[i] & CONJUNCT_SUBORD_NOUN) strcat(buffer,"subordnoun ");
	}
#endif
}

static void Tags(char* buffer, unsigned int i)
{
	*buffer = 0;
	WORDP D = (originalLower[i]) ? originalLower[i] : originalUpper[i];
	uint64 tie = D->systemFlags & ESSENTIAL_FLAGS; // tie break values
#ifndef DISCARDPARSER
	if (bitCounts[i] <= 1) tie = 0;
#endif
	uint64 type = posValues[i];
	if (type & IDIOM) strcat(buffer,"Idiom ");
	if (type & PUNCTUATION) strcat(buffer,"Punctuation ");
	if (type & PAREN) strcat(buffer,"Parenthesis ");
	if (type & COMMA) strcat(buffer,"Comma ");
	if (type & QUOTE) strcat(buffer,"Quote ");
	if (type & POSSESSIVE) strcat(buffer,"Possessive ");
	if (type & FOREIGN_WORD) strcat(buffer,"Foreign_word ");
	if (type & (NOUN | NOUN_BITS|NOUN_INFINITIVE)) 
	{
		if (type & NOUN_PLURAL) Showit(buffer,"Noun_plural ",tie&NOUN);
		if (type & NOUN_GERUND) Showit(buffer,"Noun_gerund ",tie&VERB);
		if (type & NOUN_INFINITIVE) Showit(buffer,"Noun_infinitive ",tie&VERB);
		if (type & NOUN_SINGULAR) Showit(buffer,"Noun_singular ",tie&NOUN);
		if (type & NOUN_PROPER_SINGULAR) Showit(buffer,"Noun_proper_singular ",tie&NOUN);
		if (type & NOUN_PROPER_PLURAL) Showit(buffer,"Noun_proper_plural ",tie&NOUN);
		if (type & NOUN_NUMBER) Showit(buffer,"Noun_number ",tie&NOUN);
		if (!(type & (NOUN_BITS|NOUN_INFINITIVE))) 
			Showit(buffer,"Noun_unknown ",tie&NOUN);
	}
	if (type & (AUX_VERB | AUX_VERB_BITS)) 
	{
		if (type & AUX_VERB_FUTURE) strcat(buffer,"Aux_verb_future ");
		if (type & AUX_VERB_PAST) strcat(buffer,"Aux_verb_past ");
		if (type & AUX_VERB_PRESENT) strcat(buffer,"Aux_verb_present ");
		if (type & AUX_BE && D->properties & VERB_INFINITIVE) strcat(buffer,"Aux_be_infinitive ");
		if (type & AUX_BE && D->properties & VERB_PAST_PARTICIPLE) strcat(buffer,"Aux_be_pastparticiple ");
		if (type & AUX_BE && D->properties & VERB_PRESENT_PARTICIPLE) strcat(buffer,"Aux_be_presentparticiple ");
		if (type & AUX_BE && D->properties & VERB_PRESENT) strcat(buffer,"Aux_be_present ");
		if (type & AUX_BE && D->properties & VERB_PRESENT_3PS) strcat(buffer,"Aux_be_present_3ps ");
		if (type & AUX_BE && D->properties & VERB_PAST) strcat(buffer,"Aux_be_past ");
		if (type & AUX_HAVE && D->properties & VERB_PRESENT_3PS) strcat(buffer,"Aux_have_present_3ps ");
		if (type & AUX_HAVE && D->properties & VERB_PRESENT && !firstAux && i > 1 && stricmp(wordStarts[i-1],"to")) strcat(buffer,"Aux_have_present "); //  have in first position will be conjugated
		else if (type & AUX_HAVE && D->properties & VERB_INFINITIVE) strcat(buffer,"Aux_have_infinitive "); 
		if (type & AUX_HAVE && D->properties & VERB_PAST) strcat(buffer,"Aux_have_past ");
		if (type & AUX_DO && D->properties & VERB_PAST) strcat(buffer,"Aux_do_past ");
		if (type & AUX_DO && D->properties & VERB_PRESENT) strcat(buffer,"Aux_do_present ");
		if (type & AUX_DO && D->properties & VERB_PRESENT_3PS) strcat(buffer,"Aux_do_present_3ps ");
		if (!(type & AUX_VERB_BITS)) strcat(buffer,"Aux_verb_unknown ");
		firstAux = D;
	}
	if (type & (VERB|VERB_TENSES)) 
	{
		if (type & VERB_INFINITIVE) Showit(buffer,"Verb_infinitive ",tie&VERB);
		if (type & VERB_PRESENT_PARTICIPLE) Showit(buffer,"Verb_present_participle ",tie&VERB);
		if (type & VERB_PAST) Showit(buffer,"Verb_past ",tie&VERB);
		if (type & VERB_PAST_PARTICIPLE) Showit(buffer,"Verb_past_participle ",tie&VERB);
		if (type & VERB_PRESENT) Showit(buffer,"Verb_present ",tie&VERB);
		if (type & VERB_PRESENT_3PS) Showit(buffer,"Verb_present_3ps ",tie&VERB);
		if (!(type & VERB_TENSES)) Showit(buffer,"Verb_unknown ",tie&VERB);
	}
	if (type & PARTICLE) strcat(buffer,"Particle ");
	if (type & INTERJECTION) strcat(buffer,"Interjection ");
	if (type & (ADJECTIVE|ADJECTIVE_BITS))
	{
		if (type & ADJECTIVE_NOUN) Showit(buffer,"Adjective_noun ",tie&NOUN); // can be dual kind of adjective
		if (type & ADJECTIVE_PARTICIPLE) Showit(buffer,"Adjective_participle ",tie&VERB); // can be dual kind of adjective
		if (type & ADJECTIVE_NUMBER) Showit(buffer,"Adjective_number ",tie&ADJECTIVE);
		if (type & ADJECTIVE_NORMAL) 
		{
			if (lcSysFlags[i] & MORE_FORM) Showit(buffer,"Adjective_more ",tie&ADJECTIVE);
			else if (lcSysFlags[i] & MOST_FORM) Showit(buffer,"Adjective_most ",tie&ADJECTIVE);
			else  Showit(buffer,"Adjective_basic ",tie&ADJECTIVE);
		}
		if (!(type & ADJECTIVE_BITS))  Showit(buffer,"Adjective_unknown ",tie&ADJECTIVE);
	}
	if (type & (ADVERB|ADVERB_BITS))
	{
		if (lcSysFlags[i] & MORE_FORM) Showit(buffer,"Adverb_more ",tie&ADVERB);
		else if (lcSysFlags[i] & MOST_FORM) Showit(buffer,"Adverb_most ",tie&ADVERB);
		else Showit(buffer,"Adverb_basic ",tie&ADVERB);
		if (!(type & ADVERB_BITS)) Showit(buffer,"Adverb_unknown ",tie&ADVERB);
	}
	if (type & PREPOSITION) Showit(buffer,"Preposition ",tie&PREPOSITION);
	if (type & TO_INFINITIVE) strcat(buffer,"To_infinitive ");
	if (type & PRONOUN_BITS)
	{
		if (type & PRONOUN_OBJECT) strcat(buffer,"Pronoun_object ");
		if (type & PRONOUN_SUBJECT) strcat(buffer,"Pronoun_subject ");
	}
	if (type & THERE_EXISTENTIAL)  strcat(buffer,"There_existential ");
	if (type & CONJUNCTION_BITS)
	{
		if (type & CONJUNCTION_COORDINATE) Showit(buffer,"Conjunction_coordinate ",0);
		if (type & CONJUNCTION_SUBORDINATE) Showit(buffer,"Conjunction_subordinate ",0);
	}
	if (type & DETERMINER_BITS) 
	{
		if (type & PRONOUN_POSSESSIVE) strcat(buffer,"Pronoun_possessive ");
		if (type & PREDETERMINER) strcat(buffer,"Predeterminer ");
		if (type & DETERMINER) strcat(buffer,"Determiner ");
	}
}

char* DumpAnalysis(unsigned int start, unsigned int end,uint64 flags[MAX_SENTENCE_LENGTH],const char* label,bool original,bool roleDisplay)
{
	static char buffer[BIG_WORD_SIZE];
	*buffer = 0;
	char* ambiguous = "";
	char* faultyparse = "";
	if (!original && tokenFlags & FAULTY_PARSE) faultyparse = "badparse "; // only one of ambiguous (worse) and faultyparse will be true
	sprintf(buffer,"%s%s%s %d words: ",ambiguous,faultyparse,label,end-start+1);
	unsigned int lenpre;
	firstAux = NULL;

	for (unsigned int i = start; i <= end; ++i)
    {
		WORDP D = originalLower[i];
		if (flags[i] & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL) && originalUpper[i]) D = originalUpper[i];

		if (D) strcat(buffer,D->word); // we know it as lower or upper depending
		else  strcat(buffer,wordStarts[i]); // what he gave which we didnt know as lower or upper
		if (original && ignoreWord[i]) 
		{
			strcat(buffer," ( --- )  ");
			continue;
		}
		// canonical
		if (!original) 
		{
			if (canonicalLower[i] && originalLower[i] && !strcmp(canonicalLower[i]->word,originalLower[i]->word)); // same
			else if (canonicalUpper[i] && originalUpper[i] && !strcmp(canonicalUpper[i]->word,originalUpper[i]->word)); // same
			else 
			{
				if (D && !(D->properties & PART_OF_SPEECH) && D->properties & FOREIGN_WORD && canonicalLower[i] && !stricmp(canonicalLower[i]->word,"unknown-word"))  strcat(buffer,"/foreign");
				else if (canonicalLower[i]) 
				{
					strcat(buffer,"/");
					strcat(buffer,canonicalLower[i]->word);
				}
				else if (canonicalUpper[i]) 
				{
					strcat(buffer,"/");
					strcat(buffer,canonicalUpper[i]->word);
				}
				else if (D && D->properties & FOREIGN_WORD)  strcat(buffer,"/foreign");
			}
		}
		strcat(buffer," (");
		lenpre = strlen(buffer);
#ifndef DISCARDPARSER
		if (roleDisplay)
		{
			if (!original && clauses[i] && clauses[i-1] != clauses[i]) strcat(buffer,"<Clause ");
			if (!original && verbals[i] && verbals[i-1] != verbals[i]) strcat(buffer,"<Verbal ");
			if (!original && phrases[i] && phrases[i-1] != phrases[i]) 
			{
				if (posValues[i] & (PREPOSITION|NOUN_BITS|PRONOUN_BITS) || roles[i] & OMITTED_TIME_PREP || i != startSentence || phrases[startSentence] != phrases[endSentence])  
				{
					if (posValues[i] & ABSOLUTE_PHRASE) strcat(buffer,"<AbsolutePhrase ");
					else strcat(buffer,"<Phrase ");  // wont be true on sentence start if wrapped from end  BUT ABSOLUTE will be true
				}
			}
			if (!original && roles[i]) strcat(buffer,GetRole(i));
		}
#endif

		Tags(buffer+strlen(buffer),i); // tags clears

#ifndef DISCARDPARSER
		if (roleDisplay && !original) // show endings of phrases
		{
			if (phrases[i] && ( !(phrases[i+1] & phrases[i]) || i == endSentence) ) // a phrase where next is different 
			{
				if (i != endSentence || !(phrases[startSentence] & phrases[endSentence])) strcat(buffer,"Phrase> "); // if wrapped to start from end of sentence, this wont end here, ends at start
			}
			if (phrases[i] && phrases[i-1] && phrases[i] != phrases[i-1]  ) // a phrase overlapped "I yelled from *inside the house" 
			{
				strcat(buffer,"Phrase> "); // if wrapped to start from end of sentence, this wont end here, ends at start
			}
			if (verbals[i] && verbals[i+1] != verbals[i]) strcat(buffer,"Verbal> ");
			if (clauses[i] && clauses[i+1] != clauses[i]) strcat(buffer,"Clause> ");
		}
#endif
		size_t len = strlen(buffer);
		if (len == lenpre) strcpy(buffer+len,")  ");
		else strcpy(buffer+len-1,")  ");
	}

	strcat(buffer,"\r\n");
	return buffer;
}

void MarkTags(unsigned int i)
{
	size_t len = strlen(wordStarts[i]);
	uint64 bits = finalPosValues[i];
	if (bits & NOUN) bits |= allOriginalWordBits[i] & (NOUN_NODETERMINER | NOUN_MASS | NOUN_HUMAN | NOUN_FIRSTNAME | NOUN_SHE | NOUN_HE | NOUN_THEY | NOUN_TITLE_OF_ADDRESS | NOUN_TITLE_OF_WORK| NOUN_ABSTRACT );
	if (allOriginalWordBits[i] & LOWERCASE_TITLE ) bits |= LOWERCASE_TITLE;

	// mark pos data and supplemental checking on original proper names, because canonical may mess up, like james -->  jam
	uint64 bit = START_BIT;
	for (int j = 63; j >= 0; --j)
	{
		if (bits & bit) 
		{
			if (bit & PRONOUN_BITS)  MarkFacts(MakeMeaning(Dpronoun),i,i); // general as opposed to specific
			if (bit & NOUN && finalPosValues[i] & NOUN_SINGULAR) MarkFacts(posMeanings[j],i,i); // NOUNS which have singular like "well" but could be infinitive, are listed as nouns but not infintive
			else if (i > 1 && finalPosValues[i] & NOUN_INFINITIVE && stricmp(wordStarts[i-1],"to") && (bit & (NOUN | NOUN_INFINITIVE))) {;} // skip noun-inifitive lacking TO 
			else MarkFacts(posMeanings[j],i,i);
			if (bits & NOUN_HUMAN) // impute additional meanings
			{
				if (bits & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL)) MarkFacts(MakeMeaning(Dhumanname),i,i);
				if (bits & NOUN_HE) MarkFacts(MakeMeaning(Dmalename),i,i);
				if (bits & NOUN_SHE) MarkFacts(MakeMeaning(Dfemalename),i,i);
			}
			if (bit & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL) && len >= 3) 
			{
				MarkFacts(MakeMeaning(Dpropername),i,i); // short things are not names, even if caps
			}
		}

		bit >>= 1;
	}
		
	// system flags we allow
	bit = START_BIT;
	for (int j = 63; j >= 0; --j)
	{
		if (bit & MARK_FLAGS && originalLower[i] && originalLower[i]->systemFlags & bit)  MarkFacts(sysMeanings[j],i,i);
		bit >>= 1;
	}

	if (bits & (AUX_VERB_BITS | AUX_BE | AUX_HAVE | AUX_DO)) finalPosValues[i] |= VERB;	// lest it report "can" as untyped, and thus become a noun -- but not ~verb from system view

}

/////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////// PARSER CODE

/////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DISCARDPARSER
#ifdef INFORMATION

The algorithm is:

1. figure out what POS tags we can be certain of
2. Assign roles as we go, forcing bindings that seem to make sense at the time. This is subject to garden-path phenomena, which means when we detect inconsistency later,
we have to go back and patch up the roles and even the POS tags to make a coherent whole. Probability is built into the expectation of role coercions we do as we go.

E.g., when we have two nouns and dont need the second, we have to decide is it appositive or is it start of implied clause.

3. As parsing progresses, we enter and exit new nested roleLevels as phrases, verbals and clauses spring into being and become complete. A roleLevel indicates what we are currently seeking or allow
like a subject, verb, object, etc. So until we see a verb, for example, we are not expected to see an object. We may mislabel an object as a subject (because we were seeking that) but have to
patch later when the structure becomes more apparent.

Structures:

1. Object complement:    It is most often used with verbs of creating or nominating such as make, name, elect, paint, call, choosing, judging, appointing, etc. in the active voice,.. implied missing "to be"
	Subject Verb Object nounphrase.		He considered her his grandmother.
	Subject Verb Object adjective.		He drove her crazy.
	Subject Verb Object prep-phrase.	He loved her like a sister.???
	Subject verb object gerund	?		I saw the Prime Minister sleeping
	Subject verb object clause			I like the shawl *people wear

2. Appostive noun (at end will have a comma, lest it be object ocmplement)
	He considered Joe, a self-starter.	(comma helps)
	The commander stood his ground, a heroic figure. (delayed appositive of commander)
	It is a pleasure *to meet up (delayed appositive of it but fine as appossitive of pleasure)
	I, the leader of the rebellion that defines eternity, call this to order.

3. Clause-omitting starter
	The shawl *people wear is green (subject complement)
	Roger likes the shawl *people wear (object complement)

4. Prep phrase omitting prep
	Time phrases					He will walk *next week

5.	Adjective Object
	Subject verb adjective		The shawl is green


The first noun encountered is generally the subject of the sentence except:

0. Inside a prepositional phrase, verbal, or clause.
1. Appositive noun at sentence start with comma:  "A dark wedge, the eagle hurtled  at nearly 200 miles per hour."
	detectable because it starts the sentence and has no verb before the comma, and has a noun and verb after the comma.
2. Questions often flip subject/object:  "what is your name"
3. Absolute phrase at start. separated by comma, 
	a) lacking a full verb (a participle w/o aux)
		Their reputation as winners secured by victory, the New York Liberty charged into the semifinals
	b) lacking any verb (sometimes implied) --
		Your best friends, where are they now, when you need them?  # NOUN PHRASE (NO VERB)  # http://grammar.ccc.commnet.edu/grammar/phrases.htm#absolute
		The season over, they were mobbed by fans in Times Square  # IMPLIED BEING AS VERB
		Stars all their adult lives, they seemed used to the attention # IMPLIED [Having been AS VERB] 
4. Direct address

PARENS include:
1.  pretend they are commas for appositive: Steve Case (AOL s former CEO)
2. junk extra "You will need a flashlight for the camping trip (don't forget the batteries!). "

COMMAS denote:
1. appositives embedded " Bill, our CEO, ate here"
2. a list of nouns	"he ate green bananas, lush oranges, and pineapple"
3. multiple adjectives " he ate ripe, green fruit."
4. after intro prep phrase  "After the show, John and I went out to dinner."
5. before coord conjunction: "Ryan went to the beach yesterday, but he forgot his sunscreen."
6. Direct address by name: "Amber, could you come here for a moment?"
7. leading adjective_participle: "Running toward third base, he suddenly realized how stupid he looked."

# opinion size age shape colour origin material is adjective order

ROLES:

Where a noun infinitive is the complement, we note the role on the verb, not on the To.  If the noun infintiive is not a complement,
then its role will be VERB2 (generic).

PHRASES and CLAUSES

The system recognizes:
1. prepositional phrase + ommited prep time phrase
2. verbals (noun-infinitive, adjective participle, noun-gerund)
3. subordinate clause
	a. started by subordinate conjunction
	b. started by relative pronoun serving as subject
	c. ommitted
4. absolute phrase
5. address phrase
6. appostive phrase

Back to back nouns can occur as follows:

1. A clause/phrase/verbal is ending and noun is subject of next chunk - best with commas
		"Smelling food cats often eat"  though better with a comma
2. Appositive - can use commas
	    "My friend Tom lives here"
		"Tom my friend lives here" though better with comma
		one or both must be determined nouns, where one the other must be a proper name. Determiners a and the must be intermixed, not duplicated.
3.  Adjective nouns -- do not use commas
		"I saw the bank clerk"
4. with commas, we can have address  "Bill, dogs eat meat" -- requires commas

Verb structures:

1.  Intransitive - takes no object
2.  Transitive - takes a direct object
3.  DiTransitive - takes direct and indirect object
4.  Factitive - takes two objects (second is like prep phrase "as") "elect him president" or noun adjective
5.  Causative - causes an action - generally followed by a noun or pronoun, then by an infinitive.  The infinitive in "Peter helped Polly correct exams." is to correct.  The to is understood, and not necessary to include it  


Is there a distinction between: OBJECT_COMPLEMENT  in "they found the way *to go"
and POSTNOMINAL_ADJECTIVE in "They described the way *to survive"
and direct appositive -- "The mistake, *to elect him", was critical - this requires comma separation

Postnominal can occur after any normal noun (including subjects).  It is either a predictable adjective (there are some specific ones that usually are post noun, or
a verbal.

Some Verbs "expect" an object complement after object, but that complement can be 
a POSTNOMINAL_ADJECTIVE or a noun. As a adjective, the adjective is an OBJECT_COMPLEMENT that describes how the object ended up AFTER the
verb happened (causal verbs).

How to tell a interrupter infinitive, sandwiched by commas from an appositive infinitive- cant. we will let it be appositive



subject auxverb inversion happens with:
1. questions
2. sometimes when the sentence starts with a place expression (here comes the bride)  (existential there) and nowhere
3. when the sentence begins with some negative words (negative adverbials) and no/only expressions)
4. when we use a condition without if -- had were and should starting as helpers
5. sometimes when the sentence has a comparison

subject complement can preceed subject after: how 

#endif

static unsigned char clauseBit;
static unsigned char prepBit;
static unsigned char verbalBit;


static unsigned int firstnoun;	 // first noun we see in a sentence (maybe object of wrapped prep from end)
static unsigned int determineVerbal;
static unsigned int firstNounClause;

#define INCLUSIVE 1
#define EXCLUSIVE 2

#define AMBIGUOUS_VERBAL (ADJECTIVE_PARTICIPLE | NOUN_GERUND )
#define AMBIGUOUS_PRONOUN (PRONOUN_SUBJECT | PRONOUN_OBJECT )

#define GUESS_NOCHANGE 0
#define GUESS_ABORT 1
#define GUESS_RETRY 2
#define GUESS_CONTINUE 3
#define GUESS_RESTART 4

static unsigned int GetClauseHead(unsigned int i)
{
	unsigned int clause = clauses[i];
	if (clause)
	{
		while (--i  >= startSentence && clauses[i] & clause){;}
		return i+1;
	}
	else return 0;
}

static unsigned int GetClauseTail(unsigned int i)
{
	unsigned int clause = clauses[i];
	if (clause)
	{
		while (++i <= endSentence && clauses[i] & clause){;}
		return i-1;
	}
	else return 0;
}

static unsigned int GetVerbalHead(unsigned int i)
{
	unsigned int verbal = verbals[i];
	if (verbal)
	{
		while (--i >= startSentence  && verbals[i] & verbal){;}
		return i+1;
	}
	else return 0;
}

static unsigned int GetVerbalTail(unsigned int i)
{
	unsigned int verbal = verbals[i];
	if (verbal)
	{
		while (++i <= endSentence && verbals[i] & verbal){;}
		return i-1;
	}
	else return 0;
}

static unsigned int GetPhraseHead(unsigned int i)
{
	unsigned int phrase = phrases[i];
	if (phrase)
	{
		while (--i >= startSentence && phrases[i] & phrase){;}
		return i+1;
	}
	else return 0;
}

static unsigned int GetPhraseTail(unsigned int i)
{
	unsigned int phrase = phrases[i];
	if (phrase)
	{
		while (++i <= endSentence && phrases[i] & phrase){;}
		return i-1;
	}
	else return 0;
}

static void ErasePhrase(unsigned int i)
{
	unsigned int phrase = phrases[i--];
	while (++i <= endSentence && phrases[i] & phrase)
	{
		if (roles[i] & OBJECT2) 
		{
			roles[i] ^= OBJECT2;
			objectRef[i] = 0;
		}
		phrases[i] ^= phrase;
	}
}

static void AddRoleLevel(unsigned int roles,unsigned int i)
{
	needRoles[++roleIndex] = roles; 
	subjectStack[roleIndex] = 0;
	verbStack[roleIndex] = 0;
	auxVerbStack[roleIndex] = 0;
	startStack[roleIndex] = (unsigned char) i;
}

static void InitRoleSentence()
{
	needRoles[0] = COMMA_PHRASE;		// a non-zero level
	determineVerbal = 0;
	currentVerb2 = currentMainVerb = 0;
	predicateZone = -1;
	roleIndex = 0;
	lastPhrase = lastVerbal = lastClause = 0; 
	firstAux = NULL;
	firstnoun = firstNounClause = 0;
	AddRoleLevel(MAINSUBJECT|MAINVERB,startSentence);
	verbStack[0] = 0;
	startStack[roleIndex] = (unsigned char) startSentence;
	objectRef[0] = objectRef[MAX_SENTENCE_LENGTH] = 0;
	if (*wordStarts[startSentence] == '"' && parseFlags[startSentence+1] & QUOTEABLE_VERB) // absorb quote reference into sentence
	{
		SetRole(startSentence,MAINOBJECT,true);
	}

	if (trace & TRACE_POS) Log(STDUSERLOG,"  *** Sentence start: %s (%d) to %s (%d)\r\n",wordStarts[startSentence],startSentence,wordStarts[endSentence],endSentence);
}

static bool NounSeriesFollowedByVerb(unsigned int at)
{
	while (posValues[++at] & (DETERMINER|ADJECTIVE_NORMAL|ADJECTIVE_NUMBER|NORMAL_NOUN_BITS)  && bitCounts[at] == 1);
	return (posValues[at] & (VERB_TENSES|AUX_VERB_BITS) && bitCounts[at] == 1);
}

static bool ResolveByStatistic(unsigned int i,bool &changed) 
{
	if (bitCounts[i] == 1) return false;
	
	// if something could be noun or verb, and  we are not looking for a verb yet, be a noun.
	if (posValues[i] & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL|NOUN_PLURAL|NOUN_SINGULAR) && posValues[i] & VERB_TENSES && roleIndex == MAINLEVEL && !(needRoles[MAINLEVEL] & MAINVERB))
	{
		LimitValues(i,-1 ^ VERB_TENSES,"in noun/verb conflict discarding verb when none is sought",changed);
	}
	else if (lcSysFlags[i] & ESSENTIAL_FLAGS)
	{
		if (lcSysFlags[i] & NOUN && posValues[i] & NOUN_BITS)
		{
			LimitValues(i,NOUN_BITS,"statistic force original noun",changed);
		}
		if (lcSysFlags[i] & VERB && posValues[i] & VERB_TENSES)
		{
			LimitValues(i,VERB_TENSES,"statistic force original verb",changed);
		}
		if (lcSysFlags[i] & PREPOSITION && posValues[i] & PREPOSITION)
		{
			LimitValues(i,PREPOSITION,"statistic force original preposition",changed);
		}
		if (lcSysFlags[i] & ADVERB && posValues[i] & ADVERB_BITS)
		{
			LimitValues(i,ADVERB_BITS,"statistic force original adverb",changed);
		}
		if (lcSysFlags[i] & ADJECTIVE && posValues[i] & ADJECTIVE_BITS)
		{
			LimitValues(i,ADJECTIVE_BITS,"statistic force original adjective",changed);
		}
	}
	if (canSysFlags[i] & ESSENTIAL_FLAGS)
	{
		if (canSysFlags[i] & NOUN && posValues[i] & NOUN_BITS)
		{
			LimitValues(i,NOUN_BITS,"statistic force canonical noun",changed);
		}
		if (canSysFlags[i] & VERB && posValues[i] & VERB_TENSES)
		{
			LimitValues(i,VERB_TENSES,"statistic force canonical verb",changed);
		}
		if (canSysFlags[i] & PREPOSITION && posValues[i] & PREPOSITION)
		{
			LimitValues(i,PREPOSITION,"statistic force canonical preposition",changed);
		}
		if (canSysFlags[i] & ADVERB && posValues[i] & ADVERB_BITS)
		{
			LimitValues(i,ADVERB_BITS,"statistic force canonical adverb",changed);
		}
		if (canSysFlags[i] & ADJECTIVE && posValues[i] & ADJECTIVE_BITS)
		{
			LimitValues(i,ADJECTIVE_BITS,"statistic force canonical adjective",changed);
		}
	}
	if (posValues[i] & PRONOUN_POSSESSIVE && NounSeriesFollowedByVerb(i)) // "he hid because *his bank notes were bad"
	{
		LimitValues(i,PRONOUN_POSSESSIVE,"statistic force possesive pronoun with following noun-based series and then verb",changed);
	}
	
	if (posValues[i] & NOUN_BITS)
	{
		LimitValues(i,NOUN_BITS,"statistic force noun",changed);
		if (posValues[i] & NOUN_NUMBER) 
		{
			LimitValues(i,NOUN_NUMBER,"statistic force cardinal noun",changed);
		}
	}
	if (posValues[i] & AUX_VERB_BITS)
	{
		LimitValues(i,AUX_VERB_BITS,"statistic force aux verb",changed);
	}
	if (posValues[i] & VERB_TENSES)
	{
		LimitValues(i,VERB_TENSES,"statistic force verb",changed);
	}
	if (posValues[i] & FOREIGN_WORD)
	{
		LimitValues(i,FOREIGN_WORD,"statistic force foreign word",changed);
	}
	if (posValues[i] & PREPOSITION)
	{
		LimitValues(i,PREPOSITION,"statistic force preposition",changed);
	}
	if (posValues[i] & ADVERB_BITS)
	{
		LimitValues(i,ADVERB_BITS,"statistic force adverb",changed);
	}
	if (posValues[i] & ADJECTIVE_BITS)
	{
		LimitValues(i,ADJECTIVE_BITS,"statistic force adjective",changed);
		if (posValues[i] & ADJECTIVE_NUMBER) // vs subject
		{
			LimitValues(i,ADJECTIVE_NUMBER,"statistic force numeric adjective",changed);
		}
		if (posValues[i] & ADJECTIVE_NORMAL) // vs subject
		{
			LimitValues(i,ADJECTIVE_NORMAL,"statistic force adjective normal",changed);
		}
	}

	if (posValues[i] & NORMAL_NOUN_BITS)
	{
		LimitValues(i,NORMAL_NOUN_BITS,"statistic force normal noun",changed);
		if (posValues[i] & NOUN_PROPER_PLURAL) // vs singular proper
		{
			LimitValues(i,NOUN_PROPER_PLURAL,"statistic force proper plural noun",changed);
		}
	}
	if (posValues[i] & (VERB_PRESENT|VERB_PRESENT_3PS))
	{
		LimitValues(i,(VERB_PRESENT|VERB_PRESENT_3PS),"statistic force present tense",changed);
	}
	if (posValues[i] & VERB_PAST) // vs infinitive of another like found/find
	{
		LimitValues(i,VERB_PAST,"statistic force past tense",changed);
	}
	if (posValues[i] & PRONOUN_OBJECT) // vs subject
	{
		LimitValues(i,PRONOUN_OBJECT,"statistic force object pronoun",changed);
	}
	if (posValues[i] & PRONOUN_SUBJECT) // vs determiner
	{
		LimitValues(i,PRONOUN_SUBJECT,"statistic force subject pronoun",changed);
	}
	if (posValues[i] & TO_INFINITIVE) // vs particle perhaps
	{
		LimitValues(i,TO_INFINITIVE,"statistic force to infinitive",changed);
	}
	return false;
}

static int GetZone(unsigned int i)
{
	for (unsigned int zone = 0; zone < zoneIndex; ++zone)
	{
		if (i >= zoneBoundary[zone] && i < zoneBoundary[zone+1]) return zone;
	}
	return -1;
}

void MarkRoles(unsigned int i)
{
	// mark its main parser role - not all roles are marked and parsing might not have been done
	uint64 role = roles[i];
	if (role & MAINSUBJECT)  MarkFacts(MakeMeaning(StoreWord("~mainsubject")),i,i); 
	if (role & MAINVERB) MarkFacts(MakeMeaning(StoreWord("~mainverb")),i,i); 
	if (role & MAININDIRECTOBJECT) MarkFacts(MakeMeaning(StoreWord("~mainindirectobject")),i,i); 
	if (role & MAINOBJECT) MarkFacts(MakeMeaning(StoreWord("~mainobject")),i,i); 
	if (role & SUBJECT_COMPLEMENT)  MarkFacts(MakeMeaning(StoreWord("~subjectcomplement")),i,i); 
	if (role & OBJECT_COMPLEMENT) MarkFacts(MakeMeaning(StoreWord("~objectcomplement")),i,i); 
	if (role & ADJECTIVE_COMPLEMENT) MarkFacts(MakeMeaning(StoreWord("~adjectivecomplement")),i,i); 
	if (role & NOUN_OMITTED_ADJECTIVE)  MarkFacts(MakeMeaning(StoreWord("~nounomittedadjective")),i,i); 
	
	if (role & SUBJECT2) MarkFacts(MakeMeaning(StoreWord("~subject2")),i,i);
	if (role & VERB2) MarkFacts(MakeMeaning(StoreWord("~verb2")),i,i);
	if (role & INDIRECTOBJECT2)  MarkFacts(MakeMeaning(StoreWord("~indirectobject2")),i,i); 
	if (role & OBJECT2)  MarkFacts(MakeMeaning(StoreWord("~object2")),i,i); 
	
	if (role & ADDRESS) MarkFacts(MakeMeaning(StoreWord("~address")),i,i); 
	if (role & APPOSITIVE) MarkFacts(MakeMeaning(StoreWord("~appositive")),i,i); 
	if (role & POSTNOMINAL_ADJECTIVE) MarkFacts(MakeMeaning(StoreWord("~postnominaladjective")),i,i); 
	if (role & REFLEXIVE) MarkFacts(MakeMeaning(StoreWord("~reflexive")),i,i); 
	if (role & ABSOLUTE_PHRASE) MarkFacts(MakeMeaning(StoreWord("~absolutephrase")),i,i); 
	if (role & OMITTED_TIME_PREP) MarkFacts(MakeMeaning(StoreWord("~omittedtimeprep")),i,i); 

	uint64 crole = role & CONJUNCT_KINDS;
	if (crole == CONJUNCT_PHRASE) MarkFacts(MakeMeaning(StoreWord("~CONJUNCT_PHRASE")),i,i); 
	if (crole ==  CONJUNCT_CLAUSE) MarkFacts(MakeMeaning(StoreWord("~CONJUNCT_CLAUSE")),i,i); 
	if (crole ==  CONJUNCT_SENTENCE) MarkFacts(MakeMeaning(StoreWord("~CONJUNCT_SENTENCE")),i,i); 
	if (crole ==  CONJUNCT_NOUN) MarkFacts(MakeMeaning(StoreWord("~CONJUNCT_NOUN")),i,i);
	if (crole ==  CONJUNCT_VERB) MarkFacts(MakeMeaning(StoreWord("~CONJUNCT_VERB")),i,i); 
	if (crole ==  CONJUNCT_ADJECTIVE) MarkFacts(MakeMeaning(StoreWord("~CONJUNCT_ADJECTIVE")),i,i); 
	if (crole == CONJUNCT_ADVERB) MarkFacts(MakeMeaning(StoreWord("~CONJUNCT_ADVERB")),i,i);

	crole = role & ADVERBIALTYPE;
	if (crole == WHENUNIT) MarkFacts(MakeMeaning(StoreWord("~whenunit")),i,i); 
	if (crole ==  WHEREUNIT) MarkFacts(MakeMeaning(StoreWord("~whereunit")),i,i); 
	if (crole ==  HOWUNIT) MarkFacts(MakeMeaning(StoreWord("~howunit")),i,i); 
	if (crole ==  WHYUNIT) MarkFacts(MakeMeaning(StoreWord("~whyunit")),i,i);



	// meanwhile mark start/end of phrases
	unsigned int phrase = phrases[i];
	if (phrase && phrase != phrases[i-1])
	{
		if (i == startSentence && phrase == phrases[endSentence]) {;} // start at end instead
		else
		{
			if (posValues[i] & NOUN_BITS) MarkFacts(MabsolutePhrase,i,i);
			else if (posValues[i] & (ADVERB_BITS|ADJECTIVE_BITS)) MarkFacts(MtimePhrase,i,i);
			else MarkFacts(Mphrase,i,i);
		}
	}
	
	// meanwhile mark start/end of clause
	unsigned int clause = clauses[i];
	if (clause && clause != clauses[i-1])
	{
		unsigned int at = i;
		while (clauses[++at] == clause);
		MarkFacts(MakeMeaning(Dclause),i,at-1);
	}

	// meanwhile mark start/end of verbals
	unsigned int verbal = verbals[i];
	if (verbal && verbal != verbals[i-1])
	{
		unsigned int at = i;
		while (verbals[++at] == verbal);
		MarkFacts(MakeMeaning(Dverbal),i,at-1);
	}
	if (role & SENTENCE_END) MarkFacts(MakeMeaning(StoreWord("~sentenceend")),i,i); 

}

void InitEnglishParser()
{
	roleIndex = 0; 
	prepBit = clauseBit = verbalBit = 1;
	memset(tried,0,sizeof(char) * (wordCount + 2));
	memset(phrases,0,sizeof(int) *(wordCount+4));
	memset(verbals,0,sizeof(int) *(wordCount+4));
	memset(clauses,0,sizeof(int) *(wordCount+4));
	memset(roles,0,(wordCount+4) * sizeof(uint64));
	memset(parseFlags,0,(wordCount+2) * sizeof(int));
	memset(indirectObjectRef,0,sizeof(int) *(wordCount+4));
	memset(objectRef,0,sizeof(int) *(wordCount+4));
	memset(complementRef,0,sizeof(int) *(wordCount+4));
}

static void AddRole(unsigned int i, uint64 role)
{
	// all major assignments go thru setrole
	if (!roles[i] || role & (MAINSUBJECT | SUBJECT2 | MAINVERB | VERB2 | MAINOBJECT | OBJECT2 | MAININDIRECTOBJECT | INDIRECTOBJECT2 | OBJECT_COMPLEMENT | SUBJECT_COMPLEMENT))
	{
		SetRole(i,role,false,0);
		return;
	}

	roles[i] |= role; // assign secondary role characteristic
	if (trace & TRACE_POS) Log(STDUSERLOG,"   +%s->%s\r\n",wordStarts[i],GetRole(i));
}

void SetRole(unsigned int i, uint64 role,bool revise,unsigned int currentVerb)
{
	if (i < startSentence || i > endSentence) return; // precaution

	// remove old reference if it had one
	if (roles[i] & (MAINSUBJECT|SUBJECT2) && subjectStack[roleIndex] == i) subjectStack[roleIndex] = 0;
	if (roles[i] & (MAINVERB|VERB2) && verbStack[roleIndex] == i) verbStack[roleIndex] = 0;
	if (roles[i] & (MAININDIRECTOBJECT|INDIRECTOBJECT2) && indirectObjectRef[currentVerb] == i) indirectObjectRef[currentVerb] = 0;
	if (roles[i] & (OBJECT2|MAINOBJECT) && objectRef[currentVerb] == i) objectRef[currentVerb] = 0;
	if (roles[i] & OBJECT2 && objectRef[lastPhrase] == i) objectRef[lastPhrase] = 0;
	if (roles[i] & (SUBJECT_COMPLEMENT|OBJECT_COMPLEMENT) && complementRef[currentVerb] == i) complementRef[currentVerb] = 0;
	
	roles[i] = role;
	if (trace & TRACE_POS) Log(STDUSERLOG,"   +%s->%s\r\n",wordStarts[i],GetRole(i));

	// set new reference
	if (role & needRoles[roleIndex] || revise) // store role xref when we were looking for it - we might see objects added when we have one already
	{ // dont store if already there (conjunction multiple form for example)
		if (role & (NOUN_OMITTED_ADJECTIVE|MAINSUBJECT|SUBJECT2) && !subjectStack[roleIndex]) subjectStack[roleIndex] = (unsigned char)i;
		else if (role & (VERB2|MAINVERB) && !verbStack[roleIndex]) verbStack[roleIndex] = (unsigned char)i;
		else if (role & (MAININDIRECTOBJECT|INDIRECTOBJECT2)) indirectObjectRef[currentVerb] = (unsigned char)i; // implicit at 0 cache if no verb yet
		else if (role & MAINOBJECT) objectRef[currentVerb] = (unsigned char)i; // implicit at 0 cache if no verb yet
		else if (role & OBJECT2) 
		{
			if (lastPhrase) objectRef[lastPhrase] = (unsigned char)i;
			else if (currentVerb2) objectRef[currentVerb] = (unsigned char)i;
			else objectRef[MAX_SENTENCE_LENGTH] = (unsigned char)i; // cache at end til we do see the verb
		}
		else if (role & (SUBJECT_COMPLEMENT|OBJECT_COMPLEMENT)) complementRef[currentVerb] = (unsigned char)i;
	}
	needRoles[roleIndex] &= -1 ^ role; // remove what was supplied
	if (role & (OBJECT2|MAINOBJECT|VERB_INFINITIVE_OBJECT|VERB_INFINITIVE_OBJECT|SUBJECT_COMPLEMENT)) needRoles[roleIndex] &= -1 ^ (SUBJECT_COMPLEMENT|MAININDIRECTOBJECT|INDIRECTOBJECT2|OBJECT2|MAINOBJECT|VERB_INFINITIVE_OBJECT|TO_INFINITIVE_OBJECT);	// cant be both - can still have inifitive pending- "he wanted his students to *read"
	if (role & SUBJECT_COMPLEMENT) needRoles[roleIndex] &= -1 ^ (ALL_OBJECTS|OBJECT_COMPLEMENT);	// cant be these now
	// if (role & (MAININDIRECTOBJECT|INDIRECTOBJECT2)) needRoles[roleIndex] &= -1 ^ OBJECT_COMPLEMENT; // wrong for "this makes Jenn's mom mad
	if (role & MAINVERB) 
	{
		if (needRoles[roleIndex] & MAINSUBJECT)
		{
			// "are you" questions do not abandon subject yet, same for non-aux have -- but not are as AUX
			// but "be" will be different as infinitive.
			if (parseFlags[startSentence] & (LOCATIONAL_INVERTER|NEGATIVE_SV_INVERTER)) {;} // inversion expected
			else if (canonicalLower[i] &&  (!stricmp(canonicalLower[i]->word,"be")||!stricmp(canonicalLower[i]->word,"have"))) {;} // no subject yet
			else needRoles[roleIndex] &= -1 ^ MAINSUBJECT;
		}
	}
	if (role & VERB2 && roleIndex > 1)  // conjunction copy of a verb might be at main level but copy an object/verb2 "let us stand *and *hear the crowd"
	{
		// assume clause subject met, unless implicide clause starter -- bug 
		if (!(needRoles[roleIndex] & CLAUSE) && needRoles[roleIndex] & SUBJECT2) needRoles[roleIndex] &= -1 ^ SUBJECT2;
		else needRoles[roleIndex] &= -1 ^ SUBJECT2;  /// BUG 
	}
	if (role & OBJECT2 && roles[i-1] & OBJECT_COMPLEMENT) SetRole(i-1,INDIRECTOBJECT2); // need to revise backward "I had the mechanic *check the car"
	if (role & MAINOBJECT && roles[i-1] & OBJECT_COMPLEMENT) SetRole(i-1,MAININDIRECTOBJECT);
	if (role & POSTNOMINAL_ADJECTIVE && roles[i-1] & (INDIRECTOBJECT2|MAININDIRECTOBJECT)) // cannot post describ indirect, becomes direct
	{
		needRoles[roleIndex] &= -1 & OBJECT_COMPLEMENT; // cannot have one if we are postnominal adj
		SetRole(i-1, (roles[i-1] & INDIRECTOBJECT2) ? OBJECT2 : MAINOBJECT,true);
	}
}

static bool ProcessSplitNoun(unsigned int verb1,bool &changed)
{
	// 1 when we have dual valid verbs, maybe we swallowed a noun into a prep phrase that shouldnt have been.  (sequence: noun noun (ad:v) verb)
	// 2 Or We may have an inner implied clause -- the shawl people often wear isn't yellow ==  I hate the sh~awl people wear
	// 3 or a clause in succession when object side- to sleep is the thing eli wanted
	// 4 or a clause on subject side -  what they found thrilled them

	// 1 For 1st verb, see if we have  noun noun {adv} verb  formats (which implies noun should have been separated,
	unsigned int before = verb1;
	if (posValues[verb1] & VERB_TENSES) // past tense needs to go to participle
	{
		while (--before > 0) 
		{
			if (posValues[before] & ADVERB_BITS) continue; // ignore this
			// find the subject just before our 2nd verb
			if (posValues[before] & (NOUN_BITS - NOUN_GERUND - NOUN_NUMBER + PRONOUN_SUBJECT + PRONOUN_OBJECT) &&
				posValues[before-1] & (NOUN_BITS - NOUN_GERUND - NOUN_NUMBER  + PRONOUN_SUBJECT + PRONOUN_OBJECT))
			{ // misses, the shawl the people wear
				if (trace) Log(STDUSERLOG,"split noun @ %s(%d) to %s(%d)\r\n",wordStarts[before],before,wordStarts[verb1],verb1);

				if (posValues[before] & (PRONOUN_BITS)) // pronoun will already be split, but might be a clause starter
				{
					if (parseFlags[before-1]  & POTENTIAL_CLAUSE_STARTER)
					{
						SetRole(before,SUBJECT2,true);
						phrases[before] = 0;
						SetRole(verb1, VERB2,true);
						if (objectRef[verb1]) SetRole(objectRef[verb1],OBJECT2,true);
						--before; // subsume starter for clause
					}
					else
					{
						SetRole(before,SUBJECT2,true);
						phrases[before] = 0;
						SetRole(verb1,VERB2,true);
						if (objectRef[verb1]) SetRole(objectRef[verb1],OBJECT2,true);
					}
				}
				else if (posValues[before-1] & (PRONOUN_BITS))// pronoun will already be split
				{
					SetRole(before,SUBJECT2,true);
					phrases[before] = 0;
					SetRole(verb1,VERB2,true);
					if (objectRef[verb1]) SetRole(objectRef[verb1],OBJECT2,true);
				}
				else 
				{
					SetRole(before-1,roles[before]);
					SetRole(before,SUBJECT2,true);
					phrases[before] = 0;
					SetRole(verb1,VERB2,true);
					if (objectRef[verb1]) SetRole(objectRef[verb1],OBJECT2,true);
				}

				// if we find an entire given clause with starter, add the starter "what they found thrilled them"  
				while (before <= verb1) clauses[before++] |= clauseBit;
				clauseBit <<= 1;
				changed = true;
				return true;	
			}
			else break;
		}
	}
	return false;
}

static bool ProcessImpliedClause(unsigned int verb1,bool &changed) 
{
	if (clauses[verb1]) return false;	// already in a clause
	if (roles[verb1] & MAINVERB) return false;	// assume 1st is main verb

	unsigned int subject = verb1 - 1;
	if ( posValues[subject] & (AUX_VERB_BITS|ADVERB_BITS)) --subject;

	if (roles[subject] & MAINOBJECT) // implied clause as direct object  "I hope (Bob will go)"
	{
		if (trace) Log(STDUSERLOG,"implied direct object clause @ %s(%d)\r\n",wordStarts[subject],subject);
		SetRole(subject,SUBJECT2|MAINOBJECT,true);
		SetRole(verb1,VERB2,true);
		while (subject <= verb1) clauses[subject++] |= clauseBit;
		clauseBit <<= 1;
		changed = true;
		return true;	
	}
	return false;
}

static bool ProcessCommaClause(unsigned int verb1,bool &changed)
{
	if (!clauses[verb1]) return false; 
	if (trace) Log(STDUSERLOG,"Comma clause\r\n");
	needRoles[roleIndex] &= -1 ^ CLAUSE;
	unsigned int subject = verb1;
	while (--subject && posValues[subject] != COMMA);
	while (++subject <= verb1) clauses[subject] |= clauseBit;
	clauseBit <<= 1;
	return true;	
}

static unsigned int ForceValues(unsigned int i, uint64 bits,char* msg,bool& changed)
{
	uint64 old = posValues[i];
	posValues[i] = bits;
	if (old != posValues[i])
	{
		changed = true;
		bitCounts[i] = BitCount(posValues[i]);
		if (trace & TRACE_POS) Log(STDUSERLOG,"Force \"%s\"(%d) %s\r\n",wordStarts[i],i,msg);
	}
	return bitCounts[i];
}

static bool AcceptsInfinitiveObject(unsigned int i)
{
	return (canSysFlags[i] & (VERB_TAKES_INDIRECT_THEN_TOINFINITIVE |VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE) ) ? true : false;
}

static bool ProcessReducedPassive(unsigned int verb1,bool allowObject,bool &changed)
{
	if (clauses[verb1]) return false;	// already in a clause
	if (objectRef[verb1] && !allowObject)  // be pessimistic, we dont want the main verb taken over
	{
		// the man given the ball is ok.
		// but the man dressed the cow is not - AND normal verbs might have objects
		// but "called" "named" etc create subjects of their objects and are ok.
		return false;
	}

	// or a past participle clause immediately after a noun --  the woman dressed in red
	// Or past particple clause starting sentence (before subject)  Dressed in red the woman screamed.   OR  In the park dressed in red, the woman screamed
	// OR -- the men driven by hunger ate first (directly known participle past)
	char* base = GetInfinitive(wordStarts[verb1],false);
	if (!base) return false;
	char* pastpart = GetPastParticiple(base);
	if (!pastpart) return false;
	if (stricmp(pastpart,wordStarts[verb1])) return false;	// not a possible past particple

	unsigned int before = verb1;
	if (posValues[verb1] & (VERB_PAST | VERB_PAST_PARTICIPLE)) 
	{
		bool causal = false;
		if (AcceptsInfinitiveObject(verb1) )
		{
			while (--before > 0) // past tense needs to go to participle
			{
				if (posValues[before] & ADVERB_BITS) continue; // ignore this
				if (posValues[before] & (NOUN_BITS - NOUN_GERUND - NOUN_NUMBER + PRONOUN_SUBJECT + PRONOUN_OBJECT)) 
				{
					if (phrases[before]) before = 0;	// cannot take object of prep and make it subject of clause directly
					break;
				}
				if (posValues[before] & COMMA) continue;
				return false;	// doesnt come after a noun or pronoun
			}

			// should this be main verb due to made me do it verb "the devil *made me do it"  causal verbs
			unsigned int after = verb1;
			while (++after < endSentence)
			{
				if (canSysFlags[after] & ANIMATE_BEING || IsUpperCase(*wordStarts[after]))
				{
					if (posValues[after+1] & (TO_INFINITIVE|VERB_INFINITIVE)) break;
				}
				else if (posValues[after] & (DETERMINER|ADJECTIVE_BITS)) continue;
				else break;
			}
			if (canSysFlags[verb1] & (VERB_TAKES_INDIRECT_THEN_TOINFINITIVE|VERB_TAKES_TOINFINITIVE)  && posValues[after+1] & TO_INFINITIVE) causal = true; 
			else if (canSysFlags[verb1] & (VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE|VERB_TAKES_VERBINFINITIVE) && posValues[after+1] & VERB_INFINITIVE) causal = true; 
		}

		if (!causal) // "the devil *made me do it" blocks this reduction to a clause
		{
			// before might be 0 when clause at start of sentence
			LimitValues(verb1,VERB_PAST_PARTICIPLE,"reduced passive",changed);
			SetRole(verb1,VERB2,true);
			if (objectRef[verb1]) SetRole(objectRef[verb1],OBJECT2,true);
			clauses[verb1] |= clauseBit;
			clauseBit <<= 1;
			return true;	
		}
	}
	// alternative is we have coordinating sentences we didnt know about
	// defines the object, we come after main verb - We like the boy Eli *hated -   but "after he left home *I walked out
	// clause defines the subject, we come before main verb - The boy Eli hated *ate his dog - boy was marked as subject, and hated as mainverb.
	return false;
}

static void AddClause(unsigned int i,char* msg)
{
	// if we found a verb and still want a subject, seeing this clause--- it's not coming!  "under the bed is *where I am"
	if (needRoles[roleIndex] & (SUBJECT2|MAINSUBJECT) && !(needRoles[roleIndex] & (VERB2|MAINVERB))) needRoles[roleIndex] &= -1 ^ (SUBJECT2|MAINSUBJECT);
	// be the needed object if one is wanted
	if (!(posValues[i] & CONJUNCTION_COORDINATE) && needRoles[roleIndex] & (OBJECT2|MAINOBJECT)  && !(parseFlags[i] & CONJUNCTIONS_OF_ADVERB) ) 
	 // clause should not intervene before direct object unless describing indirect object
	{ 
		SetRole(i,needRoles[roleIndex] & (OBJECT2|MAINOBJECT));
		needRoles[roleIndex] &= -1 ^ OBJECT_COMPLEMENT; // in addition remove this
	}

	if (trace) Log(STDUSERLOG,msg,wordStarts[i]);
	if (!clauses[i])
	{
		clauses[i] |= clauseBit;
		clauseBit <<= 1;
		if (trace & TRACE_POS) Log(STDUSERLOG,"Clause added at %s(%d)\r\n",wordStarts[i],i);
	}

	if (clauses[i] && clauses[i] != clauses[i-1]) // a new clause runs thru here
	{
		if (posValues[i-1] & ADJECTIVE_BITS) SetRole(i,ADJECTIVE_COMPLEMENT);
		AddRoleLevel(CLAUSE|SUBJECT2|VERB2,i); // start of a clause triggers a new level for it, looking for subject and verb (which will be found).
		// possibly the start is the subject (or object) or possibly not. cannot tell in advance usually.
		if (!firstNounClause) // pending noun clause as subject for verb
		{					
			WORDP D = FindWord(wordStarts[i]);
			if (D && D->systemFlags & CONJUNCT_SUBORD_NOUN) firstNounClause = i; 
		}
		lastClause = i;		// where last clause was, if any
	}
}

static void ExtendChunk(unsigned int from, unsigned int to,unsigned int chunk[MAX_SENTENCE_LENGTH])
{
	unsigned int unit = chunk[from];
	if (!unit) unit = chunk[to]; 
	if (unit) while (from <= to) chunk[from++] |= unit;
}
	
// commas occur after a phrase at start, after an inserted clause or phrase, and in conjunction lists, and with closing phrases

static int FindPriorVerb(int at)
{
	while (--at)
	{
		if (roles[at] & (VERB2|MAINVERB)) break;
	}
	return at;
}

static int FindPriorNoun(unsigned int i)
{
	unsigned int priorNoun = i;
	while (--priorNoun && !(posValues[priorNoun] & (NORMAL_NOUN_BITS|PRONOUN_BITS))) {;}
	return priorNoun;
}

static void ImpliedNounObjectPeople(unsigned int i, uint64 role) // for object
{
	if (!role || !(posValues[i] & ADJECTIVE_NORMAL) || stricmp(wordStarts[i-1],"the")) return; 
	unsigned int at = i;
	while (++at <= endSentence && posValues[at] & ADVERB_BITS) {;}	// the wicked very often *can outwit others"
	if (at > endSentence || posValues[at] & (VERB_TENSES|AUX_VERB_TENSES|PREPOSITION|TO_INFINITIVE))
	{
		SetRole(i,NOUN_OMITTED_ADJECTIVE|role);
	}
}

static bool FinishSentenceAdjust(bool resolved,bool & changed,unsigned int start,unsigned int end)
{
	if (verbStack[MAINLEVEL] > end) 
	{
		ReportBug("verb out of range");
		return true;
	}
	if (subjectStack[MAINLEVEL] > end) 
	{
		ReportBug("object out of range");
		return true;
	}
	ImpliedNounObjectPeople(end, needRoles[roleIndex] & (MAINOBJECT|OBJECT2));

	////////////////////////////////////////////////////////////////////////////////
	///// This part can revise pos tagging and return false (reanalyze sentence)
	////////////////////////////////////////////////////////////////////////////////

	
	///////////////////////////////////////////////////////////////////////////
	// CLOSE OUT NEEDS
	///////////////////////////////////////////////////////////////////////////

	// we still need a main verb--- might this have been command - "talk about stuff"
	if (needRoles[MAINLEVEL] & MAINVERB)
	{
		unsigned int at = start;
		if (posValues[at] & ADVERB_BITS) ++at;	// skip over 1st word, trying for 2nd
		if (allOriginalWordBits[at] & VERB_INFINITIVE)
		{
			// if after is unheaded noun, then we cant change this from adjective... "*brave old dog"
			unsigned int noun = at;
			while (++noun <= endSentence)
			{
				if (!(posValues[noun] & (DETERMINER|ADJECTIVE_BITS|ADVERB_BITS|POSSESSIVE))) break;
			}
			if (posValues[noun] & NOUN_BITS)
			{
				unsigned int det;
				if (!IsDeterminedNoun(noun,det)) // we CANT change this
				{
					resolved = false;
					return true; // we cant do more
				}
			}

			LimitValues(at,VERB_INFINITIVE,"missing main verb, retrofix to command",changed);
			SetRole(at,MAINVERB);
			unsigned int v = verbals[at];
			unsigned int i = 0;
			while (verbals[++i] == v) verbals[i] ^= v; // rip out the verbal
			resolved = false;
			return false;
		}

		// maybe we made a noun instead of verb-- "the good *die young"
		unsigned int subj = subjectStack[MAINLEVEL];
		if (subj)
		{
			unsigned int start = subj;
			while (posValues[start-1] & ADJECTIVE_NOUN) --start; // back to start of nouns...
			if (allOriginalWordBits[start] & VERB_TENSES && posValues[start-1] & ADJECTIVE_NORMAL && posValues[start-2] & DETERMINER)
			{
				SetRole(subj,0,true);
				LimitValues(start,VERB_TENSES - VERB_INFINITIVE,"missing verb recovered from bad noun",changed);
				while (++start <= subj)
				{
					LimitValues(start,0,"retrying all bits after verb flipover",changed);
				}
				resolved = false;
				return false;
			}
		}
	}
	
	while (needRoles[roleIndex] & (OBJECT2|MAINOBJECT|OBJECT_COMPLEMENT) || needRoles[roleIndex] == PHRASE || needRoles[roleIndex] == CLAUSE || needRoles[roleIndex] == VERBAL) // close of sentence proves we get no final object... 
	{
		if (needRoles[roleIndex] & (VERB2 | MAINVERB | MAINSUBJECT | SUBJECT2 ) || needRoles[roleIndex] == (PHRASE|OBJECT2)) // we HAVE NOTHING finished here
		{
			resolved = false;
			break;
		}
		if (needRoles[roleIndex] & CLAUSE && lastClause) ExtendChunk(lastClause,end,clauses);
		if (needRoles[roleIndex] & VERBAL && lastVerbal) ExtendChunk(lastVerbal,end,verbals);
		if (needRoles[roleIndex] & PHRASE && lastPhrase) ExtendChunk(lastPhrase,end,phrases);

		DropLevel(); // close out level that is complete
		if (roleIndex == 0) // put back main sentence level
		{
			++roleIndex;
			break;
		}
	}
	
	// inverted subject complement "how truly *fine he looks"
	if (!stricmp(wordStarts[startSentence],"how") && posValues[startSentence+1] & ADJECTIVE_BITS && !roles[startSentence+1])
	{
		LimitValues(startSentence+1,ADJECTIVE_BITS,"inverted subject complement is adjective",changed);
		roles[startSentence+1] = SUBJECT_COMPLEMENT;
	}
	if (!stricmp(wordStarts[startSentence],"how") && posValues[startSentence+1] & ADVERB_BITS && posValues[startSentence+2] & ADVERB_BITS && !roles[startSentence+2])
	{
		LimitValues(startSentence+2,ADJECTIVE_BITS,"inverted subject complement is adjective",changed);
		roles[startSentence+2] = SUBJECT_COMPLEMENT;
	}	

	///////////////////////////////////////////////////////////////
	//  DOWNGRADE ITEMS
	///////////////////////////////////////////////////////////////

	// check clause completion, may have to switch to prep
	unsigned int currentClause = 0;
	unsigned int currentVerbal = 0;
	unsigned int currentVerb = 0;
	int commas = 0;
	unsigned int mainVerb = 0;
	currentMainVerb = 0;
	currentVerb2 = 0;

	for (unsigned int i = start; i <= end; ++i)
	{
		if (ignoreWord[i]) continue;
		if (!clauses[i])
		{
			if (currentClause) 
			{
				if (!currentVerb) // clause is a problem...  (we do allow missing subject when verb is a gerund)
				{
					if (allOriginalWordBits[currentClause] & PREPOSITION) // change it over
					{
						LimitValues(currentClause,PREPOSITION,"clause missing verb, changing over to preposition",changed);
						for (unsigned int x = currentClause; x <= i; ++x) clauses[x] = 0; // rip out clause
					}
				}
				// we ended the clause, check it
				currentClause = 0;
				currentVerb = 0;
			}
		}
		else if (!currentClause) currentClause = i;
		else if (posValues[i] & NOUN_GERUND && !currentVerb) currentVerb = i; // may be noun_gerund
		else if (roles[i] & VERB2 && !currentVerb) currentVerb = i; // may be noun_gerund

		if (!verbals[i])
		{
			if (currentVerbal) currentVerbal = 0;
		}
		else if (!currentVerbal) currentVerbal = i;


		// downgrade indirect object to direct when none there
		if (roles[i] & MAINVERB)
		{
			currentMainVerb = i;
			if (indirectObjectRef[i] && !objectRef[i]) SetRole(indirectObjectRef[i],MAINOBJECT,true,i);
			
			// if start is COMMAND and seems to have object but its not headed AND start might have been adjective- "*brave old dog"
			if (!subjectStack[MAINLEVEL] && posValues[i] & VERB_INFINITIVE  && allOriginalWordBits[i] & ADJECTIVE_NORMAL)
			{
				unsigned int obj = objectRef[i];
				unsigned int det;
				if (obj && !IsDeterminedNoun(obj,det))
				{
					LimitValues(i,ADJECTIVE_NORMAL,"command has undetermined object, become adjective phrase instead",changed);
					SetRole(i,0,true,i);
					SetRole(obj,0,true,i);
					return false; 
				}
			}
		}
		else if (roles[i] & VERB2)
		{
			if (indirectObjectRef[i] && !objectRef[i]) SetRole(indirectObjectRef[i],OBJECT2,true,i); // change object 
		}

		// when something was possible adjective participle over adjective, we accepted it. Now downgrade if has no object attached 
		// Particularly when participle describes a condition, not an action
		if (posValues[i] == ADJECTIVE_PARTICIPLE && !objectRef[i] && allOriginalWordBits[i] & ADJECTIVE_NORMAL && !(posValues[i+1] & PARTICLE)) // not "I found her *worn out"
		{
			LimitValues(i,ADJECTIVE_NORMAL,"adjective participle sans object downgraded to normal adjective",changed);
			roles[i] &= -1 ^ VERB2;
			verbals[i] = 0;
		}

		// remaining conflict adj/adv resolve to adverb "let us stand *still, and hear"
		if (posValues[i] & ADJECTIVE_BITS && posValues[i] & ADVERB_BITS)
		{
			if (posValues[i+1] & (NOUN_BITS|PRONOUN_BITS)) LimitValues(i,ADJECTIVE_BITS,"adj/adv pending resolved by being adjective in front of noun",changed);
			else if (parseFlags[i] & ADJECTIVE_NOT_SUBJECT_COMPLEMENT)  LimitValues(i,-1 ^ ADJECTIVE_BITS,"adj/adv pending resolved by adj suitable for subject complement",changed);
			// if verb is go then do not accept adj if could be adverb
			else if (canonicalLower[currentVerb] && !stricmp(canonicalLower[currentVerb]->word,"go"))
			{
				LimitValues(i, ADVERB_BITS,"for verb go we prefer adverb instead of subject complement",changed);
			}
			// do we still have a pending main need
			else  if (needRoles[MAINLEVEL] & SUBJECT_COMPLEMENT && roles[i-1] & MAINVERB)
			{
				LimitValues(i, ADJECTIVE_BITS,"we needed subject complement, so fill that in",changed);
			}
			
			else if (!verbStack[MAINLEVEL]) 
			{
				if (canSysFlags[i] & ADVERB) LimitValues(i,ADVERB_BITS,"adj/adv pending resolved by being probable adverb given no main verb exists",changed); // " Good!"
				else LimitValues(i,ADJECTIVE_BITS,"adj/adv pending resolved by being probable adjective given no main verb exists",changed); // " Good!"
			}
			else LimitValues(i,-1 ^ ADJECTIVE_BITS,"adj/adv pending resolved by rejecting adjective",changed);
		}

		// BUG  when something was participle VERB but had no object and could have been subject complement of "be" verb, alter it...
		if (false && roles[i] & MAINVERB && posValues[i] & (VERB_PRESENT_PARTICIPLE|VERB_PAST_PARTICIPLE) && allOriginalWordBits[i] & ADJECTIVE_NORMAL && !objectRef[i] && posValues[i-1] & AUX_BE)
		{
			LimitValues(i,ADJECTIVE_NORMAL,"verb tense with no object and could have been subject complement adjective, downgrade to normal adjective",changed);
			SetRole(i,SUBJECT_COMPLEMENT,true,i-1);

			uint64 tense = allOriginalWordBits[i-1] & VERB_TENSES;
			if (tense & VERB_PRESENT) LimitValues(i-1,VERB_PRESENT,"convert aux to present",changed);
			else if (tense & VERB_PRESENT_3PS) LimitValues(i-1,VERB_PRESENT_3PS,"convert aux to present 3ps",changed);
			else if (tense & VERB_PAST) LimitValues(i-1,VERB_PAST,"convert aux to past",changed);
			else if (tense & VERB_PAST_PARTICIPLE) LimitValues(i-1,VERB_PAST_PARTICIPLE,"convert aux to past particple",changed);
			SetRole(i-1,MAINVERB,true,i-1);
		}
		if (posValues[i] == COMMA) ++commas;
		if (!(roles[i] & MAINVERB) && posValues[i] & VERB_TENSES && !mainVerb  && !clauses[i] && !phrases[i] && !verbals[i]) mainVerb = i;  // 1st actual main verb if role not given yet
	
		// update after things, because VERB2 can be used as object of earlier VERB2 before becoming verb2 in its own right "let us stop and hear him *play the guitar"
		if (roles[i] & VERB2) currentVerb2 = i;
	}

	// was aux assigned as main verb, now we have actual verb?
	unsigned int assignedMainVerb = verbStack[MAINLEVEL]; // 1st verb
	if (assignedMainVerb && mainVerb && !roles[mainVerb] && allOriginalWordBits[assignedMainVerb] & (AUX_VERB_TENSES|AUX_BE|AUX_HAVE|AUX_DO)) // we dont know what this extraneous verb is doing
	{
		SetRole(assignedMainVerb,0);
		LimitValues(assignedMainVerb,allOriginalWordBits[assignedMainVerb] & (AUX_VERB_TENSES|AUX_BE|AUX_HAVE|AUX_DO),"changing aux from mainverb to aux",changed);
		LimitValues(mainVerb,allOriginalWordBits[mainVerb] & VERB_TENSES,"changing mainverb from unknown",changed);
		SetRole(mainVerb,MAINVERB,false,mainVerb);
		assignedMainVerb = mainVerb;
	}

	if (assignedMainVerb) mainVerb = assignedMainVerb;
	else if (mainVerb)
	{
		SetRole(mainVerb,MAINVERB,true,mainVerb); 
		if (trace & TRACE_POS) Log(STDUSERLOG,"Forcing found verb into main verb \"%s\"(%d)\r\n",wordStarts[mainVerb],mainVerb);
		if (objectRef[mainVerb] ) SetRole(objectRef[mainVerb],MAINOBJECT,true,mainVerb);
	}
	// found no main verb? resurrect a clause into main verb - prefer removal of clause modifying prep object
	else 
	{
		for (unsigned int i = start; i <= end; ++i)
		{
			if (ignoreWord[i]) continue;
			if (posValues[i] & VERB_TENSES && clauses[i] && phrases[i-1]) // verb w/o a role?
			{
				SetRole(i,MAINVERB,false,i); 
				if ( objectRef[i] ) SetRole(objectRef[i],MAINOBJECT,false,i);
				clauses[i] = 0;
				if (trace & TRACE_POS) Log(STDUSERLOG,"Lacking main verb, resurrect clause into main verb \"%s\"(%d)\r\n",wordStarts[i],i);
				break;
			}
		}
	}

	unsigned int assignedMainSubject = subjectStack[MAINLEVEL]; // 1st subject
	unsigned int assignedMainObject = objectRef[assignedMainVerb];
	
	// we have no mainverb or mainsubject, but we started with coordinating conjunction so downgrade to adverb if we can...
	if (!mainVerb && !assignedMainSubject && posValues[startSentence] & CONJUNCTION_BITS && allOriginalWordBits[startSentence] & ADVERB_BITS)
	{
		LimitValues(startSentence,ADVERB_BITS,"changing coordconjunct to adverb since no main sentence",changed);
		unsigned int c = clauses[startSentence];
		unsigned int at = startSentence - 1;
		while (clauses[++at] == c)
		{
			if (roles[at] & SUBJECT2 && !assignedMainSubject) 
			{
				SetRole(at,MAINSUBJECT);
				subjectStack[MAINLEVEL] = (unsigned char)at;
				assignedMainSubject = at;
			}
			if (roles[at] & VERB2 && !assignedMainVerb) 
			{
				SetRole(at,MAINVERB);
				verbStack[MAINLEVEL] = (unsigned char)at;
				mainVerb = assignedMainVerb = at;
				if (indirectObjectRef[at]) SetRole(indirectObjectRef[at],MAININDIRECTOBJECT,false,at);
				if (objectRef[at]) SetRole(objectRef[at],MAINOBJECT,false,at);
			}
			clauses[at] = 0;	// remove clause
		}
	}

	// no verb but have subject, and if we were coordinate conjunct that could have been prep, downgrade
	if (!mainVerb && assignedMainSubject && start != 1 && posValues[start-1] == CONJUNCTION_COORDINATE && 
		allOriginalWordBits[start-1] & PREPOSITION)
	{
		LimitValues(start-1,PREPOSITION,"no verb for conjunction, demote to prep",changed);
		SetRole(assignedMainSubject,OBJECT2,true,0);
		return false;
	}

	// main subject cant be in zone adjacent to verb, maybe appositve is bad: "Hamlet(A), the guy(S) who has to decide, decides(V) to stick it out for a while."
	if (mainVerb && assignedMainSubject && GetZone(assignedMainSubject) == (GetZone(mainVerb)-1))
	{
		unsigned int priorNoun = FindPriorNoun(assignedMainSubject);
		if (priorNoun && roles[priorNoun] & APPOSITIVE && GetZone(assignedMainSubject) == 1 && GetZone(priorNoun) == 0)
		{
			SetRole(priorNoun,MAINSUBJECT,true,0);
			SetRole(assignedMainSubject,APPOSITIVE,true,0);
			assignedMainSubject = priorNoun;
		}
	}

	// starting prep describes subject?
	if (posValues[start] & PREPOSITION && assignedMainSubject) crossReference[start] = (unsigned char)assignedMainSubject;

	if (assignedMainSubject && assignedMainVerb && (zoneMember[assignedMainVerb] - zoneMember[assignedMainSubject]) == 1 && clauses[assignedMainSubject]) // was this a clause and an imperative: "whoever comes to the door, ask them to wait"
	{
		if (allOriginalWordBits[assignedMainVerb] & VERB_INFINITIVE) // rewrite as imperative
		{
			SetRole(assignedMainSubject,SUBJECT2,true,0);
			LimitValues(assignedMainVerb,VERB_INFINITIVE,"clause is not subject, making sentence imperative",changed);
			assignedMainSubject = 0;
			subjectStack[MAINLEVEL] = 0;
		}
	}

	// here, Ned, jump out
	unsigned int zoneSubject = (assignedMainSubject) ? GetZone(assignedMainSubject) : 0;
	unsigned int zoneVerb = (assignedMainVerb) ? GetZone(assignedMainVerb) : 0;
	// "Hector, address the class"  is command, not subject, verb also "here, Ned, catch this"
	if (( zoneVerb - zoneSubject) == 1 && allOriginalWordBits[assignedMainVerb] & VERB_INFINITIVE && (zoneBoundary[zoneVerb] + 1) == assignedMainVerb)
	{
		if (trace & TRACE_POS) Log(STDUSERLOG,"Forcing subject in leading comma zone to be address \"%s\"(%d)\r\n",wordStarts[startSentence],1);
		SetRole(assignedMainSubject,ADDRESS,true,0);
		LimitValues(assignedMainVerb,VERB_INFINITIVE,"Force verb to be infinitive on command",changed);
		assignedMainSubject = 0;
	}
	
	////////////////////////////////////////////////////////////////////////////////
	///// This part can no longer revise pos tagging, only roles
	////////////////////////////////////////////////////////////////////////////////
	
	// if we have no subject, have an object, and it's not a command verb, object must become subject (particularly for clauses): "under the bed is *where we looked"
	if (assignedMainObject && !assignedMainSubject && assignedMainVerb && !(posValues[assignedMainVerb] & VERB_INFINITIVE))
	{
		SetRole(assignedMainObject,MAINSUBJECT,true,0);
		assignedMainSubject = assignedMainObject;
		assignedMainObject = 0;
	}

	for (unsigned int i = start; i <= end; ++i)
	{
		if (ignoreWord[i]) continue;
		if (posValues[i] & VERB_TENSES && !roles[i]) // verb w/o a role?
		{
			ProcessCommaClause(i,changed); // clause bounded by commas?
			ProcessSplitNoun(i,changed); // see if is clause instead
			ProcessReducedPassive(i,false,changed); // we carefully avoid verbs with object in this pass
			ProcessImpliedClause(i,changed);
			if (!clauses[i]) 
			{
				ProcessReducedPassive(i,true,changed); // allow objects to be accepted
				ProcessOmittedClause(i,changed);		  // whole seemingly second sentence
			}
		}
	}	

	// sentence starting in qword, not in a clause. maybe flip subject and object 
	if (subjectStack[MAINLEVEL] &&  !clauses[startSentence] && verbStack[MAINLEVEL] && objectRef[verbStack[MAINLEVEL]] && (allOriginalWordBits[startSentence] & QWORD || (allOriginalWordBits[startSentence] & PREPOSITION && allOriginalWordBits[2] & QWORD) ))
	{
		//  WHAT (what did john eat == john did eat what) 
		// but not when WHO (who hit the ball != the ball hit who)
		bool flip = true;
		unsigned int subj = subjectStack[MAINLEVEL];
		// NEVER flip particple verbs:   who is hitting the ball. What is hitting the ball.  what squashed the ball
		if (posValues[verbStack[MAINLEVEL]] & (VERB_PRESENT_PARTICIPLE|VERB_PAST_PARTICIPLE)) flip = false;
		else if (objectRef[verbStack[MAINLEVEL]] < subj) flip = false; // already flipped
		else if (!(allOriginalWordBits[subj] & QWORD)) flip = false; // "why did *john hit the ball"
		else if ((!stricmp(wordStarts[subj],"who") || !stricmp(wordStarts[subj],"which") || !stricmp(wordStarts[subj],"whoever") || !stricmp(wordStarts[subj],"whichever") || !stricmp(wordStarts[subj],"whatever") || !stricmp(wordStarts[subj],"what")) && !(parseFlags[verbStack[MAINLEVEL]] & VERB_TAKES_ADJECTIVE)) flip = false; // "*who will go" but not "who is president"
		// "which will bell the cat" does not flip but "which is the cat" will
		else flip = true;

		if (flip)
		{
			currentMainVerb = verbStack[MAINLEVEL];
			unsigned int newsubject = objectRef[currentMainVerb];
			unsigned int newobject = subjectStack[MAINLEVEL];
			SetRole(newobject, MAINOBJECT,true,currentMainVerb);
			if (posValues[newobject] == PRONOUN_SUBJECT) posValues[newobject] = PRONOUN_OBJECT;
			SetRole(newsubject,MAINSUBJECT,true,currentMainVerb);
			if (posValues[newsubject] == PRONOUN_OBJECT) posValues[newsubject] = PRONOUN_SUBJECT;
			if (trace & TRACE_POS) Log(STDUSERLOG,"Flipping subject and object due to qword start \"%s\"(%d)\r\n",wordStarts[newobject],newobject);
		}
	}

	// sentence starting in qword and ending in prep- remove qword as main object and make it OBJECT2 of prep
	if (end == endSentence && allOriginalWordBits[startSentence] & QWORD && posValues[end] == PREPOSITION && roles[startSentence] & MAINOBJECT)
	{
		SetRole(startSentence,OBJECT2,false,verbStack[MAINLEVEL]);
		if (allOriginalWordBits[startSentence] & PRONOUN_OBJECT) posValues[startSentence] = PRONOUN_OBJECT;
		if (trace & TRACE_POS) Log(STDUSERLOG,"Pronoun wrap to start, coercing start to object2 and maybe pronoun object \"%s\"(%d)\r\n",wordStarts[startSentence],startSentence);
	}

	// sentence starting with here or there as subject
	if (subjectStack[MAINLEVEL] && objectRef[verbStack[MAINLEVEL]] && verbStack[MAINLEVEL] && (!stricmp(wordStarts[subjectStack[MAINLEVEL]],"here") || !stricmp(wordStarts[subjectStack[MAINLEVEL]],"there"))) // HERE and THERE can not be the subject of a sentence:  here is the pig.. BUT  here is nice is legal.
	{
		unsigned int subject = subjectStack[MAINLEVEL];
		unsigned int object = objectRef[verbStack[MAINLEVEL]];
		if (trace & TRACE_POS) Log(STDUSERLOG,"Here/There cannot be subject, revise object\"%s\"(%d)\r\n",wordStarts[object],object);
		SetRole(subject,0,false,0); 
		if (!stricmp(wordStarts[subject],"here"))  LimitValues(subject,ADVERB_NORMAL,"Here as subject is adverb",changed);
		else if (posValues[subject] == THERE_EXISTENTIAL) {;}
		else LimitValues(subject,ADVERB_NORMAL,"Tere as subject is adverb not existential",changed); 
		SetRole(object,MAINSUBJECT,true,0);
	}

	//////////////////////////////////////////////////////////////
	// HOOK UP CROSS REFERENCES NOT YET HOOKED (phrases, aux, verbals, clauses
	//////////////////////////////////////////////////////////////

	for (unsigned int i = start; i <= end; ++i)
	{
		if (ignoreWord[i]) continue;
	
		// fix xref of aux to a verb
		if (posValues[i] & AUX_VERB_BITS)
		{
			for (unsigned int j = i+1; j <= endSentence; ++j)
			{
				if (posValues[j] & VERB_TENSES) // closest verb
				{
					crossReference[i] = (unsigned char) j;
					break;
				}
			}
		}
		if (posValues[i] & (PRONOUN_BITS|NOUN_BITS)) // find adjectives and determiners to bind to it
		{
			for (unsigned int j = i-1; j >= start; --j)
			{
				if (roles[j] & OMITTED_TIME_PREP){;} // dont link that to time
				else if (posValues[j] & (DETERMINER|PREDETERMINER|ADJECTIVE_BITS)) crossReference[j] = (unsigned char)i; 
				else if (posValues[j] & ADVERB_BITS) crossReference[j] = (unsigned char)(j+1); 
				else break; // no more to see
			}
		}

		if (posValues[i] & PRONOUN_POSSESSIVE) // link to what it possesses
		{
			unsigned int at = i;
			while (!(posValues[++at] & NOUN_BITS)) {;}
			crossReference[i] = (unsigned char) at;
		}

		if (posValues[i] & POSSESSIVE) // link to what it possesses
		{
			unsigned int at = i;
			while (!(posValues[++at] & NOUN_BITS)) {;}
			crossReference[i] = (unsigned char) at;  // Bob 's dog   has possessive linked to dog
			crossReference[i-1] = (unsigned char) i;	// Bob 's dog   has bob linked to possessive
		}

		if (posValues[i] & ADVERB_BITS)
		{
			if (posValues[i+1] & NOUN_BITS && parseFlags[i+1] & QUANTITY_NOUN) crossReference[i] = (unsigned char)(i + 1); // "*over half are there"
			else if (posValues[i+2] & NOUN_BITS && parseFlags[i+2] & QUANTITY_NOUN && posValues[i+1] & DETERMINER) crossReference[i] = (unsigned char)(i + 2); // "*over a third are there"
			else if (posValues[i-1] & ADJECTIVE_BITS && roles[i-1] & SUBJECT_COMPLEMENT && parseFlags[i] & ADVERB_POSTADJECTIVE) crossReference[i] = (unsigned char)(i - 1); // "he is powerful *enough"
			else if (posValues[i+1] & (ADJECTIVE_BITS|ADVERB_BITS)) crossReference[i] = (unsigned char)(i + 1); // if next is ADJECTIVE/ADVERB, then it binds to that?  "I like *very big olives"
			else if (posValues[i+1] & VERB_TENSES) //  next to next verb bind forward ("if this is tea please bring me sugar")
			{
				if (clauses[i+1]) clauses[i] = clauses[i+1];
				if (verbals[i+1]) verbals[i] = verbals[i+1];
				crossReference[i] = (unsigned char)(i + 1);
			}
			// adverb as object of prep...
			else if (posValues[i-1] & PREPOSITION && !stricmp(wordStarts[i-1], "from") && !(posValues[i+1] & (ADVERB_BITS|ADJECTIVE_BITS|DETERMINER_BITS|NOUN_BITS|PRONOUN_BITS)))
			{
				crossReference[i] = (unsigned char)(i + 1);
			}
			else // bind back to prior verb or forward to main verb 
			{
				if (clauses[i-1]) clauses[i] = clauses[i-1];
				if (verbals[i-1]) verbals[i] = verbals[i-1];
				if ( phrases[i-1]  && !phrases[i] && posValues[i-1] & NOUN_GERUND) phrases[i] = phrases[i-1];
				unsigned int prior = FindPriorVerb(i);
				if (prior) crossReference[i] = (unsigned char)prior;
				else if (!prior && i == startSentence && mainVerb) crossReference[i] = (unsigned char)mainVerb;
			}
		}

		// http://www.brighthubeducation.com/english-homework-help/46995-the-nominal-functions-of-prepositions-and-prepositional-phrases/
		// Phrases can act as adjective modifying a noun (ADJECTIVAL) , as an adverb modifying a verb (ADVERBIAL), or as a nominal when used in conjunction with "be".
		// The park is next to the hospital. The student is between an A and a B. The fight scene is before the second act.
		// The old farmhouse stood for years, after the revolution, by the fork in the road, beyond the orange grove, over the wooden bridge, at the farthest edge of the family's land, toward the great basin, down in the valley, under the old mining town, outside the city's limits, and past the end of the county maintained road.
		if (phrases[i] != phrases[i-1]  && phrases[i]) // start of a prep phrase, always needs hooking
		{
			unsigned int v = 0;
			bool adjectival = false;
			if (!(posValues[i] & PREPOSITION)) // is EITHER wrapped object from prep at end of clause or sentence, OR  its an ommited prep like omitted time prep
			{
				if (roles[i] & ABSOLUTE_PHRASE) adjectival = true;
				else if (i == 1 && roles[i] & OMITTED_TIME_PREP) // find first noun or verb to link onto
				{
					unsigned int j = i;
					while (++j < endSentence && phrases[j] == phrases[j-1]){;}
					while (!(posValues[j] & VERB_TENSES)) ++j;	 // find noun or verb
					v = j; // post verb
				}
				else if (roles[i] & OMITTED_TIME_PREP) v = FindPriorVerb(i); // xref is the verb BEFORE it
			}
			else
			{
				if (i == 1) // find first noun or verb to link onto
				{
					unsigned int j = i;
					while (++j < endSentence && phrases[j] == phrases[j-1]){;}
					while (!(posValues[j] & (NOUN_BITS|PRONOUN_BITS|VERB_TENSES))) ++j;	 // find noun or verb
					if (posValues[j] & (NOUN_BITS|PRONOUN_BITS)) adjectival = true;
					else v = j; // post verb
				}
				else v = FindPriorVerb(i); // xref is the verb BEFORE it

				if (posValues[i-1] & ADJECTIVE_BITS && !(parseFlags[i-1] & NONDESCRIPTIVE_ADJECTIVE) ) 
				{
					SetRole(i,ADJECTIVE_COMPLEMENT,false,0); // "I was shocked *by the news"
					crossReference[i] = (unsigned char)(i - 1);
					if (clauses[i-1]) ExtendChunk(i-1,GetPhraseTail(i),clauses);
					if (verbals[i-1]) ExtendChunk(i-1,GetPhraseTail(i),verbals);
				}
				else if (posValues[i-1] & (NOUN_BITS - NOUN_GERUND) && canSysFlags[i] & LOCATIONWORD) // it COULD describe the preceeding noun
				{
					SetRole(i,ADJECTIVAL,false,0); // "I made a home *of wood"
					crossReference[i] = (unsigned char)(i - 1);	// linked to noun
					adjectival = true;
					if (clauses[i-1]) ExtendChunk(i-1,GetPhraseTail(i),clauses);
					if (verbals[i-1]) ExtendChunk(i-1,GetPhraseTail(i),verbals);
				}
				// phrase as object of prep from... "I called from *within the house"
				else if (posValues[i-1] & PREPOSITION && !stricmp(wordStarts[i-1], "from"))
				{
					ExtendChunk(i-1,i,phrases);
					crossReference[i] = (unsigned char)(i - 1);
					adjectival = true;
				}
			}
			if (!adjectival)
			{
				AddRole(i,ADVERBIAL);  // "after passing *through the area"
				// set range of roles to resolve when we see its object
				bool when = false;
				bool where = false;
				bool why = false;
				bool how = false;
				if (canSysFlags[i] & TIMEWORD && !(canSysFlags[i] & (HOWWORD|LOCATIONWORD ))) when = true;
				else if (canSysFlags[i] & LOCATIONWORD && !(canSysFlags[i] & (HOWWORD|TIMEWORD)) ) where = true;
				else if ((canSysFlags[i] & (LOCATIONWORD | TIMEWORD|HOWWORD )) == (LOCATIONWORD | TIMEWORD |HOWWORD) ) where = when = how = true; // needs closer inspection, might be either, decide when we see the object
				else if ((canSysFlags[i] & (LOCATIONWORD | TIMEWORD )) == (LOCATIONWORD | TIMEWORD ) ) when = where = true;// needs closer inspection, might be either, decide when we see the object
				else if ((canSysFlags[i] & (TIMEWORD|HOWWORD )) == (TIMEWORD |HOWWORD) ) when = how = true; // needs closer inspection, might be either, decide when we see the object
				else if ((canSysFlags[i] & (LOCATIONWORD|HOWWORD) ) == (TIMEWORD |LOCATIONWORD) ) where = how = true; // needs closer inspection, might be either, decide when we see the object
				else how = true; // default is how if not when or where or why
				// if we dont know the prep role yet, assign it based on this object
				if (!(roles[i] & ADVERBIALTYPE) && when)
				{
					if (canonicalLower[i] && canonicalLower[i]->systemFlags & TIMEWORD) roles[i] |=  WHENUNIT;
				}
				if (!(roles[i] & ADVERBIALTYPE) && where)
				{
					if (canSysFlags[i] & LOCATIONWORD) roles[i] |= WHEREUNIT;
				}
				if (!(roles[i] & ADVERBIALTYPE)  && how) roles[i] |=  HOWUNIT;
				if (!(roles[i] & ADVERBIALTYPE)  && why) roles[i] |=  WHYUNIT;
				if (v) 
				{
					crossReference[i] = (unsigned char)v;
					if (clauses[v]) ExtendChunk(v,GetPhraseTail(i),clauses);
					if (verbals[v]) ExtendChunk(v,GetPhraseTail(i),verbals);
				}
			}
		}
		if (clauses[i] != clauses[i-1] && clauses[i] && !(roles[i] & (MAINSUBJECT|SUBJECT2|MAINOBJECT|OBJECT2))) // start of clause that needs hooking
		{
			if (roles[i-1] & (OBJECT2|MAINOBJECT|SUBJECT2|MAINSUBJECT)) // clause immediately after a noun item will be adjectival, describing that noun
			{
				crossReference[i] = (unsigned char) (i-1);
				AddRole(i,ADJECTIVAL);
			}
			else if (parseFlags[i] & CONJUNCTIONS_OF_ADVERB)
			{
				AddRole(i,ADVERBIAL);
				if (parseFlags[i] & CONJUNCTIONS_OF_TIME && !(parseFlags[i] & CONJUNCTIONS_OF_SPACE)) AddRole(i,WHENUNIT);
				if (!(parseFlags[i] & CONJUNCTIONS_OF_TIME) && parseFlags[i] & CONJUNCTIONS_OF_SPACE) AddRole(i,WHEREUNIT);
				
				// xref is the verb BEFORE it
				unsigned int v = FindPriorVerb(i);
				if (v) 
				{
					crossReference[i] = (unsigned char)v;
					if (verbals[v]) ExtendChunk(v,GetClauseTail(i),verbals);
				}
			}
		}

		// verbals (infintives, gerunds, participles)  can be adjective (participles are always adjectives) or adverb or noun (gerunds are always nounds)
		if (verbals[i] != verbals[i-1] && verbals[i])
		{
			if (coordinates[i] && coordinates[i] < i)  // cover chunk to here?
			{
				if (clauses[coordinates[i] ]) ExtendChunk(coordinates[i] ,GetVerbalTail(i),clauses); // cover us from same clause
			}
			while (i <= endSentence && !(roles[i] & VERB2)) ++i;	// find the verb to annotate
			if (roles[i] & (MAINSUBJECT|SUBJECT2|MAINOBJECT|OBJECT2|SUBJECT_COMPLEMENT|APPOSITIVE|OBJECT_COMPLEMENT)) {;} // already hook into role
			else if (roles[i-1] & (OBJECT2|MAINOBJECT|SUBJECT2|MAINSUBJECT|SUBJECT_COMPLEMENT)) // verbal  immediately after a noun item (or subject complement adjective) will be adjectival, describing that noun
			{
				crossReference[i] = (unsigned char) (i-1);
				AddRole(i,ADJECTIVAL);
				if (clauses[i-1]) ExtendChunk(i-1,GetVerbalTail(i),clauses);
			}
			else if (posValues[i] & NOUN_GERUND) 
			{
				// gerund a noun , marked as object2, mainsubject, etc
			}
			else if (posValues[i] & (VERB_PRESENT_PARTICIPLE|VERB_PAST_PARTICIPLE))
			{
				// might lead off sentence, describing subject -- "Hidden by the trees, Jerry waited to scare Mark."
				for (unsigned int j = start; j<= endSentence; ++j)
				{
					if (verbals[j] || phrases[j]) continue;
					if (posValues[j] & (NOUN_BITS|PRONOUN_BITS))
					{
						crossReference[i] = (unsigned char) j;
						AddRole(i,ADJECTIVAL);
					}
					else ReportBug("particple verbal must be adjective");
				}
			}
			else
			{
				AddRole(i,ADVERBIAL);
				unsigned int v = FindPriorVerb(i);
				if (v) 
				{
					crossReference[i] = (unsigned char)v;
					if (clauses[v]) ExtendChunk(v,GetVerbalTail(i),clauses);
				}
			}
		}
	}
	
	// migrate direct objects into clauses and verbals....  (should have been done already)
	for (unsigned int i = start; i <= end; ++i)
	{
		if (ignoreWord[i]) continue;
		if (!objectRef[i]) continue; // nothing interesting
		unsigned int object;
		unsigned int at;
		if (verbals[i])
		{
			unsigned int phrase = phrases[i];	// verbal might be object of a phrase
			at = i;

			// see if it has an object also...spread to cover that...
			while (at && (object = objectRef[at]) && object > at)
			{
				ExtendChunk(at,object,verbals);
				if (phrase) ExtendChunk(at,object,phrases);
				at = objectRef[at]; // extend to cover HIS object if he is gerund or infintiive
			}
		}
		if (clauses[i])
		{
			at = i;
			// see if it has an object also...spread to cover that...
			while (at && (object = objectRef[at])  && object > at)
			{
				ExtendChunk(at,object,clauses);
				at = objectRef[object]; // extend to cover HIS object
			}
		}
		if (phrases[i])
		{
			at = i;
			// see if it has an object also...spread to cover that... "after eating *rocks"
			while (at && (object = objectRef[at]) && object > at)
			{
				ExtendChunk(at,object,phrases);
				at = objectRef[at]; // extend to cover HIS object
			}
		}
	}

	// if we have OBJECT2 not in a clause or phrase.... maybe we misfiled it. "Hugging the ground, Nathan peered."
	if (resolved) for (unsigned int i = start; i <= end; ++i)
	{
		if (ignoreWord[i]) continue;
		if (!(roles[i] & OBJECT2) || phrases[i] || clauses[i] || verbals[i]) continue;
		if (subjectStack[MAINLEVEL] && subjectStack[MAINLEVEL] < i && posValues[subjectStack[MAINLEVEL]] == NOUN_GERUND) // the Verbal will be an adjective phrase on the main subject
		{
			SetRole(i,MAINSUBJECT,false,0);
			SetRole(subjectStack[MAINLEVEL],SUBJECT2,false,0);
		}
		// if subject is 1st word, after it is clause, and comma, then our phrase, migrate into clause -- those dressed in red, the men ate first
		if (subjectStack[MAINLEVEL] == 1 && clauses[start+1] && i < verbStack[MAINLEVEL]) // just assume it is right for now if is before main verb
		{
			SetRole(subjectStack[MAINLEVEL],SUBJECT2,false,0); // establishs transient subjectstack on wrong level but is fixed by next setrole
			SetRole(i, MAINSUBJECT,false,0);
			clauses[startSentence] = clauses[startSentence+1];
		}
	}

	roles[end] |= SENTENCE_END;  // we mark end of sentence
	return true;
}

static int FindCoordinate(int i) // i is on comma
{
	int comma2 = 0;
	while ((unsigned int) ++i < endSentence)
	{
		if (posValues[i] & COMMA) comma2 = i; // there is a comma
		if (posValues[i] & CONJUNCTION_COORDINATE)
		{
			if (comma2 == (i-1)) return i; // conjunction immediately after a second comma is a clear end of sequence
		}
	}
	return -1; // didnt find
}

static void DoCoord(unsigned int i, unsigned int before, unsigned int after, uint64 type)
{
	SetRole(i,type);	
	if (type != CONJUNCT_SENTENCE) SetRole(after,roles[before]); // pass along any earlier role
	crossReference[after] = crossReference[before];
	if ((type == CONJUNCT_NOUN || type == CONJUNCT_VERB))
	{
		// if he has previously filled a noun role, we need to request it again
		if (roles[before] & (SUBJECT2 | MAINSUBJECT | MAINOBJECT | OBJECT2 )) needRoles[roleIndex] |= roles[before] & (SUBJECT2 | MAINSUBJECT | MAINOBJECT | OBJECT2 );
		else if (roles[before] & (VERB2|MAINVERB)) 
		{
			needRoles[roleIndex] |= roles[before];
			needRoles[roleIndex] &= -1 ^ (OBJECT2|MAINOBJECT|OBJECT_COMPLEMENT|SUBJECT_COMPLEMENT); // cant have these intruding after the and or comma
		}
	}

	// form or continue a ring - x AND y  where y loops back to x
	unsigned int hook = coordinates[before]; // loop onto any prior ring 
	if (!hook || hook > before) hook = before; // if already hooked later, dont use that hook. it should be part of earlier loop
	coordinates[after] = (unsigned char)hook;
	coordinates[before] = (unsigned char)i;
	coordinates[i] = (unsigned char)after;
	if (phrases[before]) ExtendChunk(before,after,phrases); // expand dual object in prep phrase
	if (trace & TRACE_POS) Log(STDUSERLOG,"Conjunct %s(%d) joins %s(%d) with %s(%d) hooked at %d\r\n",wordStarts[i],i,wordStarts[before],before,wordStarts[after],after,hook);

	// if what we conjoin is a chunk, extend the chunk to cover us also
	if (phrases[before] && type == CONJUNCT_NOUN) ExtendChunk(before,after,phrases);  // multiple objects in phrase
	if (verbals[before] && type == CONJUNCT_NOUN && !(posValues[after] & (NOUN_GERUND|NOUN_INFINITIVE))) ExtendChunk(before,after,verbals);   // multiple objects in verbal
	if (clauses[before]) ExtendChunk(before,after,clauses); // can span mulitple verbs or subjects or objects
}

static void ForceNounPhrase(unsigned int i, bool &changed) // insure things before are proper words
{
	while (--i  >= startSentence && !(posValues[i] & CONJUNCTION_COORDINATE))
	{
		if (bitCounts[i] != 1 && posValues[i] & (ADJECTIVE_BITS|DETERMINER))
		{
			LimitValues(i,ADJECTIVE_BITS|DETERMINER,"ForceNounPhrase",changed);
		}
	}
}

static unsigned int NearestProbableNoun(unsigned int i)
{
	while (++i < endSentence)
	{
		if (posValues[i] & (PRONOUN_BITS|NOUN_BITS) && (posValues[i] & (PRONOUN_BITS) || bitCounts[i] == 1 || (originalLower[i] && originalLower[i]->systemFlags & NOUN))) break; // probable noun
	}
	return (i <= endSentence) ? i : 0;
}

static unsigned int NearestProbableVerb(unsigned int i)
{
	while (++i < endSentence)
	{
		if (posValues[i] & (VERB_TENSES|AUX_VERB_BITS) && (bitCounts[i] == 1 || (originalLower[i] && originalLower[i]->systemFlags & VERB))) break; // probable verb
	}
	return (i <= endSentence) ? i : 0;
}

static int ConjoinPhrase(unsigned int i, bool &changed)
{
	unsigned int before = i - 1;
	unsigned int after = i + 1;
	if (posValues[before] == COMMA) --before;					
	// do before NOUN because of issues about noun at end of phrase being involved. more likely prep phrases than dual noun, but can test for prep

	if (posValues[after] & PREPOSITION && posValues[before] & (NOUN_BITS|PRONOUN_BITS))  
	{
		int r = before;
		while (--r) // prove phrase matching going on
		{
			if (! (posValues[r] & (NOUN_BITS|DETERMINER|PREDETERMINER|ADJECTIVE_BITS|ADVERB_BITS))) break;
		}
		if ( posValues[r] & PREPOSITION) 
		{
			SetRole(i, CONJUNCT_PHRASE);
			coordinates[i] = (unsigned char)r;
		}
		if (trace) Log(STDUSERLOG,"DuplicatePhrase");
		return 0;
	}

	// phrase before and possible preposition after
	if (phrases[before] && posValues[after] & PREPOSITION)  
	{
		unsigned int deepBefore = before;
		while (deepBefore && phrases[deepBefore] == phrases[deepBefore-1]) --deepBefore; // find the prep
		if (bitCounts[after] != 1) // can we force preposition on after?
		{
			if (LimitValues(after,PREPOSITION,"forcing PREPOSITION conflict to clear conjunction after",changed)) return GUESS_RETRY;
		}
		if (posValues[deepBefore] == posValues[after]) // preps now match
		{
			DoCoord(i,deepBefore,after,CONJUNCT_PHRASE);
			return 0;
		}
	}
	// phrase after and possible preposition before
	if (phrases[after] && posValues[after] & PREPOSITION && !phrases[before])  
	{
		unsigned int deepBefore = before;
		while (deepBefore && posValues[deepBefore] & (NOUN_BITS|ADJECTIVE_BITS|DETERMINER|PREDETERMINER)) --deepBefore; // find the prep if any
		if (posValues[deepBefore] & PREPOSITION && bitCounts[deepBefore] != 1) // can we force preposition on after?
		{
			if (LimitValues(deepBefore,PREPOSITION,"forcing PREPOSITION conflict to clear conjunction before",changed)) return GUESS_RETRY;
		}
		if (posValues[deepBefore] == posValues[after]) // preps now match
		{
			DoCoord(i,deepBefore,after,CONJUNCT_PHRASE);
			return 0;
		}
	}
	return -1;
}

static int ConjoinAdjective(unsigned int i, bool &changed)
{
	unsigned int before = i - 1;
	unsigned int after = i + 1;
	if (posValues[before] == COMMA) --before;					

		// after any coord one might have an intervening adverb to ignore like "I like dogs but rarely cats" or "I like dogs and often cats"
	while (posValues[after] == ADVERB_NORMAL && after < endSentence) ++after;

	// simple ADJECTIVE  "green and red beets"  
	int deepAfter = after;
	while (posValues[deepAfter] & ADVERB_BITS && !(posValues[deepAfter] & ADJECTIVE_BITS)) ++deepAfter;	// "I like green *and very red ham" can skip adverbs intervening
	if (posValues[before] & ADJECTIVE_BITS && posValues[deepAfter] & ADJECTIVE_BITS) 
	{
		if (bitCounts[before] == 1 && bitCounts[deepAfter] != 1) 
		{
			if (LimitValues(deepAfter,ADJECTIVE_BITS,"forcing ADJECTIVE conflict to clear conjunction after",changed)) return GUESS_RETRY;
		}
		else if (bitCounts[deepAfter] == 1  && bitCounts[before] != 1) 
		{
			if (LimitValues(before,ADJECTIVE_BITS,"forcing ADJECTIVE conflict to clear conjunction before",changed)) return GUESS_RETRY;
		}
		if (bitCounts[deepAfter] == 1 &&  bitCounts[before] == 1)
		{
			DoCoord(i,before,deepAfter,CONJUNCT_ADJECTIVE);
			return 0;
		}
	}
	return -1;
}

static int ConjoinNoun(unsigned int i, bool &changed)
{
	unsigned int before = i - 1;
	unsigned int after = i + 1;
	if (posValues[before] == COMMA) --before;		

	unsigned int deepBefore = i;
	while (--deepBefore && !(posValues[deepBefore] & NOUN_INFINITIVE)){;}

	if (posValues[deepBefore] & NOUN_INFINITIVE && posValues[after] & NOUN_INFINITIVE)
	{
		LimitValues(after, NOUN_INFINITIVE,"forcing NOUN infinitive after conjoin",changed);
		DoCoord(i,deepBefore,after,CONJUNCT_NOUN);
		return 0;
	}

	// conjoin noun-infinitive?
	if (posValues[before] == NOUN_INFINITIVE)
	{
		unsigned int deepAfter = i;
		while (++deepAfter <= endSentence)
		{
			if (posValues[deepAfter] & (NOUN_BITS | VERB_TENSES | AUX_VERB_BITS)) break;
		}
		if (posValues[deepAfter] & NOUN_INFINITIVE)
		{
			DoCoord(i,before,deepAfter,CONJUNCT_NOUN);
			LimitValues(deepAfter, NOUN_INFINITIVE,"forcing NOUN infinitive after conjoin",changed);
			return 0;
		}
	}
	
	unsigned int deepAfterVerb = after;
	if (needRoles[roleIndex] & (SUBJECT2|MAINSUBJECT)){;} // wont be sentence conjoin
	else if (!(needRoles[roleIndex] & (OBJECT2|MAINOBJECT)))
	{
		while (++deepAfterVerb < endSentence && !(posValues[deepAfterVerb] & (COMMA|CONJUNCTION_COORDINATE)))
		{
			if (posValues[deepAfterVerb] & VERB_TENSES) break;	 // possible verb
		}
	}

	// simple NOUN after "ate rocks and greens" 
	// But be careful about noun when might be prep phrase instead being paired

	if (posValues[before] & (PRONOUN_BITS|NOUN_BITS) && posValues[after] &  (PRONOUN_BITS|NOUN_BITS) && !(posValues[deepAfterVerb] & VERB_TENSES)) 
	{
		if (bitCounts[after] == 1  && bitCounts[before] != 1) 
		{
			if (LimitValues(before, (PRONOUN_BITS|NOUN_BITS),"forcing NOUN conflict to clear conjunction before",changed)) return GUESS_RETRY;
		}
		if (bitCounts[after] != 1  && bitCounts[before] == 1) 
		{
			if (LimitValues(after, (PRONOUN_BITS|NOUN_BITS),"forcing NOUN conflict to clear conjunction after",changed)) return GUESS_RETRY;
		}
		if (bitCounts[after] == 1 &&  bitCounts[before] == 1) // before and after are known
		{
			DoCoord(i,before,after,CONJUNCT_NOUN);
			ForceNounPhrase(after,changed);
			return 0;
		}
	}

	// known noun before and described noun after (simple noun would already be done by now)
	if (posValues[before] &  (PRONOUN_BITS|NOUN_BITS) && bitCounts[before] == 1 && posValues[after] & (DETERMINER|ADVERB_BITS|ADJECTIVE_BITS|POSSESSIVE_BITS)  && bitCounts[after] == 1) 
	{
		int deepAfter = after;
		while (posValues[deepAfter] & (DETERMINER|ADVERB_BITS|ADJECTIVE_BITS|POSSESSIVE_BITS)) ++deepAfter;
		if (deepAfter <= (int)endSentence && posValues[deepAfter] &  (PRONOUN_BITS|NOUN_BITS))
		{
			if (bitCounts[deepAfter] != 1) 
			{
				if (LimitValues(deepAfter, (PRONOUN_BITS|NOUN_BITS),"forcing NOUN conflict to clear conjunction after",changed)) return GUESS_RETRY;
			}
			if (bitCounts[deepAfter] == 1 &&  bitCounts[before] == 1)
			{
				DoCoord(i,before,deepAfter,CONJUNCT_NOUN);
				ForceNounPhrase(deepAfter,changed);
				return 0;
			}
		}
	}

	int deepAfter = after;
	while (posValues[deepAfter] & (DETERMINER|ADVERB_BITS|ADJECTIVE_BITS|POSSESSIVE_BITS)) 
	{
		if (posValues[deepAfter] & NORMAL_NOUN_BITS) break;
		++deepAfter;
	}

	// known noun before (mainsubject) and verb still pending, be NOUN coord on mainsubject 
	if (roleIndex == MAINLEVEL && needRoles[roleIndex] & MAINVERB && posValues[i-1] & NORMAL_NOUN_BITS && roles[i-1] & MAINSUBJECT) // be main subject conjunct
	{
		DoCoord(i,before,deepAfter,CONJUNCT_NOUN);
		ForceNounPhrase(deepAfter,changed);
		return 0;
	}

	// known noun after w/o following verb or adverb, hunt for before
	if (posValues[after] & NOUN_BITS && bitCounts[after] == 1 && !(posValues[after+1] & (ADVERB_BITS|AUX_VERB_BITS|VERB_TENSES)))
	{
		int deepBefore = i;
		while (--deepBefore) 
		{
			if (posValues[deepBefore] & NOUN_BITS && bitCounts[deepBefore] == 1)
			{
				DoCoord(i,deepBefore,after,CONJUNCT_NOUN);
				ForceNounPhrase(after,changed);
				return 0;
			}
		}
	}
	
	if (!(needRoles[MAINLEVEL] & (MAINSUBJECT|MAINVERB))) 
	{
		// if prior was a direct object and we have only a few words left, replicate it
		unsigned int noun = NearestProbableNoun(i);
		unsigned int verb = NearestProbableVerb(i);
		if (roles[before] & MAINOBJECT && (int)noun > i && !verb ) // we have some noun we could find, and no verb to make into a clause maybe
		{
			needRoles[MAINLEVEL] |= MAINOBJECT;
			roles[i] = CONJUNCT_NOUN;
			return 0;
		}
	}

	// dual object? "what a big nose he has, *and big eyes too"
	if (objectRef[currentMainVerb] && posValues[deepAfter] & NOUN_BITS)
	{
		DoCoord(i,objectRef[currentMainVerb],deepAfter,CONJUNCT_NOUN);
		ForceNounPhrase(deepAfter,changed);
		return 0;
	}

	return -1;
}

static int ConjoinVerb(unsigned int i, bool &changed)
{
	unsigned int before = i - 1;
	unsigned int after = i + 1;
	if (posValues[before] == COMMA) --before;					
	unsigned int firstAfter = i;
	while (++firstAfter <= endSentence && !(posValues[firstAfter] & (NOUN_INFINITIVE|VERB_TENSES))){;}		// forward to a potential verbal 

	int deepBefore = i;
	while (--deepBefore && !(posValues[deepBefore] & (VERB_TENSES|NOUN_INFINITIVE))) {;}

	// closest verbal after precludes a subject for a sentence match
	if (posValues[deepBefore] & NOUN_INFINITIVE && posValues[firstAfter] & (NOUN_INFINITIVE|VERB_INFINITIVE) && firstAfter == (i + 1)) // "she taught him how to lace his boots, make his bed, and eat food."
	{
		if (LimitValues(firstAfter,NOUN_INFINITIVE,"Forcing noun infinitive as closest match",changed)) return GUESS_RETRY; 
		return -1;
	}

	// simple verb after matches verb before (adverb already sorted out earlier) "he danced and pranced"
	if (posValues[after] & VERB_TENSES) 
	{
		if (deepBefore) // tense must match up as possible "he pulled carrots and *dip" cannot match up verbs
		{
			uint64 tense = posValues[deepBefore] & VERB_TENSES;
			if (posValues[after] & tense) // maybe can match up verb tenses
			{
				if (LimitValues(after,tense,"Forcing tense match for AND verb",changed)) return GUESS_RETRY;
				if (posValues[deepBefore] == posValues[after]) // tenses now match
				{
					DoCoord(i,deepBefore,after,CONJUNCT_VERB);
					return 0;
				}
			}
			else if (posValues[after] & AUX_VERB_BITS) // "she is coming *and can scamper"
			{
				if (LimitValues(after,AUX_VERB_BITS,"Forcing tense aux for AND verb",changed)) return GUESS_RETRY;
				DoCoord(i,deepBefore,after,CONJUNCT_VERB);
				return 0;
			}
			// cannot match up verb tenses
			else
			{
				if (bitCounts[after] > 1 && bitCounts[deepBefore] == 1) 
				{
					if (LimitValues(after,-1 ^ VERB_TENSES,"tenses dont line up for AND, so remove verb potential",changed)) return GUESS_RETRY;
				}
			}
		}
	}
	
	if (posValues[before] & PARTICLE)  // he stood up and quickly ran  down the street
	{
		unsigned int deepBefore = before;
		while (--deepBefore > 2) if ( posValues[deepBefore] & (VERB_TENSES|NOUN_INFINITIVE)) break;
		unsigned int deepAfter = after -1;
		while (++deepAfter <= endSentence)
		{
			if ( posValues[deepAfter] & (VERB_TENSES|NOUN_INFINITIVE|NORMAL_NOUN_BITS|DETERMINER)) break;
		}
		uint64 val = posValues[deepAfter] & (VERB_TENSES|NOUN_INFINITIVE);
		if (val & posValues[deepBefore] ) // verbs both there (same tense?)
		{
			DoCoord(i,deepBefore,deepAfter,CONJUNCT_VERB);
			return 0;
		}
	}
	
	unsigned int deepAfter = i;
	while (++deepAfter <= endSentence && !(posValues[deepAfter] & VERB_TENSES)) // forward to a potential verb 
	{	
		if (posValues[deepAfter] & (NOUN_BITS|PRONOUN_BITS)) return -1;	// cannot have intervening noun. might be sentence
	}

	if (posValues[deepAfter] & VERB_TENSES && verbStack[MAINLEVEL] && posValues[deepAfter] & NOUN_BITS) // verb/noun conflict... "what a big nose you have, and big eyes too"
	{
		if (posValues[deepAfter-1] & ADVERB_BITS) return -1; // wont have an adverb BEFORE the verb when conjoined
	}

	if (posValues[deepAfter] & VERB_TENSES && verbStack[MAINLEVEL]) // we and to a verb... expect this to be WORD
	{
		if (LimitValues(deepAfter,VERB_TENSES,"conjoined after is VERB",changed)) return GUESS_RETRY;
		SetRole(i,CONJUNCT_VERB);
		unsigned int verb = i;
		while (--verb && !(posValues[verb] & VERB_TENSES)); // find verb before
		SetRole(deepAfter,roles[verb]);	// copy verb role from before
		coordinates[i] = (unsigned char)verb;
		if (roles[deepAfter] & MAINVERB && canSysFlags[i] & (VERB_DIRECTOBJECT|VERB_INDIRECTOBJECT)) // change to wanting object(s)
		{
			needRoles[MAINLEVEL] |= MAINOBJECT;
			if ( canonicalLower[i]->properties & VERB_INDIRECTOBJECT) needRoles[MAINLEVEL] |= MAININDIRECTOBJECT;
			if (trace) Log(STDUSERLOG,"DuplicateVerb");
		}
	}

	return -1;
}

static int ConjoinImmediate(unsigned int i, bool & changed)
{
	unsigned int before = i - 1;
	unsigned int after = i + 1;
	if (posValues[before] == COMMA) --before;			
	
	// conjoin adjective?
	if (posValues[before] & (ADJECTIVE_NORMAL|ADJECTIVE_PARTICIPLE))
	{
		if (posValues[after] & (ADJECTIVE_NORMAL|ADJECTIVE_PARTICIPLE)) // "how soft and *white its fur is"
		{
			LimitValues(after, (ADJECTIVE_NORMAL|ADJECTIVE_PARTICIPLE),"forcing simple adjective or participle adjective after conjoin",changed);
			LimitValues(before, (ADJECTIVE_NORMAL|ADJECTIVE_PARTICIPLE),"forcing simple adjective or participle adjective before conjoin",changed);
			DoCoord(i,before,after,CONJUNCT_ADJECTIVE);
			return 0;
		}
	}
	// conjoin adverb?
	if (posValues[before] & ADVERB_BITS)
	{
		if (posValues[after] & ADVERB_BITS)
		{
			LimitValues(after, ADVERB_BITS,"forcing simple adverb after conjoin",changed);
			DoCoord(i,before,after,CONJUNCT_ADVERB);
			return 0;
		}
	}
	// conjoin infinitive or gerund
	if (posValues[before] & (NOUN_INFINITIVE|NOUN_GERUND))
	{
		if (posValues[after] & (NOUN_INFINITIVE|NOUN_GERUND))
		{
			LimitValues(after, (NOUN_INFINITIVE|NOUN_GERUND),"forcing noun infinitive/gerund conjoin",changed);
			DoCoord(i,before,after,CONJUNCT_NOUN);
			return 0;
		}
	}

	// conjoin noun?
	if (posValues[before] & ((NOUN_BITS  |PRONOUN_BITS) ^ NOUN_INFINITIVE))
	{
		unsigned int deepAfter = after;
		if (bitCounts[deepAfter] == 1 && posValues[deepAfter] & SIGNS_OF_NOUN_BITS) // we know a noun follows
		{
			--deepAfter;
			while (++deepAfter <= endSentence)
			{
				if (posValues[deepAfter] & (NOUN_BITS|PRONOUN_BITS)) break; // but may be wrong one
			}
		}
		else deepAfter = 0;
		if (deepAfter && posValues[deepAfter] & (NOUN_BITS|PRONOUN_BITS)) // "I like apples and *Bob"
		{
			// cannot conjoin if followed by verb
			unsigned int thereafter = deepAfter;
			while (++thereafter <= endSentence)
			{
				if (posValues[thereafter] & (CONJUNCTION_BITS|COMMA)) break;
				if (posValues[thereafter] & (AUX_VERB_BITS|VERB_TENSES)) break;
			}
			if (posValues[thereafter] & (AUX_VERB_BITS|VERB_TENSES)) return -1; // cannot safely conjoin, might be conjoining sentences "I like apples and *Bob likes gold"
			else
			{
				LimitValues(deepAfter, NOUN_BITS|PRONOUN_BITS,"forcing simple noun/pronoun conjoin",changed);
				DoCoord(i,before,deepAfter,CONJUNCT_NOUN);
				return 0;
			}
		}
	}

	// conjoin verb?
	if (posValues[before] & VERB_TENSES)
	{
		if (posValues[after] & VERB_TENSES && !(posValues[after] & NORMAL_NOUN_BITS))
		{
			uint64 tenses = posValues[before] & VERB_TENSES;
			if (posValues[after] & tenses)
			{
				LimitValues(after, tenses,"forcing simple verb matching tense conjoin",changed);
			}
			else LimitValues(after, VERB_TENSES,"forcing simple verb conjoin",changed);
			DoCoord(i,before,after,CONJUNCT_VERB);
			return 0;
		}
	}

	return -1;
}

static bool FlipPrepToConjunction(unsigned int i,bool question, bool changed) // at the verb we detect
{
	unsigned int prep = GetPhraseHead(i-1);
	if (!(posValues[prep] & PREPOSITION)) return false;	// phrase at i-1 is BAD!!!
	if (allOriginalWordBits[prep] & CONJUNCTION_SUBORDINATE && !clauses[prep]) // BUG- but if prep ended clause, then we wouldn't know...
	{
		LimitValues(prep,CONJUNCTION_SUBORDINATE ,"unexpected verb after phrase, convert prep to subord clause",changed);
		if (question) return true;
		unsigned int object = objectRef[prep];
		ErasePhrase(prep);
		if (posValues[object] & PRONOUN_OBJECT) LimitValues(object,PRONOUN_SUBJECT,"switching to pronoun subject to use as subject",changed);
		return true;
	}
	else if (allOriginalWordBits[prep] & CONJUNCTION_COORDINATE && !clauses[prep])
	{
		LimitValues(prep,CONJUNCTION_COORDINATE ,"unexpected verb after phrase, convert prep to coord clause",changed);
		if (question) return true;
		unsigned int object = objectRef[prep];
		ErasePhrase(prep);
		if (posValues[object] & PRONOUN_OBJECT) LimitValues(object,PRONOUN_SUBJECT,"switching to pronoun subject to use as subject",changed);
		return true;
	}
	return false;
}

static  int ConjoinAdverb(unsigned int i, bool &changed)
{
	unsigned int before = i - 1;
	unsigned int after = i + 1;
	if (posValues[before] == COMMA) --before;					

	// simple ADVERB before  "moved quickly and quietly"  
	if (posValues[before] & ADVERB_BITS && posValues[after] & ADVERB_BITS) 
	{
		bool badmix = false;
		// - but not if a verb is before and after like "they worked hard and then walked"
		if (posValues[before-1] & (VERB_INFINITIVE|VERB_PAST|VERB_PRESENT|VERB_PRESENT_3PS) && posValues[after+1] & (VERB_INFINITIVE|VERB_PAST|VERB_PRESENT|VERB_PRESENT_3PS) && 
			bitCounts[after+1] == 1) badmix = true; // know verb after
		 // dont mix time and OTHER adverbs with and
		else if ((canSysFlags[before] & TIMEWORD) != (canSysFlags[after] & TIMEWORD)) badmix = true;
		else if (bitCounts[before] == 1 && bitCounts[after] != 1) 
		{
			if (LimitValues(after,ADVERB_BITS,"forcing ADVERB conflict to clear conjunction after",changed)) return GUESS_RETRY;
		}
		else if (bitCounts[after] == 1  && bitCounts[before] != 1) 
		{
			if (LimitValues(before,ADVERB_BITS,"forcing ADVERB conflict to clear conjunction before",changed)) return GUESS_RETRY;
		}
		if (!badmix && bitCounts[after] == 1 &&  bitCounts[before] == 1)
		{
			DoCoord(i,before,after,CONJUNCT_ADVERB);
			return 0;
		}
	}
	return -1;
}

static bool CanBeStdAdjective(unsigned int i)
{
	if (!(posValues[i] & ADJECTIVE_BITS)) return false;
	if (bitCounts[i] == 1) return true;

	// check forward for possible noun
	while (++i <= endSentence)
	{
		if (posValues[i] & NOUN_BITS) break;
		if (posValues[i] & (ADVERB_BITS|ADJECTIVE_BITS)) continue; // part of sequence
		if (posValues[i] & (DETERMINER|PREDETERMINER|PREPOSITION)) break; // cannot find a noun after this
		if (posValues[i] & (AUX_VERB_BITS|VERB_TENSES)) break; // since wasnt possibly something else, this ends hunt
	}

	return (posValues[i] & NOUN_BITS) ? true : false;
}

static unsigned int HandleCoordConjunct(unsigned int i,bool &changed) // determine kind of conjunction- 
{// Word (adjective/adjectve, adverb/adverb, noun/noun, verb/verb) 
 // Phrase/Clause/Sentence
	//  x coord y will be linked in a ring structure.

	if (!stricmp(wordStarts[i],"so") || !stricmp(wordStarts[i],"for")) // these only do sentences
	{
		SetRole(i,CONJUNCT_SENTENCE); 
		return 0;
	}

	unsigned int comma = lastConjunction;
	if (comma) // bind the way we did before
	{
		uint64 match = 0;
		match = posValues[coordinates[comma]];	// what is being bound
		if (match & NOUN_INFINITIVE) match = NOUN_INFINITIVE | VERB_INFINITIVE;
		else if (match & (NOUN_BITS | PRONOUN_BITS)) match = NOUN_BITS | PRONOUN_SUBJECT | PRONOUN_OBJECT;
		else if (match & VERB_TENSES) match = VERB_TENSES;
		else if (match & ADJECTIVE_BITS) match = ADJECTIVE_BITS;
		else if (match & ADVERB_BITS) match = ADVERB_BITS;
		else match = 0;
		unsigned int deepAfter = i;
		while (++deepAfter <= endSentence)
		{
			if (posValues[deepAfter] & match) // closest matching type
			{
				if (posValues[coordinates[comma]] & NOUN_INFINITIVE) match = NOUN_INFINITIVE; // convert verb infintiive to noun
				LimitValues(deepAfter,match,"Forcing comma match of pos",changed);
				break;
			}
			// if we want to match a verb but find a noun or pronoun that could be subject, will have to be a coord clause instead "let us run and jump *and that will keep us warm"
			if (match & VERB_TENSES && posValues[deepAfter] & (PRONOUN_BITS|NOUN_BITS))
			{
				deepAfter = endSentence;
			}
		}
		if (deepAfter <= endSentence)	
		{
			DoCoord(i,coordinates[comma],deepAfter,roles[comma]);
			return 0;
		}
	}
	
	// find the first match from scratch to determine the type

	int result = ConjoinImmediate(i,changed); // try for most LOCAL matching
	if (result >= 0) return result;

	result = ConjoinAdverb(i,changed);
	if (result >= 0) return result;
	
	result = ConjoinAdjective(i,changed);
	if (result >= 0) return result;

	// test for verb match first before noun, since maybe we can confirm nouns on tense...
	result = ConjoinVerb(i,changed);
	if (result >= 0) return result;

	result = ConjoinPhrase(i,changed); 
	if (result >= 0) return result;
	
	result = ConjoinNoun(i,changed);
	if (result >= 0) return result;

	// BUG not handling conjunction of clause
	
	unsigned int before = i - 1;
	if (posValues[before] == COMMA) --before;					

	if (roleIndex > 1 && subjectStack[MAINLEVEL] && verbStack[MAINLEVEL] && subjectStack[2])
	{
		DoCoord(i,subjectStack[MAINLEVEL],subjectStack[2],CONJUNCT_SENTENCE);
		return 0;
	}
	else if (!(needRoles[MAINLEVEL] & (MAINSUBJECT|MAINVERB))) // can it be sentence we need
	{
		// if prior was a direct object and we have only a few words left, replicate it
		unsigned int noun = NearestProbableNoun(i);
		unsigned int verb = NearestProbableVerb(i);
		if (roles[before] & MAINOBJECT && (int)noun > i && !verb ) {;} // we have some noun we could find, and no verb to make into a clause maybe
		else if (noun && verb > noun) // we can find a potential noun and verb in succession, so assume it is a sentence
		{
			SetRole(i,CONJUNCT_SENTENCE); 
		}
	}
	// we dont know what it binds to yet--- might be mainsubject, might be to a current verbal
	if (trace) Log(STDUSERLOG,"bind Conjunct=%s(%d)\r\n",wordStarts[i],i);
	return 0;
}

static void DropLevel()
{
	if (trace) Log(STDUSERLOG,"Dropped Level %d\r\n",roleIndex);
	--roleIndex;
}

static void CloseLevel(int  i)
{
	while (roleIndex > 1 ) 
	{
		unsigned int at = i;
		if (needRoles[roleIndex] & PHRASE) // closes out a phrase, drag phrase over it
		{
			if (needRoles[roleIndex] & OBJECT2) break;	 // need vital stuff
			if (posValues[at] & COMMA) --at; // stop before here
			if (!phrases[at]) ExtendChunk(lastPhrase,at,phrases);
			lastPhrase = 0;
		}
		else if (needRoles[roleIndex] & CLAUSE) // closes out a clause, drag clause over it
		{
			if (needRoles[roleIndex] & (SUBJECT2|VERB2)) break;	// need vital stuff
			if (needRoles[roleIndex] != CLAUSE && posValues[at] != COMMA) break;	// we think we need something and its still going
			if (posValues[at] & COMMA) --at; // stop before here
			if (!clauses[at]) ExtendChunk(lastClause,at,clauses);
			lastClause = 0;
		}
		else if (needRoles[roleIndex] & VERBAL) // closes out a verbal, drag verbal over it
		{
			if (needRoles[roleIndex] & VERB2) break;	// need vital stuff
			if (needRoles[roleIndex] != VERBAL && posValues[at] != COMMA) break;	// we think we need something and its still going
			if (posValues[at] & COMMA) --at; // stop before here
			if (!verbals[at]) ExtendChunk(lastVerbal,at,verbals);
			lastVerbal = 0;
		}

		DropLevel(); 	// level complete (not looking for anything anymore)
	}
}

static void DecodeneedRoles(unsigned int x,char* buffer)
{
	*buffer = 0;
	if (needRoles[x] & MAINSUBJECT) strcat(buffer," MainSubject");
	if (needRoles[x] & MAINVERB) strcat(buffer," MainVerb");
	if (needRoles[x] & MAININDIRECTOBJECT) strcat(buffer," MainIO");
	if (needRoles[x] & MAINOBJECT) strcat(buffer," Mainobj");

	if (needRoles[x] & SUBJECT2) strcat(buffer," Subject2");
	if (needRoles[x] & VERB2) strcat(buffer," Verb2");
	if (needRoles[x] & INDIRECTOBJECT2) strcat(buffer," Io2");
	if (needRoles[x] & OBJECT2) strcat(buffer," Obj2");

	if (needRoles[x] & PHRASE) strcat(buffer," Phrase:");
	if (needRoles[x] & CLAUSE) strcat(buffer," Clause:");
	if (needRoles[x] & VERBAL) strcat(buffer," Verbal:");
	if (!(needRoles[x] & (PHRASE|CLAUSE|VERBAL))) strcat(buffer," Main:");
	
	if (needRoles[x] & SUBJECT_COMPLEMENT) strcat(buffer," SubCompl"); // adjective as object
	if (needRoles[x] & OBJECT_COMPLEMENT) strcat(buffer," ObjCompl"); // usually adjective after object "paint his car *purple"
	if (needRoles[x] & TO_INFINITIVE_OBJECT) strcat(buffer," verb-toinfinitive-object");
	if (needRoles[x] & VERB_INFINITIVE_OBJECT) strcat(buffer," verb-infinitive-object");
}

static void SeekObjects(unsigned int i) // this is a verb, what objects does it want
{
	if (!verbStack[roleIndex]) verbStack[roleIndex] = (unsigned char)i;	// this is the verb for this level
	
	if (roleIndex == MAINLEVEL && objectRef[currentMainVerb] && !coordinates[i]) // main verb has an objects already (qword like in "what do you *like to do") - but not if we have a coordinating word verb needing own object
	{
		if (*wordStarts[objectRef[currentMainVerb]] == '"') // quoted object
		{
			crossReference[objectRef[currentMainVerb]] = (unsigned char) i;
			needRoles[roleIndex] &= -1 ^ (MAINOBJECT|MAININDIRECTOBJECT|OBJECT2|INDIRECTOBJECT2);
			if (!subjectStack[roleIndex] && !(needRoles[roleIndex] & (SUBJECT2|MAINSUBJECT))) needRoles[roleIndex] |= (roleIndex == MAINLEVEL) ? MAINSUBJECT : SUBJECT2;
		}

		if (objectRef[currentMainVerb] < currentMainVerb) return; // object was presupplied
	}

	if (canonicalLower[i] == DunknownWord)  // unknown verb -- presume takes object and indirect object and maybe object complement
	{ // presumed NOT a linking verb, so cannot take SUBJECT_COMPLEMENT.
		if (roleIndex == MAINLEVEL) needRoles[MAINLEVEL] |= MAININDIRECTOBJECT | MAINOBJECT | OBJECT_COMPLEMENT;
		else needRoles[roleIndex] |= OBJECT2 | INDIRECTOBJECT2 | OBJECT_COMPLEMENT;
		return;
	}

	if (canSysFlags[i] & VERB_DIRECTOBJECT) // change to wanting object(s)
	{
		// if a question, maybe object already filled in "what dog do you like"
		if (roleIndex == MAINLEVEL && ( !objectRef[currentMainVerb] || coordinates[i])) 
		{
			needRoles[roleIndex] |= MAINOBJECT;
			if (parseFlags[i] & (FACTITIVE_ADJECTIVE_VERB|FACTITIVE_NOUN_VERB))  needRoles[roleIndex] |= OBJECT_COMPLEMENT; // "we made him *happy"  "we elected him *president"
			else if (canSysFlags[i] & (VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE|VERB_TAKES_INDIRECT_THEN_TOINFINITIVE))  needRoles[roleIndex] |= OBJECT_COMPLEMENT; // "we want him to go"
		}
		else if (roleIndex > MAINLEVEL && (!objectRef[currentVerb2] || coordinates[i])) 
		{
			needRoles[roleIndex] |= OBJECT2;
			if (parseFlags[i] & (FACTITIVE_ADJECTIVE_VERB|FACTITIVE_NOUN_VERB))  needRoles[roleIndex] |= OBJECT_COMPLEMENT; // "we made him *happy"  "we elected him *president"
			else if (canSysFlags[i] & (VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE|VERB_TAKES_INDIRECT_THEN_TOINFINITIVE))  needRoles[roleIndex] |= OBJECT_COMPLEMENT; // "we want him to go"
		}
		// are you able to drive a car wants object2 for car
	}

	// various infinitives in object positions
	if (canSysFlags[i] & VERB_TAKES_INDIRECT_THEN_TOINFINITIVE)  // "I allowed John *to run"
	{
		if ( !(posValues[i+1] & (DETERMINER | PREDETERMINER | ADJECTIVE | ADVERB | PRONOUN_OBJECT  | PRONOUN_POSSESSIVE | NOUN_BITS))); // must come immediately
		else needRoles[roleIndex] |= TO_INFINITIVE_OBJECT | ((roleIndex == MAINLEVEL) ? MAININDIRECTOBJECT : INDIRECTOBJECT2);
	}
	if (canSysFlags[i] & VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE) // "he made John *run"
	{
		if ( !(posValues[i+1] & (DETERMINER | PREDETERMINER | ADJECTIVE | ADVERB | PRONOUN_OBJECT  | PRONOUN_POSSESSIVE | NOUN_BITS))); // must come immediately
		else needRoles[roleIndex] |= VERB_INFINITIVE_OBJECT | ((roleIndex == MAINLEVEL) ? MAININDIRECTOBJECT : INDIRECTOBJECT2);
	}
	if (canSysFlags[i] & VERB_TAKES_TOINFINITIVE) // proto 28 "Somebody ----s to INFINITIVE"   "we agreed to plan"
	{
		needRoles[roleIndex] |= TO_INFINITIVE_OBJECT;
	}
	if (canSysFlags[i] & VERB_TAKES_VERBINFINITIVE) // proto 32, 35 "Somebody ----s INFINITIVE"   "Something ----s INFINITIVE"
	{
		needRoles[roleIndex] |= VERB_INFINITIVE_OBJECT; 
	}

	if (canSysFlags[i] & VERB_INDIRECTOBJECT) 
	{
		if ( !(posValues[i+1] & (DETERMINER | PREDETERMINER | ADJECTIVE | ADVERB | PRONOUN_OBJECT  | PRONOUN_POSSESSIVE | NOUN_BITS))); // must come immediately
		else needRoles[roleIndex] |=  (roleIndex == MAINLEVEL) ? MAININDIRECTOBJECT : INDIRECTOBJECT2;
	}
	
	if (canSysFlags[i] & VERB_TAKES_ADJECTIVE)  
	{
		needRoles[roleIndex] |= SUBJECT_COMPLEMENT; // linking verbs expect adjective  "he is pretty"
		needRoles[roleIndex] |= (roleIndex == MAINLEVEL) ? MAINOBJECT : OBJECT2; // but may take objects instead "he seems a fool"
	}

	// verb wants noun complement - we will eventually have to decide on object complement vs indirect object, but when we could be both, we wait
	if (parseFlags[i] & FACTITIVE_NOUN_VERB)  needRoles[roleIndex] |= OBJECT_COMPLEMENT;
}

static bool IsLegalAddress(unsigned int first)
{
	unsigned int start = startSentence;
	if (*wordStarts[start] == '"') ++start; // ignore quote
	unsigned int end = endSentence;
	if (*wordStarts[end] == '"') --end; // ignore quote
	if (posValues[end] & PUNCTUATION) --end; // ignore terminator
	// simple address
	if (posValues[first] & NOUN_PROPER_SINGULAR && posValues[first-1] == COMMA && first == end) return true; // tail "I hate you, Barbara"
	if (posValues[first] & NOUN_PROPER_SINGULAR && posValues[first+1] == COMMA && first == start && posValues[first+2] & PRONOUN_SUBJECT) return true; // tail "Barbara, I hate you"

	return false;
}

static bool PossibleNounAfter(unsigned int i)
{
	while (++i <= endSentence)
	{
		if (posValues[i] & (NOUN_BITS|PRONOUN_BITS)) return true;
	}
	return false; // wrong when ambigious pronoun at end wraps to front   BUG
}

bool IsDeterminedNoun(unsigned int i,unsigned int& det)
{
	if (posValues[i] & ( NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL | NOUN_PLURAL | PRONOUN_BITS)) // needs no determiner
	{
		det = i;
		return true;
	}

	if (allOriginalWordBits[i] & (NOUN_MASS | NOUN_NODETERMINER))	// mass nouns need none also, same for special nouns	
	{
		det = i;
		return true;
	}

	// singular nouns must be determined  - "my cat, dog" is not legal but "my cat, a dog" is -- or a title like "Julie Winter president of the club" or "CEO Tom"
	// a possessived noun is also determined "John's cat"
	det = i - 1;
	while (det > 1 && posValues[det] & (ADJECTIVE_BITS|ADVERB_BITS) && !(posValues[det] & (ADJECTIVE_NUMBER|NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL|COMMA|CONJUNCTION_BITS))) 
	{
		--det;
	}
	return  (posValues[det] & (DETERMINER|POSSESSIVE_BITS|ADJECTIVE_NUMBER)) ? true : false;
}

static bool IsLegalAppositive(unsigned int first, unsigned int second)
{
	if (!(posValues[first] & (NOUN_SINGULAR|NOUN_PLURAL|NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL|NOUN_NUMBER)) || bitCounts[first] != 1) return false;
	if (!(posValues[second] & (NOUN_SINGULAR|NOUN_PLURAL|NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL|NOUN_NUMBER)) || bitCounts[second] != 1) return false;

	// first is proper, 2nd is not and 1st is not human and is adjacent
	if (posValues[first] & NOUN_PROPER_SINGULAR && posValues[second] & (NOUN_SINGULAR|NOUN_PLURAL) && !(allOriginalWordBits[first] & NOUN_HUMAN) && (second-first) < 2) return false;

	// nouns must be determined or proper - "my cat, dog" is not legal but "my cat, a dog" is -- or a title like "Julie Winter president of the club" or "CEO Tom"
	unsigned int det1, det2;
	if (!IsDeterminedNoun(first,det1)) return false;
	if (!IsDeterminedNoun(second,det2)) return false;

	// cannot have both using the "the cat, the dog" is illegal. But "A cat, a fine species" is legal
	if (!stricmp(wordStarts[det1],"the") && !stricmp(wordStarts[det2],"the")) return false;

	return true;
}

static bool ProcessOmittedClause(unsigned int verb,bool &changed) // They were certain (they were happy)
{
	if (clauses[verb]) return false;	// already done
	unsigned int subject = verb;
	while (subject)
	{
		if (posValues[--subject] & (NOUN_BITS | PRONOUN_BITS)) break;
		if (posValues[subject] & (AUX_VERB_BITS|ADVERB_BITS)) continue;
		return false;
	}
	if (!subject) return false;

	AddClause(subject,"omitted clause");
	SeekObjects(verb);
	SetRole(verb,VERB2,true);
	SetRole(subject,SUBJECT2,true);
	if (posValues[subject] == PRONOUN_OBJECT) 
	{
		LimitValues(subject,PRONOUN_SUBJECT,"omitted clause subject goes from object to subject pronoun",changed);
	}
	ExtendChunk(subject,verb,clauses);
	if (needRoles[roleIndex] == CLAUSE) DropLevel();  // now down maybe...
	changed = true;
	return true;
}

static void HandleComplement(unsigned int i,bool & changed)
{
	// this cannot be an indirect object
	if (posValues[i] & PRONOUN_OBJECT && !(lcSysFlags[i] & PRONOUN_INDIRECTOBJECT)) needRoles[roleIndex] &= -1 ^ (MAININDIRECTOBJECT|INDIRECTOBJECT2);
	if (posValues[i] & (NOUN_GERUND|NOUN_INFINITIVE|VERB_TENSES)) needRoles[roleIndex] &= -1 ^ (MAININDIRECTOBJECT|INDIRECTOBJECT2);	// cannot be indirect object with these...

	// object complements are handled elsewhere
	unsigned int subject = needRoles[roleIndex] & (SUBJECT2|MAINSUBJECT);
	unsigned int indirectObject = needRoles[roleIndex] & (MAININDIRECTOBJECT|INDIRECTOBJECT2);
	unsigned int directObject = needRoles[roleIndex] & (MAINOBJECT|OBJECT2);

	unsigned int priorNoun = FindPriorNoun(i);
	unsigned int currentVerb = verbStack[roleIndex]; 

// beware: Dogs, my favorite animals, are swift.   SUBJECT/APPOSITIVE/PREDICATE
// vs Bill, I hate you.	ADDRESS/SENTENCE 
// Bill, dogs, those fast creatures, can outrun you. ADDRESS/SUBJECT/APPOSITIVE/PREDICATE
//  Fleeing home, they left.
// walking home, my favorite activity, happens often. - gerund, appositive, predicate  OR  adjectivepariticle, subject, predicate (cannot be)
//  subject, predicate is not a possible format...  subject, description, predicate is possible
	// predicate object is not a possible format either.

	// having no expected use for gerund, is it a comma'ed off appositive
	if (posValues[i] & NOUN_GERUND && !indirectObject && !directObject && !subject && !(zoneData[zoneIndex] & ZONE_FULLVERB)) // is this an appositivie gerund "his goal, walking briskly, was in sight"
	{
		unsigned int at = i;
		while (--at)
		{
			if (posValues[at] & COMMA) break;
			if (posValues[at] & NOUN_BITS) break;
		}
		if (at && posValues[at] & COMMA && posValues[at-1] & NORMAL_NOUN_BITS) // we are in zone after ending noun.
		{
			SetRole(i,APPOSITIVE);
			return;
		}
	}

	// infinitives
	if (posValues[i] & (NOUN_INFINITIVE|VERB_INFINITIVE)) 
	{
		unsigned int indirect = indirectObjectRef[currentVerb];
		if (indirect && needRoles[roleIndex] & OBJECT_COMPLEMENT) // change format to mainobject + complement for causals like "I caused Ben to think" and "I make Ben think"
		{
			SetRole(indirect,(roleIndex == MAINLEVEL) ? MAINOBJECT : OBJECT2,true); 
			SetRole(i,OBJECT_COMPLEMENT,false);
		}
		else if (subject && needRoles[roleIndex] & (SUBJECT2|MAINSUBJECT)) SetRole(i,(roleIndex == MAINLEVEL) ? MAINSUBJECT : SUBJECT2,true);
		else if (needRoles[roleIndex] & (OBJECT2|MAINOBJECT)) SetRole(i,(roleIndex == MAINLEVEL) ? MAINOBJECT : OBJECT2,true); 
		// otherwise is just part of verbal
		else if (posValues[i] & NOUN_INFINITIVE)
		{
			unsigned int at = i;
			while (--at > startSentence && !(posValues[at] & TO_INFINITIVE)) {;} // locate the to
			// adjective expects a modifier infinitive phrase
			if (posValues[at-1] & ADJECTIVE_NORMAL && parseFlags[at-1] & ADJECTIVE_TAKING_NOUN_INFINITIVE)  SetRole(i,ADJECTIVE_COMPLEMENT);
			else if (posValues[at-1] & (NOUN_SINGULAR)) SetRole(at,POSTNOMINAL_ADJECTIVE); // postnominal adjective
			// trailing or embedded appositive -- "his wish, to eat, was fulfilled"
			else if (posValues[at-1] == COMMA && roles[at-2] & (OBJECT2|MAINOBJECT|SUBJECT2|MAINSUBJECT) ) SetRole(i,APPOSITIVE);
		}
		return;
	}
	
	// indirect object in normal speech must be an animate being.  But "I told the mountain my name" would be legal, just uncommon.
	if (indirectObject )
	{
		//if (posValues[i+1] == VERB_INFINITIVE ) indirectObject = 0;	// cannot be an indirect object
		//else 
		if (originalLower[i] && originalLower[i]->properties & (NOUN_PROPER_SINGULAR | NOUN_PROPER_PLURAL | NOUN_HUMAN | PRONOUN_SUBJECT | PRONOUN_OBJECT )) // proper names are good as are pronouns
		{
		}
		else if (canSysFlags[i] & ANIMATE_BEING) // animate beings are good
		{
		}
		else if (i > 1 && IsUpperCase(*wordStarts[i])){;} // anything uppercase not 1st word is good
		else 
		{
			if (trace & TRACE_POS && (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"Abandoning indirect object at %s nonanimate\r\n",wordStarts[i]);
			needRoles[roleIndex] &= -1 ^ (MAININDIRECTOBJECT|INDIRECTOBJECT2); 
			indirectObject = 0;
		}
	}
retry:
	if (subject)
	{
		if (predicateZone == -1) {;}									// never located verb yet (ambiguous or missing)
		else if ((int)currentZone == predicateZone) {;}							// zone data says this will be subject since must happen before verb
		else if ((predicateZone - currentZone) == 1 && roleIndex == MAINLEVEL && !(zoneData[currentZone] & ZONE_AMBIGUOUS)) subject = 0;			// cannot have main subject in zone immediately before predicate unless its a clause zone
		else if (zoneData[predicateZone] & ZONE_SUBJECT && roleIndex == MAINLEVEL) subject = 0;		// main sentence is elsewhere
		
		// initial zone cannot support verb which is in next zone with subject, so we are apposive if noun zone
		if (currentZone == 0 && zoneData[0] & ZONE_SUBJECT && !(zoneData[0] & ZONE_VERB) && !clauses[i-1] && !verbals[i-1] && !phrases[i-1] && 
			(zoneData[1] & (ZONE_SUBJECT|ZONE_FULLVERB)) == (ZONE_SUBJECT|ZONE_FULLVERB)) 
		{
			subject = 0;
			SetRole(i,APPOSITIVE);
		}
		else if (i < 3 && roleIndex == MAINLEVEL && needRoles[MAINLEVEL] & MAINSUBJECT && IsLegalAddress(i)) SetRole(i,ADDRESS);
		else if (subject)
		{
			// seeking subject but this is noun matching ending prep, with qword heading, so cant be subject "*who did you give your number to" or 
			if (i == firstnoun && posValues[endSentence] & PREPOSITION && originalLower[startSentence] && originalLower[startSentence]->properties & QWORD)
			{
				SetRole(i,OBJECT2);
			}
			else
			{
				if (roles[i] & (OBJECT2|MAINOBJECT) && clauses[i]) AddRole(i,subject); // clause fulfilling mainobject role or object2 role
				else SetRole(i,subject);
			}
			// guessed appostive now has US as appositive clause, so revert and make him subject - "my mom, whose name is, is"
			if (roleIndex == 2 && lastClause && priorNoun && currentZone && zoneBoundary[currentZone] > priorNoun && priorNoun > zoneBoundary[currentZone-1] && roles[priorNoun] & APPOSITIVE)
			{
				AddRole(i,APPOSITIVE); // we are HIS appositive
				--roleIndex;
				SetRole(priorNoun,MAINSUBJECT,true);
				++roleIndex;
		}
		}
		else if ( posValues[i] & NOUN_NUMBER) // cannot be appositive (except-  "John, the first, went home" maybe)
		{
		}
		return;
	}
	// main sentence ending in preposition, with Qword at front, qword becomes OBJECT2--- Eg. who are you afraid of -- but not what dog are you afraid of
	else if (roleIndex == MAINLEVEL && directObject && posValues[i] & (PRONOUN_BITS) && posValues[endSentence] == PREPOSITION  && canonicalLower[startSentence] && canonicalLower[startSentence]->properties & QWORD )
	{
		unsigned int oldsubject = subjectStack[roleIndex];
		SetRole(i,MAINSUBJECT,true);
		SetRole(oldsubject,MAINOBJECT,true);
		directObject = 0;
	}
	// sentence starting with qword determiner (which and what for example) or possessive (whose) on this noun  "what fruit do you like"
	else if (roleIndex == MAINLEVEL && posValues[startSentence] & (DETERMINER|PRONOUN_POSSESSIVE) && canonicalLower[startSentence]->properties & QWORD )
	{
		unsigned int oldsubject = subjectStack[roleIndex];
		SetRole(i,MAINSUBJECT,true);
		SetRole(oldsubject,MAINOBJECT,true);
		if (posValues[oldsubject] & PRONOUN_SUBJECT)  ForceValues(i,PRONOUN_OBJECT,"Forcing object pronoun",changed);
		
		needRoles[roleIndex] &= -1 ^ (OBJECT_COMPLEMENT|MAININDIRECTOBJECT); // in addition to ones cleared by setrole
		if (posValues[i] & PRONOUN_OBJECT)  ForceValues(i,PRONOUN_SUBJECT,"Forcing subject pronoun",changed);
		directObject = 0;
	}
	// sentence starting with qword, have bound subject on it, seeing noun (not in clause or phrase or verbal) but havent seen MAINVERB yet
	else if (roleIndex == MAINLEVEL && canonicalLower[startSentence] && canonicalLower[startSentence]->properties & QWORD  && needRoles[roleIndex] & MAINVERB)  // what are *you doing
	{
		unsigned int oldsubject = subjectStack[roleIndex];
		needRoles[MAINLEVEL] |= MAINSUBJECT|MAINOBJECT;	// enable role revision
		SetRole(oldsubject,MAINOBJECT,true);
		if (posValues[oldsubject] == PRONOUN_SUBJECT) ForceValues(startSentence,PRONOUN_OBJECT,"Forcing object pronoun",changed);
		SetRole(i,MAINSUBJECT,true);
		if (posValues[i] & PRONOUN_OBJECT)  ForceValues(i,PRONOUN_SUBJECT,"Forcing subject pronoun",changed);
		directObject = 0;
	}
	else if (indirectObject )
	{
		if (posValues[i] & PRONOUN_SUBJECT) ForceValues(i,PRONOUN_OBJECT,"Forcing object pronoun for indirect object",changed);

		bool allowedIndirect = false;
		// can be indirect ONLY if next thing is known a noun indicator (including gerund)
		// except for causal verbs expecting To Infinitive
		unsigned int currentVerb = verbStack[roleIndex];
		while (coordinates[currentVerb] && coordinates[currentVerb] < i && coordinates[currentVerb] > currentVerb) currentVerb = coordinates[currentVerb]; // find most recent verb if conjoined
		if (AcceptsInfinitiveObject(currentVerb) )
		{
			allowedIndirect = true; // causal verb can be in any tense--- "he painted his jalopy black"
		}
		else if (needRoles[roleIndex] & TO_INFINITIVE_OBJECT  && posValues[i+1] & NOUN_INFINITIVE) allowedIndirect = true;
		else if (posValues[i+1] & (SIGNS_OF_NOUN_BITS|TO_INFINITIVE))
		{
			if (posValues[i+1] & ADJECTIVE_BITS && (i+1) == endSentence) {;} // if sentence ends in adjective, this is not indirect obj - eg "This made *Jen mad"
			else allowedIndirect = true;
		}
		if (allowedIndirect)
		{
			SetRole(i,indirectObject);
			directObject = 0;
		}
		else
		{
			indirectObject = 0;
			goto retry;
		}
	}
	else if (directObject )
	{
		// if this is NOUN and verb was factitive, revise to not have indirect object - "they elected the milkman president"  "they named our college the best" -- but not "joey found his baby bottle" but "he found the baby unpleasant"
		if (roleIndex == MAINLEVEL && parseFlags[currentMainVerb] & FACTITIVE_NOUN_VERB && indirectObjectRef[currentMainVerb] && posValues[i] & NOUN_BITS)  
		{
			SetRole(indirectObjectRef[currentMainVerb],MAINOBJECT,true);
			SetRole(i,OBJECT_COMPLEMENT);
		}
		// if this is NOUN and verb was factitive, revise to not have indirect object - "they elected the milkman president"  "they named our college the best" -- but not "joey found his baby bottle" but "he found the baby unpleasant"
		else if (roleIndex > MAINLEVEL && parseFlags[currentVerb2] & FACTITIVE_NOUN_VERB && indirectObjectRef[currentVerb2] && posValues[i] & NOUN_BITS)  
		{
			SetRole(indirectObjectRef[currentVerb2], OBJECT2);
			SetRole(i,OBJECT_COMPLEMENT);
		}
		// singular direct object must be determined or possessed or mass or Proper -- "I walked my dog" not "I walked dog"
		else if (roleIndex == MAINLEVEL && (currentZone - predicateZone ) == 1 && !roles[i]) // illegal for object to be in adjacent zone unless it was a propogated already role from Coord conjunct - "tom sent email, cards, and letters"
		{
		}
		else
		{
			if (posValues[i] & PRONOUN_SUBJECT) ForceValues(i,PRONOUN_OBJECT,"Forcing object pronoun",changed);
			SetRole(i,directObject);
			if (needRoles[roleIndex] & VERBAL) 
			{
				ExtendChunk(lastVerbal,i,verbals);
				DropLevel(); 
				lastVerbal = 0;
			}
			if (needRoles[roleIndex] & CLAUSE) 
			{
				unsigned int prior = FindPriorVerb(i);
				if (prior) crossReference[i] = (unsigned char)prior;		// link from object to clause verb
				ExtendChunk(lastClause,i,clauses);
				DropLevel(); 
				lastClause = 0;
			}
			if (needRoles[roleIndex] & PHRASE)
			{
				crossReference[i] = (unsigned char) lastPhrase; // objects point back to prep that spawned them
				ExtendChunk(lastPhrase,i,phrases);
				DropLevel(); 
				lastPhrase = 0;
			}
		}
	}		
	else if (roleIndex == MAINLEVEL && needRoles[roleIndex] == 0 && IsLegalAddress(i) && !coordinates[i]) SetRole(i,ADDRESS);
	// simple superfluous noun immediately follows simple noun used as object, presume he was adjective_noun
	else if (!subject && !directObject && roles[i-1] & OBJECT2 && posValues[i-1] & NOUN_SINGULAR && posValues[i] & (NOUN_SINGULAR|NOUN_PLURAL))
	{
		roles[i] = OBJECT2; // direct object assign, no level associated any more probably
		roles[i-1] = 0;
		verbals[i] = verbals[i-1];
		phrases[i] = phrases[i-1];
		clauses[i] = clauses[i-1];
		LimitValues(i-1,ADJECTIVE_NOUN,"superfluous noun forcing prior noun to adjective status",changed);
	}
	else if (!(posValues[i] & (NOUN_INFINITIVE|NOUN_GERUND)) && priorNoun && phrases[priorNoun] && !lastPhrase && (i - priorNoun) < 5) // there was a prep object, now finished, are we appostive to it - "John Kennedy the popular US president was quite different from John Kennedy the unfaithful *husband."
	{
		SetRole(i,APPOSITIVE);
		ExtendChunk(priorNoun,i,phrases);
	}
	// appositives will be next noun (not being used as adjective)
	else if (objectRef[currentVerb] && objectRef[currentVerb] < i) // object happens earlier 
	{
		int base = i;
		while (--base > objectRef[currentVerb]) if (posValues[base] & CONJUNCTION_COORDINATE) break;
		if (posValues[base] & CONJUNCTION_COORDINATE && (roles[base] & CONJUNCT_KINDS) == CONJUNCT_NOUN) // later must match earlier
		{
			unsigned int after = coordinates[base];
			unsigned int before = coordinates[after];
			SetRole(i,roles[before]);
		}
		else if (needRoles[roleIndex] & SUBJECT2) SetRole(i,SUBJECT2);
		else if (needRoles[roleIndex] & OBJECT_COMPLEMENT && verbStack[roleIndex] && objectRef[currentVerb]) SetRole(i,OBJECT_COMPLEMENT);
		else if (base == objectRef[currentVerb] && !(posValues[i] & (NOUN_GERUND|NOUN_INFINITIVE))) SetRole(i,APPOSITIVE); // or form of address
		else  SetRole(i,OBJECT2); // unknown
	}
	else if (subjectStack[roleIndex] && subjectStack[roleIndex] < i) // subject happens earlier 
	{
		if (needRoles[roleIndex] == ( CLAUSE | VERB2)) // clause has subject, was it qword?
		{
			// change subject to object and us be subject
			if (originalLower[subjectStack[roleIndex]] && originalLower[subjectStack[roleIndex]]->properties & QWORD && roles[subjectStack[roleIndex]] & SUBJECT2)
			{
				SetRole(subjectStack[roleIndex],OBJECT2);
				SetRole(i,SUBJECT2);
				return;
			}
		}

		// can this be actual object instead of subject complement structure?
		unsigned int at = i;
		while (--at > startSentence)
		{
			if (roles[at] & SUBJECT_COMPLEMENT) break;
			if (posValues[at] & (DETERMINER_BITS|ADJECTIVE_BITS)) {;}
			else break;  // not the right thing
		}
		if (roles[at] & SUBJECT_COMPLEMENT) // change this over
		{
			SetRole(at,0,true);
			if (allOriginalWordBits[at] & DETERMINER_BITS) 
			{
				LimitValues(at,DETERMINER_BITS,"convert subject complement to determiner of some kind",changed);
			}
			SetRole(i,(roleIndex == MAINLEVEL) ? MAINOBJECT : OBJECT2,true);
			return;
		}

		int base = i;
		while (--base > subjectStack[roleIndex]) if (posValues[base] & CONJUNCTION_COORDINATE) break; 
		if (coordinates[i] && coordinates[i] < 1){;} // coord copies the role
		else if ( verbStack[roleIndex] && subjectStack[roleIndex] < verbStack[roleIndex] && i > verbStack[roleIndex]) 
		{
			SetRole(i,OBJECT2); // handles "the man was eager to *die" - adjective_object can take a complement sometimes
		}
		else if (base == subjectStack[roleIndex] && IsLegalAppositive(base,i)) // appostive SUBJECT?
		{
			// if the word before is ALSO a noun appositive, convert it to an adjective noun
			if (roles[i-1] & APPOSITIVE && posValues[i-1] & NOUN_BITS)
			{
				roles[i-1] = 0;
				LimitValues(i-1,ADJECTIVE_NOUN,"Forcing prior noun appositive to be adjective noun",changed); 
				if (trace & TRACE_POS) Log(STDUSERLOG,"Forcing prior noun appositive to be adjective noun %s\r\n",wordStarts[i-1]);
			}
			SetRole(i,APPOSITIVE); 
		}
		else if (!roles[i])  SetRole(i,SUBJECT2); // unknown
		// or form of address
	}
	 // presuming it is appositive after noun :  "I hit my friend *George"
}

static void ShowZone(unsigned int zone)
{
	if (zoneData[zone] & ZONE_AMBIGUOUS) Log(STDUSERLOG,"Ambiguous zone, ");
	else if (zoneData[zone] & ZONE_ABSOLUTE) Log(STDUSERLOG,"Absolute zone, ");
	else if ((zoneData[zone] & (ZONE_SUBJECT|ZONE_VERB)) == (ZONE_SUBJECT|ZONE_VERB)) 
	{
		if (zoneData[zone] & ZONE_FULLVERB) Log(STDUSERLOG,"subject/verb zone, ");
		else Log(STDUSERLOG,"Appositive zone, ");
	}
	else if ((zoneData[zone] & ZONE_VERB)) Log(STDUSERLOG,"Predicate zone, ");
	else if (zoneData[zone] & ZONE_SUBJECT && !(zoneData[zone] & ZONE_VERB)) 
	{
		if (zoneData[zone] & ZONE_ADDRESS) Log(STDUSERLOG,"Address zone, ");
		else Log(STDUSERLOG,"NounPhrase zone, "); // might be subject or object with appositive or something else after it
	}
	else if (zoneData[zone] == ZONE_PCV) Log(STDUSERLOG,"Phrases zone, ");
	else Log(STDUSERLOG,"??? zone,");
}

#ifdef INFORMATION
A needRoles value indicates what we are currently working on (nested), what we want to find to complete this role.
Base level is always the main sentence. Initially subject and verb. When we get a verb, we may add on looking for object and indirect object.
	Other levels may be:
1. phrase (from start of phrase which is usually a preposition but might be omitted) til noun ending phrase
but-- noun might be gerund in which case it extends to find objects of that.
2. clause (from start of clause which might be omitted til verb ending clause
but -- might have objects which extend it, might have gerunds which extend it (and it will include prep phrases attached at the end of it - presumed attached to ending noun)
3. verbal (infinitive and gerund and adjective_participle) - adds a level to include potential objects. 

The MarkPrep handles finding and marking basic phrases and clauses. AssignRoles extends those when the system "might" find an object.
It will backpatch later if it finds it swalllowed a noun into the wrong use.
#endif

static bool ValidateSentence(bool &resolved)
{
	wordStarts[0] = NULL;

	// now verify sentence is proper   
	// 0. all words are resolved and there is a main verb
	// 1. all nouns and pronouns and verbs have roles. Any object2 role noun must be a part of a phrase or clause or verbal (not free)
	// 2. predeterminer determiner or adjective must find its closing noun -- but adjective MAY use linking verb to do so
	// 3. preposition must find its closing noun
	// 4. clause has both subject and verb
	// 5. currently no constraints on adverbs or particles (though they go with a verb)
	// 6. currently dont require predeterminer to find a determiner
	// main object cannot preceed main verb unless in 1st position?
	// if it has no subject, the verb is infinitive.
	// main verb is present/past if no aux, is infinitive or participle if has aux
	unsigned int subject = subjectStack[MAINLEVEL];
	unsigned int verb = verbStack[MAINLEVEL];
	unsigned int object = objectRef[verbStack[MAINLEVEL]];
	unsigned int aux = auxVerbStack[MAINLEVEL];
	unsigned int lastSubjectComplement = 0;

	bool isQuestion =  ((tokenFlags & QUESTIONMARK) || (allOriginalWordBits[startSentence] & QWORD) || (allOriginalWordBits[startSentence+1] & QWORD && allOriginalWordBits[startSentence] & PREPOSITION)) ? true : false;

	if (roleIndex > MAINLEVEL) 
	{
		resolved = false; 
		if (trace & TRACE_POS && (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: roleIndex > main level\r\n");
	}
	// check main verb  vs aux
	else if (!verb) // main verb doesnt exist
	{
		resolved = false; // some unfinished business
		if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: no main verb\r\n");
	}
	if (auxVerbStack[MAINLEVEL] && resolved) // aux exists, prove main verb matches
	{ // legal: "have you had your breakfast"  -- but so is "you are having your breakfast"
		if (posValues[verb] & (VERB_PRESENT|VERB_PRESENT_3PS))
		{
			resolved = false; // some unfinished business
			if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: main verb %s has aux but not aux tense\r\n",wordStarts[verb]);
		}
	}
	else if (resolved)// no aux exists, prove main verb matches
	{
		if (posValues[verb] & (VERB_PRESENT|VERB_PAST|VERB_PRESENT_3PS)){;}
		else if (posValues[verb] == VERB_INFINITIVE && !subjectStack[MAINLEVEL]) {;} // command
		else if (posValues[verb] == VERB_INFINITIVE && aux == 1) {;} // helped verb
		else if (roles[verb] & VERB2) {;} // allowable infinitive
		else
		{
			resolved = false; // some unfinished business
			if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: main verb %s has aux tense but no aux\r\n",wordStarts[verb]);
		}
	}
	// prove subject/verb match
	if (!subject)
	{
		if (resolved && posValues[verb] != VERB_INFINITIVE)
		{
			resolved = false; // some unfinished business
			if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: main verb lacks subject and is not infinitive\r\n");
		}
		else if (resolved && posValues[verb] == VERB_PRESENT  && posValues[subject] & (NOUN_SINGULAR|NOUN_PROPER_SINGULAR))
		{
			resolved = false; // some unfinished business
			if (trace & TRACE_POS  &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: main verb is plural and subject is singulare\r\n");
		}
		else if (resolved && posValues[verb] == VERB_PRESENT_3PS && posValues[subject] & (NOUN_PLURAL|NOUN_PROPER_PLURAL) )
		{
			resolved = false; // some unfinished business
			if (trace & TRACE_POS  &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: main verb is singular and subject is plural\r\n");
		}
	}
	// prove subject is not in zone immediately before verb zone (except coordinate zone is fine since conjoined subject will span multiple zones
	if (resolved && subject && verb && (zoneMember[verb] - zoneMember[subject]) == 1 && !clauses[subject] && !coordinates[subject])  
	{
		// resolved = false; // some unfinished business
		// if (trace & TRACE_POS  &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: subject in zone immediately before verb\r\n"); // dumb 1st grade has "the dog with the black spot on his tail, is with Tom"
	}

	int adjective = 0;
	int preposition = 0;
	bool clauseSubject = false;
	bool clauseVerb = false;
	unsigned int currentClause = 0;
	unsigned int i = 0;

	bool accepted = false;

	if (resolved) for (i = startSentence; i <= endSentence+1; ++i) // walk off end of sentence
	{
		if (ignoreWord[i]) continue;
		char* xxword = wordStarts[i]; // for debugging
		if (roles[i] & MAINVERB) verb = i; // most recent copy since there can be conjoined ones, some with objects and some without
		if (roles[i] & MAINOBJECT)
		{
			object = i; // most recent copy
			// prove object is not in zone immediately after verb zone
			if (resolved && object && verb && (zoneMember[object] - zoneMember[verb]) == 1 && !coordinates[object]) // verb can be in earlier zone if conjoined objects
			{
				resolved = false; // some unfinished business
				if (trace & TRACE_POS  &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: object in zone immediately after verb\r\n");
			}
		}

		if (roles[i] & (MAINVERB|VERB2) && indirectObjectRef[i] && !objectRef[i])
		{
				resolved = false; // some unfinished business
				if (trace & TRACE_POS  &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: freestanding indirect object\r\n");
		}
	
		else if (roles[i] & MAINVERB && !isQuestion && objectRef[i] && objectRef[i] < verb && objectRef[i] != startSentence)
		{
			resolved = false; // some unfinished business
			if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: object preceeds verb and not start or question r\n");
		}
		
		// check for tag questions
		if (roles[i] & TAGQUESTION)
		{
			accepted = true;
			break;
		}
	
		// object 2 can occur at start of sentence after ending prep "who did you give it to"
		if (roles[i] & OBJECT2 && !clauses[i] && !verbals[i] && !phrases[i] && (!coordinates[i] || coordinates[i] > i) ) 
		{
			if (posValues[endSentence] == PREPOSITION && i == firstnoun) 
			{
				for (unsigned int x = 1; x <= firstnoun; ++x) phrases[x] = phrases[endSentence];
			}
			else
			{
				if (trace & TRACE_POS  &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: %s OBJECT2 not in clause/verbal/phrase\r\n",wordStarts[i]);
				break;	// free floating noun?
			}
		}

		if (roles[i] & SUBJECT_COMPLEMENT)
		{
			if ((i-1) == lastSubjectComplement) 
			{
				if (trace & TRACE_POS  &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: Two subject complements in a row: %s %s\r\n",wordStarts[i-1],wordStarts[i]);
				break;	// free floating noun?
			}
			lastSubjectComplement = i;
		}
		// confirm clause has subject and verb
		if (!clauses[i] && currentClause) // clause is ending
		{
			currentClause = 0;
			if (clauseVerb) // we are allowed to omit a clause subject
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: ending a clause not fulfilled\r\n");
				break;	// didnt fulfill these
			}
		}
		else if (clauses[i] != clauses[i-1]) // clause is starting
		{
			if (currentClause && (clauseVerb))// we are allowed to omit a clause subject
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: changing from a clause not fulfilled\r\n");
				break; // failed to complete earlier clause
			}
			if (stricmp(wordStarts[i],"albeit")) clauseSubject = clauseVerb = true; // albeit supplies implied "it is"
			currentClause = clauses[i];
		}
		if (clauseSubject && roles[i] & SUBJECT2) clauseSubject = 0;
		if (clauseVerb && roles[i] & VERB2)  clauseVerb = 0;

		if (preposition && roles[i] & OBJECT2) preposition = 0;

		if (posValues[i] & ADJECTIVE_PARTICIPLE) {;} // doesnt require a noun (comes after or before or with be verb)
		else if (posValues[i] & DETERMINER_BITS)
		{
			adjective = i; // want a noun to complete this
		}
		else if (posValues[i] & ADJECTIVE_BITS)
		{
			if (!(roles[i] & (SUBJECT_COMPLEMENT|OBJECT_COMPLEMENT))) adjective = i; // want a noun to complete this
		}
		else if (posValues[i] & PREPOSITION)// adjective or preposition requires NOUN closure by now
		{
			if (adjective && !(roles[adjective] & POSTNOMINAL_ADJECTIVE)) 
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: adj %s (%d) not fulfilled on seeing prep %s\r\n",wordStarts[adjective],adjective,wordStarts[i]);
				preposition = adjective = 0;
				break;
			}
			if (preposition && stricmp(wordStarts[preposition],"from")) // "from under the bed" is legal" - from is an unusual prep 
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: prep not fulfilled on seeing prep %s\r\n",wordStarts[preposition],preposition,wordStarts[i]);
				preposition = adjective = 0;
				break;
			}
			adjective = 0;
			preposition = i;
		}
		else if (posValues[i] & VERB_TENSES)
		{
			if (adjective || preposition) // adjective or preposition requires NOUN closure
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) 
				{
					if (adjective) Log(STDUSERLOG,"badparse: adj %s not fulfilled on seeing verb %s\r\n",wordStarts[adjective],wordStarts[i]);
					else  Log(STDUSERLOG,"badparse: prep %s not fulfilled on seeing verb %s\r\n",wordStarts[preposition],wordStarts[i]);
				}
				break;
			}
			if (!roles[i] && !verbals[i]) // if verbal, might be adverb verbal
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: verb with no known role\r\n");
				break;	// we dont know what it is doing
			}
			if (roles[i] & MAINVERB && !subjectStack[MAINLEVEL] && posValues[i] != VERB_INFINITIVE)// imperative failure
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: non-imperative main verb %s has no subject \r\n,wordStarts[i]");
				break;
			}
		}
		else if (posValues[i] & ADVERB_BITS)
		{
			if (preposition && stricmp(wordStarts[preposition],"from") && !(posValues[i+1] & (ADVERB_BITS|ADJECTIVE_BITS|DETERMINER_BITS|NOUN_BITS|PRONOUN_BITS))) // "from under the bed" is legal" - from is an unusual prep 
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: prep not fulfilled on seeing adverb %s\r\n",wordStarts[preposition],preposition,wordStarts[i]);
				preposition = adjective = 0;
				break;
			}
		}
		else if (posValues[i] & NOUN_INFINITIVE)
		{
			if (adjective) // cannot describe a noun infinitive
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: unfinished adjective %s at noun infinitive %s\r\n",wordStarts[adjective],wordStarts[i]);
				break;
			}
			// its marked on to infinitve
		}
		else if (posValues[i] & TO_INFINITIVE)
		{
			if (!roles[i]) // we dont know what it is doing, must be an adverb phrase
			{
			}
		}
		else if (posValues[i] & NOUN_BITS)
		{
			adjective = false;
			if (!roles[i]) 	// we dont know what it is doing
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: unknown role for noun %s\r\n",wordStarts[i]);
				break;
			}
		}
		else if (posValues[i] & (PRONOUN_BITS))
		{
			adjective = false; // if we had adjectives before "the blue one" or the "blue you", this closes it
			if (!roles[i]) 	// we dont know what it is doing
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse: unknown role for pronoun %s\r\n",wordStarts[i]);
				break;
			}
		}
		else if (posValues[i] & CONJUNCTION_SUBORDINATE)
		{
			if (adjective || preposition) // adjective or prep requires NOUN closure
			{
				if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) 
				{
					if (adjective) Log(STDUSERLOG,"badparse: adj %s not fulfilled on seeing verb %s\r\n",wordStarts[adjective],wordStarts[i]);
					else  Log(STDUSERLOG,"badparse: prep %s not fulfilled on seeing verb %s\r\n",wordStarts[preposition],wordStarts[i]);
				}
				break;
			}
		}
		else if (i > endSentence) //  end of sentence
		{
			if (preposition && phrases[endSentence] == phrases[startSentence]) {;} // wraps back to front
			else if (preposition || clauseVerb) // adjective or preposition or clause requires  closure - we can omit clause subjects
			{
				if (posValues[endSentence] == PREPOSITION && roles[startSentence] & OBJECT2){;} // wrapped prep to start as question
				else
				{
					if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse:  unfinished prep or clause at end of sentence\r\n");
					break; 
				}
			}
			if (adjective && verbStack[MAINLEVEL]) // allowed to hang only if in main be sentence with linking verb or as object complement "This made mom mad"
			{
				if (canonicalLower[verbStack[MAINLEVEL]] && !(canSysFlags[verbStack[MAINLEVEL]] & VERB_TAKES_ADJECTIVE) && !(roles[adjective-1] & MAINOBJECT))
				{
					if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) Log(STDUSERLOG,"badparse:  unfinished adjective %s at end of sentence\r\n",wordStarts[adjective]);
					break; // not a be sentence -- bug need to do seem as well
				}
			}		
		}
		if (roles[i] & SUBJECT2 && !clauses[i] && !(roles[i] & ABSOLUTE_PHRASE))
		{
			if (trace & TRACE_POS &&  (prepareMode && prepareMode != POSVERIFY_MODE)) 
			{
				Log(STDUSERLOG,"badparse:  Subject2 %s not in clause\r\n",wordStarts[i]);
				break; 
			}
		}
		// CONSIDER ALSO COORDINATE CONJUNCTION IF SENTENCE COORDINATOR
		//else if (posValues[i] && (ADVERB_BITS | PARTICLES | COMMA | PAREN | NOUN_INFINITIVE | THERE_EXISTENTIAL |  TO_INFINITIVE));
	}

	if (i == (endSentence+2)) accepted = true;	 // found nothing to stop us
	else if (i <= (endSentence + 1) && !accepted) resolved = false; // failed something along the way

	// assign sentence type
	if (!verbStack[MAINLEVEL] || !(roles[verbStack[MAINLEVEL]] &  MAINVERB)) // FOUND no verb, not a sentence
	{
		if (trace & TRACE_POS || prepareMode == POS_MODE) Log(STDUSERLOG,"Not a sentence\r\n");
		if (tokenFlags & (QUESTIONMARK|EXCLAMATIONMARK)) {;}
		else if (posValues[startSentence] & AUX_VERB_BITS) tokenFlags |= QUESTIONMARK;// its a question because AUX starts
		else if (allOriginalWordBits[startSentence]  & QWORD) tokenFlags |= QUESTIONMARK;
		else if (allOriginalWordBits[startSentence] & PREPOSITION && allOriginalWordBits[startSentence+1] & QWORD) tokenFlags |= QUESTIONMARK;
	}
	else if (!(tokenFlags & (QUESTIONMARK|EXCLAMATIONMARK))) // see if question or statement if we dont know
	{
		unsigned int i;
		bool subjectFound = false;
		for (i = startSentence; i <= endSentence; ++i) 
		{
			if (roles[i] & MAINSUBJECT) subjectFound = true;
		}
		if (subjectStack[MAINLEVEL] && subjectStack[MAINLEVEL] > verbStack[MAINLEVEL] && (allOriginalWordBits[startSentence] & QWORD || (allOriginalWordBits[startSentence] & PREPOSITION && allOriginalWordBits[startSentence+1] & QWORD)))  tokenFlags |= QUESTIONMARK; // qword + flipped order must be question (vs emphasis?)
	
		for (i = startSentence; i <= endSentence; ++i) 
		{
			if (ignoreWord[i]) continue;
			if (roles[i] & MAINSUBJECT) 
			{
				if (i == startSentence && originalLower[startSentence] && originalLower[startSentence]->properties & QWORD) tokenFlags |= QUESTIONMARK;
				break;
			}
			if (phrases[i] || clauses[i] || verbals[i]) continue;
			if ( bitCounts[i] != 1) break;	// all bets about structure are now off
			if (posValues[i] & AUX_VERB_BITS && (i == startSentence || subjectFound)) // its a question because AUX or VERB comes before MAINSUBJECT
			{
				// EXCEPT for negative adverb starter: "never can I go home"
				if (parseFlags[i-1] & NEGATIVE_ADVERB_STARTER) {;}
				else
				{
					tokenFlags |= QUESTIONMARK;
					break;
				}
			}
		}
	}

	return resolved;
}

static void AssignZones()
{
	if (trace & TRACE_POS) Log(STDUSERLOG,"     Zones: ");
	memset(zoneData,0,sizeof(unsigned int) * ZONE_LIMIT); 
	memset(zoneMember,0,sizeof(unsigned char) * MAX_SENTENCE_LENGTH); 
	currentZone = 0;
	zoneIndex = 0;
	for (unsigned int i = startSentence; i <= (int)endSentence; ++i)
	{
		if (ignoreWord[i]) continue;	// ignore these
		zoneMember[i] = (unsigned char)zoneIndex; // word is in current zone
		if (phrases[i] || clauses[i] || verbals[i]) zoneData[zoneIndex] |= ZONE_PCV; // a phrase/clause/verbal runs thru here -- and has been marked all the way thru the noun as well
		if (bitCounts[i] != 1) zoneData[zoneIndex] |= ZONE_AMBIGUOUS;
		else if (posValues[i] & (PRONOUN_BITS|NOUN_BITS)) // this is definitely a noun
		{
			zoneData[zoneIndex] |=  (zoneData[zoneIndex] & ZONE_VERB) ? ZONE_OBJECT : ZONE_SUBJECT;
			// the only way to know an address zone is NOT the subject, is to find the subject in a different zone in advance (presumably next)
			// and zone 1 wouldnt be appositive in that case:  "Bill, my parrot is good" because a proper name wouldnt be appositive coming first
			if ( i == startSentence && posValues[i] & NOUN_PROPER_SINGULAR && posValues[i+1] == COMMA && zoneData[zoneIndex+1] & ZONE_SUBJECT) 
				zoneData[zoneIndex] |= ZONE_ADDRESS;
			if ( i == startSentence && posValues[i] & NOUN_PROPER_SINGULAR && posValues[i+1] == COMMA && posValues[i+2] & (PRONOUN_SUBJECT | PRONOUN_OBJECT |NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL)) 
				zoneData[zoneIndex] |= ZONE_ADDRESS;
		}
		else if (posValues[i] & VERB_TENSES) // this is definitely a verb but might be from a clause
		{
			zoneData[zoneIndex] |= ZONE_VERB;
			if (posValues[i] & (VERB_PAST_PARTICIPLE|VERB_PRESENT_PARTICIPLE))
			{
				if (zoneData[zoneIndex] & ZONE_SUBJECT && !(zoneData[zoneIndex] & ZONE_AUX) ){;}
				else if (zoneData[zoneIndex] & ZONE_AUX) predicateZone = zoneIndex;
			}
			else  zoneData[zoneIndex] |= ZONE_FULLVERB;
		}
		else if (posValues[i] & AUX_VERB_BITS) zoneData[zoneIndex] |= ZONE_FULLVERB | ZONE_AUX; 
		else if (posValues[i] & COMMA) 
		{
			// too many commas
			if (zoneIndex == (ZONE_LIMIT-1)) return;
			zoneData[++zoneIndex] = 0;
			zoneBoundary[zoneIndex] = (unsigned char)i;
		}
	}
	if (trace & TRACE_POS) 
	{
		for (unsigned int i = 0; i <= zoneIndex; ++i) ShowZone(i);
		Log(STDUSERLOG,"\r\n");
	}
	zoneBoundary[++zoneIndex] = (unsigned char)(endSentence + 1);	// end of last current zone

	unsigned int lastComma = (zoneIndex) ? zoneBoundary[zoneIndex-1] : 0;
	if (lastComma)
	{
		if ((endSentence-lastComma) == 3 && posValues[lastComma+1] & VERB_TENSES && allOriginalWordBits[lastComma+1] & AUX_VERB_BITS && !stricmp(wordStarts[lastComma+2],"not") && posValues[lastComma+3] & PRONOUN_BITS) roles[lastComma] = TAGQUESTION; // don't they ?
		if ((endSentence-lastComma) == 2 && posValues[lastComma+1] & VERB_TENSES  && allOriginalWordBits[lastComma+1] & AUX_VERB_BITS  && posValues[lastComma+2] & PRONOUN_BITS) roles[lastComma] = TAGQUESTION; // do you ? do theirs?
		if ((endSentence-lastComma) == 2 &&  !stricmp(wordStarts[lastComma+1],"and") &&  !strnicmp(wordStarts[lastComma+2],"you",3)) roles[lastComma] = TAGQUESTION;//  and you ?  - and yours?
		if ((endSentence-lastComma) == 2 &&  !strnicmp(wordStarts[lastComma+1],"you",3) &&  !stricmp(wordStarts[lastComma+2],"too")) roles[lastComma] = TAGQUESTION;//  yours too?
		if ((endSentence-lastComma) == 1 &&  !strnicmp(wordStarts[lastComma+1],"you",3) ) roles[lastComma] = TAGQUESTION; //  you ?  yours?
	}
}

static unsigned int GuessAmbiguousNoun(unsigned int i, bool &changed)
{
	unsigned int currentVerb = (roleIndex == MAINLEVEL) ? currentMainVerb : currentVerb2;

	// if this is adjective or noun and following is a possible noun, be adjective, unless we are sentence start and "here" "there" etc
	if (posValues[i] & ADJECTIVE_NORMAL && posValues[i] & NOUN_SINGULAR && posValues[i+1] & (NOUN_SINGULAR|NOUN_PLURAL))
	{
		if (posValues[i] & ADVERB_BITS && i == startSentence && (!stricmp(wordStarts[i],"here") || !stricmp(wordStarts[i],"there"))) {;}
		// not a conflict if we need indirect and this is human
		else if (canSysFlags[i] & ANIMATE_BEING && needRoles[roleIndex] & (MAININDIRECTOBJECT|INDIRECTOBJECT2)) // "he had the *mechanic check the brakes"
		{
			if (LimitValues(i,NOUN_SINGULAR ,"adj noun conflict needing indirect, use noun",changed)) return GUESS_RETRY;
		}
	}

	int beAdj = 0;
	if (posValues[i+1] & NOUN_BITS && bitCounts[i+1] == 1) beAdj = i+1;
	else if (i < (endSentence - 1) && posValues[i+1] & ADJECTIVE_BITS  && bitCounts[i+1] == 1 && posValues[i+2] & NOUN_BITS) beAdj = i+2;
	else if (i < (endSentence - 2) && posValues[i+1] & ADJECTIVE_BITS  && bitCounts[i+1] == 1 && posValues[i+2] & ADJECTIVE_BITS && posValues[i+3]) beAdj = i+3;
	if (!beAdj){;}
	else if (bitCounts[beAdj] == 1) {;} // yes
	else if (canSysFlags[beAdj] & NOUN) {;}
	else beAdj = 0;	// not a probable noun
	if (posValues[i] & NOUN_GERUND && beAdj && !(posValues[i] & (PARTICLE|PREPOSITION))) // can be an adjective, have upcoming noun, and cant be particle (whose verb might take an object) "mom picked *up Eve after school"
	{
		// if verb cannot take an object, must be adjective   // "he hates *decaying broccoli"
		if (!(canSysFlags[i]  & VERB_DIRECTOBJECT)){;}
		// if verb needs an object, be verbal --  // "he hates *eating broccoli"
		else 
		{
			if (LimitValues(i,NOUN_GERUND,"potential gerund preceeding nearby noun as object, be that",changed)) return GUESS_RETRY;
		}
	}
	
	if (posValues[i] == AMBIGUOUS_VERBAL)
	{
		// we need a noun as subject of a clause, but gerund can mean subject is omitted...
		if (needRoles[roleIndex] & CLAUSE && needRoles[roleIndex] & SUBJECT2)
		{
			if (LimitValues(i,NOUN_GERUND,"possibly omitted subject w gerund verb in clause",changed)) return GUESS_RETRY; 
		}

		// we need a noun, go for that, unless it is followed by a noun, in which case we be adjective particile
		if (needRoles[roleIndex] & (MAINOBJECT|OBJECT2|MAINSUBJECT|SUBJECT2))
		{
			if (posValues[i+1] & (ADJECTIVE_BITS|NOUN_BITS) && !(posValues[i+1] & (-1 ^ (ADJECTIVE_BITS|NOUN_BITS))) ) {;}
			else if (LimitValues(i,NOUN_GERUND,"need noun so accept noun-gerund",changed)) return GUESS_RETRY; 
		}
		//  NOUN_GERUND ADJECTIVE_PARTICIPLE conflict after and which has verbal before it
		else if (i > 1 && posValues[i-1] & CONJUNCTION_COORDINATE && verbals[i-2])
		{
			if (LimitValues(i,NOUN_GERUND,"gerund/adjparticle conflict after coordinate with verbal before it, go verbal",changed)) return GUESS_RETRY; 
		}
	}

		// do we need a verb next which is in conflict with a noun
	uint64 remainder = posValues[i] & (-1 ^ (NOUN_BITS|VERB_TENSES));
	if (needRoles[roleIndex] & (VERB2|MAINVERB) && posValues[i] & VERB_TENSES && posValues[i] & NOUN_BITS && !remainder && 
	!(needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2)))
	{
		if (currentZone < zoneIndex && zoneData[currentZone+1] & ZONE_FULLVERB)	{;} // we expect verb in NEXT zone, so dont force it here
		else if (posValues[i+1] & (VERB_TENSES|AUX_VERB_BITS) && !(posValues[i+1] & (NOUN_BITS|ADJECTIVE_BITS|DETERMINER|POSSESSIVE_BITS)))
		{
			if (LimitValues(i,NOUN_BITS,"says verb required, but next can be verb or aux so bind this as noun",changed)) return GUESS_RETRY;
		}
	}

	//starting up, if we need subject and verb and after us is noun evidence, we might be flippsed order with qword "what a big *nose he has" 
	if (posValues[i] & VERB_TENSES && posValues[i] & NORMAL_NOUN_BITS && posValues[i+1] & (PRONOUN_BITS|NORMAL_NOUN_BITS) && originalLower[startSentence] && originalLower[startSentence]->properties & QWORD)
	{
		if (LimitValues(i, NORMAL_NOUN_BITS,"qword inverted object before subject, accept noun meaning",changed)) return GUESS_RETRY;
	}

	// if follows to infintiive, prefer noun inf over noun sing "they went to *pick berries"
	if (posValues[i-1] == TO_INFINITIVE  && posValues[i] & NORMAL_NOUN_BITS && posValues[i] & NOUN_INFINITIVE)
	{
		if (LimitValues(i,-1 ^ NORMAL_NOUN_BITS,"following to infinitive wont be normal noun",changed)) return GUESS_RETRY;
	}

	// the word "home" w/o a determiner or adjective and not in prep phrase will be adverb - "I walk *home" but not "I walk to my *home"
	if (!lastPhrase && !stricmp(wordStarts[i],"home") && posValues[i] & ADVERB_BITS && !(posValues[i-1] & (DETERMINER|POSSESSIVE_BITS|ADJECTIVE_BITS)))
	{
		if (LimitValues(i,-1 ^ NORMAL_NOUN_BITS,"undetermined home will not be a noun",changed)) return GUESS_RETRY;
	}
	
	if (needRoles[roleIndex] & (OBJECT2|MAINOBJECT) && posValues[i] & NORMAL_NOUN_BITS) // "she was a big *apple"
	{
		// if this is a number and next could be adjective, lets just wait "I have *3 purple mugs"
		if (posValues[i] & NOUN_NUMBER && posValues[i] & ADJECTIVE_NUMBER && posValues[i+1] & (ADJECTIVE_BITS|NORMAL_NOUN_BITS)) {;}
		else if (posValues[i] & VERB_INFINITIVE && needRoles[roleIndex] & VERB_INFINITIVE_OBJECT){;} // prefer this
		// unless can be adjective and our verb will want complement
		else if (needRoles[roleIndex] & SUBJECT_COMPLEMENT && posValues[i] & ADJECTIVE_BITS) {;} // "she was getting *upset"
		else if (LimitValues(i,NORMAL_NOUN_BITS,"if can be normal noun as object, be that",changed)) return GUESS_RETRY;
	}

	if (posValues[i] & ADJECTIVE_NORMAL && needRoles[roleIndex] & SUBJECT_COMPLEMENT && posValues[i] & (NOUN_INFINITIVE|NOUN_SINGULAR)) // "she was feeling *down"
	{ // particularly "go *home"
		if (LimitValues(i,-1 ^ (NOUN_INFINITIVE|NOUN_SINGULAR),"if can be adjective as subject complement, dont be noun infintive or singular",changed)) return GUESS_RETRY;
	}

	// if seeking object for main or clause and noun is not determined, kill it
	unsigned int det;
	if (needRoles[roleIndex] & (MAINOBJECT|OBJECT2|MAINSUBJECT|SUBJECT2) && !(needRoles[roleIndex] & PHRASE) && !IsDeterminedNoun(i,det))
	{
		if (LimitValues(i,-1 ^ NOUN_BITS,"undetermined noun cannot be subject or object",changed)) return GUESS_RETRY;
	}

	// if seeking direct object and we have seen adverb just before us, be not a noun if can be an adverb  "John came back *inside"  - cant put adverb before direct object unless it modifies adjective
	if (i > 2 && needRoles[roleIndex] & (OBJECT2|MAINOBJECT) && posValues[i-1] & ADVERB_BITS && posValues[i-2] & VERB_TENSES && tokenControl & TOKEN_AS_IS)
	{
		needRoles[roleIndex] &= -1 ^ ALL_OBJECTS;
		if (LimitValues(i,-1 ^ NOUN_BITS,"no noun after verb then adverb as direct object ",changed)) return GUESS_RETRY;
	}

	// object complement:  causal infinitive- "we watched them play"
	if (!(posValues[i] & PREPOSITION) && posValues[i] & VERB_INFINITIVE && needRoles[roleIndex] & OBJECT_COMPLEMENT && !(posValues[i-1] & (NOUN_INFINITIVE|NOUN_GERUND)))
	{
		if (currentVerb && canSysFlags[currentVerb] & VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE && indirectObjectRef[currentVerb] && !objectRef[currentVerb])
		{
			if (LimitValues(i,-1 ^ (NOUN_BITS - NOUN_INFINITIVE),"conflict noun infinitive, needing object after indirect- go  infinitive if directobject_infinitive complement verb",changed)) return GUESS_RETRY; 
		}
	}

	// if something could be noun or verb infinitive, and we need a noun, use noun - but not "while walking *home, Jack ran"
	// AND must have TO before it or be a verb not requiring it...  not "Nina raced her brother Carlos *down the street"
	if (!(posValues[i] & PREPOSITION) && posValues[i] & NOUN_INFINITIVE && needRoles[roleIndex] & (MAINOBJECT|OBJECT2) && !(posValues[i-1] & (NOUN_INFINITIVE|NOUN_GERUND)))
	{
		// unless causal infinitive- "we watched them play"
	
		if (posValues[i] & ADJECTIVE_PARTICIPLE && needRoles[roleIndex] & SUBJECT_COMPLEMENT) // she was getting *upset"
		{
			if (LimitValues(i,-1 ^ NOUN_BITS,"need complement, reject noun",changed)) return GUESS_RETRY; 
		}
		if (currentVerb && canSysFlags[currentVerb] & VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE && indirectObjectRef[currentVerb] && !objectRef[currentVerb])
		{
			if (LimitValues(i,NOUN_INFINITIVE,"conflict noun infinitive, needing object after indirect- go noun infinitive if directobject_infinitive complement verb",changed)) return GUESS_RETRY; 
		}
		else if (needRoles[roleIndex] & TO_INFINITIVE_OBJECT && indirectObjectRef[currentVerb] && !objectRef[currentVerb])
		{
			if (LimitValues(i,NOUN_INFINITIVE,"conflict noun infinitive, needing object- go noun infinitive if causal verb",changed)) return GUESS_RETRY; 
		}
		else if (posValues[i] & NOUN_SINGULAR ) 
		{
			if (LimitValues(i,NOUN_SINGULAR,"conflict noun infinitive and singular, needing object- go noun singular",changed)) return GUESS_RETRY;
		}
	}

	// will not have infinitive noun after a gerund. "walking *home is fun
	if (posValues[i] & NOUN_INFINITIVE && posValues[i-1] == NOUN_GERUND)
	{
		if (LimitValues(i,-1 ^ NOUN_INFINITIVE,"no noun infinitive after a gerund",changed)) return GUESS_RETRY;
	}
	// will not have gerund after a gerund. 
	if (posValues[i] & NOUN_GERUND && posValues[i-1] == NOUN_GERUND)
	{
		if (LimitValues(i,-1 ^ NOUN_GERUND,"no noun gerund after a gerund",changed)) return GUESS_RETRY;
	}

	// we arent expecting anything, so kill off noun meanings - but cant kill off proper nouns ever - not "I hit my friend *Carlos"
	if (posValues[i] & (NOUN_BITS - NOUN_PROPER_SINGULAR - NOUN_PROPER_PLURAL ) && posValues[i] & (ADVERB_BITS|ADJECTIVE_BITS|PARTICLE) && roleIndex == MAINLEVEL && needRoles[MAINLEVEL] == 0)
	{
		if (LimitValues(i,-1 ^ NOUN_BITS,"needing nothing, kill off noun meanings in favor of adverb/adj/particle",changed)) return GUESS_RETRY; 
	}

	if (posValues[i] & NOUN_INFINITIVE && roleIndex == MAINLEVEL && needRoles[MAINLEVEL] == 0 && i == endSentence)
	{
		if (LimitValues(i,-1 ^ NOUN_INFINITIVE,"no use for noun infinitive at end of sentence",changed)) return GUESS_RETRY;  // "i want to take the day off"
	}

	if (posValues[i-1] == PRONOUN_POSSESSIVE && posValues[i] & (NOUN_INFINITIVE|NOUN_GERUND) && posValues[i] & NOUN_SINGULAR) // remove ambiguity
	{
		if (LimitValues(i,-1 ^ (NOUN_INFINITIVE|NOUN_GERUND),"potential gerund or infintive preceeded by possessive is killed",changed)) return GUESS_RETRY; 
	}
	
	if (needRoles[roleIndex] & (MAINSUBJECT|OBJECT2|MAINOBJECT|SUBJECT2) && posValues[i] & (NOUN_INFINITIVE|NOUN_GERUND))
	{
		if (i == startSentence && posValues[i] & VERB_INFINITIVE && posValues[i+1] & (PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS|NOUN))
		{
			 if (LimitValues(i,-1 ^ NOUN_BITS,"Potential command at start has object after it be not noun",changed)) return GUESS_RETRY;  // "let him go"
		}
		// Joey found his baby *blanket"
		else if (posValues[i] & NOUN_INFINITIVE && needRoles[roleIndex] & TO_INFINITIVE_OBJECT) // "she ran *back home"
		{
			if (LimitValues(i,-1 ^ NOUN_INFINITIVE,"Need a noun, but infinitive lacks to and prior verb cant accept that, delete",changed)) return GUESS_RETRY; 
		}
		else if (posValues[i] & NOUN_INFINITIVE && verbStack[roleIndex] &&  posValues[i] & (NOUN_SINGULAR|NOUN_PLURAL) && posValues[i-1] & (DETERMINER|ADJECTIVE_BITS))  
		{
			if (LimitValues(i,(NOUN_SINGULAR|NOUN_PLURAL),"Need a noun and prior is determiner/adjective, be normal noun not infinitive",changed)) return GUESS_RETRY; // "Never have I seen this *dog."
		}
		else if (posValues[i] & NOUN_INFINITIVE && verbStack[roleIndex] &&  AcceptsInfinitiveObject(verbStack[roleIndex]))  
		{
			if (LimitValues(i,NOUN_INFINITIVE,"Need a noun and verb expects infinitives, take that",changed)) return GUESS_RETRY;
		}
		else if (posValues[i] & NOUN_SINGULAR && posValues[i-1] & (ADJECTIVE_BITS|DETERMINER|POSSESSIVE_BITS)) 
		{
			if (LimitValues(i,NOUN_SINGULAR,"Need a noun, take simple noun with extras",changed)) return GUESS_RETRY;
		}
		// dont accept singular noun lacking pre-evidence and being noun-infinitive unless mass noun... "We  had  nothing  to  do  except  *look  at  the  cinema  posters"
		else if (posValues[i] & NOUN_SINGULAR && !(posValues[i-1] & (NOUN_BITS|ADJECTIVE_BITS|DETERMINER)) && posValues[i] & NOUN_INFINITIVE && !(allOriginalWordBits[i] & NOUN_MASS))
		{
			if (LimitValues(i,-1 ^ NOUN_SINGULAR,"Need a noun, but simple noun not preceeeded by evidence and not mass noun, prefer noun infinitive",changed)) return GUESS_RETRY;
		}
		else if (posValues[i] & NOUN_SINGULAR && (i == endSentence || posValues[i+1] & (PREPOSITION|TO_INFINITIVE|CONJUNCTION_BITS|COMMA))) // Tashonda sent e-mail
		{
			if (LimitValues(i,NOUN_SINGULAR,"Need a noun, take simple noun when gerund not followed by interesting stuff",changed)) return GUESS_RETRY;
		}
		else if (roleIndex == MAINLEVEL &&  i <= 2 && posValues[i] & VERB_INFINITIVE && !(posValues[i-1] & (NOUN_BITS|PRONOUN_BITS))) 
		{
			needRoles[roleIndex] &= (unsigned int)( -1 ^ MAINSUBJECT);	// you is the subject
			if (LimitValues(i,-1 ^ NOUN_BITS,"Leading verb infinitive, be a command and not noun",changed)) return GUESS_RETRY;
		}
		else if (posValues[i] & ADJECTIVE_BITS && needRoles[roleIndex] & SUBJECT_COMPLEMENT) {;} // "it was *wrong"
		else 
		{
			if (LimitValues(i,(NOUN_INFINITIVE|NOUN_GERUND),"Need a noun, take potential gerund or infintive",changed)) return GUESS_RETRY;
		}
	}

	//  if something could be noun followed by potential prep and we need a noun, take it - but "our old dog Gizmo dreamed" should not
	if (posValues[i] & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL|NOUN_PLURAL|NOUN_SINGULAR) && posValues[i+1] & PREPOSITION && needRoles[roleIndex] & (SUBJECT2|OBJECT2|MAINSUBJECT|MAINOBJECT))
	{
		if (posValues[i] & VERB_INFINITIVE &&  canSysFlags[currentVerb] & (VERB_TAKES_INDIRECT_THEN_VERBINFINITIVE | VERB_TAKES_VERBINFINITIVE)) {;}
		else if (LimitValues(i,NOUN_BITS,"something looking like noun followed by potential prep, make it a noun when we need one",changed)) return GUESS_RETRY;
	}
	// if something could be noun and next could be verb and we are hunting for both, be noun. Unless we have obvious verb coming up
	if (posValues[i] & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL|NOUN_PLURAL|NOUN_SINGULAR) && posValues[i+1] & ((VERB_TENSES - VERB_INFINITIVE)|AUX_VERB_BITS) && needRoles[roleIndex] & (SUBJECT2|MAINSUBJECT) && needRoles[roleIndex] & (MAINVERB|VERB2))
	{
		unsigned int at = i;
		while (++at <= endSentence && posValues[at] & !(VERB_TENSES|AUX_VERB_BITS))
		{
			if (posValues[at] & (COMMA | PREPOSITION | CONJUNCTION_SUBORDINATE | CONJUNCTION_COORDINATE)) break;
		}
		if (!(posValues[at] & (VERB_TENSES|AUX_VERB_BITS)) || bitCounts[at] != 1)
		{
			if (LimitValues(i,NOUN_BITS,"potential noun followed by potential verb/aux and we need both, take it as noun",changed)) return GUESS_RETRY;
		}
	}

	// "it flew *past me"
	if (posValues[i] & PREPOSITION && needRoles[roleIndex] & MAINOBJECT && !(needRoles[roleIndex] & SUBJECT_COMPLEMENT) && roleIndex == MAINLEVEL && !phrases[i]) // not "the exercise is the *least expensive"
	{
		unsigned int priorVerb = FindPriorVerb(i);
		if (priorVerb && canSysFlags[priorVerb] & VERB_NOOBJECT)
		{
			if (LimitValues(i,-1 ^ NOUN_BITS,"forcing preposition of noun1 since can live without object and are followed by known object2",changed)) return GUESS_RETRY;
		}
	}

	// if we want a main object and instead have ambigous non-headed noun - "I walked *home yesterday"  BUG- consider the impossiblity "I walked home the dog"
	if (posValues[i] & NOUN_SINGULAR && needRoles[roleIndex] & MAINOBJECT && !(needRoles[roleIndex] & SUBJECT_COMPLEMENT) && roleIndex == MAINLEVEL && !phrases[i]) // not "the exercise is the *least expensive"
	{
		if (LimitValues(i,NOUN_BITS,"forcing noun  since want direct object",changed)) return GUESS_RETRY;
	}

	// a potential noun that needs a determiner will abandoned "Cat is where the heart is"  but time words are ok "today is yesterday"
	// but hard to tell so dont do restriction test

	// if noun can be singular or plural, PRESUME plural, unless verb following is 3ps 
	if (posValues[i] == (NOUN_SINGULAR|NOUN_PLURAL))
	{
		if (posValues[i] & VERB_PRESENT_3PS) 
		{
			if (LimitValues(i, NOUN_SINGULAR,"is singular over plural since verb next is 3ps",changed)) return GUESS_RETRY;
		}
		else if (LimitValues(i, NOUN_PLURAL,"is plural over singular",changed)) return GUESS_RETRY; 
	}

	// if we want a noun, be one
	if (posValues[i] & (NOUN_SINGULAR|NOUN_PLURAL) && needRoles[roleIndex] & (OBJECT2 | MAINSUBJECT | MAINOBJECT))
	{
		// unless can be adjective and our verb will want complement
		if (needRoles[roleIndex] & SUBJECT_COMPLEMENT && posValues[i] & ADJECTIVE_BITS) {;} // "she was getting *upset"

		// if our priority is not as noun but as adjective or adverb, and next could be noun or adjective, be adjective and defer - "the *little old dog hit the man"
		else if (canSysFlags[i] & (ADJECTIVE|ADVERB) && !(canSysFlags[i] & NOUN))
		{
			if (posValues[i+1] & (NORMAL_NOUN_BITS | ADJECTIVE_BITS))
			{
				if (LimitValues(i, ADJECTIVE_BITS|ADVERB_BITS,"we are likely to describe a noun following still",changed)) return GUESS_RETRY;
			}
		}
		else if (LimitValues(i, NOUN_PLURAL|NOUN_SINGULAR,"be a noun because we need one",changed)) return GUESS_RETRY; 
	}

	// if we come after an adj or det (in a noun phrase) and after us MIGHT be a noun and we are NOT likely a noun, kill off nouniness
	if (posValues[i-1] & (ADJECTIVE_BITS|DETERMINER|ADVERB_BITS) && posValues[i+1] & (NORMAL_NOUN_BITS|NOUN_NUMBER) && !(canSysFlags[i] & NOUN))
	{
		if (LimitValues(i,-1 ^ (NOUN_NUMBER | NORMAL_NOUN_BITS),"we are unlikely noun, in noun phrase and next could be noun, so we wont be",changed)) return GUESS_RETRY;
	}

	return GUESS_NOCHANGE;
}

static unsigned int GuessAmbiguousVerb(unsigned int i, bool &changed)
{
	// possble adverb followed by comma, be adverb like "*last, he went"
	if ( i == startSentence && posValues[i+1] & COMMA  && posValues[i] & VERB_TENSES && posValues[i] & ADVERB_BITS)
	{
		if (LimitValues(i, -1 ^ VERB_TENSES ,"don't start a sentence with verb then comma if it can be adverb",changed)) return GUESS_RETRY; 
	}
	
	// (A) if we have a noun coming up and we can be adjectives to get there, do so if noun is probable - unless gerund
	// "Doc made his students *read 4 books." - verb infinitve expected over participle being adjective

	if (needRoles[roleIndex] & (MAINSUBJECT|OBJECT2|MAINOBJECT|SUBJECT2) && posValues[i] & VERB_INFINITIVE)
	{
		if (i == startSentence && posValues[i] & VERB_INFINITIVE && posValues[i+1] & (PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS|NOUN))
		{
			 if (LimitValues(i,VERB_INFINITIVE,"Potential command at start has object after it be infintiive",changed)) return GUESS_RETRY;  // "let him go"
		}
		if (roleIndex == MAINLEVEL &&  i <= 2 && posValues[i] & VERB_INFINITIVE && !(posValues[i-1] & (NOUN_BITS|PRONOUN_BITS))) 
		{
			needRoles[roleIndex] &= (unsigned int)( -1 ^ MAINSUBJECT);	// you is the subject
			if (LimitValues(i,VERB_INFINITIVE,"Leading verb infinitive, be a command",changed)) return GUESS_RETRY;
		}
	}

	// could this be ommited subject "people"
	bool impliedPeople = false;
	unsigned int at = i;
	while (--at > startSentence && posValues[at] & ADVERB_BITS) --at;	// the wicked very often *can outwit others"
	if (needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2) && posValues[at] & ADJECTIVE_NORMAL && !stricmp(wordStarts[at-1],"the")) impliedPeople = true; 

	if (posValues[i] & (VERB_PAST|VERB_PRESENT) && impliedPeople)
	{
		 if (LimitValues(i,VERB_PAST|VERB_PRESENT,"adjective as subject forces verb past/present",changed)) return GUESS_RETRY;  // "the beautiful run"
	}

	// *talk about stuff
	if (posValues[i] & VERB_INFINITIVE && needRoles[roleIndex] & (MAINSUBJECT|OBJECT2|MAINOBJECT|SUBJECT2) &&
		posValues[i] & (NOUN_INFINITIVE|NOUN_GERUND))
	{
		if (i == startSentence && posValues[i] & VERB_INFINITIVE && !(posValues[i] & PREPOSITION)) 
		{
			// prove there is no other verb in sight
			unsigned int at;
			for (at = i+1; at < endSentence; ++at)
			{
				if (posValues[at] == CONJUNCTION_COORDINATE || posValues[at] == CONJUNCTION_SUBORDINATE) at = endSentence; // abort
				else if (posValues[at] & (AUX_VERB_BITS|VERB_TENSES)) break; // potential verb, maybe we are noun
			}
			if (at >= endSentence) 
			{
				if (LimitValues(i,VERB_INFINITIVE,"Potential command at start has object after it",changed)) return GUESS_RETRY; // "let him go"
			}
		}
	}
	
	// we dont need a verb, we are ending a phrase coming up on a comma, be another noun
	if (posValues[i] & NOUN_BITS && posValues[i] & VERB_TENSES && currentZone < zoneIndex && zoneData[currentZone+1] & ZONE_FULLVERB &&// we expect verb in NEXT zone, so dont need it here -- "My brother's car, a sporty red convertible with bucket *seats, is the envy of my friends."
		phrases[i-1] && !phrases[i] && posValues[i+1] & COMMA)
	{
		if (LimitValues(i,-1 ^ VERB_TENSES,"wrapping up a prep object before a comma, not needing verb, be a noun",changed)) return GUESS_RETRY; // but would not match: "The dog near the man eats, to the best of my knowledge, but doesn't drink"
	}

	// if we are possible noun and have a pending adj or det, we must be not verb "a big *nose is what he has"
	if (posValues[i] & NORMAL_NOUN_BITS)
	{
		unsigned int deepBefore = i;
		while (--deepBefore)
		{
			if (posValues[deepBefore] & (ADJECTIVE_BITS| DETERMINER) && bitCounts[deepBefore] == 1) break; // we have solid value
			if (posValues[deepBefore] & (ADJECTIVE_BITS|ADVERB_BITS)) continue;
			break; // will be no good
		}
		if (posValues[deepBefore] & (ADJECTIVE_BITS| DETERMINER) && bitCounts[deepBefore] == 1)
		{
			if (LimitValues(i, VERB_TENSES|AUX_VERB_BITS,"pending noun status blocks possible verb or aux",changed)) return GUESS_RETRY;
		}
	}
	
	// starting up, if need subject and verb and after us is noun evidence and we could be verb, go with verb -- "here *comes the band"
	if (posValues[i] & NORMAL_NOUN_BITS && posValues[i] & (VERB_PRESENT_3PS|VERB_PRESENT) && needRoles[roleIndex] & MAINSUBJECT && needRoles[roleIndex] & MAINVERB && bitCounts[i+1] == 1 && posValues[i+1] & (PRONOUN_BITS|ADJECTIVE_BITS|DETERMINER|NOUN_BITS|PREDETERMINER))
	{
		unsigned int noun = i;
		while (++noun <= endSentence && !(posValues[noun] & (PRONOUN_BITS|NORMAL_NOUN_BITS))){;}
		if (posValues[noun] & (NOUN_SINGULAR|NOUN_PROPER_SINGULAR))
		{
			if (LimitValues(i, VERB_PRESENT_3PS,"3ps verb needed and shows up before clear singular noun",changed)) return GUESS_RETRY;
		}
		else if (posValues[noun] & (NOUN_PLURAL|NOUN_PROPER_PLURAL))
		{
			if (LimitValues(i, VERB_PRESENT,"present verb needed and shows up before clear singular noun",changed)) return GUESS_RETRY;
		}
		else 
		{
			if (LimitValues(i, VERB_PRESENT|VERB_PRESENT_3PS,"present verb needed and shows up before some kind of pronoun",changed)) return GUESS_RETRY;
		}
	}

	//starting up, if we need subject and verb and after us is noun evidence, we might be flippsed order with qword "what a big *nose he has" 
	if (posValues[i] & NORMAL_NOUN_BITS && posValues[i+1] & (PRONOUN_BITS|NORMAL_NOUN_BITS) && originalLower[startSentence] && originalLower[startSentence]->properties & QWORD)
	{
		if (LimitValues(i, -1 ^ VERB_TENSES,"qword inverted object before subject, reject verb meaning",changed)) return GUESS_RETRY;
	}

	// imperative infinitive when not followed by some bad things - "Go home" but not "just *like earthworms, I eat"
	if (i == startSentence && posValues[i] & VERB_INFINITIVE && !(posValues[i] & (AUX_VERB_BITS|NOUN_BITS|PRONOUN_BITS)) &&
		!(posValues[i] & (PRONOUN_BITS | CONJUNCTION_SUBORDINATE  | PREPOSITION  | ADJECTIVE_BITS | DETERMINER_BITS))) //  cant allow "have you seen"  Do you want, etc.
	{
		// but see if subject verb available next zone 
		if (currentZone == 0 &&  (zoneData[1] & (ZONE_SUBJECT|ZONE_FULLVERB)) == (ZONE_SUBJECT|ZONE_FULLVERB)) {;}
		else if (LimitValues(i, -1 ^ VERB_INFINITIVE,"command infinitive",changed)) return GUESS_RETRY; 
	}
	// imperative infinitive when not followed by some bad things - "*Boldly go home" but not "just *like earthworms, I eat" 
	if (i == (startSentence+1) && posValues[i] & VERB_INFINITIVE && !(posValues[i] & (AUX_VERB_BITS|NOUN_BITS|PRONOUN_BITS)) && posValues[i-1] & ADVERB_BITS &&
		!(posValues[i] & (PRONOUN_BITS | CONJUNCTION_SUBORDINATE  | PREPOSITION  | ADJECTIVE_BITS | DETERMINER_BITS))) //  cant allow "have you seen"  Do you want, etc.
	{
		// but see if subject verb available next zone 
		if (currentZone == 0 &&  (zoneData[1] & (ZONE_SUBJECT|ZONE_FULLVERB)) == (ZONE_SUBJECT|ZONE_FULLVERB)) {;}
		else if (LimitValues(i, -1 ^ VERB_INFINITIVE,"command infinitive",changed)) return GUESS_RETRY; 
	}

	// inverted order based on start as here,there,and nowhere - "nowhere *is that more evident." or based on negative starts- only once seldom "only once have I seen it"
	if (parseFlags[startSentence] & (LOCATIONAL_INVERTER|NEGATIVE_SV_INVERTER)  && roleIndex == MAINLEVEL && needRoles[MAINLEVEL] & MAINSUBJECT && posValues[i] & (VERB_PRESENT|VERB_PRESENT_3PS|VERB_PAST))
	{
		if (LimitValues(i, VERB_PRESENT|VERB_PRESENT_3PS|VERB_PAST,"inverted subject after negative or locational start means this is verb",changed)) return GUESS_RETRY; 
	}

	// present-tense std verb preceeded by singular noun subject will not be such "the pill *bug is" unless  conjunction in effect
	if (posValues[i] & VERB_PRESENT && roles[i-1] & (SUBJECT2|MAINSUBJECT) && posValues[i-1] & (NOUN_SINGULAR|NOUN_NUMBER|NOUN_PROPER_SINGULAR) && !coordinates[i-1])
	{
		if (LimitValues(i, -1 ^ VERB_PRESENT,"present plural verb after singular noun subject removed",changed)) return GUESS_RETRY; 
	}

	// present-tense 3ps  verb preceeded by singular noun subject will not be such "the pill *bug is"
	if (posValues[i] & VERB_PRESENT_3PS && roles[i-1] & (SUBJECT2|MAINSUBJECT) && posValues[i-1] & (NOUN_PLURAL|NOUN_PROPER_PLURAL))
	{
		if (LimitValues(i, -1 ^ (VERB_PRESENT_3PS|VERB_INFINITIVE),"singular plural verb or infinitive after plural subject noun removed",changed)) return GUESS_RETRY; 
	}

	// present-tense 3ps  verb preceeded by multiple noun subjects part of coordination will not be such "the pill, bottle, and *bug is"
	if (posValues[i] & VERB_PRESENT_3PS && roles[i-1] & (SUBJECT2|MAINSUBJECT) && posValues[i-1] & (NOUN_SINGULAR|NOUN_PROPER_SINGULAR) && coordinates[i-1])
	{
		if (LimitValues(i, -1 ^ VERB_PRESENT_3PS,"singular  verb  after conjuncted multiple subject nouns removed",changed)) return GUESS_RETRY; 
	}

	// infinitive verb after subject ONLY if aux question
	if (posValues[i] & VERB_INFINITIVE && roles[i-1] & (SUBJECT2|MAINSUBJECT)) 
	{
		unsigned int at = i-1;
		while (--at && !(posValues[at] & AUX_VERB_BITS))
		{
			if (posValues[at] & (CONJUNCTION_BITS|COMMA|PUNCTUATION|NOUN_BITS|PRONOUN_BITS|PREPOSITION|TO_INFINITIVE)) break;
		}
		if  (posValues[at] & AUX_VERB_BITS){;}
		else if (LimitValues(i, -1 ^ VERB_INFINITIVE,"cannot have infinitive verb after subject w/o aux",changed)) return GUESS_RETRY; 
	}

	// could also do same for pronouns, but not so vital

	// potential verb infinitive but we dont need anything and are followed by conjunction
	if (posValues[i] & VERB_INFINITIVE && roleIndex == MAINLEVEL && needRoles[MAINLEVEL] == 0 && posValues[i+1] & CONJUNCTION_BITS)
	{
		if (LimitValues(i,-1 ^ VERB_INFINITIVE,"infinitive unneeded and followed by conjunction, discard",changed)) return GUESS_RETRY;  // "let him go"
	}

	// potential verb infinitive and we want one
	if (posValues[i] & VERB_INFINITIVE && needRoles[roleIndex] & VERB_INFINITIVE_OBJECT)
	{
		if (LimitValues(i,VERB_INFINITIVE,"infinitive with causal verb infinitive, keep",changed)) return GUESS_RETRY; // "He heard the bird *sing"
	}  
	// potential verb infinitive following a noun and verb before does not take causal verb to infinitve
	if (posValues[i] & VERB_INFINITIVE && posValues[i-1] == NOUN_SINGULAR)
	{
		unsigned int at = FindPriorVerb(i);
		if (posValues[at] & VERB_TENSES && !(canSysFlags[at] & VERB_TAKES_INDIRECT_THEN_TOINFINITIVE) )
		{
			if (LimitValues(i,-1 ^ VERB_INFINITIVE,"infinitive follows noun but not causal verb infinitive, discard",changed)) return GUESS_RETRY; // "He took the day *off"
		}
	}

	// command
	if (i == startSentence && posValues[i] & VERB_INFINITIVE && posValues[i+1] & (PRONOUN_BITS|DETERMINER_BITS|ADJECTIVE_BITS|NOUN_BITS))
	{
		if (LimitValues(i,VERB_INFINITIVE,"Potential command at start has object after it so use it",changed)) return GUESS_RETRY; // "let him go"
	}

	// we arent expecting anything, but a moment ago it was a phrase that could have been elevated to a clause...
	if (posValues[i] & (VERB_PRESENT | VERB_PRESENT_3PS | VERB_PAST) && roleIndex == MAINLEVEL && !(needRoles[roleIndex] & (VERB2|MAINVERB)) && phrases[i-1])
	{
		if (FlipPrepToConjunction(i,true,changed))
		{
			LimitValues(i,(VERB_PRESENT | VERB_PRESENT_3PS | VERB_PAST)  ,"verb expected for clause",changed);
			return GUESS_RESTART;
		}
	}

	// we arent expecting anything, so kill off verb meanings
	if (posValues[i] & VERB_TENSES && posValues[i] & (ADVERB_BITS|ADJECTIVE_BITS|PARTICLE) && roleIndex == MAINLEVEL && needRoles[MAINLEVEL] == 0)
	{
		if (LimitValues(i,-1 ^ (VERB_PRESENT | VERB_PRESENT_3PS | VERB_PAST | VERB_PAST_PARTICIPLE | VERB_PRESENT_PARTICIPLE) ,"needing nothing, kill off verb meanings in favor of adverb/adj/particle except infinitive",changed)) return GUESS_RETRY;
	}
	
	// we arent expecting anything, keep verb infinitive (verbal) or particle after noun or pronoun but must have something after it
	if (posValues[i] & VERB_INFINITIVE && posValues[i-1] & (PRONOUN_BITS|NOUN_BITS) && roleIndex == MAINLEVEL && needRoles[MAINLEVEL] == 0 && i != endSentence && !(posValues[i+1] & CONJUNCTION_BITS)
		&& !(needRoles[roleIndex] & VERB_INFINITIVE_OBJECT)) // not "that will keep us *warm"
	{
		if (posValues[i] & PARTICLE) {;} 
		else if (LimitValues(i,VERB_INFINITIVE ,"needing nothing, keep potential verbal infinitive after noun/pronoun acting as postnominal adjective phrase",changed)) return GUESS_RETRY;
	}
	
	// "we watched them *play"
	if (posValues[i] & VERB_INFINITIVE && needRoles[roleIndex] & VERB_INFINITIVE_OBJECT)
	{
		if (LimitValues(i,VERB_INFINITIVE,"needing infinitive - go  infinitive",changed)) return GUESS_RETRY; 
	}

	// if something at the end of the sentence could be a verb and we dont want one.... dont be  "He can speak Spanish but he can't write it very *well."
	if (posValues[i] & VERB_TENSES && i == (int)endSentence && !(needRoles[MAINLEVEL] & MAINVERB) && roleIndex == MAINLEVEL)
	{
		if (verbStack[roleIndex] && canSysFlags[verbStack[roleIndex]] & VERB_TAKES_VERBINFINITIVE && needRoles[roleIndex] & MAINOBJECT) {;} //"let him run"
		else if (LimitValues(i,-1 ^ VERB_TENSES,"potential verb at end of sentence has no use",changed)) return GUESS_RETRY;
	}

	// if something might be verb, but AUX is later and no conjunction_subordinate exists, assume it cannot be a verb "*like what does she look"
	// BUT WE CANT TELL ABOUT CLAUSES EASILY

	// when cant tell the tense, pick past  "I *hit my friend"
	if (posValues[i] == (VERB_PRESENT|VERB_PAST))
	{
		if (LimitValues(i,VERB_PAST,"forcing PRESENT/PAST conflict on verb to past",changed)) return GUESS_RETRY;
	}

	// do we need a verb next which is in conflict with a noun
	uint64 remainder = posValues[i] & (-1 ^ (NOUN_BITS|VERB_TENSES));
	if (needRoles[roleIndex] & (VERB2|MAINVERB) && posValues[i] & VERB_TENSES && posValues[i] & NOUN_BITS && !remainder && 
	!(needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2)))
	{
		if (currentZone < zoneIndex && zoneData[currentZone+1] & ZONE_FULLVERB)	{;} // we expect verb in NEXT zone, so dont force it here
		else if (posValues[i+1] & (VERB_TENSES|AUX_VERB_BITS) && !(posValues[i+1] & (NOUN_BITS|ADJECTIVE_BITS|DETERMINER|POSSESSIVE_BITS))) {;}
		else
		{
			if (LimitValues(i,VERB_TENSES,"says verb required, binding tenses over noun",changed)) return GUESS_RETRY;
		}
	}
			
	// we need a verb- take whatever we can get - "the road following the edge of the frozen lake *died"
	if (currentZone < zoneIndex && zoneData[currentZone+1] & ZONE_FULLVERB)  {;} // we expect verb in NEXT zone, so dont force it here -- "My brother's car, a sporty red convertible with bucket *seats, is the envy of my friends."
	else if (needRoles[roleIndex] & (VERB2|MAINVERB) && posValues[i] & VERB_TENSES &&  !(posValues[i] & AUX_VERB_BITS) && !(needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2)))
	{
		// if we have no aux and this cannot be absolute because 1st is already that, drop past participle
		if (currentZone != 0 && posValues[i] & VERB_PAST_PARTICIPLE && zoneData[0] & ZONE_ABSOLUTE && !auxVerbStack[roleIndex]) 
		{
			if (LimitValues(i,-1 ^ VERB_PAST_PARTICIPLE,"limiting to anything but participle",changed)) return GUESS_RETRY;
		}
		if (auxVerbStack[roleIndex] && posValues[i] & (VERB_PRESENT_PARTICIPLE|VERB_INFINITIVE|VERB_PAST_PARTICIPLE)) 
		{
			if (LimitValues(i,VERB_PRESENT_PARTICIPLE|VERB_INFINITIVE|VERB_PAST_PARTICIPLE,"limiting to participles and infinitives",changed)) return GUESS_RETRY;
		}
		else if (posValues[i+1] & (VERB_TENSES|AUX_VERB_BITS) && bitCounts[i+1] == 1) // "I *even walked home"
		{
			if (LimitValues(i,-1 ^ (VERB_PRESENT|VERB_PAST|VERB_PRESENT_3PS),"removingverb tense since we need a verb but next is a verb",changed)) return GUESS_RETRY;
		}
		else if (posValues[i+1] & VERB_TENSES && canSysFlags[i+1] & VERB && canSysFlags[i] & ADVERB && posValues[i] & ADVERB_BITS) // "I *even make it home" - PROBABLE verb vs probable adverb
		{
			if (LimitValues(i,-1 ^ (VERB_PRESENT|VERB_PAST|VERB_PRESENT_3PS),"removingverb tense since we need a verb but next is a verb",changed)) return GUESS_RETRY;
		}
		else if (posValues[i] & ( VERB_PRESENT|VERB_PAST|VERB_PRESENT_3PS )) 
		{
			if (LimitValues(i, VERB_PRESENT|VERB_PAST|VERB_PRESENT_3PS,"limiting to verb tense since we need a verb",changed)) return GUESS_RETRY;
		}
	}

	// if this is a clausal verb w/o aux, then we must be normal...
	unsigned int startOf = zoneBoundary[currentZone] + 1; 
	if (clauses[startOf] && needRoles[roleIndex] & VERB2 && !auxVerbStack[roleIndex])
	{
		if (LimitValues(i,VERB_PRESENT|VERB_PAST|VERB_PRESENT_3PS,"says normal verb required for clause w/o aux",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
	}

	// "arms *folded, we lept"
	// if we are 1st zone and follow a noun with no aux and predicate is in next zone,  we are participle absolute phrase. unless we are a clause
	if (currentZone == 0 && posValues[i] & (VERB_PRESENT_PARTICIPLE|VERB_PAST_PARTICIPLE) && predicateZone >= 0 && zoneData[predicateZone] & ZONE_SUBJECT &&
		zoneData[predicateZone] != ZONE_AMBIGUOUS && (zoneData[currentZone] & ZONE_SUBJECT) && 
		!(zoneData[currentZone] & ZONE_AUX))
	{
		if (LimitValues(i, VERB_PRESENT_PARTICIPLE|VERB_PAST_PARTICIPLE,"says VERB_PARTICIPLE required for absolute phrase",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
	}
	
	 // can we infer present tense or infinitive when we need a verb -- "do you *attend this school"
	 if (posValues[i] == (VERB_PRESENT|VERB_INFINITIVE) && needRoles[roleIndex] & (VERB2|MAINVERB) )
	 {
		if (auxVerbStack[roleIndex] || needRoles[roleIndex] & MAINSUBJECT) // a command?
		{
			if (LimitValues(i, VERB_INFINITIVE,"is present tense verb since aux or is command",changed)) return GUESS_RETRY;
		}
		else if (LimitValues(i, VERB_PRESENT,"is present tense verb since no aux",changed)) return GUESS_RETRY;
	 }

	 // if following potential aux is potential verb, be aux.... "the sun *has set"
	 if (posValues[i] & VERB_TENSES && posValues[i] & AUX_VERB_BITS && posValues[i+1] & VERB_TENSES) 
	 {
		if (LimitValues(i,-1 ^ VERB_TENSES,"presume aux not verb given potential verb thereafter",changed)) return GUESS_RETRY; 
	 }
	return GUESS_NOCHANGE;
}

static unsigned int GuessAmbiguousParticle(unsigned int i, bool & changed)
{
	WORDP D = NULL;
	unsigned int priorPhrasalVerb = PriorPhrasalVerb(i,D);
	if (!priorPhrasalVerb)
	{
		if (LimitValues(i,-1 ^ PARTICLE,"verb before potential particle cant have one, dont be one",changed)) return GUESS_RETRY;
	}
		
	// cannot have adverb before split phrasal: "I crawled all *over" not allowed
	if (posValues[i-1] & ADVERB_BITS)
	{
		if (LimitValues(i,-1 ^ PARTICLE,"particle can only be split by object, not adverb",changed)) return GUESS_RETRY;
	}
	// if it might be particle or adverb, be particle - "the thought of getting up is bad"
	if (posValues[i] == (ADVERB_NORMAL|PARTICLE)) // if causal is possible
	{
		if (LimitValues(i, PARTICLE," be particle in particle-adverb conflict",changed)) return GUESS_RETRY; 
	}
	// if prep or particle
	if (!(posValues[i] & TO_INFINITIVE)) // does verb before want a particle?
	{
		if (bitCounts[i+1] == 1 && posValues[i+1] & (NOUN_SINGULAR|NOUN_PLURAL|ADJECTIVE_BITS|PREDETERMINER|DETERMINER|PRONOUN_POSSESSIVE))
		{
			if (LimitValues(i,PARTICLE,"verb before potential particle can have one, but we have noun phrase after, so assume particle w object",changed)) return GUESS_RETRY;
		}
		else if (posValues[i+1] & NOUN_GERUND) // "Wolfson wrote a book *about playing basketball"
		{
			if (LimitValues(i,-1 ^ PARTICLE,"verb before potential particle can have one, but we have noun gerund after, so assume !particle",changed)) return GUESS_RETRY;
		}
		else if (posValues[i+1] & PRONOUN_OBJECT && !(D->systemFlags & VERB_DIRECTOBJECT)) // "You need not make such a fuss *over it."
		{
			if (LimitValues(i,-1 ^ PARTICLE,"verb before potential particle can have one, but we have probable pronoun after and it wont take object, so assume !particle",changed)) return GUESS_RETRY;
		}
		else 
		{
			if (LimitValues(i,PARTICLE,"verb before potential particle can have one and not to infinitive, be one",changed)) return GUESS_RETRY; // "I did not know if my boss would let me take the day *off, so I left early" but not "I would write to him"
		}
	}

	// we arent expecting anything, keep verb infinitive (verbal) or particle after noun or pronoun but must have something after it
	if (posValues[i] & VERB_INFINITIVE && posValues[i-1] & (PRONOUN_BITS|NOUN_BITS) && roleIndex == MAINLEVEL && needRoles[MAINLEVEL] == 0 && i != endSentence && !(posValues[i+1] & CONJUNCTION_BITS))
	{
		if (posValues[i] & PARTICLE) 
		{
			if (LimitValues(i,PARTICLE ,"needing nothing, keep potential particle after noun/pronoun",changed)) return GUESS_RETRY; // "The guy who has to decide, Hamlet, decides to stick it *out for a while."
		}
	}

	// we could be particle, no longer considering noun or verb and next is not noun evidence, be particle
	if (!(posValues[i] & (VERB_TENSES|NOUN_BITS)) && !(posValues[i+1] & (ADJECTIVE_BITS|DETERMINER|NOUN_BITS)))
	{
		if (priorPhrasalVerb != (i-1) && !(posValues[i+1] & (ADJECTIVE_BITS|DETERMINER_BITS|PRONOUN_BITS|NOUN_BITS))) // not immediately after "you make a fuss *over me" and no noun after
		{
			if (LimitValues(i, PARTICLE," particle immediately after particle verb",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
		}
	}
	
	// in adverb particle conflict at end of sentence, be particle "jack stopped before continuing *on."
	if (posValues[i] == (ADJECTIVE_NORMAL|PARTICLE) && i == endSentence)
	{
		if (LimitValues(i, PARTICLE,"ending adjective/particle conflict, be particle",changed)) return GUESS_RETRY; 
	}
	// if likely adjective and seeking factitive adjective for object, accept it, unless its particle "why not make it *up to him"
	if (posValues[i] & ADJECTIVE_NORMAL && needRoles[roleIndex] & OBJECT_COMPLEMENT)
	{
		if (posValues[i] & PARTICLE)
		{
			if (LimitValues(i, PARTICLE," be particle in particle-factative conflict needing object complement",changed)) return GUESS_RETRY;
		}
	}
	
	// DONT be particle if before you is adverb "I looked all *around" - adverb should be AFTER particle "I looked up rapidly" not "I looked rapidly up"
	if (posValues[i-1] == ADVERB_NORMAL)
	{
		if (LimitValues(i,-1 ^ PARTICLE,"adverb immediately before means we wont be particle",changed)) return GUESS_RETRY; 
	}
	// in adverb particle conflict at end of sentence, be particle "jack stopped before continuing *on."
	if (posValues[i] == (ADVERB_NORMAL|PARTICLE) && i == endSentence)
	{
		if (LimitValues(i, PARTICLE,"ending adverb/particle conflict, be particle",changed)) return GUESS_RETRY; 
	}
	
	// if it might be particle or adverb, be particle - "the thought of getting up is bad"
	if (posValues[i] == (ADVERB_NORMAL|PARTICLE)) // if causal is possible
	{
		if (LimitValues(i, PARTICLE," be particle in particle-adverb conflict",changed)) return GUESS_RETRY; 
	}
	// if we want a noun, maybe be particle instead
	if (posValues[i] & (NOUN_SINGULAR|NOUN_PLURAL) && needRoles[roleIndex] & (OBJECT2 | MAINSUBJECT | MAINOBJECT))
	{
		// if looking for object and this could be particle, take it unless prep phrase...  "I like getting *up and working out" but not "I rolled on my *back"
		if (needRoles[roleIndex] & (OBJECT2|MAINOBJECT) && posValues[i] & PARTICLE && !(needRoles[roleIndex] & PHRASE))
		{
			if (LimitValues(i, PARTICLE,"noun vs particle as object, go for particle",changed)) return GUESS_RETRY;
		}
	}
	
	return GUESS_NOCHANGE;
}

static bool CouldBeAdjective(unsigned int i)
{
	while (++i <= endSentence)
	{
		if (posValues[i] & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL)) return false; // no one puts adjectives in front of proper names?
		if (posValues[i] & NORMAL_NOUN_BITS) return true;
		if (!(posValues[i] & (ADJECTIVE_BITS|ADVERB_BITS))) return false;
	} 
	return false;
}

static unsigned int GuessAmbiguousAdjective(unsigned int i, bool &changed)
{
	unsigned int currentVerb = (roleIndex == MAINLEVEL) ? currentMainVerb : currentVerb2;

	// we need subject complement, so be it
	if (needRoles[roleIndex] & SUBJECT_COMPLEMENT) 
	{
		// adjective not a good complement
		if (parseFlags[i] & NON_COMPLEMENT_ADJECTIVE) // "the balloon is *little" -
		{
			if (LimitValues(i, -1 ^ ADJECTIVE_BITS,"need subject complement, but adj is lousy, discard",changed)) return GUESS_RETRY;  // "there were many little shells"
		}
	
		// if ambiguity is Adjective_basic Adverb_basic and wanting adjective as object, be adjective if next is junk "Samson was powerful but foolish"  but not "Max looked *all_over for her" and not "the ball was *inside"
		if (posValues[i] == (ADJECTIVE_NORMAL|ADVERB_BITS)  && (posValues[i+1] & (CONJUNCTION_BITS|COMMA|PAREN) || i == endSentence))
		{
			// locational adverbs should be priority - "the ball was inside"
			if (canSysFlags[i] & LOCATIONWORD) 
			{
				if (LimitValues(i, -1 ^ ADJECTIVE_NORMAL ,"adjective that could be locational adverb at end of clause discarded",changed)) return GUESS_RETRY;
			}
			else if (canonicalLower[currentVerb] && !stricmp(canonicalLower[currentVerb]->word,"go"))
			{
				if (LimitValues(i, -1 ^ ADJECTIVE_NORMAL ,"adjective-adverb when go used  and next is junk",changed)) return GUESS_RETRY;
			} // adverbs are likely directiooal (go inside, go home)
			else if (LimitValues(i, ADJECTIVE_NORMAL ,"adjective-adverb when expecting adjective and next is junk",changed)) return GUESS_RETRY; 
		}

		// we need subject complement and before us was adverb, be it
		if (posValues[i-1] & ADVERB_BITS) // "the kitty was too *small to eat"
		{
			if (LimitValues(i, ADJECTIVE_BITS,"need subject complement, be adj preceeded by adverb",changed)) return GUESS_RETRY;  // "there were many little shells"
		}

		// adjective adverb conflict but looks good as an adjective
		if (parseFlags[i] & ADJECTIVE_GOOD_SUBJECT_COMPLEMENT) // "the balloon is *little" -
		{
			if (LimitValues(i, ADJECTIVE_BITS,"need subject complement, be adj preceeded by adverb",changed)) return GUESS_RETRY;  // "there were many little shells"
		}

		if ( !(posValues[i] & ADVERB_BITS))// not "she was *up on the bank"
		{
			if (CouldBeAdjective(i) && needRoles[roleIndex] & (OBJECT2|MAINOBJECT)) // we will pass on being subject comp // "there were many little shells"
			{
				// if usually this is preposition and not adjective, be not adjective - "Bob was *under John"
				if (posValues[i] & PREPOSITION && canSysFlags[i] & PREPOSITION && !(canSysFlags[i] & ADJECTIVE))
				{
					if (LimitValues(i, -1 ^ ADJECTIVE_BITS,"likely prep rather than subj complement adjective with noun",changed)) return GUESS_RETRY;  // "there were many little shells"
				}
				else
				{
					needRoles[roleIndex] &= -1 ^ SUBJECT_COMPLEMENT;
					if (LimitValues(i, ADJECTIVE_BITS,"skip subject complement, be adj leading to noun",changed)) return GUESS_RETRY;  // "there were many little shells"
				}
			}
			else if (posValues[i] & PREPOSITION && canSysFlags[i] & PREPOSITION && !(canSysFlags[i] & ADJECTIVE))
			{
				if (LimitValues(i, -1 ^ ADJECTIVE_BITS,"likely prep rather than subj complement adjective with noun",changed)) return GUESS_RETRY;  // "there were many little shells"
			}
			else if (LimitValues(i, ADJECTIVE_BITS,"need subject complement, so be it",changed)) return GUESS_RETRY;  // "there were many little shells"
		}
	}

	// if this is a number and next could be adjective, lets just wait "I have *3 purple mugs"
	if (posValues[i] & NOUN_NUMBER && posValues[i+1] & (ADJECTIVE_BITS|NORMAL_NOUN_BITS)) 
	{
		if (LimitValues(i, ADJECTIVE_BITS,"need subject complement, so be it",changed)) return GUESS_RETRY;  
	}

	// after verb and before preposition, will not be adjective if not complement expected (may be particle or adverb) "josh ran *ahead of her"
	if (roles[i-1] & (VERB2|MAINVERB) && !(needRoles[roleIndex] & (SUBJECT_COMPLEMENT|OBJECT_COMPLEMENT)) && !(posValues[i+1] & (DETERMINER_BITS|ADJECTIVE_BITS|NOUN_BITS)))
	{
		if (LimitValues(i, -1 ^ ADJECTIVE_BITS,"unwanted adj after verb, discard ",changed)) return GUESS_RETRY; 
	}

	// if we are expecting an object and this could be ADJECTIVE OR DETERMINER and nothing came before and what follows is signs of noun, be it - but not prep as in "they are under the pots"
	if (!(posValues[i-1] & (DETERMINER_BITS|ADJECTIVE_BITS|POSSESSIVE_BITS)) && posValues[i] & DETERMINER_BITS  && needRoles[roleIndex] & (OBJECT2|MAINOBJECT) && posValues[i+1] & (ADJECTIVE_BITS | NORMAL_NOUN_BITS)) // "I won *first prize"
	{
		if (LimitValues(i, -1 ^ ADJECTIVE_BITS,"determiner/adjective clash when wanting object and after seems adj or noun, be not adjective if we would head the noun",changed)) return GUESS_RETRY; 
	}
	
	// if something is a noun or adjective, and before it was noun starter, and after is not noun but might be adjective or prep and is likely prep, assume we are noun "The chief surgeon, an *expert in organ transplant procedures, took her nephew on a hospital tour."
	if (posValues[i] & ADJECTIVE_NORMAL && posValues[i-1] & (ADJECTIVE_BITS|DETERMINER) && !(posValues[i+1] & NORMAL_NOUN_BITS) && posValues[i+1] & PREPOSITION && canSysFlags[i+1] & PREPOSITION)
	{
		if (LimitValues(i, -1 ^ ADJECTIVE_NORMAL,"be not adj after noun phrase started when next is probably prep",changed)) return GUESS_RETRY; 
	}

	// if we are not looking for anything at level 1 (had object) but we could be a noun or verb and prior was a noun direct object, presume he should be adjectival noun "he ate the carrot *cake"
	if (roleIndex == MAINLEVEL && needRoles[MAINLEVEL] == 0 && posValues[i-1] & NOUN_SINGULAR && roles[i-1] & MAINOBJECT && posValues[i] & NOUN_SINGULAR && posValues[i] & VERB_TENSES)
	{
		if (allOriginalWordBits[i-1] & ADJECTIVE_NORMAL)
		{
			if (LimitValues(i-1,ADJECTIVE_NORMAL,"convert prior presumed noun to adjective that it could have been",changed))
			{
				if (roles[i-1]) SetRole(i-1,0);
				return GUESS_RETRY;
			}
		}
		else LimitValues(i-1,ADJECTIVE_NOUN,"convert prior presumed noun to adjective from us",changed);
		needRoles[MAINLEVEL] |= MAINOBJECT;
	}

	// if something could be noun or verb infinitive, and we need a noun, use noun - but not "while walking *home, Jack ran"
	// AND must have TO before it or be a verb not requiring it...  not "Nina raced her brother Carlos *down the street"
	if (!(posValues[i] & PREPOSITION) && posValues[i] & NOUN_INFINITIVE && needRoles[roleIndex] & (MAINOBJECT|OBJECT2) && !(posValues[i-1] & (NOUN_INFINITIVE|NOUN_GERUND)))
	{
		// unless causal infinitive- "we watched them play"
		if (posValues[i] & ADJECTIVE_PARTICIPLE && needRoles[roleIndex] & SUBJECT_COMPLEMENT) // she was getting *upset"
		{
			if (LimitValues(i,ADJECTIVE_PARTICIPLE,"need complement, take adjective particple",changed)) return GUESS_RETRY; 
		}
	}

	// correlative adverb:  neither wind nor 
	if (parseFlags[i] & CORRELATIVE_ADVERB)
	{
		unsigned int at = i;
		while (++at < endSentence)
		{
			if (!stricmp(wordStarts[at],"nor") && !stricmp(wordStarts[i],"neither")) break;
			if (!stricmp(wordStarts[at],"and") && !stricmp(wordStarts[i],"both")) break;
			if (!stricmp(wordStarts[at],"or") && (!stricmp(wordStarts[i],"whether") || !stricmp(wordStarts[i],"either"))) break;
			if (!stricmp(wordStarts[at],"but_also") && (!stricmp(wordStarts[i],"not_only") || !stricmp(wordStarts[i],"either"))) break;
			if (!stricmp(wordStarts[at],"also") && !stricmp(wordStarts[at-1],"but") && !stricmp(wordStarts[i-1],"not") && !stricmp(wordStarts[i],"only")) break;
		}
		if (at < endSentence)
		{
			LimitValues(at, CONJUNCTION_COORDINATE,"other part of correlative found",changed);
			if (LimitValues(i, -1 ^ ADJECTIVE_BITS,"correlative adverb found a mate, be not adjective",changed))  return GUESS_RETRY; 
		}
	}

	// if we could be adjective but are not expecting a complement and are followed by a pronoun, dont be adjective - having seen verb: not "how *fine he looks"   but "I got her *some more."
	if (currentMainVerb && posValues[i+1] & (PRONOUN_BITS|NOUN_PROPER_SINGULAR))
	{
//		if (LimitValues(i,-1 ^ ADJECTIVE_BITS,"possible adjective is followed by a pronoun, so no.",changed)) return GUESS_RETRY; // might not be real -
	}

	// absolute phrase at start or end of sentence?  "arms *waving, he jumped"
	if (posValues[i] & ADJECTIVE_PARTICIPLE && !(posValues[i] & (VERB_PRESENT|VERB_PAST|VERB_PRESENT_3PS)) && (currentZone == 0 || currentZone == (zoneIndex-1)) && zoneIndex > 1 && !auxVerbStack[MAINLEVEL])
	{
		unsigned int at = i;
		while (--at > 1 && !phrases[at] && !verbals[at] && !clauses[at]  && !(roles[at] & ( SUBJECT2 | MAINSUBJECT | OBJECT2) )) {;}
		if (needRoles[MAINLEVEL] & MAINVERB) // we need a verb and this cant be it
		{
			if (LimitValues(i, ADJECTIVE_PARTICIPLE,"absolute phrase allows participles",changed)) return GUESS_RETRY;
		}
	}
	
	// if we need a verb and dont need a subject, then dont be adjective if can be a verb
	if (!(needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2)) && needRoles[roleIndex] & (VERB2|MAINVERB) && posValues[i] & VERB_TENSES) // Ponto then *found her"
	{
		if (LimitValues(i,-1 ^ ADJECTIVE_BITS,"dont be adjective when can be verb and we need a verb",changed)) return GUESS_RETRY; 
	}

	// nouninfintive following to infinintive, be noun infinitive "it is time to *go"
	if (posValues[i] & (NOUN_INFINITIVE|VERB_INFINITIVE) && posValues[i-1] == TO_INFINITIVE)
	{
		if (LimitValues(i,-1 ^ ADJECTIVE_BITS,"after TO infinitive will not be adjective",changed)) return GUESS_RETRY; 
	}

	if (needRoles[roleIndex] & SUBJECT_COMPLEMENT) // "it was *wrong"
	{
		if (needRoles[roleIndex] & (OBJECT2|MAINOBJECT)) {;} // but can be used for this
		else if (parseFlags[i] & ADJECTIVE_NOT_SUBJECT_COMPLEMENT) // "the bread is *up near the top"
		{
			if (LimitValues(i, -1 ^ ADJECTIVE_BITS,"adjective not usable as subject complement",changed)) return GUESS_RETRY; 
		}
		else if (LimitValues(i, ADJECTIVE_BITS,"can use subject complement, so be adjective",changed)) return GUESS_RETRY; 
	} 
		
	if (posValues[i] == AMBIGUOUS_VERBAL)
	{
		// we need a noun, go for that, unless it is followed by a noun, in which case we be adjective particile
		if (needRoles[roleIndex] & (MAINOBJECT|OBJECT2|MAINSUBJECT|SUBJECT2))
		{
			if (posValues[i+1] & (ADJECTIVE_BITS|NOUN_BITS) && !(posValues[i+1] & (-1 ^ (ADJECTIVE_BITS|NOUN_BITS))) ) {;} 
			{
				if (LimitValues(i,ADJECTIVE_PARTICIPLE,"expect we describe following noun",changed)) return GUESS_RETRY;  // can only be a noun
			}
		}
	}
	
	// if this is adjective or noun and following is a possible noun, be adjective, unless we are sentence start and "here" "there" etc
	if (posValues[i] & ADJECTIVE_NORMAL && posValues[i] & NOUN_SINGULAR && posValues[i+1] & (NOUN_SINGULAR|NOUN_PLURAL))
	{
		if (posValues[i] & ADVERB_BITS && i == startSentence && (!stricmp(wordStarts[i],"here") || !stricmp(wordStarts[i],"there")))
		{
			if (LimitValues(i,-1 ^ ADJECTIVE_BITS ,"dont be adj when here/there starts a sentence",changed)) return GUESS_RETRY;
		}
		// not a conflict if we need indirect and this is human
		else if (canSysFlags[i] & ANIMATE_BEING && needRoles[roleIndex] & (MAININDIRECTOBJECT|INDIRECTOBJECT2)) {;}// "he had the *mechanic check the brakes"
		else
		{
			if (LimitValues(i,ADJECTIVE_NORMAL ,"adj noun conflict before potential normal noun, be adj",changed)) return GUESS_RETRY;
		}
	}
	
	// if prior is det/adj and this  is adjective or noun and not followed by more adj or noun, we must not be adjective   "His red *convertible from home was green"
	if (posValues[i-1] & (DETERMINER|ADJECTIVE_BITS) && posValues[i] & ADJECTIVE_NORMAL && !(posValues[i+1] & (NOUN_BITS|ADJECTIVE_BITS|ADVERB_BITS)))
	{
		if (LimitValues(i,-1 ^ ADJECTIVE_NORMAL ,"noun phrase started but this potential adj not followed by more noun phrase stuff, be not adjective",changed)) return GUESS_RETRY;
	}

	// ending adjective makes no sense - but legal is "john painted his old jalopy *purple"
	if (posValues[i] & ADJECTIVE_NORMAL && i == endSentence && i != startSentence && roleIndex == MAINLEVEL && !(needRoles[roleIndex] & (SUBJECT_COMPLEMENT|OBJECT_COMPLEMENT)) && !(posValues[i-1] & PRONOUN_BITS)) // "there is nothing *good."
	{
		if (LimitValues(i, -1 ^ ADJECTIVE_NORMAL ,"not ending sentence in adjective since not subject complement or after pronoun",changed)) return GUESS_RETRY;
	}

	// if ambiguity is adjectvie/adverb, immediately after object/mainobject, go with adjective (assume its postnominal adjective even if verb didnt require it)
	if (posValues[i] == (ADJECTIVE_NORMAL|ADVERB_NORMAL) && roles[i-1] & MAINOBJECT && !(parseFlags[i] & ADJECTIVE_NOT_SUBJECT_COMPLEMENT))
	{
		if (LimitValues(i, ADJECTIVE_NORMAL ,"probable postnominal adjective after main direct object",changed)) return GUESS_RETRY; 
	}

	// if likely adjective and seeking factitive adjective for object, accept it, unless its particle "why not make it *up to him" or unless determiner before noun or adjective
	if (posValues[i] & ADJECTIVE_NORMAL && needRoles[roleIndex] & OBJECT_COMPLEMENT && !(posValues[i] & PREPOSITION)) // not "tom has his hat *in his hand"
	{
		if (parseFlags[i] & ADJECTIVE_NOT_SUBJECT_COMPLEMENT) {;}
		else if (posValues[i] & DETERMINER && posValues[i+1] & (ADJECTIVE_BITS|NOUN_BITS)) {;} // my dog found another ball
		else if (LimitValues(i, ADJECTIVE_NORMAL ,"factitive verb expects adjective, be that",changed)) return GUESS_RETRY;
	}

	// we are allowed to be postpostive adj after noun - except if preposition "see the duck *on the pond"
	if (posValues[i-1] & (NOUN_SINGULAR|NOUN_PLURAL) && canSysFlags[i] & ADJECTIVE_POSTPOSITIVE && !(posValues[i] & PREPOSITION))
	{
		if (LimitValues(i, ADJECTIVE_NORMAL ,"postpositive legal adjective after known noun",changed)) return GUESS_RETRY; 
	}
	
	// if ambiguity is Adjective_basic Adverb_basic and wanting adjective as object, be adjective if next is junk "Samson was powerful but foolish"  but not "Max looked *all_over for her" and not "the ball was *inside"
	if (posValues[i] == (ADJECTIVE_NORMAL|ADVERB_BITS) && needRoles[roleIndex] & SUBJECT_COMPLEMENT && (posValues[i+1] & (CONJUNCTION_BITS|COMMA|PAREN) || i == endSentence) &&
		!(parseFlags[i] & NON_COMPLEMENT_ADJECTIVE))
	{
		// locational adverbs should be priority - "the ball was inside"
		if (canSysFlags[i] & LOCATIONWORD) {;}
		else if (posValues[i] & ADVERB_BITS && canonicalLower[currentVerb] && !stricmp(canonicalLower[currentVerb]->word,"go")){;} // adverbs are likely directiooal (go inside, go home)
		else if (LimitValues(i, ADJECTIVE_NORMAL ,"adjective-adverb when expecting adjective and next is junk",changed)) return GUESS_RETRY; 
	}

	int beAdj = 0;
	if (posValues[i+1] & NOUN_BITS && bitCounts[i+1] == 1) beAdj = i+1;
	else if (i < (endSentence - 1) && posValues[i+1] & ADJECTIVE_BITS  && bitCounts[i+1] == 1 && posValues[i+2] & NOUN_BITS) beAdj = i+2;
	else if (i < (endSentence - 2) && posValues[i+1] & ADJECTIVE_BITS  && bitCounts[i+1] == 1 && posValues[i+2] & ADJECTIVE_BITS && posValues[i+3]) beAdj = i+3;
	if (!beAdj){;}
	else if (bitCounts[beAdj] == 1) {;} // yes
	else if (canSysFlags[beAdj] & NOUN) {;}
	else beAdj = 0;	// not a probable noun
	if (beAdj && !(posValues[i] & (PARTICLE|PREPOSITION))) // can be an adjective, have upcoming noun, and cant be particle (whose verb might take an object) "mom picked *up Eve after school"
	{
		if (!(posValues[i] & NOUN_GERUND) && !(posValues[i] & PREPOSITION)) // cant be gerund or particle -- "just *like earthworms I eat
		{
			if (LimitValues(i,ADJECTIVE_BITS|DETERMINER,"potential adj nongerund preceeding nearby noun, be adjective or determiner",changed)) return GUESS_RETRY;
		}
		// if verb cannot take an object, must be adjective   // "he hates *decaying broccoli"
		else if (posValues[i] & NOUN_GERUND && !(canSysFlags[i]  & VERB_DIRECTOBJECT))
		{
			if (LimitValues(i,ADJECTIVE_BITS|DETERMINER,"potential adj not verb needing direct object preceeding nearby noun, be adjective or determiner",changed)) return GUESS_RETRY;
		}
	}
	
	// if this is LIKELY an adjective not a noun and we are seeking a noun but could find it later, be an adjective
	if (originalLower[i] && originalLower[i]->systemFlags & ADJECTIVE && !(originalLower[i]->systemFlags & NOUN) && needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2|OBJECT2|MAINOBJECT))
	{
		unsigned at = i;
		while (++at <= endSentence)
		{ 
			if (posValues[at] & (NOUN_BITS|PRONOUN_BITS))
			{ // "Juanita and Celso worked *hard and then rested."
				if (LimitValues(i,ADJECTIVE_BITS|ADVERB_BITS,"probable adj/adverb while needing a noun and one found later, be adj/adv",changed)) return GUESS_RETRY;
				break;
			}
		}
	}


	// if we could be adjective participle having no noun in front of us, we dont want to be gerund if we havent come to subject zone yet
	// we want to describe subject in later zone
	if (posValues[i] & ADJECTIVE_PARTICIPLE && predicateZone >= 0 && zoneData[predicateZone] & ZONE_SUBJECT &&
		(int) currentZone == (predicateZone - 1) && !(zoneData[predicateZone] & ZONE_AMBIGUOUS) && !(zoneData[currentZone] & ZONE_SUBJECT))
	{
		if (LimitValues(i, ADJECTIVE_PARTICIPLE,"says ADJECTIVE_PARTICIPLE required because subj/verb is in next zone",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
		// could we be a noun appositive?  seems unlikely
	}
	return GUESS_NOCHANGE;
}

static unsigned int GuessAmbiguousAdverb(unsigned int i, bool &changed)
{	
	// if this can be adverb, and next could be adjective, do that "i feel *so blue" -- but "I feel *so blue people dont have to"

	if (i != startSentence && posValues[i] & ADVERB_BITS && !stricmp(wordStarts[i], "but") && posValues[i+1] & ADJECTIVE_BITS)  // "there is but one god." dont make conjunction or prep
	{
		if (posValues[i+2] & NORMAL_NOUN_BITS) // need a noun after to make this modify an adjective modifying a noun- otherwise might be conjoined adjective_object
		{
			if (LimitValues(i,ADVERB_BITS,"defaulting adverb/prep/conjunction as adverb like 'but one god'",changed)) return GUESS_RETRY;
		}
	}

	if (needRoles[roleIndex] & SUBJECT_COMPLEMENT && posValues[i] & ADVERB_BITS && posValues[i+1] & ADJECTIVE_BITS) // "they  are *most active at night"
	{
		if (needRoles[roleIndex] & (MAINOBJECT|OBJECT2) && posValues[i+1] & (PRONOUN_BITS|NOUN_BITS)){;} // "I will get her *some more" 
		else if (LimitValues(i,ADVERB_BITS,"resolving to adverb based on need of subject compleement and following potential adj ",changed)) return GUESS_RETRY; 
	}

	// if noun evidence follows it, be not an adverb unless it is sentence start 
	if (i != startSentence && posValues[i] & ADVERB_BITS && posValues[i+1] & (DETERMINER_BITS|NOUN_BITS|PRONOUN_BITS) && bitCounts[i+1] == 1 ) // "i have a paper to write *before class"
	{
		if (LimitValues(i, -1 ^ ADVERB_BITS," prep/adv conflict followed by noun evidence, be not adverb",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
	}

	// if this could be adjective or adverb and is in front of adjective, prefer adjective - "the *little old lady" but not "we were *all afraid
	if (posValues[i] & ADJECTIVE_NORMAL && posValues[i] & ADVERB_BITS && posValues[i+1] == ADJECTIVE_NORMAL)
	{
		if (needRoles[roleIndex] & SUBJECT_COMPLEMENT) // cant have 2 sub compl  in  a row
		{
			if (LimitValues(i,ADVERB_BITS,"adverb or adj conflict in front of adjective, be adverb since cant have 2 subject complements in row",changed)) return GUESS_RETRY;
		}
		else if (LimitValues(i,-1 ^ ADVERB_BITS,"adverb or adj conflict in front of adjective, be adjective",changed)) return GUESS_RETRY;
	}

	// if ambiguity is Adjective_basic Adverb_basic and wanting adjective as object, be adjective if next is junk "Samson was powerful but foolish"  but not "Max looked *all_over for her" and not "the ball was *inside"
	if (posValues[i] == (ADJECTIVE_NORMAL|ADVERB_BITS) && needRoles[roleIndex] & SUBJECT_COMPLEMENT && (posValues[i+1] & (CONJUNCTION_BITS|COMMA|PAREN) || i == endSentence) &&
		!(parseFlags[i] & NON_COMPLEMENT_ADJECTIVE))
	{
		// locational adverbs should be priority - "the ball was inside"
		if (canSysFlags[i] & LOCATIONWORD)
		{
			if (LimitValues(i, ADVERB_BITS ,"subject complement adjective-adverb where adverb is locational, prefer it",changed)) return GUESS_RETRY; 
		}
	}

	if (i == startSentence && !stricmp(wordStarts[i],"why")) // assume why is an adverb
	{
		if (LimitValues(i,ADVERB_NORMAL,"starting sentence with why will be adverb, not noun",changed)) return GUESS_RETRY; 
	}

	// correlative adverb:  neither wind nor 
	if (parseFlags[i] & CORRELATIVE_ADVERB)
	{
		unsigned int at = i;
		while (++at < endSentence)
		{
			if (!stricmp(wordStarts[at],"nor") && !stricmp(wordStarts[i],"neither")) break;
			if (!stricmp(wordStarts[at],"and") && !stricmp(wordStarts[i],"both")) break;
			if (!stricmp(wordStarts[at],"or") && (!stricmp(wordStarts[i],"whether") || !stricmp(wordStarts[i],"either"))) break;
			if (!stricmp(wordStarts[at],"but_also") && (!stricmp(wordStarts[i],"not_only") || !stricmp(wordStarts[i],"either"))) break;
			if (!stricmp(wordStarts[at],"also") && !stricmp(wordStarts[at-1],"but") && !stricmp(wordStarts[i-1],"not") && !stricmp(wordStarts[i],"only")) break;
		}
		if (at < endSentence)
		{
			LimitValues(at, CONJUNCTION_COORDINATE,"other part of correlative found",changed);
			if (LimitValues(i, ADVERB_BITS,"correlative adverb found a mate",changed)) return GUESS_RETRY; 
		}
	}
	

	// place number as adverb cannot be in front of noun or adjective, "first, he wept"
	if (allOriginalWordBits[i] & NOUN_NUMBER && posValues[i+1] & (NOUN_BITS|ADJECTIVE_BITS|DETERMINER|POSSESSIVE_BITS))
	{
		if (LimitValues(i, -1 ^ ADVERB_BITS,"place number cannot be adverb in front of adjective or noun or det or possessive",changed)) return GUESS_RETRY; 
	}

	// start of sentence adverb that might be coordinating conjunction, DONT be adverb "but he was dead"
	if (posValues[i] & CONJUNCTION_COORDINATE && i == startSentence)
	{
		if (LimitValues(i, -1 ^ ADVERB_BITS,"sentence start possible conjunction or adverb, be not adverb",changed)) return GUESS_RETRY; 
	}
	

	// if adverb is probably and immediately after aux and possible ver after it, be adverb "jack can *still smell"
	if (canSysFlags[i] & ADVERB && posValues[i-1] & AUX_VERB_BITS && posValues[i+1] & VERB_TENSES)
	{
		if (LimitValues(i, ADVERB_BITS,"probable adverb sandwiched after aux and before potential verb",changed)) return GUESS_RETRY; 
	}

	// if word is sandwiched after a verb and before a conjunction, be adverb
	if (posValues[i-1] & (VERB_TENSES|NOUN_GERUND|NOUN_INFINITIVE) && posValues[i+1] & CONJUNCTION_BITS)
	{
		if (LimitValues(i, ADVERB_BITS," be adverb sandwiched between verb and conjunction",changed)) return GUESS_RETRY; 
	}

	// if word is sandwiched after a verb and at sentence end -- but not if possible adjective of causal verb or postpositive adjective
	if (!(posValues[i] & ADJECTIVE_BITS) && posValues[i-1] & (VERB_TENSES|NOUN_GERUND|NOUN_INFINITIVE) && i == endSentence)
	{
		if (LimitValues(i, ADVERB_BITS," be adverb after verb at end",changed)) return GUESS_RETRY; 
	}

	// if a timeword could be an adverb, make it so (if we wanted a noun by now it would be one)  "right *now we will go" but not "it flew *past me"
	if (posValues[i] & ADVERB_BITS && originalLower[i] && originalLower[i]->systemFlags & TIMEWORD & !(posValues[i] & PREPOSITION))
	{
		if (LimitValues(i, ADVERB_BITS," time word could be adverb, make it so",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
	}
	// if word after could be a timeword and we could be an adverb, make it so  "*right now we will go"
	if (posValues[i] & ADVERB_BITS && posValues[i+1] & ADVERB_BITS && originalLower[i+1] && originalLower[i+1]->systemFlags & TIMEWORD )
	{
		if (LimitValues(i, ADVERB_BITS," next could be time word and we could be adverb, make it so",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
	}

	return GUESS_NOCHANGE;
}

static unsigned int GuessAmbiguousPreposition(unsigned int i, bool &changed) // and TO_INFINITIVE
{
	// possible to infinitive when next is potential infintive and we need a subject or object - but this is not "it is time *to go home" because no object needed
	if (posValues[i] & TO_INFINITIVE)
	{
		if ( needRoles[roleIndex] & (OBJECT2|MAINOBJECT|SUBJECT2|MAINSUBJECT) && posValues[i+1] & NOUN_INFINITIVE)
		{
			if (LimitValues(i, TO_INFINITIVE," be to infinitive if followed by potential infinitve and need an object or subject",changed))return GUESS_RETRY; // we have a verb, can supply verb now...
		}

		// possible to infinitive when next is potential infintive immediately after object or subject - "the time *to go is now"
		if (roles[i-1] & (OBJECT2|MAINOBJECT|SUBJECT2|MAINSUBJECT) && posValues[i+1] & NOUN_INFINITIVE)
		{
			if (LimitValues(i, TO_INFINITIVE," be to infinitive if following subject/object and followed by potential verb infinitive",changed))return GUESS_RETRY; // we have a verb, can supply verb now...
		}


		if (posValues[i+1] & (VERB_INFINITIVE|NOUN_INFINITIVE) && needRoles[roleIndex] & (OBJECT2|MAINOBJECT)) // "She was made *to pay back the money."
		{
			unsigned int prior = FindPriorVerb(i);
			if (prior && !(canSysFlags[prior] & VERB_NOOBJECT)) // "I swam *to shore" - since phrases shouldnt intrude before object if one is happening
			{
				if (LimitValues(i, TO_INFINITIVE,"prep could be to infinitive before verb infinitive and we need an object, be that",changed)) return GUESS_RETRY; 
			}
		}

		// To cannot be prep if next is potential verb and not undetermined noun
		if (posValues[i+1] & (VERB_INFINITIVE|NOUN_INFINITIVE) ) // "She was made *to pay back the money."
		{
			unsigned int det;
			if (!(posValues[i+1] & NOUN_BITS)) 
			{
				if (LimitValues(i, TO_INFINITIVE,"to cannot be prep because verb follows and not noun",changed)) return GUESS_RETRY; 
			}
			else if (posValues[i+1] & NOUN_SINGULAR && !IsDeterminedNoun(i+1,det))   // "it is fun *to run"
			{
				if (LimitValues(i, TO_INFINITIVE,"to cannot be prep because potential noun after is not determined",changed)) return GUESS_RETRY; 
			}
		}
	}


	if (startSentence != i && posValues[i] & PREPOSITION && !stricmp(wordStarts[i], "but") && posValues[i+1] & (ADJECTIVE_BITS|PRONOUN_BITS|DETERMINER_BITS|POSSESSIVE))  // "all went but me." 
	{
		if (needRoles[roleIndex] & (OBJECT2|MAINOBJECT)) needRoles[roleIndex] &= -1 ^ ALL_OBJECTS;
		if (LimitValues(i,PREPOSITION,"defaulting adverb/prep/conjunction to prep like 'but me'",changed)) return GUESS_RETRY;
	}

	if (posValues[i] & ADVERB_BITS && !stricmp(wordStarts[i], "but") && posValues[i+1] & (NOUN_BITS|ADJECTIVE_BITS|PRONOUN_BITS|DETERMINER_BITS) && posValues[i-1] & (VERB_TENSES))  // "there is but one god." dont make conjunction
	{
		// start could be "but one lives" so dont eliminate
		if (i != startSentence && !(needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2|MAINOBJECT|OBJECT2)) && posValues[i] & PREPOSITION) // we cant accept a noun next
		{
			if (LimitValues(i,PREPOSITION,"defaulting adverb/prep/conjunction as prep like 'but me'",changed)) return GUESS_RETRY; // might not be real -
		}
	}

	// if particle before Qword, cannot be prep "pick *up where I left off"
	if (posValues[i] & PARTICLE && posValues[i+1] & CONJUNCTION_BITS)
	{
		if (LimitValues(i, -1 ^ PREPOSITION," particle with conjunction following, dont be prep",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
	}

	// we arent expecting anything, keep preposition but must have something after it
	if (posValues[i] & PREPOSITION &&  roleIndex == MAINLEVEL && needRoles[MAINLEVEL] == 0 && PossibleNounAfter(i) )
	{
		if (LimitValues(i,PREPOSITION ,"needing nothing, keep potential preposition",changed)) return GUESS_RETRY;
	}

	// "it flew *past me"
	if (posValues[i] & NOUN_BITS && needRoles[roleIndex] & MAINOBJECT && !(needRoles[roleIndex] & SUBJECT_COMPLEMENT) && roleIndex == MAINLEVEL && !phrases[i]) // not "the exercise is the *least expensive"
	{
		unsigned int priorVerb = FindPriorVerb(i);
		if (priorVerb && canSysFlags[priorVerb] & VERB_NOOBJECT)
		{
			if (LimitValues(i,PREPOSITION,"forcing preposition of noun since can live without object and are followed by known object2",changed)) return GUESS_RETRY;
		}
	}
	
	// we've seen main verb but possible more verb exists - "he waited *until it was ready" - but not "It went into the flower *for some honey , and maybe it went to sleep ."

	// conjunction subrod vs prep when noun_gerund follows, be conjunction
	if (posValues[i] & CONJUNCTION_SUBORDINATE && (posValues[i+1] == NOUN_GERUND || posValues[i+2] == NOUN_GERUND))
	{
		if (LimitValues(i, -1 ^ PREPOSITION," prep/conjunct conflict followed by gerund, be conjunc",changed))return GUESS_RETRY; // we have a verb, can supply verb now...
	}
	
	// if noun evidence follows it, be not an adverb unless it is sentence start 
	if (i == startSentence && posValues[i] & ADVERB_BITS && posValues[i+1] & (DETERMINER_BITS|NOUN_BITS|PRONOUN_BITS) ) // "*next I went home"
	{
		// find NOUN and prove it not followed by verb
		unsigned int afterNoun = i;
		while (++afterNoun < endSentence)
		{
			if (posValues[afterNoun] & (PRONOUN_BITS|NORMAL_NOUN_BITS)) break;
		}
		if (posValues[afterNoun+1] & (VERB_TENSES|AUX_VERB_BITS))
		{
			if (LimitValues(i, -1 ^ PREPOSITION," prep/adv conflict at start followed by noun evidence, be adverb if possible verb immediate after",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
		}
	}
	
	// if we have PREPOSITION vs subord conjunct check for following subject/verb "I ate dinner *before I moved"
	if (posValues[i] & PREPOSITION && posValues[i] & CONJUNCTION_SUBORDINATE)
	{
		unsigned int at = i;
		while (++at <= endSentence)
		{
			if (posValues[at] & VERB_TENSES) 
			{
				if (LimitValues(i,-1 ^ PREPOSITION,"avoid prep as possible subj/verb follows",changed))  return GUESS_RETRY; // might not be real - may have to override later
				break;
			}
		}
		if (LimitValues(i,PREPOSITION,"becoming prep as simplest choice over conjunct",changed))  return GUESS_RETRY; // might not be real - may have to override later
	}
	
	// if we have PREPOSITION vs coord conjunct 
	if (posValues[i] & PREPOSITION && posValues[i] & CONJUNCTION_COORDINATE)
	{
		if (LimitValues(i,PREPOSITION,"becoming prep as simplest choice over conjunct",changed)) return GUESS_RETRY; // might not be real - may have to override later
	}

	// end is possible prep and start is object
	if (i == endSentence &&  posValues[i] & PREPOSITION && firstnoun && roles[firstnoun] & OBJECT2)
	{
		if (LimitValues(i,PREPOSITION,"ending possible prep and have object at start, use prep",changed)) return GUESS_RETRY; // might not be real
	}

	return GUESS_NOCHANGE;
}

static unsigned int GuessAmbiguousDeterminer(unsigned int i, bool & changed) // and predeterminer
{
	// if we are expecting an object and this could be ADJECTIVE OR DETERMINER and follows is signs of noun, be it - but not prep as in "they are under the pots"
	if (posValues[i-1] & DETERMINER && posValues[i] & ADJECTIVE_BITS) // "I won *first prize"
	{
		if (LimitValues(i, -1 ^ DETERMINER,"no determiner after determiner",changed)) return GUESS_RETRY; 
	}

	unsigned nextNoun = i;
	while (++nextNoun <= wordCount)
	{
		if (posValues[nextNoun] & NORMAL_NOUN_BITS) 
		{
			if (posValues[nextNoun] & VERB_TENSES || !(posValues[nextNoun+1] & NORMAL_NOUN_BITS)) break; // accept multiple nouns in a row "these bank tellers" but not "*this makes Jenn mad"
		}
	}
	if (allOriginalWordBits[i] & DETERMINER_SINGULAR && posValues[nextNoun] & NOUN_PLURAL)
	{
		if (LimitValues(i,-1 ^ DETERMINER,"singular determiner cannot be used with subsequent plural noun ",changed)) return GUESS_RETRY; 
	}
	if (allOriginalWordBits[i] & DETERMINER_PLURAL && posValues[nextNoun] & NOUN_SINGULAR && !(allOriginalWordBits[nextNoun] & (NOUN_MASS|NOUN_NODETERMINER)))
	{
		if (LimitValues(i,-1 ^ DETERMINER,"plural determiner cannot be used with subsequent singular noun ",changed)) return GUESS_RETRY; 
	}
	
	// possible determiner  "*what will is this"
	if (i == startSentence && posValues[i] & PRONOUN_BITS && posValues[i] & DETERMINER_BITS && posValues[i+1] & NOUN_BITS  &&  posValues[i+1] & (VERB_TENSES & AUX_VERB_BITS) )
	{
		if (LimitValues(i,DETERMINER,"resolving pronoun/determiner to determiner since followed by potential noun and verb",changed)) return GUESS_RETRY; // might not be real
	}
	if (needRoles[roleIndex] & (SUBJECT2|MAINSUBJECT|MAINOBJECT|OBJECT2) && posValues[i+1] & (ADJECTIVE_BITS|NOUN_BITS|DETERMINER|PRONOUN_POSSESSIVE)) // "*some people eat meat"
	{
		if (posValues[i+1] & (AUX_VERB_BITS|VERB_TENSES) && needRoles[roleIndex] & (MAINVERB|VERB2)) {;} // not "*what will my dog do?"
		else if (LimitValues(i,DETERMINER|PREDETERMINER,"resolving to determiner based on need of subject or object and following potential adj or noun",changed)) return GUESS_RETRY; 
	}
	return GUESS_NOCHANGE;
}

static unsigned int GuessAmbiguousPronoun(unsigned int i, bool &changed)
{
	// needing subject be pronoun subject
	if (needRoles[roleIndex] & (SUBJECT2|MAINSUBJECT) && posValues[i] & PRONOUN_SUBJECT )
	{
		if (posValues[i+1] & (DETERMINER_BITS|NORMAL_NOUN_BITS) && bitCounts[i+1] == 1) {;} // he will be it not us
		else if (LimitValues(i, PRONOUN_SUBJECT ,"seeking subject assume we are  pronoun subject",changed)) return GUESS_RETRY; 
	}

	// if we want indirect object, be that if you can "I gave her the ball"
	if (needRoles[roleIndex] & (INDIRECTOBJECT2|MAININDIRECTOBJECT) && posValues[i] & PRONOUN_OBJECT )
	{
		// we can be an indirect object, be so and fix later
		if (lcSysFlags[i] & PRONOUN_INDIRECTOBJECT)
		{
			if (LimitValues(i, PRONOUN_OBJECT ,"seeking indirect object, be pronoun object",changed)) return GUESS_RETRY; 
		}
		else if (posValues[i] & DETERMINER_BITS)
		{
			if (LimitValues(i, DETERMINER_BITS ,"seeking indirect object which we cant be, be determiner",changed)) return GUESS_RETRY; 
		}
		else // we cannot be indirect. maybe we are direct.
		{
			if (LimitValues(i, PRONOUN_OBJECT ,"seeking indirect object, assume none and we are pronoun object",changed)) return GUESS_RETRY; 
		}
	}

	// if we want object and this might be determiner or pronoun, check forward (go for longest) like "I gave her *some more money+", but "I gave her *some+ more" 
	if (needRoles[roleIndex] & (OBJECT2|MAINOBJECT) && posValues[i] & DETERMINER_BITS)
	{
		if (posValues[i+1] & NORMAL_NOUN_BITS)
		{
			if (LimitValues(i, DETERMINER_BITS ,"seeking object, be determiner bit not pronoun when in front of noun possible",changed)) return GUESS_RETRY; 
		}
		if (posValues[i+1] & ADJECTIVE_BITS && posValues[i+2] & NORMAL_NOUN_BITS)
		{
			if (LimitValues(i, DETERMINER_BITS ,"seeking object, be determiner bit not pronoun when in front of possible adjective possible noun",changed)) return GUESS_RETRY; 
		}
	}

	// noun/pronoun conflict, if determiner then is not pronoun "I gave her this *one"
	if (posValues[i] & NOUN_BITS && posValues[i-1] & (DETERMINER|ADJECTIVE_BITS))
	{
		if (LimitValues(i, -1 ^ PRONOUN_BITS ,"pronoun-noun conflict with determiner or adjective, be not pronoun",changed)) return GUESS_RETRY; 
	}

	// if possible pronoun/adv and followed by pronoun, dont be pronoun "it was *where he would sleep"
	if (posValues[i] & (ADVERB_BITS) && posValues[i+1] & (PRONOUN_BITS))
	{
		if (LimitValues(i, -1 ^ (PRONOUN_BITS) ,"prefer adverb over pronoun when pronoun follow",changed)) return GUESS_RETRY; 
	}
	//possible pronoun/adv followed by noun, dont be pronoun "it was *where John would sleep"
	if (posValues[i] & (PRONOUN_BITS) && bitCounts[i+1] == 1 && posValues[i+1] & NORMAL_NOUN_BITS)
	{
		if (LimitValues(i, -1 ^ (PRONOUN_BITS) ,"prefer adverb over pronoun when oun follows",changed)) return GUESS_RETRY; 
	}

	// if possessive vs pronoun object, and followed by absolute or possible prep followed by prep object "we take them to *her in my hat"
	if (posValues[i] & PRONOUN_POSSESSIVE && posValues[i+1] & PREPOSITION && posValues[i] & PRONOUN_BITS)
	{
		if (posValues[i+2] & (POSSESSIVE_BITS | DETERMINER | ADJECTIVE_BITS) && bitCounts[i+2] == 1) 
		{
			if ( LimitValues(i,PRONOUN_BITS,"resolving pronoun possessive vs object as possessive based on following noun or adjective",changed)) return GUESS_RETRY; // might not be real
		}
	}

	// if possessive vs pronoun object, and followed by an adj or noun, be possessive  -- "his new car"
	if (posValues[i] & PRONOUN_POSSESSIVE && NounSeriesFollowedByVerb(i)) // "he hid because *his bank notes were bad"
	{
		if (LimitValues(i,PRONOUN_POSSESSIVE,"resolving pronoun possessive vs object as possessive based on following noun or d",changed)) return GUESS_RETRY; // might not be real
	}
	// if possessive vs pronoun object, and followed by an adj or noun, be possessive  -- "his new car"
	if (posValues[i] & PRONOUN_POSSESSIVE && posValues[i+1] & (ADJECTIVE_BITS|NORMAL_NOUN_BITS) && bitCounts[i+1] == 1) // "he hid *her own car away"
	{
		if (LimitValues(i,PRONOUN_POSSESSIVE,"resolving pronoun possessive vs object as possessive based on following noun or adjective",changed)) return GUESS_RETRY; // might not be real
	}

		// possissive vs object followed by clear verbal will be object "we heard *her sing" - but not "Bob pressed *his nose"
	if (posValues[i] & PRONOUN_POSSESSIVE && posValues[i] & PRONOUN_OBJECT && posValues[i+1] & (NOUN_INFINITIVE|NOUN_GERUND) && !(posValues[i+1] & NOUN_SINGULAR))
	{
		if (LimitValues(i,PRONOUN_OBJECT,"resolving pronoun possessive vs object as object based on following verbal",changed)) return GUESS_RETRY; // might not be real
	}
	// if possessive vs pronoun object, and followed by  noun and adjective afer that, noun will be verbal "I saw her *light the fire"
	if (posValues[i] & PRONOUN_POSSESSIVE && posValues[i] & PRONOUN_OBJECT && posValues[i+1] & NOUN_SINGULAR  && posValues[i+1] & NOUN_INFINITIVE &&
		bitCounts[i+2] == 1 && posValues[i+2] & (DETERMINER|ADJECTIVE_BITS|NOUN_BITS|PRONOUN_BITS))
	{
		if (LimitValues(i,PRONOUN_OBJECT,"resolving pronoun possessive vs object as object based on following noun infinitive potential with clear object after it",changed)) return GUESS_RETRY; // might not be real
	}
	// if possessive vs pronoun object, and followed by an adj or noun clearly not verbal, be possessive  -- "his new car"
	if (posValues[i] & PRONOUN_POSSESSIVE && posValues[i] & PRONOUN_OBJECT && posValues[i+1] & (ADJECTIVE_BITS|NOUN_BITS) && bitCounts[i+1] == 1 )
	{
		if (LimitValues(i,PRONOUN_POSSESSIVE,"resolving pronoun possessive vs object as possessive based on following noun",changed)) return GUESS_RETRY; // might not be real
		
	}
	// pronoun possessive his and hers will never be indirect objects, and if in front of adj or noun will be possesive "*his new car"


	// if we can be possessive pronoun and after us is determiner, adjective or probably noun, be possessive pronoun "*his great ambition is to fly"
	if (posValues[i] & PRONOUN_POSSESSIVE && posValues[i+1] & DETERMINER_BITS && bitCounts[i+1] == 1)
	{
		if (LimitValues(i,-1 ^ PRONOUN_POSSESSIVE,"pronoun possesive not before determiner",changed)) return GUESS_RETRY;
	}
	if (posValues[i] & PRONOUN_POSSESSIVE && posValues[i+1] & ADJECTIVE_NORMAL && !(needRoles[roleIndex] & (MAININDIRECTOBJECT|INDIRECTOBJECT2)))
	{
		if (LimitValues(i,PRONOUN_POSSESSIVE,"pronoun possesive before simple adjective",changed)) return GUESS_RETRY;
	}
	
	// if we can be possessive pronoun and after us is probable noun "his ambition is to fly"
	if (posValues[i] & PRONOUN_POSSESSIVE && posValues[i+1] & NOUN_SINGULAR && canSysFlags[i+1] & NOUN)
	{
		if (LimitValues(i,PRONOUN_POSSESSIVE,"pronoun possesive beforeprobable noun",changed)) return GUESS_RETRY;
	}

	// if something could be a pronoun subject and we are looking for a subject, be it - but not "*some people eat stuff"
	if (posValues[i] & (PRONOUN_BITS) && !(posValues[i] & (DETERMINER|ADJECTIVE_BITS)) && needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2))
	{
		if (LimitValues(i,(PRONOUN_BITS),"needing a subject, force pronoun subject to be it",changed))  return GUESS_RETRY; // even though *some are left behind, so what.
	}
	
	// possible pronoun followed by possible aux and end is prep "*where do you come from" -- but "*what will is this"
	if (i == startSentence && posValues[i] & PRONOUN_BITS && posValues[i+1] & AUX_VERB_BITS && bitCounts[i+1] == 1 && posValues[endSentence] == PREPOSITION)
	{
		if (LimitValues(i,PRONOUN_BITS,"requiring pronoun object since aux follows and prep ends sentence",changed)) return GUESS_RETRY; // might not be real
	}

	// prior prep phrase has not ended with noun and we are becoming aux.... "from *where do you come"
	if (phrases[i-1] && !(posValues[i-1] & (NOUN_BITS|PRONOUN_BITS)) && posValues[i] & PRONOUN_BITS && posValues[i+1] & AUX_VERB_BITS && bitCounts[i+1] == 1)
	{
		if (LimitValues(i,PRONOUN_BITS,"requiring pronoun object since aux follows and prep ends sentence",changed)) return GUESS_RETRY; // might not be real
	}

	// if we have pronoun subject and object, decide what we needed
	if (posValues[i] == (PRONOUN_BITS))
	{
		// if we are starting a conjunction and following us is a noun/pronoun, we must be object "he told us *what we said"
		if (roleIndex > MAINLEVEL && needRoles[roleIndex] & CLAUSE && posValues[i+1] & (PRONOUN_SUBJECT| NOUN_PLURAL|NOUN_SINGULAR|TO_INFINITIVE))
		{
			if (LimitValues(i,PRONOUN_OBJECT," clause needs subject but seems to be after us, assume we are object",changed)) return GUESS_RETRY;
		}
		else if (needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2) || roles[i] & SUBJECT2)
		{
			if (LimitValues(i,PRONOUN_SUBJECT," says subject pronoun needed",changed)) return GUESS_RETRY;
		}
		else if (needRoles[roleIndex] & (MAINOBJECT|OBJECT2) || roles[i] & OBJECT2)
		{
			if (LimitValues(i,PRONOUN_OBJECT," says object pronoun needed",changed)) return GUESS_RETRY;
		}
	}
	if (needRoles[roleIndex] & (OBJECT2|MAINOBJECT) && posValues[i] & (PRONOUN_BITS)) // "they all gave Susy *some"
	{
		if (posValues[i+1] & ADJECTIVE_BITS && originalLower[i] && originalLower[i]->systemFlags & TAKES_POSTPOSITIVE_ADJECTIVE) // "some more" will never use pronoun on the some
		{
			 if (LimitValues(i, PRONOUN_BITS,"be  pronoun if next is accepted postpositive adjective",changed)) return GUESS_RETRY;
		}
		else if (posValues[i+1] & (ADJECTIVE_BITS|NOUN_BITS)){;} // next may be what we need  "we gave her *some balls"
		else if (LimitValues(i,PRONOUN_BITS," be pronoun s/o because we need an object",changed)) return GUESS_RETRY;
	}
	return GUESS_NOCHANGE;
}

static unsigned int GuessAmbiguousAux(unsigned int i, bool &changed)
{
	// we arent expecting anything, but a moment ago it was a phrase that could have been elevated to a clause...
	if (roleIndex == MAINLEVEL && roleIndex == MAINLEVEL && !(needRoles[roleIndex] & (VERB2|MAINVERB)) && phrases[i-1])
	{
		if (FlipPrepToConjunction(i,true,changed))
		{
			LimitValues(i,AUX_VERB_BITS  ,"aux verb expected for clause",changed);
			return GUESS_RESTART;
		}
	}

	 // simple infinitive after aux "I *can help"
	 if (posValues[i+1] & VERB_INFINITIVE && posValues[i+1] & (DETERMINER|ADJECTIVE_BITS|NOUN_BITS) && !(posValues[i+1] & CONJUNCTION_BITS)) // but not "*do as I say"
	 {
		if (LimitValues(i, AUX_VERB_BITS,"presume aux with infintiive after",changed)) return GUESS_RETRY; 
	 }

	 // she *does her best work - in verb/aux conflict, assume verb, and when we find extra verb later, revert it to aux
	 if (posValues[i] & VERB_TENSES && posValues[i] & AUX_VERB_BITS && posValues[i+1] & (DETERMINER|ADJECTIVE_BITS|NOUN_BITS) && !(posValues[i+1] & CONJUNCTION_BITS)) // but not "*do as I say"
	 {
		if (LimitValues(i, -1 ^ AUX_VERB_BITS,"presume aux is real, override later if extra verb",changed)) return GUESS_RETRY; 
	 }

	if (i == (startSentence+1) && originalLower[startSentence] && originalLower[startSentence]->properties & QWORD) // assume we are aux after qword
	{
		if (LimitValues(i,AUX_VERB_BITS,"requiring aux since qword preceeds at 1st word",changed)) return GUESS_RETRY;
	}

	// we are followed by appropriate verb infinitive potential :   not "this *is mine" which requires participle
	if (!(posValues[i] & (AUX_BE|AUX_HAVE)))  // I can go
	{
		if (posValues[i+1] & VERB_INFINITIVE)
		{
			if (LimitValues(i,AUX_VERB_BITS,"normal aux followed by potential infinitive, be aux",changed)) return GUESS_RETRY;
		}
	}

	// perfect tenses - we are followed by appropriate verb past  potential :   "we *have walked" "we *had walked"
	if (!(posValues[i] & AUX_HAVE) )
	{
		if (posValues[i+1] & VERB_PAST_PARTICIPLE)
		{
			if (LimitValues(i,AUX_VERB_BITS,"have aux followed by potential past participle, be aux",changed)) return GUESS_RETRY;
		}
	}

	// continuous tenses  - we are followed by appropriate verb past  potential :   "we *are walking" "we *had walked"
	if (!(posValues[i] & AUX_BE) )
	{
		if (posValues[i+1] & VERB_PRESENT_PARTICIPLE)
		{
			if (LimitValues(i,AUX_VERB_BITS,"be aux followed by potential present participle, be aux",changed)) return GUESS_RETRY;
		}
	}

	// this is start and after might be prep/conjunction so be verb infinitive
	if (i == startSentence && posValues[i] & VERB_INFINITIVE && posValues[i+1] & (PREPOSITION | CONJUNCTION_BITS))
	{
		if (LimitValues(i,-1 ^ AUX_VERB_BITS,"looks like command with possible prep/conjuct after",changed)) return GUESS_RETRY;
	}

	// if this can be aux and later is verb only, be aux
	if (posValues[i] & AUX_VERB_BITS)
	{
		unsigned int at = i;
		int counter  = 0;
		while (++at <= endSentence)
		{
			if (posValues[at] & VERB_TENSES && !(posValues[at] & (-1 ^ VERB_TENSES))) break; // some kind of insured verb
			if (posValues[at] & (NOUN_BITS |PRONOUN_BITS) && bitCounts[at] == 1) // if found 2nd noun, then could have been inverted aux 
			{
				++counter;
				if (counter > 1) break; 
				if (roleIndex == MAINLEVEL && !(needRoles[MAINLEVEL] & MAINSUBJECT)) break; // "Susie got her son" object cannot intrude between aux and verb in normal order
			}
			if (posValues[at] & TO_INFINITIVE) break; 
		}
		if (at <= endSentence && posValues[at] & VERB_TENSES) 
		{
			bool possibleSubjectComplement = false;
			if (canSysFlags[i] & VERB_TAKES_ADJECTIVE) // might this be linking to adjective first
			{
				unsigned int adj = i;
				while (++adj < at) if (posValues[adj] & ADJECTIVE_BITS) break;
				if (adj < at) possibleSubjectComplement = true;
			}

			if (!possibleSubjectComplement)
			{
				if (LimitValues(i,AUX_VERB_BITS,"requiring aux since see verb later w/o subjectcomplement needed",changed)) return GUESS_RETRY;
			}
		}
	}
	return GUESS_NOCHANGE;
}

static unsigned int GuessAmbiguousConjunction(unsigned int i, bool &changed)
{
	unsigned int at = i;
	while (++at < endSentence && !(posValues[at] & VERB_TENSES)) {;}
	if (!(posValues[at] & VERB_TENSES)) 
	{
		if (LimitValues(i,-1 ^ CONJUNCTION_BITS,"can't be conjunction since no possible verb later",changed)) return GUESS_RETRY; // might not be real -
	}

	// why is unusual qword because it can precede command verb and others cant
	// if qword starts sentence followed by aux or command infinitive, dont believe its conjunction - "*how can I tell" and "why stand up"
	if (i == startSentence && originalLower[startSentence]->properties & QWORD && posValues[i+1] & (AUX_VERB_BITS | VERB_INFINITIVE))
	{
		if (LimitValues(i,-1 ^ CONJUNCTION_BITS,"qword at start wont be conjunction",changed)) return GUESS_RETRY; // might not be real - if cant find verb, may need to downgrade to preoposition if subject found
	}

	at = i;
	while (++at <= endSentence)
	{
		if (posValues[at] & ((VERB_TENSES - VERB_INFINITIVE) | NOUN_GERUND)) break;
	}
	if (at > endSentence && posValues[i] & CONJUNCTION_SUBORDINATE) // no verb for subordinate conjunction
	{
		if (LimitValues(i,-1 ^ CONJUNCTION_SUBORDINATE,"potential subord conjunction has no verb/gerund after it",changed)) return GUESS_RETRY;
	}

	// at start of sentence followed by comma, default NOT conjunction
	if (i == startSentence && posValues[i+1] & COMMA)
	{
		if (LimitValues(i,-1 ^ CONJUNCTION_BITS,"defaulting not conjunction when at start and follows with comma ",changed)) return GUESS_RETRY; // might not be real - if cant find verb, may need to downgrade to preoposition if subject found
	}

	return GUESS_NOCHANGE;
}

static unsigned int GuessAmbiguous(unsigned int i, bool &changed)
{
	if (ApplyRulesToWord(i,changed,0))  return GUESS_RETRY;


	// the various GuessAmbiguousXXX routines may only keep or discard their choices, they can't speak for a different part of speech

	// can we INFER what things are
	unsigned int result;
	uint64 priority = (originalLower[i]) ? (originalLower[i]->systemFlags & ESSENTIAL_FLAGS) : 0;
	if (!priority) priority = canSysFlags[i]  & ESSENTIAL_FLAGS;
	uint64 bits = posValues[i];

	if (bits & PARTICLE)
	{
		bits &= -1 ^ PARTICLE;
		result = GuessAmbiguousParticle(i,changed); // clean out this
		if (result != GUESS_NOCHANGE) return result;
	}

	// prefer static priority to solve
	if (priority & ADJECTIVE && bits & ADJECTIVE_BITS) 
	{
		bits &= -1 ^ ADJECTIVE_BITS;
		result = GuessAmbiguousAdjective(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}	
	if (priority & ADVERB && bits & ADVERB_BITS) 
	{
		bits &= -1 ^ ADVERB_BITS;
		result = GuessAmbiguousAdverb(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}	
	if (priority & PREPOSITION && bits & PREPOSITION) 
	{
		bits &= -1 ^ PREPOSITION;
		result = GuessAmbiguousPreposition(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}	
	if (bits & AUX_VERB_BITS) // resolve aux before nouns ("how *can you live")
	{
		bits &= -1 ^ AUX_VERB_BITS;
		result = GuessAmbiguousAux(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}

	if (priority & NOUN && bits & NOUN_BITS) 
	{
		bits &= -1 ^ NOUN_BITS;
		result = GuessAmbiguousNoun(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}
	if (priority & VERB && bits & VERB_TENSES) 
	{
		bits &= -1 ^ VERB_TENSES;
		result = GuessAmbiguousVerb(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}

	// try things we havent tried if they are relevant
	if (bits & CONJUNCTION_BITS)
	{
		result = GuessAmbiguousConjunction(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}
	if (bits & ADJECTIVE_BITS)
	{
		result = GuessAmbiguousAdjective(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}
	if (bits & ADVERB_BITS)
	{
		result = GuessAmbiguousAdverb(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}
	if (bits & VERB_TENSES)
	{
		result = GuessAmbiguousVerb(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}
	if (bits & NOUN_BITS)
	{
		result = GuessAmbiguousNoun(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}
	if (bits & (DETERMINER|PREDETERMINER))
	{
		result = GuessAmbiguousDeterminer(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}
	if (bits & (PRONOUN_BITS|PRONOUN_POSSESSIVE))
	{
		result = GuessAmbiguousPronoun(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}
	if (bits & AUX_VERB_BITS)
	{
		result = GuessAmbiguousAux(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}
	if (bits & PREPOSITION)
	{
		result = GuessAmbiguousPreposition(i,changed);
		if (result != GUESS_NOCHANGE) return result;
	}
	
	// can we infer preposition since noun follows.. if not needing noun then yes
	if (needRoles[roleIndex] & (VERB2|MAINVERB) && posValues[i] & PREPOSITION) // between subject and verb
	{
		if (posValues[i+1] & ( NOUN_BITS | DETERMINER | ADJECTIVE | PRONOUN_POSSESSIVE) && bitCounts[i+1] == 1) // we know noun is coming
		{
			if (LimitValues(i,PREPOSITION,"says preposition required to contain upcoming noun",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
		}
	}
	
	// this is an ambiguous verbal, we can know we have met its verb level and hunt for its objects
	if (posValues[i] == (NOUN_INFINITIVE | VERB_INFINITIVE) && needRoles[roleIndex] & VERB2)
	{
		needRoles[roleIndex] &= -1 ^ VERB2;
		SetRole(i,VERB2);
		SeekObjects(i);

		// if level below needs a noun, this can be that.. BUT maybe it would be a verb if describing instead???
		if (needRoles[roleIndex-1] & (MAINSUBJECT | SUBJECT2 | MAINOBJECT | OBJECT_COMPLEMENT | OBJECT2))
		{
			if (LimitValues(i, NOUN_INFINITIVE," is a noun infinitive because we want one below",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
		}
	}

	// can we infer noun? do we need a subject or an object -- cant use potential adjective/determiner/adverb cause it is legal
	if (needRoles[roleIndex] & (MAINSUBJECT | SUBJECT2 | MAINOBJECT  | OBJECT_COMPLEMENT | OBJECT2) && posValues[i] & NOUN_BITS) // can we conclude this must be a noun?
	{
		// not if it might be adverb and we are looking for an object (meaning coming after a verb)
		if (needRoles[roleIndex] & (MAINOBJECT|OBJECT_COMPLEMENT|OBJECT2) && posValues[i] & ADVERB_BITS) // "the men ate first."
		{
		}
		else if ( !(posValues[i] & (ADVERB_BITS|ADJECTIVE_BITS|DETERMINER)))
		{
			if (LimitValues(i, NOUN_BITS,"is a noun because we want one",changed)) return GUESS_RETRY;

			if (posValues[i] & NOUN_INFINITIVE && AcceptsInfinitiveObject(currentMainVerb))
			{
				if (LimitValues(i, NOUN_INFINITIVE,"we want an object complement and expect an infinitive so be one",changed)) return GUESS_RETRY;
			}

			if (posValues[i] & NOUN_SINGULAR) 
			{
				if (LimitValues(i, NOUN_SINGULAR,"is a singularnoun because",changed)) return GUESS_RETRY;
			}
		}
		else if (posValues[i] & ADJECTIVE_BITS && !(posValues[i] & NOUN_BITS) && posValues[i+1] & NOUN_BITS) // john has *2 cats.
		{
			if (LimitValues(i, ADJECTIVE_BITS," is an adj because we want a noun and thing after it could be and we are not",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
		}
	}

	// can we infer verb vs aux verb in clause?
	uint64 remainder = posValues[i] & (-1 ^ (AUX_VERB_BITS|VERB_TENSES));
	if (needRoles[roleIndex] & VERB2 && posValues[i] & AUX_VERB_BITS && posValues[i] & VERB_TENSES && !remainder) // can we decide if this is aux or verb?
	{
		// to be aux, we need to find verb shortly. Skip over adverbs, block at pronouns,nouns (except in prep phrases)
		unsigned int x = i;
		while (++x <= endSentence)
		{
			if (posValues[x] & (NOUN_BITS|PRONOUN_BITS)) // failed to find a verb
			{
				if (LimitValues(i, VERB_TENSES,"is a verb because we found following noun/pronoun",changed)) return GUESS_ABORT;
			}
			if (posValues[x] & VERB_TENSES) // found a verb. assume aux.
			{
				if (LimitValues(i, AUX_VERB_BITS,"is a aux not verb because we found verb",changed)) return GUESS_ABORT;
			}
		}
	}

	// can we infer verb past vs adj participle
	remainder = posValues[i] & (-1 ^ (ADJECTIVE_PARTICIPLE|VERB_PAST));
	if (needRoles[roleIndex] & (MAINVERB|VERB2) && posValues[i] & ADJECTIVE_PARTICIPLE && posValues[i] & VERB_PAST && !remainder) // can we decide if this is adj part or verb past?
	{
		if (LimitValues(i, VERB_PAST," is a verb past not adj participle because we need it",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
	}

	// can we infer adjective_participle vs verb_participle?   "it was a tomb *built by man"
	 remainder = posValues[i] & (-1 ^ (ADJECTIVE_PARTICIPLE|VERB_TENSES));
	 if (posValues[i] & ADJECTIVE_PARTICIPLE && posValues[i] & VERB_TENSES && !remainder) // can we decide if this is aux or verb?
	 {
		 // if BEFORE us is a noun and no one is looking for a verb, we should describe him...
		 if (posValues[i-1] & NOUN_BITS && bitCounts[i-1] == 1 && !(needRoles[roleIndex] & (MAINVERB|VERB2))) 
		 {
			if (LimitValues(i, ADJECTIVE_PARTICIPLE,"is an adjective participle because we found noun before and no desire for a verb",changed)) return GUESS_RETRY; // we have a verb, can supply verb now...
		}
	 }

	 // if ambiguity is between adverb and adjective, ignore it and keep going to solve a different ambiguity
	 remainder = posValues[i] & (-1 ^ (ADJECTIVE_BITS|ADVERB_BITS));
	 if (posValues[i] & ADJECTIVE_BITS && posValues[i] & ADVERB_BITS && !remainder) // can we decide if this is aux or verb?
	 {
		 return GUESS_CONTINUE;
	 }


	WORDP D = originalLower[i];
	uint64 tie = (D) ? (D->systemFlags & ESSENTIAL_FLAGS) : 0; // tie break values
	// remove non-possible values
	if (!(posValues[i] & NOUN_BITS)) tie &= -1 ^ NOUN;
	if (!(posValues[i] & VERB_TENSES)) tie &= -1 ^ VERB;
	if (!(posValues[i] & ADJECTIVE_BITS)) tie &= -1 ^ ADJECTIVE;
	if (!(posValues[i] & ADVERB_BITS)) tie &= -1 ^ ADVERB;
	if (!(posValues[i] & PREPOSITION)) tie &= -1 ^ PREPOSITION;

	// if clear stats, go with guess
	if (posValues[i] & NOUN_BITS && (tie & ESSENTIAL_FLAGS) == NOUN)
	{
		if (posValues[i] & ADJECTIVE_NUMBER && posValues[i+1] & NOUN_BITS)
		{
			if (LimitValues(i,ADJECTIVE_NUMBER,"numeric noun better as adjective before noun",changed)) return GUESS_RETRY; // "I put *one shoe on"
		}
		else if (posValues[i] & NOUN_NUMBER && posValues[i] & PRONOUN_BITS)
		{
			if (LimitValues(i,PRONOUN_BITS,"numeric noun better as pronoun",changed)) return GUESS_RETRY; // "no *one is here"
		}
		else if (LimitValues(i,NOUN_BITS,"noun is purely probably",changed)) return GUESS_RETRY;
	}
	if (posValues[i] & VERB_TENSES && (tie & ESSENTIAL_FLAGS) == VERB)
	{
		if (LimitValues(i,VERB_TENSES,"verb is purely probably",changed)) return GUESS_RETRY;
	}
	if (posValues[i] & PREPOSITION && (tie & ESSENTIAL_FLAGS) == PREPOSITION)
	{
		if (LimitValues(i,PREPOSITION,"preposition is purely probably",changed)) return GUESS_RETRY;
	}
	if (posValues[i] & ADJECTIVE_BITS && (tie & ESSENTIAL_FLAGS) == ADJECTIVE)
	{
		if (posValues[i] & ADVERB_BITS)
		{
			if (LimitValues(i,ADJECTIVE_BITS|ADVERB_BITS,"adjective adverb will remain pending",changed)) return GUESS_RETRY;
		}
		else if (LimitValues(i,ADJECTIVE_BITS,"adjective is purely probably",changed)) return GUESS_RETRY;
	}
	if (posValues[i] & ADVERB_BITS && (tie & ESSENTIAL_FLAGS) == ADVERB)
	{
		if (posValues[i] & ADJECTIVE_BITS)
		{
			if (LimitValues(i,ADJECTIVE_BITS|ADVERB_BITS,"adjective adverb will remain pending",changed)) return GUESS_RETRY;
		}
		else if (LimitValues(i,ADVERB_BITS,"adverb is purely probably",changed)) return GUESS_RETRY;
	}

	return GUESS_CONTINUE;
}

static void AddPhrase(unsigned int i)
{
	if (!phrases[i]) 
	{
		phrases[i] |= prepBit;
		prepBit <<= 1;
	}
	AddRoleLevel(PHRASE|OBJECT2,i);
	lastPhrase = i;		// where last verbal was, if any
	if (trace & TRACE_POS) Log(STDUSERLOG,"Phrase added at %s(%d)\r\n",wordStarts[i],i);
}

static void AddVerbal(unsigned int i)
{
	if (needRoles[roleIndex] & PHRASE && needRoles[roleIndex] & OBJECT2) needRoles[roleIndex] ^= OBJECT2; // verbal acts as object
	if (!verbals[i]) 
	{
		verbals[i] |= verbalBit;
		verbalBit <<= 1;
	}
	AddRoleLevel(VERBAL|VERB2,i);
	if (posValues[i] == AMBIGUOUS_VERBAL) determineVerbal = i; // If we don't know if this is a GERUND or PARTICIPLE, we need to find out.
	lastVerbal = i;		// where last verbal was, if any
	if (trace & TRACE_POS) Log(STDUSERLOG,"Verbal added at %s(%d)\r\n",wordStarts[i],i);
}

static void StartImpliedPhrase(unsigned int i,bool &changed)
{
	if (roles[i] & OMITTED_TIME_PREP) // reestablish prior phrase we found
	{
		if (needRoles[roleIndex] & (CLAUSE|VERBAL) && roleIndex > 1) DropLevel(); 	 // was formerly a clause or verbal, ended by prep phrase  clause/verbal will never have direct object after this
		AddPhrase(i);
		return;
	}

	// absolute phrase is like implied prep phrase "with" in "legs quivering, we ran"  requires comma seaparation and no aux verbs
	if (!phrases[i] && !auxVerbStack[roleIndex] && posValues[i] & ADJECTIVE_PARTICIPLE && (currentZone == 0|| currentZone == (int)(zoneIndex-1)) && zoneIndex > 1)
	{
		unsigned int at = i;
		while (--at > 1 && !phrases[at] && !verbals[at] && !clauses[at] && !(posValues[at] & (COMMA|CONJUNCTION_SUBORDINATE)) && !(roles[at] & ( SUBJECT2 | MAINSUBJECT | OBJECT2) )) {;}
		bool abs = false;
		if (roles[at] & (OBJECT2 | APPOSITIVE | SUBJECT2) || !roles[at])  abs = true;
		else if (roles[at] & MAINSUBJECT && needRoles[MAINLEVEL] & MAINVERB  && !auxVerbStack[MAINLEVEL]) abs = true; // we need a verb and this cant be it
		if (abs) 
		{
			zoneData[currentZone] = ZONE_ABSOLUTE;
			SetRole(at,0,true);
			AddPhrase(i);
			SetRole(at,SUBJECT2);
			AddRole(at,ABSOLUTE_PHRASE);
			ExtendChunk(at,i,phrases); // cover with prep phrase (not treated as clause)
		}
		return;
	}

	bool valid = false;
	WORDP D = originalLower[i];
	WORDP E = canonicalLower[i+1];
	if (E && E->systemFlags & TIMEWORD && posValues[i+1] & NOUN_BITS && D && posValues[i] & (ADJECTIVE_BITS|DETERMINER))  // some time expressions can omit a preposition and just have an object
	{
		if (!phrases[i] && !roles[i] && D && D->systemFlags & OMITTABLE_TIME_PREPOSITION) // after it is timeword?  // omitted prepoistion time phrase (adjective)  "next year"  - also "one day"  or   "five days ago"
		{
			if ( i == startSentence && endSentence > (startSentence+3) && *wordStarts[startSentence+2] == ',') valid = true;
			else if ( i == (endSentence - 1)) valid = true;
			else if ((endSentence - i) < 3) {;}
			else if (i == startSentence && posValues[i+2] & (DETERMINER|ADJECTIVE_BITS|NOUN_BITS|(PRONOUN_BITS))) valid = true; // we  see a subject potential after us...
			else if (phrases[i+2] || clauses[i+2]  || verbals[i+2] || posValues[i+2] == COMMA) valid = true; // we are isolated from stuff
		}
		else if (posValues[i] & ADJECTIVE_NUMBER) valid = true; // "one day"
	}
	if (valid) // time phrase at start or end
	{
		LimitValues(i,ADJECTIVE_BITS|DETERMINER,"forced determiner/adj for timephrase",changed);
		LimitValues(i+1,NOUN_BITS,"Assigning noun to time word at start or end",changed);
		if (needRoles[roleIndex] & (CLAUSE|VERBAL) && roleIndex > 1) DropLevel(); 	 // was formerly a clause or verbal, ended by prep phrase  clause/verbal will never have direct object after this
		SetRole(i, OMITTED_TIME_PREP);
		AddPhrase(i);
	}
}

static void StartImpliedClause(unsigned int i,bool & changed)
{
	if (posValues[i] & PREPOSITION) return;	// at best a conflict, we prefer prep and overrule later.
	if (posValues[i] == CONJUNCTION_SUBORDINATE) return;	// at best a conflict, we prefer prep and overrule later.
	if (clauses[i]) return; // clause already started here

	// we are at MAIN level and experienceing a verb we don't need....  hidden clause "I think it *is good"
	if (roleIndex == MAINLEVEL && !(needRoles[MAINLEVEL] & MAINVERB) && roles[i-1] & (MAINOBJECT|MAININDIRECTOBJECT) && posValues[i] & (AUX_VERB_TENSES|VERB_TENSES) && bitCounts[i] == 1)
	{
		if (posValues[i] & VERB_INFINITIVE && AcceptsInfinitiveObject(currentMainVerb)) {;} // "let us *stand still"
		else
		{
			SetRole(i-1,MAINOBJECT,true);	// force prior to be main object 
			needRoles[roleIndex] = 0;	// we are fulfilled. Do not take an object complement as well.
			AddClause(i-1,"omitted that clause as main object ");
			SetRole(i-1,SUBJECT2);
			return;
		}
	}
		
	// prove there is a possible verb later - no "I can do *that too"
	unsigned int at = i;
	while (++at < endSentence && !(posValues[at] & VERB_TENSES)) {;}
	if (!(posValues[at] & VERB_TENSES)) return;	// cannot be a clause

	// find clauses  (markers start, ending with a verb)
	if (!stricmp(wordStarts[i],"however") ||  !stricmp(wordStarts[i],"whoever") || !stricmp(wordStarts[i],"whomever") ||  !stricmp(wordStarts[i],"whatever")|| !stricmp(wordStarts[i],"whenever") || !stricmp(wordStarts[i],"whichever")) {;} // will be a clause most likely
	else if (i == startSentence && originalLower[i] && originalLower[i]->properties & QWORD && posValues[startSentence+1] & (VERB_TENSES|AUX_VERB_BITS))  // qwords are not clauses but main sentence-- what is my name, EXCEPT "when the"
	{
		return;
	}
		
	// a certain  clause

// SUBJECT clause starters immediately follow a noun they describe
	// OBJECT clause starters arise in any object position and may even be ommited  -This is the man (whom/that) I wanted to speak to . The library didn't have the book I wanted
	// The book whose author won a Pulitzer has become a bestseller.
	// clause starter CANNOT be used as adjective... can be pronoun or can be possessive determiner (like whose)
	// USE originalLower because "that" becomes "a" when canonical
	if (i == startSentence && posValues[i] != CONJUNCTION_SUBORDINATE) {;} // these things may all be a normal question, not a clause
	else if (posValues[i] == DETERMINER) {;} // that, used as a determiner so not a clause starter
	else if (originalLower[i] && (parseFlags[i] & POTENTIAL_CLAUSE_STARTER || posValues[i] & CONJUNCTION_SUBORDINATE)) // who whom whoever which whichever  what whatever whatsoever where wherever when whenever how however why that whether  whose?
	{
		if (posValues[i+1] & AUX_VERB_BITS && !(needRoles[roleIndex] & (MAINOBJECT|OBJECT2))) return;	// more a real sentence, UNLESS we were looking for an object "I ate what was given"
		//whoever, whatever, whichever, however, whenever and wherever are called compound relative pronouns -- acts as a subject, object or adverb in its own clause;
		if (!clauses[i])
		{
			if (tried[i]) return; // been here already, it didn't work out
			if (parseFlags[i] & CONJUNCTIONS_OF_ADVERB) {;}
			else if (!stricmp(wordStarts[i],"what") || !stricmp(wordStarts[i],"who") || !stricmp(wordStarts[i],"whom") || !stricmp(wordStarts[i],"whoever") || !stricmp(wordStarts[i],"whatever") 
				|| !stricmp(wordStarts[i],"whichever") || !stricmp(wordStarts[i],"whatsoever")) 
			{
				if (posValues[i] == CONJUNCTION_SUBORDINATE){;}
				else LimitValues(i,PRONOUN_BITS,"clause starts with WH-pronoun, forcing pronoun",changed); // WP Penntag
				if (!(posValues[i] & CONJUNCTION_COORDINATE) && needRoles[roleIndex] & (MAINOBJECT | OBJECT2)) // we will satisfy this as a clause
				{
					SetRole(i,needRoles[roleIndex] & (MAINOBJECT | OBJECT2));
				}
			}
			else if (!stricmp(wordStarts[i],"which") || !stricmp(wordStarts[i],"that") ) // wh-determiners (or simple clause starters)
			{
				if (posValues[i] == CONJUNCTION_SUBORDINATE){;} // leave it alone
				// need an object but not two and one follows us
				else if (posValues[i+1] & (PRONOUN_BITS|DETERMINER_BITS))
				{
					if (posValues[i] & CONJUNCTION_SUBORDINATE) LimitValues(i,CONJUNCTION_SUBORDINATE,"clause starts with no need of extra noun so be simple conjunction for now",changed); 
					else LimitValues(i,PRONOUN_OBJECT,"clause starts with no need of extra noun so be object",changed); 
				}
				else if (posValues[i+1] & (AUX_VERB_BITS|VERB_TENSES))
				{
					LimitValues(i,PRONOUN_SUBJECT,"clause starts with WH-pronoun followed by verb or aux, forcing Pronoun subject",changed); // WDT Penntag
				}
			}
			else if (!stricmp(wordStarts[i],"whose") ) // wh-possessive pronoun
			{
				LimitValues(i,PRONOUN_POSSESSIVE,"clause starts with WH-pronoun, forcing POSSESSIVE",changed); // WP$ Penntag
				if (posValues[i-1] & COMMA) AddClause(i,"clause - qword starter\r\n"); // expecting it to be appositive clause "my mom, whose life is described, is fun"
				return;		// just because possessive doesnt mean clause
			}
		}

		AddClause(i,"clause - qword starter\r\n");
		if (posValues[i] & CONJUNCTION_SUBORDINATE) LimitValues(i,CONJUNCTION_SUBORDINATE,"adverb clause forcing subord conjunct, forcing",changed); // WRB Penntag
		return;
	}
	else // implicit clause
	{
//normally not implicit: , what, which, who, whoever, whom, whomever, whose -- after, although, as, because, before, if, once, since, though, till, unless, until, , whenever, where, wherever, while 
//I must admit * Ralph was my first and only blind date. (Noun clause--direct object)
//The first blind date * I ever had was Ralph. (Adjective clause BEFORE MAIN VERB) 
// Ralph was my first and only blind date because I married him. (Adverb clause NOTHING OMITTED)
	//I'll never forget the day * I met her.   -- after a noun to describe it -- The day I met her was warm
	//He discovered * he was hungry and * the fridge was empty
	// He believes * Mary is beatiful. -- common AFTER main verb is done
	// President Jefferson believed * the headwaters of the Missouri might reach all the way to the Canadian border and * he could claim all that land for the United States.
//An elliptical clause may seem incorrect as it may be missing essential sentence elements, but it is actually accepted grammatically. As these clauses must appear together with complete clauses which contain the missing words, repetition is avoided by leaving the same words (or relative pronoun) out in the elliptical clause. This conciseness actually adds to the flow of the text and promotes writing that is more elegant.
//The Louvre museum was one of the sites (that) we did not want to miss.
//[The relative pronoun that is omitted from the adjective clause]
//After (we visited) the Louvre, we went out to dinner at a French bistro.
//[subject and verb omitted from adverb clause]
//The French make better croissants than the American (make or do).
//[second half of comparison omitted]
//Though (they) sometimes (appear) impatient and somewhat assertive, most French people are actually kind and warm-hearted.
//[subject and verb omitted from adverb clause]

		// usual PUNCTUATION is  < subclause, main sentence    OR    <  main sentence subclause (no comma)
		unsigned int prior = i;
		while (--prior && posValues[prior] & (ADJECTIVE_BITS | DETERMINER | POSSESSIVE_BITS)); // find the major unit before our noun
		// we will need 2 verbs for this to work
		if (needRoles[MAINLEVEL] & MAINVERB)
		{
			unsigned int count = 0;
			unsigned int at = i;
			while (++at <= endSentence)
			{
				if (posValues[at] & VERB_TENSES) ++count;
			}
			if (count < 2) return;	// cannot be clause along with main sentence
		}

		// conditionals lacking "if" starting the sentence
		if (i == startSentence && (!stricmp(wordStarts[i],"had") || !stricmp(wordStarts[i],"were") || !stricmp(wordStarts[i],"should")) && zoneIndex > 1)
		{
			AddClause(i,"omitted if");
			return;
		}

		// a noun arising unexpected following a noun is likely a clause with "that" or "when" omitted unless its an appositive
		if (prior && posValues[prior] & NOUN_BITS && posValues[i] & (NOUN_BITS | ADJECTIVE_NOUN | PRONOUN_BITS) && !(posValues[i] & (-1 ^ (NOUN_BITS | ADJECTIVE_NOUN| PRONOUN_BITS))) && !(needRoles[roleIndex] & (MAINSUBJECT|MAINOBJECT|OBJECT_COMPLEMENT|OBJECT2)) )
		{
			if (posValues[i] & NORMAL_NOUN_BITS && verbStack[roleIndex] && parseFlags[verbStack[roleIndex]] & FACTITIVE_NOUN_VERB) // can take a complement - He painted his old jalopy *purple 
			{
				LimitValues(i,NORMAL_NOUN_BITS,"Forcing 2nd noun as factitive complement",changed);
				return;
			}

			else if (IsLegalAppositive(prior,i)) return; // let it be appositive

			// but if the prior noun could have been adjectives "the little old lady"
			else if (posValues[i] & NORMAL_NOUN_BITS && allOriginalWordBits[i-1] & ADJECTIVE_BITS)
			{
				if (prior == (i-1)) 
				{
					LimitValues(i-1,allOriginalWordBits[i-1] & ADJECTIVE_BITS,"Forcing prior to adjective hitting unexpected noun",changed);
					needRoles[roleIndex] |= roles[prior];
					roles[prior] = 0;
					return;
				}
				if (prior == (i-2) && allOriginalWordBits[i-2] & ADJECTIVE_BITS)
				{
					LimitValues(i-2,allOriginalWordBits[i-2] & ADJECTIVE_BITS,"Forcing 2x prior to adjective hitting unexpected noun",changed);
					needRoles[roleIndex] |= roles[prior];
					roles[prior] = 0;
					return;
				}
			}

			if (posValues[i+1] & (AUX_VERB_BITS|VERB_TENSES) && !roles[i])
			{
				if (clauses[i-1] && roles[i-1] & (SUBJECT2|OBJECT2)) // but not "I am curious what color *it is" or "I am curious who *I am"
				{
					SetRole(i-1,OBJECT2,true);
					SetRole(i,SUBJECT2);
				}
				// we have dual subject stuff and awaiting verb
				else if (!stricmp(wordStarts[startSentence],"what") && roleIndex == MAINLEVEL && subjectStack[MAINLEVEL] && needRoles[MAINLEVEL] & MAINVERB) // what a big nose *he has.
				{
					unsigned int subject = subjectStack[MAINLEVEL];
					SetRole(subject,MAINOBJECT,true);
					SetRole(i,MAINSUBJECT);
				}
				else  AddClause(i,"omitted that or when?"); 
			}
		}
	}
}

static bool IsFinalNoun(unsigned int i)
{
	bool finalNoun = false;
	// see if this is final noun in a series
	if (posValues[i+1] & POSSESSIVE){;}
	else if (posValues[i] & (PRONOUN_BITS)) finalNoun = true;
	else if (posValues[i] & NOUN_PLURAL) finalNoun = true; // "She gave the *children homework" 
	else if (posValues[i] & (NOUN_PROPER_SINGULAR | NOUN_PROPER_PLURAL) && bitCounts[i+1] == 1 && (posValues[i+1] & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL|POSSESSIVE|NOUN_SINGULAR|NOUN_PLURAL))) {;} 
	else if (posValues[i] & NOUN_PROPER_PLURAL) finalNoun = true; 
	else if (posValues[i] & NOUN_PROPER_SINGULAR && allOriginalWordBits[i] & NOUN_HUMAN) finalNoun = true; // human names will be final unless made possessive
	else if (posValues[i] & ( NOUN_INFINITIVE|NOUN_GERUND)) finalNoun = true; // can also accept objects
	else if (!(posValues[i+1] & ((ADJECTIVE_BITS - ADJECTIVE_PARTICIPLE)|POSSESSIVE|(NOUN_BITS-NOUN_GERUND)))) finalNoun = true;
	else if (IsLegalAppositive(i,i+1)) finalNoun = true;
	else if (canonicalUpper[i+1] && !canonicalLower[i+1] && posValues[i+1] & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL)) finalNoun = true; // this will be noun appositive or omitted preposition - "the thing Eli wanted" or "my brother Billy"
	else if (!clauses[i] && clauses[i+1]) finalNoun = true;	// we break on clause boundary
	else if (bitCounts[i+1] != 1) finalNoun = true;	// we must assume it for now...  "eating children tastes good"  "joey found his *baby blanket" 
	else if (posValues[i+1] & (ADJECTIVE_BITS - ADJECTIVE_PARTICIPLE)) // could this be adjective complement after noun? "this makes Jenn's *mom mad"
	{
		finalNoun = true;
	}
	return finalNoun;
}

static bool AssignRoles(bool &changed)
{
	unsigned int oldStart = startSentence; // in case we revise due to conjunction
	// Roles and Phrases are cumulative from call to call
	
	if (trace & TRACE_POS) Log(STDUSERLOG,"\r\n---- Assign roles\r\n");
	char goals[MAX_WORD_SIZE];
	
	// preanalyze comma zones, to see what MIGHT be done within a zone..
	wordStarts[0] = "";
	AssignZones();

restart:
	unsigned int startComma = 0;
	unsigned int endComma = 0;
	int commalist = 0;
	InitRoleSentence();

	// Once a role is assigned, it keeps it forever unless someone overrides it explicitly.
	for (unsigned int i = startSentence; i <= endSentence; ++i)
	{
		if (roles[i] & TAGQUESTION) 
		{
			CloseLevel(i);
			needRoles[MAINLEVEL] = 0;	// now cancelled on needs
		}

		if (roles[i-1] & MAINVERB)  
		{
			currentMainVerb = i - 1;
			if (objectRef[0]) // object preceeded verb
			{
				objectRef[currentMainVerb] = objectRef[0];
				objectRef[0] = 0;
			}
		}
		else if (roles[i-1] & VERB2) 
		{
			currentVerb2 = i - 1; // can object preceed in a clause and need delayed storage?
			if (objectRef[MAX_SENTENCE_LENGTH]) // object preceeded verb
			{
				objectRef[currentVerb2] = objectRef[MAX_SENTENCE_LENGTH];
				objectRef[MAX_SENTENCE_LENGTH] = 0;
			}
		}

		if (i == endSentence && *wordStarts[i] == '"' && endSentence < wordCount) // absorb quote reference into sentence if not end of input
		{
			SetRole(i,MAINOBJECT,true);
			continue;
		}
	
		if (ignoreWord[i]) continue;	// ignore these
		char* word = wordStarts[i];

		if (trace & TRACE_POS)
		{
			char flags[MAX_WORD_SIZE];
			strcpy(flags,"Flags: ");
			ParseFlags(flags,i);
			if (!flags[7]) *flags = 0;	// remove header if none there
			char tags[MAX_WORD_SIZE];
			*tags = 0;
			Tags(tags,i);
			strcat(tags,flags);
			Log(STDUSERLOG,"\"%s %s\" %d (%s)\r\n",word,(canonicalLower[i]) ? canonicalLower[i]->word : canonicalUpper[i]->word,i,tags);
			for (unsigned int x = roleIndex; x >= 1; --x)
			{
				DecodeneedRoles(x,goals);
				if (x == MAINLEVEL) Log(STDUSERLOG, "    need %d %s - s:%d aux:%d v:%d io:%d o:%d\r\n",x,goals,subjectStack[x],auxVerbStack[x],verbStack[x],indirectObjectRef[currentMainVerb],objectRef[currentMainVerb]);
				else Log(STDUSERLOG, "    need %d %s - s:%d aux:%d v:%d io:%d o:%d\r\n",x,goals,subjectStack[x],auxVerbStack[x],verbStack[x],indirectObjectRef[currentVerb2],objectRef[currentVerb2]);
			}
		}

		if (bitCounts[i] > 1)
		{
			unsigned int result = GuessAmbiguous(i,changed);
			if (result == GUESS_RETRY) // somebody fixed it. try again
			{
				--i;
				continue;
			}
			if (result == GUESS_RESTART) goto restart;
			if (result == GUESS_ABORT) return false; // abort if we cannot resolve noun or verb conflict
			if (posValues[i] == (ADJECTIVE_NORMAL|ADVERB_NORMAL)){;}
			else ResolveByStatistic(i,changed); // prior call set back something to ambigous again.
		}
		StartImpliedPhrase(i,changed);
		StartImpliedClause(i,changed); // for things NOT known to be conjunction_subordinate

		switch(posValues[i]) // mostly only handles exact match values
		{
		case AUX_VERB_PRESENT: case AUX_VERB_FUTURE: case AUX_VERB_PAST: case AUX_BE: case AUX_HAVE: case AUX_DO: // AUX_VERB_BITS
			
			// we arent expecting anything, but a moment ago it was a phrase that could have been elevated to a clause...
			if (roleIndex == MAINLEVEL && !(needRoles[roleIndex] & (VERB2|MAINVERB)) && phrases[i-1])
			{
				if (FlipPrepToConjunction(i,false,changed)) goto restart;
			}

			// if omitted subject, imply it from adjective preceeded by the "the beautiful can do no wrong"
			if (needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2))
			{
				unsigned int at = i-1;
				if (at > startSentence && posValues[at] & ADVERB_BITS) --at;	// the wicked often *can outwit others"
				if (posValues[at] & ADJECTIVE_NORMAL && !stricmp(wordStarts[at-1],"the"))
				{
					SetRole(at,NOUN_OMITTED_ADJECTIVE| (needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2)));
				}
			}
			
			// if we are a auxverb immediately after indirectobject, presume this was an object clause instead- "do you think *she can be ready"
			if (posValues[i] & (VERB_PRESENT|VERB_PRESENT_3PS|VERB_PAST) && roles[i-1] & (MAININDIRECTOBJECT|INDIRECTOBJECT2) && parseFlags[verbStack[roleIndex]] & OMITTABLE_THAT_VERB)
			{
				SetRole(i-1,OBJECT2); // no longer indirect
				if (posValues[i-1] & PRONOUN_OBJECT) LimitValues(i-1,PRONOUN_OBJECT,"pronoun subject of clause forced to subject",changed);
				AddClause(i-1,"clause - implied by verb following indirectobject\r\n");
				SetRole(i-1,SUBJECT2); // head of clause
			}

			if (roleIndex == 2 && needRoles[roleIndex] & CLAUSE && needRoles[roleIndex] & VERB2 && !(needRoles[roleIndex] & SUBJECT2) && !subjectStack[MAINLEVEL]) // misreading "whose bike were you riding" as a clause when it isnt, its a simple question, but if we already HAVE a subject for main level not bad- "I do not know if he will go"
			{
				DropLevel(); 	// drop back to main sentence treating this as direct object instead of clause
				for (unsigned int x = lastClause; x < i; ++x) 
				{
					if (roles[x] & SUBJECT2) SetRole(x,MAINOBJECT);
					clauses[x] = 0;
				}
				lastClause = 0;
			}
			if (needRoles[roleIndex] & OBJECT2 && roleIndex > 1)
			{	
				DropLevel(); 	// not going to happen, we are done with this level
			}

			if (!verbStack[roleIndex]) auxVerbStack[roleIndex] = (unsigned char)i;	// most recent aux for this level, but only if no verb found yet (must preceed verb)
			break;
		case VERB_INFINITIVE: 
			if (roleIndex == MAINLEVEL && needRoles[roleIndex] & MAINSUBJECT && needRoles[roleIndex] & MAINVERB) needRoles[roleIndex] &= -1 ^ MAINSUBJECT; // command
	
			// drop thru to other verbs
		case VERB_PRESENT: case VERB_PRESENT_3PS: case VERB_PAST: case VERB_PAST_PARTICIPLE: case VERB_PRESENT_PARTICIPLE: //  VERB_TENSES
			 // does not include NOUN_INFINITIVE or NOUN_GERUND or ADJECTIVE_PARTICIPLE - its a true verb (not aux)
			{
				// we arent expecting anything, but a moment ago it was a phrase that could have been elevated to a clause...
				if (roleIndex == MAINLEVEL && !(needRoles[roleIndex] & (VERB2|MAINVERB)) && phrases[i-1])
				{
					if (FlipPrepToConjunction(i,false,changed))	goto restart;
				}

				// if omitted subject, imply it from adjective preceeded by the "the beautiful can do no wrong"
				if (needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2))
				{
					unsigned int at = i-1;
					if (at > startSentence && posValues[at] & ADVERB_BITS) --at;	// the wicked often *can outwit others"
					if (posValues[at] & ADJECTIVE_NORMAL && !stricmp(wordStarts[at-1],"the"))
					{
						SetRole(at,NOUN_OMITTED_ADJECTIVE| (needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2)));
					}
				}
	
				// if we are a verb immediately after indirectobject, presume this was an object clause instead- "do you think *she is ready"
				if (posValues[i] & (VERB_PRESENT|VERB_PRESENT_3PS|VERB_PAST) && roles[i-1] & (MAININDIRECTOBJECT|INDIRECTOBJECT2) && parseFlags[verbStack[roleIndex]] & OMITTABLE_THAT_VERB)
				{
					SetRole(i-1,(roleIndex == MAINLEVEL) ? MAINOBJECT : OBJECT2); // no longer indirect
					if (posValues[i-1] & PRONOUN_OBJECT) LimitValues(i-1,PRONOUN_OBJECT,"pronoun subject of clause forced to subject",changed);
					AddClause(i-1,"clause - implied by verb following indirectobject\r\n");
					SetRole(i-1,SUBJECT2); // head of clause
				}

				// if we dont need a verb and prior was a verb and could have been a noun, revert it and cancel...
				if (posValues[i] & (VERB_PRESENT|VERB_PAST|VERB_PRESENT_3PS) &&
					allOriginalWordBits[i-1] & NORMAL_NOUN_BITS &&
					roles[i-1] & (VERB2|MAINVERB))
				{
					// if we are a satisifed verbal and prior level needed a verb, we should close out this level
					//  "to wait *seemd too much"
					if (needRoles[roleIndex] & VERBAL && !(needRoles[roleIndex] & VERB2))
					{
						DropLevel(); 
					}
					else
					{
						needRoles[roleIndex] |= roles[i-1];
						SetRole(i-1,0);
						LimitValues(i-1,allOriginalWordBits[i-1] & NORMAL_NOUN_BITS,"hitting 2 verbs, force prior to noun",changed);
					}
				}

				//	if (!verbStack[roleIndex]) verbStack[roleIndex] = (unsigned char)i;	// current verb if we dont have one yet  - handled by seekobjects
				
				// a real verb will terminate a bunch of things
				//To sleep *is (no objects will be found)
				if (needRoles[roleIndex] & VERB2) // verb is inside a clause, probably clausal verb we expected
				{
					// if we are MISSING a needed subject, can we fill that in NOW?
					if (needRoles[roleIndex] & SUBJECT2)
					{
						// if a clause, is the starter a potential subject (like which, who, etc)
						if (lastClause)
						{
							if (originalLower[lastClause] && originalLower[lastClause]->properties & PRONOUN_BITS)
							{
								SetRole(lastClause,SUBJECT2);
							}
						}
						needRoles[roleIndex] &=  -1 ^ SUBJECT2;
					}

					SetRole(i,VERB2); // in case "I have to *find a ball" assigned MAINOBJECT before VERB2
					if (lastClause && needRoles[roleIndex] & CLAUSE) // drag clause thru here
					{
						// if we still need a subject, can starter of clause be it?
						if (needRoles[roleIndex] & SUBJECT2)
						{
							if (originalLower[lastClause] && originalLower[lastClause]->properties & PRONOUN_SUBJECT)
							{
								SetRole(lastClause,SUBJECT2);
							}
						}
						ExtendChunk(lastClause,i,clauses);
					}
					if (lastVerbal && needRoles[roleIndex] & VERBAL) ExtendChunk(lastVerbal,i,verbals); // drag verbal thru here
				}
				else if (needRoles[roleIndex] & MAINVERB) // we seek a main verb....
				{
					// ASSIGN SUBJECT IF WE CAN

					// if we get here and HAVE no subject, but we have a pending verbal, assign it as the subject
					if (needRoles[roleIndex] & MAINSUBJECT && lastVerbal) 
					{
						SetRole(lastVerbal,MAINSUBJECT);
						if ( bitCounts[lastVerbal] != 1 && posValues[lastVerbal] & (NOUN_GERUND|NOUN_INFINITIVE))
						{
							LimitValues(lastVerbal,NOUN_GERUND|NOUN_INFINITIVE,"pending verbal assigned as subject, be gerund or infinitive",changed);
							if (trace & TRACE_POS) Log(STDUSERLOG,"Resolve AMBIGUOUS_VERBAL as NOUN_GERUND or NOUN_INFINITIVE\r\n");
						}
					}

					// we have no subject, but we have a probable noun clause, use that
					if (needRoles[roleIndex] & MAINSUBJECT && firstNounClause) // clause should not intervene before direct object unless describing indirect object
					{
						SetRole(firstNounClause,MAINSUBJECT);
						firstNounClause =  0;
					}

					// NOW HANDLE MAIN VERB and its requirements
					unsigned int needed = needRoles[roleIndex];
					SetRole(i,MAINVERB);
					predicateZone = currentZone;
					// is not a command if the OBJECT has already been seen (like a quotation: "love you" *said Jack"
					if (needed & MAINSUBJECT && !(needRoles[roleIndex] & MAINSUBJECT) && allOriginalWordBits[i] & VERB_INFINITIVE && !objectRef[currentMainVerb])
					{
						LimitValues(i,VERB_INFINITIVE,"Resolve verb as Infinitive",changed); // go with imperative
					}
				}
				else  if (posValues[i] & VERB_INFINITIVE && needRoles[roleIndex] & VERB_INFINITIVE_OBJECT) 
				{
					unsigned int indirect = indirectObjectRef[verbStack[roleIndex]];
					if (indirect)
					{
						SetRole(indirect,(roleIndex == MAINLEVEL) ? MAINOBJECT : OBJECT2,true);
						SetRole(i,OBJECT_COMPLEMENT); 
					}
					else SetRole(i,(roleIndex == MAINLEVEL) ? MAINOBJECT : OBJECT2); 
					AddVerbal(i);
					SetRole(i,VERB2);
				}
				else if (posValues[i] & VERB_INFINITIVE)
				{
					AddRoleLevel(CLAUSE,i);
					verbStack[roleIndex] = (unsigned char)i;
					SetRole(i,VERB2);
				}
				// when an infinitive is waiting to close because it wants an object, this MAIN verb
				// this might be wrong if you can insert a clause in there somewhere 
				else if (needRoles[roleIndex] & OBJECT2)  // not absolute phrase
				{
					needRoles[roleIndex] &= -1 ^ ( OBJECT2 | INDIRECTOBJECT2);	// we wont find these any more
					CloseLevel(i-1);
				}
				else if (subjectStack[MAINLEVEL] && subjectStack[MAINLEVEL] < startComma && i < endComma) // saw a subject, now in a comma phrase, wont be main verb (except it might be- hugging the wall, nathan *peered  Or comma phrase separated subject from verb as appositive or such
				{
					SetRole(i,VERB2);
					AddRoleLevel(COMMA_PHRASE,i);
				}
				// we didnt need this verb, but was a phrase before. Maybe it should have been a conjunction.
				else if (phrases[i-1] && !(needRoles[roleIndex] & (MAINVERB|VERB2))) // "he went *until the honey ran out"
				{
					unsigned int before = i;
					unsigned int phrase = phrases[i-1];
					while (--before && phrases[before] == phrase) phrases[before] = 0;
					++before;	
					if (allOriginalWordBits[before] & CONJUNCTION_BITS)
					{
						LimitValues(before,CONJUNCTION_BITS,"unexpected verb after phrase, convert phrase to clause",changed);
					}
					AddClause(before,"converting phrase to clause");
					SetRole(i-1,SUBJECT2,false);
					crossReference[i-1] = (unsigned char) before;
					SetRole(i,VERB2,false);
					crossReference[i] = (unsigned char) before;
					ExtendChunk(before,i,clauses);
				}

				// see if verb might take an object of some kind

				// A passive voice does not take an object - need aux to be "be" verb
				bool noobject = false;
				if (posValues[i] & VERB_PAST_PARTICIPLE) // after the dog had been walked (passive takes no objects)
				{
					unsigned int x = i;
					while (--x)
					{
						if (posValues[x] & AUX_VERB_PAST) // window was broken. but not window is broken (participle description)
						{
							if (canonicalLower[x] && canonicalLower[x]->word[0] == 'b' ) noobject = true;
							break;
						}
					}
				}
				if (roles[i] & MAINVERB) currentMainVerb = i;
				else if (roles[i] & VERB2) currentVerb2 = i;
				if (!noobject) SeekObjects(i);
				// if no object is expected. If we see a noun following, PRESUME it is part of an implied "that" clause - "I hope she goes", but might be a time phrase like "this morning."
				if (needRoles[roleIndex] == CLAUSE) lastClause = 0;	// all fulfilled
				if (needRoles[roleIndex] == VERBAL && !(needRoles[roleIndex] & VERB2)) lastVerbal = 0; // all fulfilled (and didnt launch a new verbal) "let us hear the men *stand as they pass"
			}
			break;
			case AMBIGUOUS_VERBAL: // (ADJECTIVE_PARTICIPLE | NOUN_GERUND ) 
				AddVerbal(i);

				// drop thru to adjective participle
			case ADJECTIVE_NOUN: 
			case ADJECTIVE_NORMAL: case ADJECTIVE_PARTICIPLE: case ADJECTIVE_NUMBER: // ADJECTIVE_BITS
			{
				// absolute phrase is like implied prep phrase "with" in "legs quivering, we ran".  requires comma seaparation and no aux verbs
				if (!phrases[i] && !auxVerbStack[roleIndex] && (posValues[i] & ADJECTIVE_PARTICIPLE) && (currentZone == 0|| currentZone == (int)(zoneIndex-1)) && zoneIndex > 1)
				{
					unsigned int at = i;
					while (--at && !phrases[at] && !verbals[at] && !clauses[at] && !(posValues[at] & (COMMA|CONJUNCTION_SUBORDINATE)) && !(roles[at] & ( SUBJECT2 | MAINSUBJECT | OBJECT2) )) {;}
					bool abs = false;
					if (roles[at] & SUBJECT2 || roles[at] & OBJECT2 || !roles[at]) 
					{
						roles[at] = OBJECT2;
						abs = true;
					}
					else if (roles[at] & MAINSUBJECT && needRoles[MAINLEVEL] & MAINVERB && !(posValues[i] & (VERB_PRESENT|VERB_PAST|VERB_PRESENT_3PS))) // we need a verb and this cant be it
					{
						// if aux, we can also tolerate participles
						if (posValues[i] & (VERB_PRESENT_PARTICIPLE|VERB_PAST_PARTICIPLE) && auxVerbStack[MAINLEVEL]){;}
						else
						{
							needRoles[MAINLEVEL] |= MAINSUBJECT;
							roles[at] = OBJECT2;
							abs = true;
						}
					}
					if (abs) 
					{
						LimitValues(i,ADJECTIVE_PARTICIPLE,"absolute phrase will take adjective participle",changed);
						zoneData[currentZone] = ZONE_ABSOLUTE;
						AddPhrase(at);
						DropLevel();  // drop phrase level, we're done
						ExtendChunk(at,i,phrases); // cover verbal with prep phrase
					}
				}

				// if we are adjective, can we describe the noun after:
				if (needRoles[roleIndex] & SUBJECT_COMPLEMENT) SetRole(i,SUBJECT_COMPLEMENT);
				// verb expects adjective after direct object - and not nondescriptive adjective
				else if (roles[i-1] & (MAINOBJECT|OBJECT2) && needRoles[roleIndex] & OBJECT_COMPLEMENT && !(needRoles[roleIndex] & (INDIRECTOBJECT2|MAININDIRECTOBJECT)) && posValues[i-1] & (NOUN_BITS|PRONOUN_BITS) && 
					parseFlags[verbStack[roleIndex]] & FACTITIVE_ADJECTIVE_VERB && !(parseFlags[i] & NONDESCRIPTIVE_ADJECTIVE))
				{
					if (roleIndex == MAINLEVEL && indirectObjectRef[MAINLEVEL]) SetRole(indirectObjectRef[currentMainVerb],MAINOBJECT,true);
					else if (roleIndex > MAINLEVEL && indirectObjectRef[roleIndex]) SetRole(indirectObjectRef[currentVerb2],OBJECT2,true);
					needRoles[roleIndex] &= -1 ^ (MAINOBJECT|OBJECT2);	// we are here instead
					SetRole(i,OBJECT_COMPLEMENT);
				}
				else if (parseFlags[i] & NONDESCRIPTIVE_ADJECTIVE && posValues[i+1] & PREPOSITION) needRoles[roleIndex] &= -1 ^ OBJECT_COMPLEMENT; // junk (actually an idiom) but wont be wanting a complement any more
				// hopefully a legal trailing adjective
				else if (posValues[i-1] & (PRONOUN_BITS|NOUN_BITS) && !(posValues[i+1] & (ADJECTIVE_BITS|NOUN_BITS)) ) // however, when suzy came home from school, she found her mother *tired and worn out"
					SetRole(i,POSTNOMINAL_ADJECTIVE); 
				// hopefully a legal trailing adjective
				else if (canSysFlags[i-1] & TAKES_POSTPOSITIVE_ADJECTIVE && posValues[i-1] & (NORMAL_NOUN_BITS|PRONOUN_BITS) )
					SetRole(i,POSTNOMINAL_ADJECTIVE); 
			
				unsigned int level = roleIndex;
				if (posValues[i] == ADJECTIVE_PARTICIPLE)  // "the men using a sword were"  and "the walking dead"
				{
					if (roles[i]){;}
					// accidents have been reported involving passengers
					else if ( roles[i-1] & MAINVERB && allOriginalWordBits[i] & VERB_PRESENT_PARTICIPLE)
					{
						SetRole(i,VERB2);	// default role -- will be verbal describing verb...EXCEPT it may be an adjective object of a linking verb
					}
					else if (posValues[i+1] & (NOUN_BITS|DETERMINER|PRONOUN_POSSESSIVE)) {;} // describing a noun as boring adjective UNLESS its our object!
					else SetRole(i,0);	// default role
				
					// establish a permanent verbal zone if this is freestanding or following a noun and isnt in a zone
					if (posValues[i-1] & (ADJECTIVE_BITS|DETERMINER|POSSESSIVE|PRONOUN_POSSESSIVE|CONJUNCTION_BITS)){;} // wont take an object, can only describe one "the tall and distinguished gentleman"
					
					// we dont care about adj part occurring BEFORE a noun.. that's ordinary adjective
					else 
					{
						AddVerbal(i); // BUT NOT if it is following an adjective,determiner, possessive, etc (before a noun)
						needRoles[roleIndex] &= -1 ^ VERB2;
					}
					//  "who is a *dating service for" has the object as not part of this level
					
					// present participle can start a sentence and have objects
					bool mightWantObject = (i == startSentence); // as a sentence start, it can want an object.
					if (posValues[i] & VERB_PAST_PARTICIPLE) mightWantObject = false; // past participle cannot have an object
					else if (verbals[i] && posValues[i-1] & (ADJECTIVE_BITS|DETERMINER)) mightWantObject = false; // not following a noun
					else if (posValues[i] & ADJECTIVE_PARTICIPLE) mightWantObject = false;
					else if (verbals[i] ) // occuring after the noun // note- adjective-participles may occur AFTER the noun and have objects but not when before - we have the people *taken care of
					{
						mightWantObject = true;
						if (canSysFlags[i] & (VERB_DIRECTOBJECT|VERB_INDIRECTOBJECT)) // change to wanting object(s)
						{
							// wont have indirect object we presume
							verbStack[roleIndex] = (unsigned char)i;	// this is the verb for this
							needRoles[roleIndex] |= OBJECT2; // mark this kind of level (infinitive or gerund) UNLESS this is actually the main verb
						}
					}
					//else- occurring before the noun it is just a descriptor and cant take objects

					if (mightWantObject) SeekObjects(i);
				}

				// assign adjective object for this level if appropriate
				// not "he is a green man"
				// he is green. but not they are green and sticky men
				if (!roles[i] && canSysFlags[verbStack[level]] & VERB_TAKES_ADJECTIVE) 
				{
					// see if we are postnominal
					if (posValues[i-1] & (NOUN_BITS | PRONOUN_BITS) && roles[i-1] & MAINOBJECT ) 
					{
						SetRole(i, OBJECT_COMPLEMENT);
						continue; // not for object complements:  they considered him crazy  
					}
					// check is we are prenominal
					unsigned int j = i;
					while (++j <= endSentence) // prove no nouns in our way after this -- are you the scared cat  vs  are you afraid of him
					{
						if ((clauses[j] && clauses[i] != clauses[j]) || (verbals[j] && verbals[i] != verbals[j]) || 
							(phrases[j] && phrases[i] != phrases[j])) break;	// not relevant (though detecting these in a clause would be nice)
						if (posValues[j] & (PAREN | COMMA | CONJUNCTION_BITS|PREPOSITION|TO_INFINITIVE|NOUN_GERUND)) break; // fall off "we are *responsible for it all"
						if (posValues[j] & NOUN_BITS)  //  but not they are green men  -- we probably describe a noun
						{
							j =  2000; // fall off
							break;
						}
					}
					if ( j != 2000) 
					{
						SetRole(i,SUBJECT_COMPLEMENT);
						needRoles[level] &= -1 ^ ALL_OBJECTS; // prior level is done
					}
				}
				// we can be an adj complement IF expected and not in front of some other continuing thing like "I like *gooey ice cream"
				if (!roles[i] && needRoles[roleIndex] & OBJECT_COMPLEMENT && !(posValues[i+1] & (ADJECTIVE_BITS|NOUN_BITS)))
				{
					SetRole(i, OBJECT_COMPLEMENT);
					continue;  
				}

			}
			break;
			case AMBIGUOUS_PRONOUN: // (PRONOUN_SUBJECT | PRONOUN_OBJECT )
				// drop thru to pronouns
			case NOUN_SINGULAR: case NOUN_PLURAL: case NOUN_PROPER_SINGULAR: case NOUN_PROPER_PLURAL: case NOUN_GERUND: case NOUN_NUMBER: case NOUN_INFINITIVE: //NOUN_BITS
			case PRONOUN_SUBJECT: case PRONOUN_OBJECT:
			{
				// cancels direct object if adverb after verb before noun - EXCEPT "there are always cookies tomorrow 
				//if (posValues[i-1] & ADVERB_BITS && posValues[i-2] & VERB_TENSES && needRoles[roleIndex] & (OBJECT2|MAINOBJECT) && tokenControl & TOKEN_AS_IS) 
				//{
					//needRoles[roleIndex] &= -1 ^ (OBJECT2|MAINOBJECT|MAININDIRECTOBJECT|INDIRECTOBJECT2);
				//}
	
				// forced role on reflexives so wont be  or some kind of compelement "I prefer basketball *myself" but not "I cut *myself"
				if (originalLower[i] && originalLower[i]->systemFlags & PRONOUN_REFLEXIVE && !(needRoles[roleIndex] & (MAINOBJECT|OBJECT2)))
				{
					SetRole(i,REFLEXIVE);
					break;
				}
				if (roles[i] & ADDRESS) break;	// we already know we are an address role, dont rethink it
				
				// we thought prior was a complete noun, but now we know it wasnt - change it over 
				if (posValues[i-1] == NOUN_SINGULAR && posValues[i] & (NOUN_SINGULAR|NOUN_PLURAL) && roles[i-1] && !(parseFlags[verbStack[roleIndex]] & FACTITIVE_NOUN_VERB))
				{
					uint64 role = roles[i-1];
					SetRole(i-1,0);
					SetRole(i,role,true); // move role over to here
					LimitValues(i-1,ADJECTIVE_NOUN,"revising prior nounsingular to adjectivenoun",changed);
					if (phrases[i-1]) phrases[i] = phrases[i-1];	// keep phrase going to here
					break;
				}

				if (!IsFinalNoun(i) && posValues[i] & NORMAL_NOUN_BITS && posValues[i] & ADJECTIVE_BITS)  // not really at end of noun sequence, not the REAL noun - dont touch "*Mindy 's"
				{
					LimitValues(i,ADJECTIVE_BITS,"forcing adjective since not final",changed);
					SetRole(i,0);
					continue;
				}
				
				if (!IsFinalNoun(i) && posValues[i] & NORMAL_NOUN_BITS)  // not really at end of noun sequence, not the REAL noun - dont touch "*Mindy 's"
				{
					LimitValues(i,ADJECTIVE_NOUN,"forcing adj noun since not final",changed);
					SetRole(i,0);
					continue;
				}

				// if we thought a leading verbal was the subject and we have a superfluous noun here in next zone, revise...
				if (roleIndex == MAINLEVEL && needRoles[MAINLEVEL] & MAINVERB && !(needRoles[MAINLEVEL] & MAINSUBJECT) &&
					currentZone == 1 && subjectStack[MAINLEVEL] && posValues[subjectStack[MAINLEVEL]] & NOUN_GERUND)
				{
					if (firstnoun == subjectStack[MAINLEVEL]) firstnoun = 0;
					LimitValues(subjectStack[MAINLEVEL],ADJECTIVE_PARTICIPLE,"revising old mainsubject on finding new one",changed);
					SetRole(subjectStack[MAINLEVEL], 0);	// remove role
					needRoles[MAINLEVEL] |= MAINSUBJECT;	// add it back
				}

				// noun of address? - "here, *Ned, catch the ball"
				if (posValues[i] & NOUN_PROPER_SINGULAR && posValues[i-1] & COMMA && posValues[i+1] & COMMA && roleIndex == MAINLEVEL && needRoles[roleIndex] & MAINSUBJECT && posValues[i+2] & VERB_INFINITIVE)
				{
					SetRole(i,ADDRESS);
					LimitValues(i+2,VERB_INFINITIVE,"command infinitive after address noun",changed);
					break;
				}

				if (!firstnoun) firstnoun = i; // note noun for potential prep wrapped from end

				// something wanting subject or object can solve unknown pronoun now. 
				if (posValues[i] != AMBIGUOUS_PRONOUN || !(needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2|MAINOBJECT|OBJECT_COMPLEMENT|OBJECT2)) ){;} // we are not ambigous pronoun and not looking to have a noun at present
				else 
				{
					if (needRoles[roleIndex] & (MAINSUBJECT|SUBJECT2)) 
					{
						LimitValues(i,PRONOUN_SUBJECT,"Resolve AMBIGUOUS_PRONOUN as subject",changed);
					}
					else 
					{
						if (needRoles[roleIndex] & VERBAL) ExtendChunk(lastVerbal,i,verbals); // drag  verbal to here
						else if (needRoles[roleIndex] & CLAUSE) ExtendChunk(lastClause,i,clauses) ; // drag clause  to here
						LimitValues(i,PRONOUN_OBJECT,"Resolve AMBIGUOUS_PRONOUN as object",changed);
					}
				}
	
				if (parseFlags[i] & FACTITIVE_NOUN_VERB && needRoles[roleIndex] & (MAINOBJECT|OBJECT2) && !(needRoles[roleIndex] & OBJECT_COMPLEMENT)) // 1st time thru, set factitive needs
				{
					needRoles[roleIndex] |= OBJECT_COMPLEMENT;
					needRoles[roleIndex] &= -1 ^ (INDIRECTOBJECT2|MAININDIRECTOBJECT); // we elected Jim president will be caught here  but we elected Jim to run will be parsed wrongly....
				}

				// ASSSIGN ROLE OF NOUN

				// unexpected noun/pronoun - if we are still awaiting mainverb and think we have main subject as "what"
				// make this the subject
				if (needRoles[MAINLEVEL] & VERB && roleIndex == MAINLEVEL && roles[startSentence] & MAINSUBJECT &&
					canonicalLower[startSentence] && canonicalLower[startSentence]->properties & QWORD)
				{
					SetRole(i,MAINSUBJECT);
					SetRole(startSentence,MAINOBJECT);
				}
				// unexpected noun/pronoun - if we are still awaiting verb for clause and think we have  subject as "what"
				// make this the subject
				else if (needRoles[roleIndex] & VERB && roles[i-1]& SUBJECT2 && canonicalLower[i-1] && canonicalLower[i-1]->properties & QWORD) // "I ate what they said"
				{
					SetRole(i-1,MAINOBJECT);
					SetRole(i,MAINSUBJECT);
				}
				// unexpected noun/pronoun - may be appositive
				else if (IsLegalAppositive(i-1,i))
				{
					SetRole(i,APPOSITIVE);
					crossReference[i] =  (unsigned char) (i-1);
				}
		
				else if (posValues[i] == NOUN_GERUND && needRoles[roleIndex] & CLAUSE && needRoles[roleIndex] & SUBJECT2) {;} // omitted subject "John ran while *walking"
				else if (roles[i-1] & (MAINOBJECT|OBJECT2) && parseFlags[verbStack[roleIndex]] & FACTITIVE_NOUN_VERB) SetRole(i,OBJECT_COMPLEMENT);
				else HandleComplement(i,changed);
				
				// NOW HANDLE VERBAL PROPERTIES
				
				// if this is a verbal (NOUN_GERUND/NOUN_INFINITIVE) it will be at new level ..
				//  Raise it back to its level and fill it in
				// extend reach for supplemental objects
				if (posValues[i] & (NOUN_GERUND|NOUN_INFINITIVE))  
				{
					AddVerbal(i);
					if (posValues[i] == NOUN_GERUND && needRoles[roleIndex] & CLAUSE && needRoles[roleIndex] & SUBJECT2) // omitted subject "John ran while *walking" - participle clause
					{
						needRoles[roleIndex-1] &= -1 &  ( SUBJECT2 | MAINSUBJECT);	// no subject expected now
						ExtendChunk(lastClause,i,clauses);
					}
					else if (posValues[i-1] & TO_INFINITIVE && posValues[i] & NOUN_INFINITIVE) ExtendChunk(i-1,i,verbals);
					else if (i > startSentence && posValues[i-2] & TO_INFINITIVE && posValues[i] & NOUN_INFINITIVE)  ExtendChunk(i-1,i,verbals);
					SetRole(i,VERB2);
					SeekObjects(i);
					// are you able to drive a car wants object2 for car
					// "Be a man"
					// need to know if this is supplying an object or is describing a noun...
					// EG  I want to eat   vs  I want chitlins to eat ...
				}
				
				// "a flying wedge, the *eagle soared" is other order  of appoistive
				// MIGHT be appositive, or might be run-on 
			}
			break;
			case PREPOSITION: // PREPOSITION
			{
				// preposition as object of prep? "I came from *within the house"
				if (needRoles[roleIndex] & PHRASE && !stricmp(wordStarts[i-1],"from"))
				{
					SetRole(i,OBJECT2);
					CloseLevel(lastPhrase);
				}

				ImpliedNounObjectPeople(i-1, needRoles[roleIndex] & (MAINOBJECT|OBJECT2));
	
				if (!(posValues[i-1] & ADJECTIVE_BITS)) needRoles[roleIndex] &= -1 ^ SUBJECT_COMPLEMENT;	// cannot have linking verb result after this (unless before was possible adjectives) "it was better *than a cookie"
				if (needRoles[roleIndex] & (CLAUSE|VERBAL) && roleIndex > 1) DropLevel(); 	 // was formerly a clause or verbal, ended by prep phrase  clause/verbal will never have direct object after this

				AddPhrase(i);// uncovered preposition via ambiguity

				if (needRoles[roleIndex-1] & MAINOBJECT && subjectStack[MAINLEVEL] > verbStack[MAINLEVEL]){;} // if main subject comes after main verb (question), then prep phrase cancels nothing
				else if (needRoles[roleIndex-1] & (OBJECT2|MAINOBJECT|OBJECT_COMPLEMENT) && !objectRef[verbStack[roleIndex-1]]) // phrase should not intervene before direct object unless describing indirect object
				{
					needRoles[roleIndex-1] &= -1 ^ ALL_OBJECTS;
				}

				// ENDING of sentence preposition wrapped to front
				if (i == endSentence && roles[startSentence] & MAINOBJECT  && posValues[startSentence] & (PRONOUN_BITS)  && canonicalLower[startSentence] && canonicalLower[startSentence]->properties & QWORD )
				{
					objectRef[startSentence] = (unsigned char)0; // implied higher level for prep phrase, so disable on level 1
					SetRole(startSentence,OBJECT2);
					phrases[startSentence] = phrases[endSentence]; // same marker
				}

			}
			break;
			case CONJUNCTION_COORDINATE: // CONJUNCTION_COORDINATE
			{
				if (i == startSentence) break;	// ignore coordination since it occurs to PRIOR sentence.
				if (needRoles[roleIndex] & VERBAL && needRoles[roleIndex] & (SUBJECT_COMPLEMENT|TO_INFINITIVE_OBJECT|VERB_INFINITIVE_OBJECT|OBJECT2)) // also for if we didnt decide its role
				{
					lastVerbal = 0; // cancel existing verbal which is waiting for an object. It wont get one
					DropLevel(); 
				}

				unsigned int result = HandleCoordConjunct(i,changed);
				if (result == GUESS_RETRY) // somebody fixed it. try again
				{
					--i;
					continue;
				}

				if ((roles[i] & CONJUNCT_KINDS) == CONJUNCT_ADJECTIVE) {;}
				else if ((roles[i] & CONJUNCT_KINDS) == CONJUNCT_ADVERB) {;}
				lastConjunction = 0;
				if ((roles[i] & CONJUNCT_KINDS) == CONJUNCT_SENTENCE) // we want a whole new sentence
				{
					if (!FinishSentenceAdjust(false,changed,startSentence,i-1)) break; // start over, it changed stuff
					startSentence = i+1;
					InitRoleSentence();
				}
			}
			break;
			case CONJUNCTION_SUBORDINATE:  // any clause will have been started by StartClause because many start w/o conjunction
			{
				ImpliedNounObjectPeople(i-1, needRoles[roleIndex] & (MAINOBJECT|OBJECT2));			
				// remaining conflict adj/adv resolve to adverb "let us stand *still, and hear"
				if (posValues[i-1] & ADJECTIVE_BITS && posValues[i-1] & ADVERB_BITS)
				{
					LimitValues(i-1,ADVERB_BITS,"adj/adv pending resolved by a conjunction",changed);
				}
				AddClause(i,"clause - conjunction subordinate\r\n");
				if (!stricmp(wordStarts[i],"albeit")) // means "although it is"
				{
					needRoles[roleIndex] &= -1 ^ ( SUBJECT2 | VERB2);
					needRoles[roleIndex] |= SUBJECT_COMPLEMENT;
				}
	
			}
			break;
			case PARTICLE: //  particle binds to PRIOR verb
			{
				// find its matching verb
				WORDP D = NULL;
				unsigned int where = PriorPhrasalVerb(i,D);
				if (where) // the clausal verb we assume
				{
					crossReference[i] = (unsigned char) where;  // back link to verb from particle
					ExtendChunk(where,i,clauses);
					ExtendChunk(where,i,verbals);
					if (!phrases[i] && posValues[where] & NOUN_GERUND) ExtendChunk(where,i,phrases);
					if (posValues[i-1] == PARTICLE) crossReference[i-1] =  (unsigned char) where; // 3word verb
				}
			}
			break;

			case INTERJECTION:
				break;

			case ADVERB_NORMAL: // adverb  binds to PRIOR verb, not next verb unless next to next verb ("if this is tea *please bring me sugar")
			{
				// adverb as object of prep? "I came from *within"
				if (needRoles[roleIndex] & PHRASE && !stricmp(wordStarts[i-1],"from") && !(posValues[i+1] & ADJECTIVE_BITS)) // BUG for I came from *very bad parents"
				{
					SetRole(i,OBJECT2);
					ExtendChunk(i-1,i,phrases);
					CloseLevel(i);
				}

				if (*wordStarts[i-1] == ';' && *wordStarts[i+1] == ',' && parseFlags[i] & CONJUNCTIVE_ADVERB) // conjunctive adverb
				{
					SetRole(i,CONJUNCT_SENTENCE);
					if (!FinishSentenceAdjust(false,changed,startSentence,i)) break; // start over, it changed stuff
					++i;
					startSentence = i+1;
					InitRoleSentence();
				}
				else if (posValues[i+1] & (ADJECTIVE_BITS|ADVERB_BITS)) crossReference[i] = (unsigned char)(i + 1); // if next is ADJECTIVE/ADVERB, then it binds to that?  "I like *very big olives"
				else if (posValues[i+1] & VERB_TENSES) //  next to next verb ("if this is tea please bring me sugar")
				{
					if (clauses[i+1]) clauses[i] = clauses[i+1];
					if (verbals[i+1]) verbals[i] = verbals[i+1];
					crossReference[i] = (unsigned char)(i + 1);
				}
				else // bind to prior verb
				{
					if (clauses[i-1]) clauses[i] = clauses[i-1];
					if (verbals[i-1]) verbals[i] = verbals[i-1];
					if ( phrases[i-1]  && !phrases[i] && posValues[i-1] & NOUN_GERUND) phrases[i] = phrases[i-1];
					unsigned int prior = FindPriorVerb(i);
					if (prior) crossReference[i] = (unsigned char)prior;
				}
			}
			break;
			case PUNCTUATION:
				if (!stricmp(wordStarts[i],"--")) // emphatic comma
				{
					// objects cannot pass thru -- boundaries 
					if (needRoles[roleIndex] & (ALL_OBJECTS|OBJECT_COMPLEMENT|SUBJECT_COMPLEMENT)) needRoles[roleIndex] &= -1 ^ (INDIRECTOBJECT2 | OBJECT2 | MAINOBJECT | MAINOBJECT|OBJECT_COMPLEMENT|SUBJECT_COMPLEMENT);
					CloseLevel(i);  // drop the clause/verbal now.... "my mom, whose life is *, is"
					posValues[i] = COMMA; // revise to comma use for later noun-appositive tests
				}
				else if (*wordStarts[i] == ';') // do new sentence 
				{
					if (!FinishSentenceAdjust(false,changed,startSentence,i-1)) break; // altered world
					startSentence = i+1;
					InitRoleSentence();
				}
				else if (*wordStarts[i] == ':') // do new sentence
				{
					if (!FinishSentenceAdjust(false,changed,startSentence,i-1)) break; // altered world
					startSentence = i+1;
					InitRoleSentence();
				}
				// BUG not handling ( ) stuff yet
			break;
			case COMMA: // close needs for indirect objects, ends clauses e.g.   after being reprimanded, she went home
			{
				++currentZone;
	
				// MAY NOT close needs for indirect objects, ends clauses because adjectives separated by commas) - hugging the cliff, Nathan follows the narrow, undulating road.
				if (posValues[i-1] & ADJECTIVE_BITS && posValues[i+1] & (NOUN_BITS|ADVERB_BITS|ADJECTIVE_BITS|CONJUNCTION_COORDINATE)) break; 
				
				// objects cannot pass thru comma boundaries unless they get reinstated by handleconjunct from the earlier side role
				if (needRoles[roleIndex] & (ALL_OBJECTS|OBJECT_COMPLEMENT|SUBJECT_COMPLEMENT)) needRoles[roleIndex] &= -1 ^ (INDIRECTOBJECT2 | OBJECT2 | MAINOBJECT | MAINOBJECT|OBJECT_COMPLEMENT|SUBJECT_COMPLEMENT);
				
				// "the guy <c who has <v to decide >c>v, Hamlet, is"
				CloseLevel(i);  // drop the clause/verbal now.... "my mom, whose life is *, is"
				// one might have a start of sentence commas off from rest, like: After I arrived, he left and went home.
				// one might have a middle part like: I find that often, to my surprise, I like the new food.
				// one might have a tail part like:  I like you, but so what?
				// or comma might be in a list:  I like apples, pears, and rubbish.

				// one might have a start of sentence commas off from rest, like: After I arrived, he left and went home.
				// one might have a middle part like: I find that often, to my surprise, I like the new food.
				// one might have a tail part like:  I like you, but so what?
				// or comma might be in a list:  I like apples, pears, and rubbish.
				if (!startComma) // we have a comma, find a close.  if this is a comma list, potential 3d comma might exist
				{
					startComma = i;
					for (unsigned int j = i+1; j < endSentence; ++j) 
					{
						if (posValues[j] & COMMA) // this comma ends first here at next comma
						{
							endComma = j;
							break;
						}
					}
				}
				// if we already had a comma and this is the matching end we found for it and we are in a comma-phrase, end it.
				else if (i == endComma && needRoles[roleIndex] & COMMA_PHRASE) 
				{
					DropLevel(); // end phrase
					if (roleIndex == 0) ++roleIndex;
				}

				// address?  "come here, Ned, and eat stuff"
				if (roleIndex == MAINLEVEL && !(needRoles[roleIndex] & MAINVERB) && posValues[i+1] & NOUN_PROPER_SINGULAR && posValues[i+2] == COMMA)
				{
					SetRole(i+1,ADDRESS);
					i += 2; // swall  ,Ned,
					++currentZone;
					continue;
				}

				// commas end some units like phrases, clauses and infinitives
				if (commalist <= (int) i) commalist = 0;	// reset comma list for potential new sequence
				commalist = FindCoordinate(i); // commalist is now the matching conjunction after last comma
				if (commalist > 0) // treat this as coordinate conjunction (but skip over possible adj conjunct)
				{
					if (!(posValues[i+1] & CONJUNCTION_COORDINATE)) // when you get , and  --- want it on the and (for type) and not the comma so last comma is ignored
					{
						unsigned int result = HandleCoordConjunct(i,changed);
						if (result)
						{
							--i;
							continue;
						}
						lastConjunction = i;

						if ((roles[i] & CONJUNCT_KINDS) == CONJUNCT_SENTENCE) // start a new sentence now, after cleanup of old sentence
						{
							if (!FinishSentenceAdjust(false,changed,startSentence,i-1)) break;
							startSentence = i+1;
							InitRoleSentence();
						}
					}
				}
				else 
				{
					needRoles[roleIndex] &= -1 ^ (INDIRECTOBJECT2 | OBJECT2);
				}
			} 
			break;
			case TO_INFINITIVE:
				// adverb verbal to express purpose of verb (why) but looks like adjective verbal as well:  "he bought flowers *to give his wife"
				// after verbs of thinking and feeling and saying : "he decided *to eat"
				// some (TO_INFINITIVE_OBJECT_verbs) verbs take direct object + to infinitive: "he encouraged his friends *to vote"  as object complement
				// some subject complement adjectives take it to give a reason (~adjectivecomplement_taking_noun_infinitive) : " he was unhappy *to live" also treated as object complement
				{
					
					ImpliedNounObjectPeople(i-1, needRoles[roleIndex] & (MAINOBJECT|OBJECT2));
					if (posValues[i+1] & NOUN_INFINITIVE)
					{
						LimitValues(i+1,NOUN_INFINITIVE,"following TO immediate noun infinitive",changed);
						crossReference[i] = (unsigned char) i+1;
					}
					else if (posValues[i+2] & NOUN_INFINITIVE)
					{
						LimitValues(i+2,NOUN_INFINITIVE,"following TO delayed noun infinitive",changed);
						crossReference[i] = (unsigned char) i+2;
					}			
				}
				break;
			case FOREIGN_WORD:
				break;
			case DETERMINER: case PREDETERMINER:
				needRoles[roleIndex] &= -1 ^ SUBJECT_COMPLEMENT;
		
				// cancels direct object if adverb after verb before det
				if (posValues[i-1] & ADVERB_BITS && posValues[i-2] & VERB_TENSES && needRoles[roleIndex] & (OBJECT2|MAINOBJECT) && tokenControl & TOKEN_AS_IS) needRoles[roleIndex] &= -1 ^ (OBJECT2|MAINOBJECT|MAININDIRECTOBJECT|INDIRECTOBJECT2);
				break;
			case PRONOUN_POSSESSIVE: case POSSESSIVE:
				needRoles[roleIndex] &= -1 ^ SUBJECT_COMPLEMENT;
				break;
			case THERE_EXISTENTIAL:
				SetRole(i,MAINSUBJECT); // have to overrule it later
				break;
			case PAREN:
				break;
			default:  // UNKNOWN COMBINATIONS (undecided values) 
			{
				if (posValues[i] & (NOUN_BITS|VERB_TENSES)) return false;	// unresolved noun or verb conflict
			}
		}// end of switch
		if (bitCounts[i] != 1)	// now still confused about futures....dont risk altering things later on except if we are hunting for a noun
		{
			// if conflict is merely adjective vs adverb, particle, etc, ignore it for now since its outcome doesn't determine much
			if (posValues[i] & (NOUN_BITS|VERB_TENSES)) return false;
		}
		CloseLevel(i);

		// see if we can assign a pending verbal
		if (determineVerbal && !phrases[i] && !clauses[i] && !verbals[i] && wordStarts[i][0] != ',') // we are back to main sentence
		{
			if (bitCounts[i] != 1) {;} // we dont know what this is
			else if (posValues[i] & (NOUN_BITS | PRONOUN_SUBJECT | PRONOUN_OBJECT)) // we find a noun, it must have described it:  "Walking home, he left me"
			{
				LimitValues(determineVerbal,ADJECTIVE_PARTICIPLE,"says verbal is adjective",changed);
			}
			else if (posValues[i] & (AUX_VERB_BITS | VERB_TENSES)) // we find a verb, it must have been the subject: "Walking home is fun"
			{
				LimitValues(determineVerbal,NOUN_GERUND,"says verbal is gerund",changed);
				SetRole(determineVerbal,SUBJECT2);
			}
			determineVerbal = 0;
		}
	}

	if (trace & TRACE_POS)
	{
		for (unsigned int x = roleIndex; x >= 1; --x)
		{
			DecodeneedRoles(x,goals);
			Log(STDUSERLOG,"      - leftover want %d: %s\r\n",x,goals);
		}

		Log(STDUSERLOG,"        ->  subject:%s  verb:%s  indirectobject:%s  object:%s  lastclause@:%s  lastverbal@:%s\r\n",wordStarts[subjectStack[MAINLEVEL]],wordStarts[verbStack[MAINLEVEL]],wordStarts[indirectObjectRef[currentMainVerb]],wordStarts[objectRef[currentMainVerb]],wordStarts[lastClause],wordStarts[lastVerbal]);
		Log(STDUSERLOG,"PreFinishSentence: ");
		for (unsigned int i = startSentence; i <= endSentence; ++i)
		{
			if (ignoreWord[i]) continue;	// ignore these
			char word[MAX_WORD_SIZE];
			char* role = GetRole(i);
			if (!*role) 
			{
				role = "";
				if (bitCounts[i] != 1) 
				{
					*word = 0; 
					Tags(word,i);
					role = word;
				}
			}
			Log(STDUSERLOG,"%s (%s) ",wordStarts[i],role);
		}
		Log(STDUSERLOG,"\r\nZones: ");
		for (unsigned int i = 0; i < zoneIndex; ++i) ShowZone(i);
		Log(STDUSERLOG,"\r\n");
	}

	bool resolved = true;
 	if (!FinishSentenceAdjust(resolved,changed,startSentence,endSentence))
	{
		startSentence = oldStart; // in case we ran a coordinating conjunction
		ambiguous = 1;
		return false;
	}
	ValidateSentence(resolved);
	if (!resolved && !changed && noReact) printf("input: %s\r\n",currentInput); //for debugging shows what sentences failed to be resolved by parser acceptibly
	startSentence = oldStart; // in case we ran a coordinating conjunction
	return resolved;
}

void English_ParseSentence(bool & resolved,bool &changed)
{
	if ((tokenControl & DO_PARSE) == DO_PARSE)
	{
		if (!idiomed)
		{
			WordIdioms(changed); // mark idioms after using normal words for rule processing
			idiomed = true;
		}
		resolved =  AssignRoles(changed); 
	}
}
#endif
#ifdef INFORMATION
Copyright (C) 2012 by Outfit7

Released under Bruce Wilcox License as follows:

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#endif

#ifndef DISCARDSERVER
#ifdef EVSERVER
/*
Copyright (c) 2012 Outfit7
by Igor Lautar <igor.lautar@outfit7.com>

Server implementation uses libev to trigger requests.
To compile, define EVSERVER during compilation, otherwise old pthread implementation is used.

Server listener:
 - listener socket is created in evsrv_init()
 - listener socket is added to libev for read event

Accepting requests:
 - libev triggers evsrv_accept
 - handler tries to accept as many connections as possible, creating Client_t instance for each
 - each client socket is registered in libev for read event

Handling client:
 - when data is available on client socket, client_read is called
 - it reads available data, if it is not enough it goes back to ev for more
 - if request is complete, it prepares the buffers and performs the chat
 - it immediatelly tries to send chat response, if socket is busy (EAGAIN) it adds write listener to ev
 - if write listener is triggered, client data is written
 - if there is still some data to write, write listener is added to ev again, until all data is written
 - once data is written, client instance is deregistered from libev, socket closed and object destroyed
*/
#include "common.h"

#include <vector>
#include <algorithm>

#define CLIENT_CHUNK_LENGTH 4*1024

// server stuff
string interface_g;
int port_g;
int listen_queue_length_g = 16*1024; // 16 k

int srv_socket_g = -1;

// EV stuff
struct ev_loop *l_g = 0;
ev_io ev_accept_r_g;
ev_timer tt_g;

#ifdef EVSERVER_FORK
// child monitors
#define MAX_CHILDREN_D 50
ev_child children_g[MAX_CHILDREN_D];
int no_children_g = 0;
int cur_children_g = 0;
bool parent_g = true;
#endif

static void evsrv_accept(EV_P_ ev_io *w, int revents);
static void client_read(EV_P_ ev_io *w, int revents);
static void client_write(EV_P_ ev_io *w, int revents);
static void evsrv_child_died(EV_P_ ev_child *w, int revents);

struct Client_t;
int evsrv_do_chat(Client_t *client);

typedef vector<char> Buffer_t;

#define ITER_TO_OFFSET(ctr, i) (&ctr[0] + (i - ctr.begin()))

struct Client_t
{
    char magic[9];
    int fd;
    ev_io ev_r;
    ev_io ev_w;
    struct ev_loop *l;
    Buffer_t incomming;
    bool requestValid;
    string ip;
    char* bot;
    char* message;
    char* user;
    Buffer_t data;

    Client_t(int fd, struct ev_loop *l_p)
        : fd(fd), l(l_p), requestValid(false)
    {
        strcpy(this->magic, "deadbeef");
        ev_io_init(&this->ev_r, client_read, this->fd, EV_READ);
        ev_io_init(&this->ev_w, client_write, this->fd, EV_WRITE);

        this->ev_r.data = this;
        this->ev_w.data = this;

        ev_io_start(this->l, &this->ev_r);
    }

    ~Client_t()
    {
        if (ev_is_active(&this->ev_r)) {
            ev_io_stop(this->l, &this->ev_r);
        }
        if (ev_is_active(&this->ev_w)) {
            ev_io_stop(this->l, &this->ev_w);
        }

        close(this->fd);
    }
    
    inline char* data_ptr()
    {
        return &this->data[0];
    }

    void prepare_for_next_request()
    {
        this->incomming.clear();
        this->requestValid = false;
        this->bot = 0;
        this->message = 0;
        this->user = 0;
        this->data.clear();
        if (!ev_is_active(&this->ev_r)) {
            ev_io_start(this->l, &this->ev_r);
        }
        if (ev_is_active(&this->ev_w)) {
            ev_io_stop(this->l, &this->ev_w);
        }
    }

    string get_foreign_address()
    {
        sockaddr_in addr;
        unsigned int addr_len = sizeof(addr);
        if (getpeername(this->fd, (sockaddr *) &addr,(socklen_t *) &addr_len) < 0)
        {
            return "";
        }
        return inet_ntoa(addr.sin_addr);
    }

    int recv_data()
    {
        if (this->requestValid)
        {
            ReportBug("recv called alhough we got whole request, should process it first")
            return -1;
        }

        int read_size = CLIENT_CHUNK_LENGTH;
        size_t dataEnd = this->incomming.size();
        this->incomming.resize(dataEnd + read_size);

        char *read_ptr = &this->incomming[dataEnd];

        int r = recv(this->fd, read_ptr, read_size, 0);

        // make buffer as long as actual data
        if (r > 0) {
            this->incomming.resize(dataEnd + r);
        }

        return r;
    }

    void prepare_answer()
    {
        // check if we have answer at all
        Buffer_t::iterator bufEnd = find(this->data.begin(), this->data.end(), 0);

        if (bufEnd == this->data.end())
        {
            // no data was provided, generate a generic answer
            string answer;
            switch(random(4))
            {
            case 0: answer = string("Hey, sorry. Had to answer the phone. What was I saying?"); break;
            case 1: answer = string("Hey, sorry. There was a salesman at the door. Where were we?"); break;
            case 2: answer = string("Hey, sorry. Got distracted. What did you say?"); break;
            case 3: answer = string("Hey, sorry. What did you say?"); break;
            }

            copy(answer.begin(), answer.end(), this->data.begin());
        }
        else
        {
            this->data.resize(bufEnd - this->data.begin());
        }
    }

    int send_data()
    {
        // try to send, if we get eagain error, schedule it for later
        int r = send(this->fd, &this->data[0], this->data.size(), 0);

        if (r < 0) {
            if (errno == EAGAIN)
            {
                ev_io_start(this->l, &this->ev_w);
                return 0;
            }

            Log(SERVERLOG, "evserver: send_data() could not send, errno: %s", strerror(errno));
            return -1;
        }

        if (r < this->data.size()) {
            ev_io_start(this->l, &this->ev_w);
            this->data.erase(this->data.begin(), this->data.begin() + r);
            return 0;
        }

        // sent all data
        this->prepare_for_next_request();

        return 1;
    }

    int prepare_for_chat()
    {
        this->data.clear();
        this->data.reserve(MAX_BUFFER_SIZE + 2);
        this->data.resize(MAX_BUFFER_SIZE + 2);

        this->ip = this->get_foreign_address();
        if (this->ip.length() == 0) {
            Log(SERVERLOG, "evserver: prepare_for_chat() could not get ip for client: %d", this->fd);
            return -1;
        }

        return 1;
    }

    int received_request() {
        int nulls = count(this->incomming.begin(), this->incomming.end(), 0);

        if (nulls < 3) {
            return 0;
        }

        if (nulls > 3) {
            return -1;
        }

        this->requestValid = true;
        user = &this->incomming[0];

        if (strlen(user) == 0) {
            return -1;
        }

        Buffer_t::iterator next_null;
        next_null = find(this->incomming.begin(), this->incomming.end(), 0);

        bot = ITER_TO_OFFSET(this->incomming, next_null + 1);

        next_null = find(next_null + 1, this->incomming.end(), 0);
        message = ITER_TO_OFFSET(this->incomming, next_null + 1);

        // since we received complete request, we will stop reading from client socket until we process it
        ev_io_stop(this->l, &this->ev_r);
        
        return 1;
    }
};

static int settcpnodelay(int fd)
{
    int on = 1;
#ifdef WIN32
    return setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char*) &on, sizeof(on));
#else
    return setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (void*) &on, sizeof(on));
#endif
}

static int setnonblocking(int fd)
{
    // non blocking (fix for windows)
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) {
        Log(SERVERLOG, "evserver: setnonblocking() fcntl(F_GETFL) failed, errno: %s\n", strerror(errno));
        return -1;
    }
    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        Log(SERVERLOG, "evserver: setnonblocking() fcntl(F_SETFL) failed, errno: %s\n", strerror(errno));
        return -1;
    }
    return 1;
}

static int settcpkeepalive(int fd)
{
    int optval = 1;
    socklen_t optlen = sizeof(optval);

    if(setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &optval, optlen) < 0) {
        Log(SERVERLOG, "evserver: setsockopt() could not set keep alive, errno: %s", strerror(errno));
        return -1;
    }

    return 1;
}

// test timer ev callback
static void timeout_cb(EV_P_ ev_timer *w, int revents) {
    Log(SERVERLOG, "test timer fired\n");
}

#ifdef EVSERVER_FORK
int fork_child(ev_child *child_watcher = 0)
{
    char *cd = 0;
    string curDir;

    pid_t pid = 0;
    pid_t sid = 0;

    pid = fork();
    if (pid < 0) {
        fprintf(stderr, "evserver: fork failed, errno %d\n", errno);
        return -1;
    }

    if (pid > 0) {
        // parent
        if (!child_watcher) {
            child_watcher = &children_g[cur_children_g];
            cur_children_g++;
        } else {
            ev_child_stop(l_g, child_watcher);
        }

        ev_child_init(child_watcher, evsrv_child_died, pid, 0);
        ev_child_start(l_g, child_watcher);

        return 0;
    }

    int b = false;
    if (!b) {
        sleep(1);
    }

    // child
    ev_loop_fork(l_g);
    for (int i = 0; i < cur_children_g; i++) {
        ev_child_stop(l_g, &children_g[i]);
    }
    cur_children_g = 0;
    parent_g = false;
    
    return 1;
}

static void evsrv_child_died(EV_P_ ev_child *w, int revents) {
    Log(SERVERLOG, "evserver: evsrv_child_died [pid: %d]\n", w->pid);
    int r = fork_child(w);

    if (r < 0) {
        Log(SERVERLOG, "  evserver: could not re-spawn child after it died [pid: %d]\n", w->pid);
    } else if (r == 1) {
        Log(SERVERLOG, "  evserver child: re-spawned [pid: %d]\n", getpid());
    }
}
#endif

// init server
int evsrv_init(const string &interfaceKind, int port, char* arg) {
    if (srv_socket_g != -1) 
	{
        ReportBug("evserver: server already initialized\n")
        return -1;
    }

	sprintf(serverLogfileName,"LOGS/serverlog%d.txt",port);

    if (arg) {
        // parse additional arguments
        // cut evsrv:
        string args(arg + 6);
    
        // parms are split by ','

        const char *s = args.c_str();
        const char *e = strchr(s, ',');

        while (true) {
            string command(s);

            if (e) {
                command = string(s, e - s);
            }


            // now split arg/value
            const char *eq = strchr(s, '=');
            if (eq) {
                string option(s, eq - s);
                string val(eq + 1);

                if (e) {
                    val = string(eq + 1, e - eq - 1);
                }

                if (option == "fork") {
                    no_children_g = atoi(val.c_str());
                    if (no_children_g > MAX_CHILDREN_D) {
                        no_children_g = MAX_CHILDREN_D;
                    }
                }
            } else {
                // no =, invalid command
                fprintf(stderr, "invalid argument to evserver: '%s'\n", command.c_str());
            }

            if (e) {
                s = e + 1;
                if (!*s) {
                    break;
                }
                e = strchr(e + 1, ',');
            } else {
                break;
            }
        }
    }

    interface_g = interfaceKind;
    port_g = port;

    // uf, got socket, now do EV
    l_g = EV_DEFAULT;

#ifdef WIN32
    WSADATA wsaData;
    unsigned short wVersionRequested = MAKEWORDX(2, 0);              //   Request WinSock v2.0
    if (WSAStartup(wVersionRequested, &wsaData) != 0) {
        Log(SERVERLOG, "evsrv_init: WSAStartup failed\n");
        return -1;
    }
#endif

    srv_socket_g = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    
    if (srv_socket_g < 0) {
        Log(SERVERLOG, "evsrv_init: socket() failed, errno: %s\n", strerror(errno));
        return -1;
    }

	int on = 1;
#ifdef WIN32
	setsockopt(srv_socket_g, SOL_SOCKET, SO_REUSEADDR, (char*) &on, sizeof(on));
#else
	setsockopt(srv_socket_g, SOL_SOCKET, SO_REUSEADDR, (void*) &on, sizeof(on));
#endif
    
    // non blocking
    if (setnonblocking(srv_socket_g) == -1) {
        return -1;
    }

	// bind the socket to its port
	sockaddr_in localAddr;
	memset(&localAddr, 0, sizeof(localAddr));
	localAddr.sin_family = AF_INET;
    if (!inet_aton(interface_g.c_str(), &localAddr.sin_addr)) {
        Log(SERVERLOG, "evsrv_init: inet_aton failed, errno: %s\n", strerror(errno));
        return -1;
    }
	localAddr.sin_port = htons(port_g);
    
	if (bind(srv_socket_g, (sockaddr *) &localAddr, sizeof(sockaddr_in)) < 0) return -1; // typical when server is already running and cron tries to start

#ifdef EVSERVER_FORK
    int parent_after_fork = -1;
    if (no_children_g > 0) {
        cur_children_g = 0;
        // fork
        int forked = 0;
        for (int i = 0; i < no_children_g; i++) {
            forked = fork_child();
            if (forked == -1) {
                // continue by ourself
                parent_after_fork = 1;
                break;
            } else if (forked == 1) {
                parent_after_fork = 0;
                Log(SERVERLOG, "  evserver: child %d alive\n", getpid());
                break;
            } else {
                parent_after_fork = 1;
            }
        }
    }
#endif

    if (parent_after_fork == 1 && cur_children_g > 0) {
        // parent of child does not accept/handle connections
        return 1;
    }

    if (listen(srv_socket_g, listen_queue_length_g) < 0) {
        Log(SERVERLOG, "evserver: listen() failed, errno: %s\n", strerror(errno));
        return -1;
    }

#if 0
    // test timer
    ev_timer_init(&tt_g, timeout_cb, 5, 5);
    ev_timer_start(l_g, &tt_g);
#endif

    // socket listener
    ev_io_init(&ev_accept_r_g, evsrv_accept, srv_socket_g, EV_READ);
    ev_io_start(l_g, &ev_accept_r_g);

    return 1;
}

// starts main server loop
int evsrv_run()
{
    if (!l_g) 
	{
        ReportBug("evsrv_run() called with no ev loop initialized\n")
        printf("no ev loop initialized, nothing to do\n");
        return -1;
    }
    if (parent_g) Log(SERVERLOG, "evserver: parent ready (pid = %d), fork=%d\n", getpid(), no_children_g);
	else Log(SERVERLOG, "  evserver: child ready (pid = %d)\n", getpid());
	printf("Server ready: %s\r\n",serverLogfileName);
    while (true) ev_run(l_g, 0);
    return 1;
}

// handler for incomming connections
static void evsrv_accept(EV_P_ ev_io *w, int revents)
{
    int fd = -1;
    struct sockaddr_storage addr;
    socklen_t sock_len = sizeof(addr);
    int r = 0;
    Client_t *client = 0;

    // try to accept as many connections as possible
    while (true)
    {
        fd = accept(w->fd, (struct sockaddr *)&(addr), &sock_len);
        if (fd == -1) {
            if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)
            {
                // cannot accept at this time, ev will call us again later
                return;
            }

            if (errno == EMFILE || errno == ENFILE)
            {
                // per-process/system table full, should be freed shortly, just do nothing for now
                return;
            }

            Log(SERVERLOG, "evserver: error accepting connection, errno: %s", strerror(errno));
            return;
        }

        if (settcpnodelay(fd) == -1) {
            Log(SERVERLOG, "evserver: could not set TCP_NODELAY, errno: %s", strerror(errno));
            return;
        }

        if (setnonblocking(fd) == -1) {
            return;
        }

        if (setnonblocking(fd) == -1) {
            return;
        }

        client = new Client_t(fd, l_g);
    }
}

static void client_read(EV_P_ ev_io *w, int revents)
{
    Client_t *client = (Client_t*)w->data;

    int r = client->recv_data();
    if (r < 0) {
        if (errno == EAGAIN) {
            return;
        }

        Log(SERVERLOG, "evserver: got error on read (errno: %s) dropping client %d\n", strerror(errno), w->fd);
        delete client;
        return;
    }
    else if (r == 0) {
        // client closed connection, lets close ours
        delete client;
        return;
    }

    // ok, got some data, do we have complete request?
    r = client->received_request();
    if (r == 0) {
        // no, read some more data
        return;
    }
    if (r < 0) {
        // invalid request
        Log(SERVERLOG, "evserver: received invalid request from %d, ignoring\n", w->fd);
        delete client;
        return;
    }

    // yes, we have, do the chat
    r = evsrv_do_chat(client);
    if (r < 0) {
        // could not process it
        delete client;
        return;
    }

    r = client->send_data();
    if (r < 0) {
        Log(SERVERLOG, "evserver: could not sent data to client: %d\n", client->fd);
        delete client;
        return;
    }

    if (r == 1) {
        // client handling finished
        delete client;
    }

    // if r = 0, it means there is still some data to be sent, which will be done next time this watcher is woken-up by ev_loop
}

static void client_write(EV_P_ ev_io *w, int revents)
{
    Client_t *client = (Client_t*)w->data;

    int r = client->send_data();
    if (r < 0) {
        Log(SERVERLOG, "evserver: could not sent data to client: %d\n", client->fd);
        delete client;
        return;
    }

    if (r == 1) {
        // client handling finished
        delete client;
    }

    // if r = 0, it means there is still some data to be sent, which will be done next time this watcher is woken-up by ev_loop
}

int evsrv_do_chat(Client_t *client)
{
    client->prepare_for_chat();

#if 1
    PerformChat(
        client->user,
        client->bot,
        client->message,
        (char*)client->ip.c_str(),
        client->data_ptr());
#else
    strcpy(client->data_ptr(), "ok");
#endif

    client->prepare_answer();

	if (serverLog) {
        char* date = GetTimeInfo()+SKIPWEEKDAY;
        date[15] = 0;	// suppress year
        string reply(client->data_ptr(), client->data.size());
        if (*client->message) {
            Log(SERVERLOG,"%s %s/%s %s msg: %s  =>  %s   <=\n",
                client->ip.c_str(), client->user, client->bot, date, client->message, reply.c_str());
        }
        else {
            Log(SERVERLOG,"%s %s/%s %s start  =>  %s   <=\n",
                client->ip.c_str(), client->user, client->bot, date, reply.c_str());
        }
    }

    return 1;
}

#endif /* EVSERVER */
#endif 
#include "common.h"

#ifdef INFORMATION

Facts are added as layers. You remove facts by unpeeling a layer. You can "delete" a fact merely by
marking it dead.

Layer1:  facts resulting from wordnet dictionary  (wordnetFacts)
Layer2:	 facts resulting from topic system build0
Layer3:	 facts resulting from topic system build1
Layer4:	 facts created by user

Layer 4 is always unpeeled after an interchange with the chatbot, in preparation for a new user who may chat with a different persona.
Layers 2 and 3 are unpeeled if you want to restart the topic system to read in new topic data on the fly or rebuild 0.
Layer 3 is unpeeled for a new build 1.

Layer 1 is never unpeeled. If you want to modify the dictionary, you either restart the chatbot entirely
or patch in data piggy backing on facts (like from the topic system).

Unpeeling a layer implies you will also reset dictionary/stringspace pointers back to levels at the
start of the layer since facts may have allocated dictionary and string items. 
This is ReturnToDictionaryFreeze for unpeeling 3/4 and ReturnDictionaryToWordNet for unpeeling layer 2.

#endif

size_t maxFacts = MAX_FACT_NODES;	// how many facts we can create at max

FACT* factBase = NULL;			// start of all facts
FACT* factEnd = NULL;			// end of all facts
FACT* wordnetFacts = NULL;		// end of facts after dictionary load
FACT* build0Facts = NULL;		// end of build0 facts, start of build1 facts
FACT* factFree = NULL;			// currently next fact we can reuse for allocation
FACT* currentFact = NULL;		// current fact

//   values of verbs to compare against
MEANING Mmember;				// represents concept sets
MEANING Mis;					// represents wordnet hierarchy
MEANING Mexclude;				// represents restriction of word not allowed in set (blocking inheritance)

static float floatValues[MAX_FIND+1];

FACT* Index2Fact(FACTOID e)
{ 
	FACT* F = NULL;
	if (e)
	{
		F =  e + factBase;
		if (F > factFree)
		{
			ReportBug("Illegal fact index")
			F = NULL;
		}
	}
	return F;
}

FACTOID Fact2Index(FACT* F) 
{ 
	return  (F) ? ((FACTOID)(F - factBase)) : 0;
}

FACT* FactTextIndex2Fact(char* id) // given number word, get corresponding fact
{
	char word[MAX_WORD_SIZE];
	strcpy(word,id);
	char* comma = word;
	while ((comma = strchr(comma,','))) memmove(comma,comma+1,strlen(comma));  // maybe number has commas, like 100,000,300 . remove them
	unsigned int n = atoi(word);
	if (n <= 0) return NULL;
	return (n <= (unsigned int)(factFree-factBase)) ? Index2Fact(n) : NULL;
}

int GetSetID(char* x)
{
	if (!IsDigit(*++x)) return -1; // illegal set
	unsigned int n = *x - '0';
	if (IsDigit(*++x)) n = (n * 10) + *x - '0';
	// allow additional characters naming a field
	return (n > MAX_FIND_SETS) ? -1 : n;
}

char* GetSetType(char* x)
{ // @13subject returns subject
	x += 2;
	if (IsDigit(*x)) ++x;
	return x;
}

void TraceFact(FACT* F,bool ignoreDead)
{
	char word[MAX_WORD_SIZE];
	Log(STDUSERLOG,WriteFact(F,false,word,ignoreDead,true));
}

void ClearUserFacts()
{
	while (factFree > factLocked)  FreeFact(factFree--); //   erase new facts
}

void InitFacts()
{
	if ( factBase == 0) 
	{
		factBase = (FACT*) malloc(maxFacts * sizeof(FACT)); // only on 1st startup, not on reload
		if ( factBase == 0)
		{
			printf("failed to allocate fact space\r\n");
			myexit("failed to get fact space");
		}
	}
	memset(factBase,0,sizeof(FACT) *  maxFacts); // not strictly necessary
    factFree = factBase;
	factEnd = factBase + maxFacts;
}

void InitFactWords()
{
	//   special internal fact markers
	Mmember = MakeMeaning(StoreWord("member"));
	Mexclude = MakeMeaning(StoreWord("exclude"));
	Mis = MakeMeaning(StoreWord("is"));
}

void CloseFacts()
{
    free(factBase);
	factBase = 0;
}

void FreeFact(FACT* F)
{ //   most recent facts are always at the top of any xref list. Can only free facts sequentially backwards.
	if (!F->subject) // unindexed fact recording a fact delete that must be undeleted
	{
		if (!F->object) // death of fact fact (verb but no object)
		{
			F = Index2Fact(F->verb);
			F->flags &= -1 ^ FACTDEAD;
		}
		else if (F->flags & ITERATOR_FACT) {;} // holds iterator backtrack
		else // undo a variable assignment fact (verb and object)
		{
			WORDP D = Meaning2Word(F->verb); // the variable
			unsigned int offset = (unsigned int) F->object;
			D->w.userValue =  (offset == 1) ? NULL : (stringBase + offset);
		}
	}
    else // normal indexed fact
	{
		if (!(F->flags & FACTSUBJECT)) SetSubjectHead(F->subject,GetSubjectNext(F));
		else SetSubjectHead(Index2Fact(F->subject),GetSubjectNext(F));

		if (!(F->flags & FACTVERB)) SetVerbHead(F->verb,GetVerbNext(F));
		else  SetVerbHead(Index2Fact(F->verb),GetVerbNext(F));

		if (!(F->flags & FACTOBJECT)) SetObjectHead(F->object,GetObjectNext(F));
		else SetObjectHead(Index2Fact(F->object),GetObjectNext(F));
	}
 }

unsigned int AddFact(unsigned int set, FACT* F) // fact added to factset
{
	unsigned int count = FACTSET_COUNT(set);
	if (!F) return count; //  shouldnt happen
	if (++count > MAX_FIND) --count; 
	factSet[set][count] = F;
	SET_FACTSET_COUNT(set,count);
	return count;
}

FACT* SpecialFact(MEANING verb, MEANING object,unsigned int flags)
{
	//   allocate a fact
	if (++factFree == factEnd) 
	{
		--factFree;
		ReportBug("out of fact space at %d",Fact2Index(factFree))
		printf("out of fact space");
		return factFree; // dont return null because we dont want to crash anywhere
	}
	//   init the basics
	memset(factFree,0,sizeof(FACT));
	factFree->verb = verb;
	factFree->object = object;
	factFree->flags = FACTTRANSIENT | FACTDEAD | flags;	// cannot be written or kept
	return factFree;
}

void KillFact(FACT* F)
{
	if (F->flags & FACTDEAD) return; // already dead

	if (trace & TRACE_INFER) 
	{
		Log(STDUSERLOG,"Kill: ");
		TraceFact(F);
	}
	F->flags |= FACTDEAD;
	if (planning) SpecialFact(Fact2Index(F),0,0); // save to restore

	// if this fact has facts depending on it, they too must die
	FACT* G = GetSubjectHead(F);
	while (G)
	{
		KillFact(G);
		G = GetSubjectNext(G);
	}
	G = GetVerbHead(F);
	while (G)
	{
		KillFact(G);
		G = GetVerbNext(G);
	}
	G = GetObjectHead(F);
	while (G)
	{
		KillFact(G);
		G = GetObjectNext(G);
	}
}

void ResetFactSystem()
{
	while (factFree > factLocked) FreeFact(factFree--); // restore to end of basic facts
	for (unsigned int i = 1; i < MAX_FIND_SETS; ++i) SET_FACTSET_COUNT(i, 0); // empty all facts sets
}

FACT* FindFact(MEANING subject, MEANING verb, MEANING object, unsigned int properties)
{
    FACT* F;
	FACT* G;
	if (!subject || !verb || !object) return NULL;
	if (properties & FACTDUPLICATE) 
		return NULL;	// can never find this since we are allowed to duplicate and we do NOT want to share any existing fact

    //   see if  fact already exists. if so, just return it 
	if (properties & FACTSUBJECT)
	{
		F  = Index2Fact(subject);
		G = GetSubjectHead(F);
		while (G)
		{
			if (!(G->flags & FACTDEAD) && G->verb == verb &&  G->object == object && G->flags == properties) return G;
			G  = GetSubjectNext(G);
		}
		return NULL;
	}
	else if (properties & FACTVERB)
	{
		F  = Index2Fact(verb);
		G = GetVerbHead(F);
		while (G)
		{
			if (!(G->flags & FACTDEAD) && G->subject == subject && G->object == object &&  G->flags == properties) return G;
			G  = GetVerbNext(G);
		}
		return NULL;
	}   
 	else if (properties & FACTOBJECT)
	{
		F  = Index2Fact(object);
		G = GetObjectHead(F);
		while (G)
		{
			if (!(G->flags & FACTDEAD) && G->subject == subject && G->verb == verb &&  G->flags == properties) return G;
			G  = GetObjectNext(G);
		}
		return NULL;
	}
  	//   simple FACT* based on dictionary entries
	F = GetSubjectHead(Meaning2Word(subject));
    while (F)
    {
		if (!(F->flags & FACTDEAD) && F->subject == subject &&  F->verb ==  verb && F->object == object && properties == F->flags)  return F;
		F = GetSubjectNext(F);
    }
    return NULL;
}

FACT* CreateFact(MEANING subject, MEANING verb, MEANING object, unsigned int properties)
{
	currentFact = NULL; 
	if (!subject || !object || !verb)
	{
		ReportBug("Missing field in fact create at line %d of %s",currentFileLine,currentFilename)
		return NULL;
	}

	//   get correct field values
    WORDP s = (properties & FACTSUBJECT) ? NULL : Meaning2Word(subject);
    WORDP v = (properties & FACTVERB) ? NULL : Meaning2Word(verb);
	WORDP o = (properties & FACTOBJECT) ? NULL : Meaning2Word(object);
	if (s && (*s->word == 0 || *s->word == ' '))
	{
		ReportBug("bad choice in fact subject")
		return NULL;
	}
	if (v && (*v->word == 0 || *v->word == ' '))
	{
		ReportBug("bad choice in fact verb")
		return NULL;
	}
	if (o && (*o->word == 0 || *o->word == ' '))
	{
		ReportBug("bad choice in fact object")
		return NULL;
	}

	//   insure fact is unique if requested
	currentFact =  (properties & FACTDUPLICATE) ? NULL : FindFact(subject,verb,object,properties); 
	return  (currentFact) ? currentFact : CreateFastFact(subject,verb,object,properties);
}

bool ExportFacts(char* name, int set,char* append)
{
	if (set < 0 || set >= MAX_FIND_SETS) return false;
	if ( *name == '"')
	{
		++name;
		size_t len = strlen(name);
		if (name[len-1] == '"') name[len-1] = 0;
	}
	FILE* out = FopenWrite(name,(append && !stricmp(append,"append")) ? (char*) "ab" : (char*) "wb");
	if (!out) return false;

	char word[MAX_WORD_SIZE];
	unsigned int count = FACTSET_COUNT(set);
	for (unsigned int i = 1; i <= count; ++i)
	{
		FACT* F = factSet[set][i];
		if (F && !(F->flags & FACTDEAD))
		{
			unsigned int original = F->flags;
			F->flags &= -1 & FACTTRANSIENT;	// dont pass transient flag out
			fprintf(out,"%s",WriteFact(F,false,word,false,true));
			F->flags = original;
		}
	}

	fclose(out);
	return true;
}

char* EatFact(char* ptr,unsigned int flags,bool attribute)
{
	char word[MAX_WORD_SIZE];
	char word1[MAX_WORD_SIZE];
	char word2[MAX_WORD_SIZE];
	ptr = SkipWhitespace(ptr); // could be user-formateed, dont trust
	unsigned int result = 0;
	//   subject
	if (*ptr == '(') //   nested fact
	{
		ptr = EatFact(ptr+1); //   returns after the closing paren
		flags |= FACTSUBJECT;
		sprintf(word,"%d",currentFactIndex() ); //   created OR e found instead of created
	}
	else  ptr = ReadShortCommandArg(ptr,word,result,OUTPUT_FACTREAD); //   subject
	ptr = SkipWhitespace(ptr); // could be user-formateed, dont trust
	if (result & ENDCODES) return ptr;
	if (!*word) 
	{
		if (compiling) BADSCRIPT("FACT-1 Missing subject for fact create")
		char* end = strchr(ptr,')');
		return (end) ? (end + 2) : ptr; 
	}

	//verb
	if (*ptr == '(') //   nested fact
	{
		ptr = EatFact(ptr+1);
		flags |= FACTVERB;
		sprintf(word1,"%d",currentFactIndex() );
	}
	else  ptr = ReadShortCommandArg(ptr,word1,result,OUTPUT_FACTREAD); //verb
	ptr = SkipWhitespace(ptr); // could be user-formateed, dont trust
	if (result & ENDCODES) return ptr;
	if (!*word1) 
	{
		if (compiling) BADSCRIPT("FACT-2 Missing verb for fact create")
		char* end = strchr(ptr,')');
		return (end) ? (end + 2) : ptr; 
	}

	//   object
	if (*ptr == '(') //   nested fact
	{
		ptr = EatFact(ptr+1);
		flags |= FACTOBJECT;
		sprintf(word2,"%d",currentFactIndex() );
	}
	else  ptr = ReadShortCommandArg(ptr,word2,result,OUTPUT_FACTREAD); 
	ptr = SkipWhitespace(ptr); // could be user-formateed, dont trust
	if (result & ENDCODES) return ptr;
	if (!*word2) 
	{
		if (compiling) BADSCRIPT("FACT-3 Missing object for fact create - %s",readBuffer)
		char* end = strchr(ptr,')');
		return (end) ? (end + 2) : ptr; 
	}
	uint64 fullflags;
	ptr = ReadFlags(ptr,fullflags);
	flags |= (unsigned int) fullflags;

	MEANING subject;
	if ( flags & FACTSUBJECT)
	{
		subject = atoi(word);
		if (!subject) subject = 1; // make a phony fact
	}
	else subject =  MakeMeaning(StoreWord(word,AS_IS),0);
	MEANING verb;
	if ( flags & FACTVERB)
	{
		verb = atoi(word1);
		if (!verb) verb = 1; // make a phony fact
	}
	else verb =  MakeMeaning(StoreWord(word1,AS_IS),0);
	MEANING object;
	if ( flags & FACTOBJECT)
	{
		object = atoi(word2);
		if (!object) object = 1; // make a phony fact
	}
	else object =  MakeMeaning(StoreWord(word2,AS_IS),0);

	if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"%s %s %s %x) = ",word,word1,word2,flags);

	FACT* F = FindFact(subject,verb,object,flags);
	if (!attribute || (F && object == F->object)) {;}  // not making an attribute or already made
	else // remove any facts with same subject and verb, UNlESS part of some other fact
	{
		F = GetSubjectHead(subject);
		while (F)
		{
			if (!(F->flags & FACTDEAD) && F->subject == subject && F->verb == verb) 
			{
				if (F->flags & (FACTSUBJECT|FACTVERB|FACTOBJECT)) return (*ptr) ? (ptr + 2) : ptr; //   FACT NOT MADE! // refuse to kill this fact
				else 
				{
					if (!(F->flags & FACTATTRIBUTE)) // this is a script failure. Should ONLY be an attribute
					{
						char word[MAX_WORD_SIZE];
						WriteFact(F,false,word,false,true);
						Log(STDUSERLOG,"Fact created is not an attribute. There already exists %s",word); 
						printf("Fact created is not an attribute. There already exists %s",word); 
						currentFact = F;
						return (*ptr) ? (ptr + 2) : ptr; 
					}
					KillFact(F); 
				}
			}
			F = GetSubjectNext(F);
		}
	}

	F = CreateFact(subject,verb,object,flags);
	if (attribute) 	F->flags |= FACTATTRIBUTE;
	return (*ptr) ? (ptr + 2) : ptr; //   returns after the closing ) if there is one
}

bool ImportFacts(char* name, char* set, char* erase, char* transient)
{
	if (*set != '@') return false;
	int store = GetSetID(set);
	SET_FACTSET_COUNT(store,0);
	if ( *name == '"')
	{
		++name;
		size_t len = strlen(name);
		if (name[len-1] == '"') name[len-1] = 0;
	}
	FILE* in = FopenReadWritten(name);
	if (!in) return false;
	unsigned int flags = 0;
	if (!stricmp(erase,"transient") || !stricmp(transient,"transient")) flags |= FACTTRANSIENT; // make facts transient
	while (ReadALine(readBuffer, in))
    {
        if (*readBuffer == 0 || *readBuffer == '#') continue; //   empty or comment
		char* ptr = strchr(readBuffer,'(');
		if (!ptr) continue; // ignore non-fact lines
        EatFact(ptr+1,flags);
		AddFact(store,currentFact);
	}
	fclose(in);
	if (!stricmp(erase,"erase") || !stricmp(transient,"erase")) remove(name); // erase file after reading
	if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"[%d] => ",FACTSET_COUNT(store));
	return true;
}

void WriteFacts(FILE* out,FACT* F) //   write out from here to end
{ 
	char word[MAX_WORD_SIZE];
	if (!out) return;
    while (++F <= factFree) 
	{
		if (!(F->flags & (FACTTRANSIENT|FACTDEAD))) fprintf(out,"%s",WriteFact(F,true,word,false,true));
	}
    fclose(out);
}

void WriteBinaryFacts(FILE* out,FACT* F) //   write out from here to end
{ 
	if (!out) return;
    while (++F <= factFree) 
	{
		unsigned int index = Fact2Index(F);
		if (F->flags & FACTSUBJECT && F->subject >= index) ReportBug("subject fact index too high")
		if (F->flags & FACTVERB && F->verb >= index) ReportBug("verb fact index too high")
		if (F->flags & FACTOBJECT && F->object >= index) ReportBug("object fact index too high")
		Write32(F->subject,out);
		Write32(F->verb,out);
		Write32(F->object,out);
		Write32(F->flags,out);
	}
    fclose(out);
}
	
FACT* CreateFastFact(MEANING subject, MEANING verb, MEANING object, unsigned int properties)
{
	//   get correct field values
	WORDP s = (properties & FACTSUBJECT) ? NULL : Meaning2Word(subject);
	WORDP v = (properties & FACTVERB) ? NULL : Meaning2Word(verb);
	WORDP o = (properties & FACTOBJECT) ? NULL : Meaning2Word(object);
	if (properties & FACTDEAD) // except for special internal system facts, this shouldnt happen - unless user intends it
	{
		int xx = 0;
	}
	// DICTIONARY should never be build with any but simple meanings and Mis
	// No fact meaning should ever have a synset marker on it. And member facts may have type restrictions on them
	if (s && ((subject & (-1 ^ SIMPLEMEANING) && verb == Mis) || subject&SYNSET_MARKER))
	{
		int xx = 0;
	}
	if (o && ((object & (-1 ^ SIMPLEMEANING) && verb == Mis)|| subject&SYNSET_MARKER))
	{
		int xx = 0;
	}

	//   allocate a fact
	FACT* F;
	if (++factFree == factEnd) 
	{
		--factFree;
		ReportBug("out of fact space at %d",Fact2Index(factFree))
		printf("out of fact space");
		return NULL;
	}
	currentFact = factFree;

	//   init the basics
	memset(currentFact,0,sizeof(FACT));
	currentFact->subject = subject;
	currentFact->verb = verb; 
	currentFact->object = object;
	currentFact->flags = properties;

	//   crossreference
	if (s) 
	{
		SetSubjectNext(currentFact,GetSubjectHead(subject));
		SetSubjectHead(subject,currentFact);
	}
	else 
	{
		F = Index2Fact(currentFact->subject);
		if (F)
		{	
			SetSubjectNext(currentFact,GetSubjectHead(F)); 
			SetSubjectHead(F,currentFact);
		}
		else
		{
			--factFree;
			return NULL;
		}
	}
	if (v) 
	{
		SetVerbNext(currentFact, GetVerbHead(verb));
		SetVerbHead(verb,currentFact);
	}
	else 
	{
		F = Index2Fact(currentFact->verb);
		if (F)
		{
			SetVerbNext(currentFact,GetVerbHead(F));
			SetVerbHead(F,currentFact);
		}
		else
		{
			--factFree;
			return NULL;
		}
	}
	if (o) 
	{
		SetObjectNext(currentFact, GetObjectHead(object));
		SetObjectHead(object,currentFact);
	}
	else
	{
		F = Index2Fact(currentFact->object);
		if (F)
		{
			SetObjectNext(currentFact,GetObjectNext(F)); 
			SetObjectHead(F,currentFact);
		}
		else
		{
			--factFree;
			return NULL;
		}
	}

	if (planning) currentFact->flags |= FACTTRANSIENT;

	if (trace & TRACE_FACTCREATE)
	{
		char* buffer = AllocateBuffer(); // fact might be big, cant use mere WORD_SIZE
		buffer = WriteFact(currentFact,false,buffer,true,true);
		Log(STDUSERLOG,"create %s",buffer);
		FreeBuffer();
	}	
	return currentFact;
}

bool ReadBinaryFacts(FILE* in) //   read binary facts
{ 
	if (!in) return false;
	while (ALWAYS)
	{
		MEANING subject = Read32(in);
		if (!subject) break;
 		MEANING verb = Read32(in);
 		MEANING object = Read32(in);
  		unsigned int properties = Read32(in);
		CreateFastFact(subject,verb,object,properties);
	}
    fclose(in);
	return true;
}

static char* WriteField(MEANING T, uint64 flags,char* buffer,bool ignoreDead)
{
	// a field is either a contiguous mass of non-blank tokens, or a user string "xxx" or an internal string `xxx`  (internal removes its ends, user doesnt)
    if (flags ) //   fact reference
    {
		FACT* G = Index2Fact(T);
		if (!*WriteFact(G,false,buffer,ignoreDead)) 
		{
			*buffer = 0;
			return buffer;
		}
		buffer += strlen(buffer);
    }
	else if (!T) 
	{
		ReportBug("Missing fact field")
		*buffer++ = '?';
	}
    else 
	{
		WORDP D = Meaning2Word(T);
		if (D->internalBits & (INTERNAL_MARK|DELETED_MARK) && !ignoreDead) // a deleted field
		{
			*buffer = 0;
			return buffer; //   cancels print
		}
		char* answer = WriteMeaning(T);
		bool embedded = *answer != '"' && (strchr(answer,' ') != NULL || strchr(answer,'(') != NULL) ; // does this need protection? blanks or function call maybe
		if (embedded) sprintf(buffer,"`%s`",answer); // has blanks, use internal string notation
		else strcpy(buffer,answer); // use normal notation

		buffer += strlen(buffer);
	}
	*buffer++ = ' ';
	*buffer = 0;
	return buffer;
}

char* WriteFact(FACT* F,bool comments,char* buffer,bool ignoreDead,bool eol)
{ //   if fact is junk, return the null string
	char* start = buffer;
	*buffer = 0;
	if (!F || !F->subject) return start; // never write special facts out
	if (F->flags & FACTDEAD) // except for user display THIS shouldnt happen to real fact writes
	{
		if (ignoreDead)
		{
			strcpy(buffer,"DEAD ");
			buffer += strlen(buffer);
		}
		else 
			return ""; // illegal - only happens with facts (nondead) that refer to dead facts?
	}

	//   fact opener
	*buffer++ = '(';
	*buffer++ = ' ';

	//   do subject
	char* base = buffer;
 	buffer = WriteField(F->subject,F->flags & FACTSUBJECT,buffer,ignoreDead);
	if (base == buffer ) 
	{
		*start = 0;
		return start; //    word itself was removed from dictionary
	}

	base = buffer;
	buffer = WriteField(F->verb,F->flags & FACTVERB,buffer,ignoreDead);
	if (base == buffer ) 
	{
		*start = 0;
		return start; //    word itself was removed from dictionary
	}

	base = buffer;
	buffer = WriteField(F->object,F->flags & FACTOBJECT,buffer,ignoreDead);
	if (base == buffer ) 
	{
		*start = 0;
		return start; //    word itself was removed from dictionary
	}

	//   add properties
    if (F->flags)  
	{
		sprintf(buffer,"0x%x ",F->flags & (-1 ^ (MARKED_FACT|MARKED_FACT2) ));  // dont show markers
		buffer += strlen(buffer);
	}

	//   close fact
	*buffer++ = ')';
	*buffer = 0;
	if (eol) strcat(buffer,"\r\n");
	return start;
}

char* ReadField(char* ptr,char* field,char fieldkind, unsigned int& flags)
{
	if (*ptr == '(')
	{
		FACT* G = ReadFact(ptr);
		if (fieldkind == 's') flags |= FACTSUBJECT;
		else if (fieldkind == 'v') flags |= FACTVERB;
		else if (fieldkind == 'o') flags |= FACTOBJECT;
		if (!G)
		{
			ReportBug("Missing fact field")
			return NULL;
		}
		sprintf(field,"%d",Fact2Index(G)); 
	}
	else if (*ptr == '`') // internal string token (fact read)
	{
		char* end = strchr(ptr+1,'`'); // find corresponding end
		*end = 0;
		strcpy(field,ptr+1);
		return end+2; // point AFTER the space after the `
	}
    else 
	{
		ptr = ReadCompiledWord(ptr,field); 
	}
	if (field[0] == '~') MakeLowerCase(field);	// all concepts/topics are lower case
	return ptr; //   return at new token
}

FACT* ReadFact(char* &ptr)
{
	char word[MAX_WORD_SIZE];
    MEANING subject = 0;
	MEANING verb = 0;
    MEANING object = 0;
 	//   fact may start indented.  Will start with (or be 0 for a null fact
    ptr = ReadCompiledWord(ptr,word);
    if (*word == '0') return 0; //   unless it is the null fact, which we dont allow (old)
	unsigned int flags = 0;

	char subjectname[MAX_WORD_SIZE];
	ptr = ReadField(ptr,subjectname,'s',flags);
    char verbname[MAX_WORD_SIZE];
	ptr = ReadField(ptr,verbname,'v',flags);
    char objectname[MAX_WORD_SIZE];
	ptr = ReadField(ptr,objectname,'o',flags);

	if (!ptr) return NULL;
	
    //   handle the flags on the fact
    uint64 properties = 0;
    if (!*ptr || *ptr == ')'); // end of fact
	else ptr = ReadFlags(ptr,properties);
	flags |= (unsigned int) properties;

    if (flags & FACTSUBJECT) subject = (MEANING) atoi(subjectname);
    else  subject = ReadMeaning(subjectname,true,true);
	if (flags & FACTVERB) verb = (MEANING) atoi(verbname);
	else  verb = ReadMeaning(verbname,true,true);
	if (flags & FACTOBJECT) object = (MEANING) atoi(objectname);
	else  object = ReadMeaning(objectname,true,true);

    FACT* F = FindFact(subject, verb,object,flags);
    if (!F)   F = CreateFact(subject,verb,object,flags); 
	if (*ptr == ')') ++ptr;	// skip over ending )
	ptr = SkipWhitespace(ptr);
    return F;
}

void ReadFacts(const char* name,uint64 zone,bool user) //   a facts file may have dictionary augmentations and variable also
{
    FILE* in = (user) ? FopenReadWritten(name) : FopenReadOnly(name); //  fact files
    if (!in) return;
	StartFile(name);
	char word[MAX_WORD_SIZE];
    while (ReadALine(readBuffer, in))
    {
		ReadCompiledWord(readBuffer,word);
        if (*word == 0 || *word == '#'); //   empty or comment
		else if (*word == '+') //   dictionary entry
		{
			char word[MAX_WORD_SIZE];
			char* at = ReadCompiledWord(readBuffer+2,word); //   start at valid token past space
			WORDP D = StoreWord(word);
			ReadDictionaryFlags(D,at);
			AddSystemFlag(D,zone);
		}
		else if (*word == '$') // variable
		{
			ReportBug("Bad fact file user var assignment")
		}
        else 
		{
			char* ptr = readBuffer;
			ReadFact(ptr); // will write on top of ptr... must not be readBuffer variable
		}
    }
   fclose(in);
}

void SortFacts(char* set) //   sort low to high ^sort(@1subject) which field we sort on (subject or verb or object)
{
	if (*set != '@') return;	 // do nothing
    unsigned int n = GetSetID(set);
	char kind = toLowercaseData[*GetSetType(set)];
	if (!kind) kind = 's';
    bool swap = true;
    unsigned int i;
    unsigned int size = FACTSET_COUNT(n);
    for (i = 1; i <= size; ++i)
    {
        FACT* F =  factSet[n][i];
		if (kind == 's') floatValues[i] = (float) atof( Meaning2Word(F->subject)->word); 
		else if (kind == 'v') floatValues[i] = (float) atof(Meaning2Word(F->verb)->word); 
		else floatValues[i] = (float) atof(Meaning2Word(F->object)->word); 
    }
    while (swap)
    {
        swap = false;
        for (i = 1; i <= size-1; ++i) 
        {
            if (floatValues[i] > floatValues[i+1])
            {
                float tmp = floatValues[i];
                floatValues[i] = floatValues[i+1];
                floatValues[i+1] = tmp;
                FACT* F = factSet[n][i];
                factSet[n][i] = factSet[n][i+1];
                factSet[n][i+1] = F;
                swap = true;
            }
        }
        --size;
    }
}
#include "common.h"
#ifdef INFORMATION

Function calls all run through DoCommand().
	
A function call can either be to a system routine or a user routine. 
	
User routines are like C macros, executed in the context of the caller, so the argument 
are never evaluated prior to the call. If you evaluated an argument during the mustering,
you could get bad answers. Consider:
	One has a function: ^foo(^arg1 ^arg2)  ^arg2 ^arg1
	And one has a call ^foo(($val = 1 ) $val )
This SHOULD look like inline code:  $val  $val = 1 
But evaluation at argument time would alter the value of $val and pass THAT as ^arg2. Wrong.

The calling Arguments to a user function are in an array, whose base starts at callArgumentBase and runs
up to (non-inclusive) callArgumentIndex.

System routines are proper functions, whose callArgumentList may or may not be evaluated. 
The callArgumentList are in an array, whose base starts at index CallingArgumentBase and runs
up to (non-inclusive) CallingArgumentIndex. The description of a system routine tells
how many callArgumentList it expects and in what way. Routines that set variables always pass
that designator as the first (unevaluated) argument and all the rest are evaluated callArgumentList.

The following argument passing is supported:
	1. Evaluated - each argument is evaluated and stored (except for a storage argument). 
		If the routine takes optional callArgumentList these are already also evaluated and stored, 
		and the argument after the last actual argument is a null string.
	2. STREAM_ARG - the entire argument stream is passed unevaled as a single argument,
		allowing the routine to handle processing them itself.

All calls have a context of "executingBase" which is the start of the rule causing this 
evaluation. All calls are passed a "buffer" which is spot in the currentOutputBase it
should write any answers.

Anytime a single argument is expected, one can pass a whole slew of them by making
them into a stream, encasing them with ().  The parens will be stripped and the
entire mess passed unevaluated. This makes it analogous to STREAM_ARG, but the latter
requires no excess parens to delimit it.

In general, the system does not test result codes on argument evaluations. So
issuing a FAILRULE or such has no effect there.

#endif

#define MAX_TOPIC_KEYS 5000

#define PLANMARK -1
#define RULEMARK -2

bool planning = false;

int globalDepth = 0;
char* stringPlanBase = 0;
char* backtrackPoint = 0;		// plan code backtrace data
unsigned int currentIterator = 0;		// next value of iterator

//   spot callArgumentList are stored for  function calls
#define MAX_ARG_BYTES MAX_WORD_SIZE * 2
char callArgumentList[MAX_ARGUMENT_COUNT+1][MAX_ARG_BYTES];    // arguments to functions
unsigned int callArgumentIndex;
unsigned int callArgumentBase;
unsigned int fnVarBase;
bool backtrackable = false;

char lastInputSubstitution[INPUT_BUFFER_SIZE];
int wasCommand; // special result passed back from some commands to control chatscript

static char oldunmarked[MAX_SENTENCE_LENGTH];
static unsigned int spellSet;			// place to store word-facts on words spelled per a pattern
char* currentPlanBuffer;

//////////////////////////////////////////////////////////
/// BASIC FUNCTION CODE
//////////////////////////////////////////////////////////

void InitFunctionSystem() // register all functions
{
	unsigned int k = 0;
	SystemFunctionInfo *fn;
	while ((fn = &systemFunctionSet[++k]) && fn->word)
	{
		if (*fn->word == '^' ) // not a header
		{
			WORDP D = StoreWord((char*) fn->word,0,FUNCTION_NAME);
			D->x.codeIndex = (unsigned short)k;
		}
	}

	oldunmarked[0] = 0;	// global unmarking has nothing
}

void ResetFunctionSystem()
{
	//   reset function call data
	fnVarBase = callArgumentBase = callArgumentIndex = 0;
}

char* SaveBacktrack(int id)
{
	// save: id, oldbacktrack point, currentfact, current dict,   
	char* mark = AllocateString(NULL,(4 * sizeof(int)),false,false); 
	if (!mark) return NULL;
	int* i = (int*) mark;
	i[0] = id;										// 1st int is a backtrack label - plan (-1) or rule (other)
	i[1] = (int)(stringPlanBase - backtrackPoint);	// 2nd is old backtrack point value
	i[2] = Fact2Index(factFree);					// 4th is fact base 
	i[3] = Word2Index(dictionaryFree);				// 5th is word base (this entry is NOT used)
	return backtrackPoint = mark;
}

static char* FlushMark() // throw away this backtrack point, maybe reclaim its string space
{
	if (!backtrackPoint) return NULL;
	// we are keeping facts and variable changes, so we cannot reassign the string free space back because it may be in use.
	if (backtrackPoint == stringFree) stringFree = backtrackPoint + (4 * sizeof(int));
	int* i = (int*) backtrackPoint;
	return backtrackPoint = stringPlanBase - i[1];
}

static void RestoreMark()
{	// undo all changes
	if (!backtrackPoint) return;
	stringFree = backtrackPoint;
	int* i = ((int*) backtrackPoint); // skip id

	// revert facts
	FACT* oldF = Index2Fact(i[2]);
	while (factFree > oldF) FreeFact(factFree--); // undo facts to start
	// revert dict entries
	WORDP oldD = Index2Word(i[3]);
	while (dictionaryFree > oldD) DeleteDictionaryEntry(--dictionaryFree); // remove entry from buckets
	
	// trim dead facts at ends of sets
	for (unsigned int store = 0; store < MAX_FIND_SETS; ++store)
	{
		unsigned int count = FACTSET_COUNT(store) + 1;
		while (--count >= 1)
		{
			if (!(factSet[store][count]->flags & FACTDEAD)) break; // stop having found a live fact
		}
		if (count) SET_FACTSET_COUNT(store,count); // new end
	}
	backtrackPoint = stringPlanBase - i[1];
}

void RefreshMark()
{	// undo all changes but leave rule mark in place
	if (!backtrackPoint) return;
	int* i = (int*) backtrackPoint; // point past id, backtrack 
	
	// revert facts
	FACT* oldF = Index2Fact(i[2]);
	while (factFree > oldF) FreeFact(factFree--); // undo facts to start
	// revert dict entries
	WORDP oldD = Index2Word(i[3]);
	while (dictionaryFree > oldD) DeleteDictionaryEntry(--dictionaryFree); // remove entry from buckets
	
	// trim dead facts at ends of sets
	for (unsigned int store = 0; store < MAX_FIND_SETS; ++store)
	{
		unsigned int count = FACTSET_COUNT(store) + 1;
		while (--count >= 1)
		{
			if (!(factSet[store][count]->flags & FACTDEAD)) break; // stop having found a live fact
		}
		if (count) SET_FACTSET_COUNT(store,count); // new end
	}
	stringFree = backtrackPoint;
}

static void UpdatePlanBuffer()
{
	size_t len = strlen(currentPlanBuffer);
	if (len) // we have output, prep next output
	{
		currentPlanBuffer += len;	// cumulative output into buffer
		*++currentPlanBuffer = ' '; // add a space
		currentPlanBuffer[1] = 0;
	}
}

static unsigned int PlanCode(WORDP plan, char* buffer)
{  // failing to find a responder is not failure.
#ifdef INFORMATION

	A plan sets a recover point for backtracking and clears it one way or another when it exits.
	A rule sets a backpoint only if it finds some place to backtrack. The rule will clear that point one way or another when it finishes.

	Undoable changes to variables are handled by creating special facts. 
#endif

	if (trace & (TRACE_MATCH|TRACE_PATTERN)) Log(STDUSERLOG,"\r\n\r\nPlan: %s ",plan->word);
	bool oldplan = planning;
	bool oldbacktrackable = backtrackable;
	char* oldbacktrackPoint = backtrackPoint;
	char* oldStringPlanBase = stringPlanBase;
	stringPlanBase = stringFree;
	backtrackPoint = stringFree;
	backtrackable = false;
	unsigned int oldWithinLoop = withinLoop;
	withinLoop = 0;
	planning = true;
	int holdd = globalDepth;
	ChangeDepth(1,"PlanCode");
	char* oldCurrentPlanBuffer = currentPlanBuffer;
	
	unsigned int tindex = topicIndex;
    unsigned int result = 0;
	if (debugger) Debugger(ENTER_TOPIC);

	SAVEOLDCONTEXT()

	// where future plans will increment naming
	char name[MAX_WORD_SIZE];
	strcpy(name,plan->word);
	char* end = name + plan->length;
	*end = '.';
	*++end = 0;

	unsigned int n = 0;
	while (!result) // loop on plans to use
	{
		*buffer = 0;
		currentPlanBuffer = buffer;	  // where we are in buffer writing across rules of a plan
		unsigned int topic = plan->x.topicIndex;
		if (!topic)  
		{
			result = FAILRULE_BIT; 
			break;
		}
		int pushed =  PushTopic(topic);  // sets currentTopicID
		if (pushed < 0) 
		{
			result = FAILRULE_BIT; 
			break;
		}
		char* xxplanMark = SaveBacktrack(PLANMARK); // base of changes the plan has made
		char* base = GetTopicData(topic); 
		int ruleID = 0;
		currentRuleTopic = currentTopicID;
		currentRule = base;
		currentRuleID = ruleID;
		char* ruleMark = NULL;
		while (base && *base ) //   loop on rules of topic
		{
			currentRule = base;
			ruleMark = SaveBacktrack(RULEMARK); // allows rule to be completely undone if it fails
			backtrackable = false;
			result = TestRule(ruleID,base,currentPlanBuffer); // do rule at base
			if (!result || (result & ENDTOPIC_BIT)) // rule didnt fail
			{
				UpdatePlanBuffer();	// keep any results
				if (result & ENDTOPIC_BIT) break; // no more rules are needed
			}
			else if (backtrackable)  // rule failed 
			{
				while (backtrackable)
				{
					if (trace & (TRACE_MATCH|TRACE_PATTERN)) Log(STDUSERTABLOG,"Backtrack \r\n");
					*currentPlanBuffer = 0;
					RefreshMark(); // undo all of rule, but leave undo marker in place
					backtrackable = false;
					result = DoOutput(currentPlanBuffer,currentRule,currentRuleID); // redo the rule per normal
					if (!result || result & ENDTOPIC_BIT) break; // rule didnt fail
				}
				if (result & ENDTOPIC_BIT) break; // rule succeeded eventually
			}
			FlushMark();  // cannot revert changes after this
			base = FindNextRule(NEXTTOPLEVEL,base,ruleID);
		}
		if (backtrackPoint == ruleMark) FlushMark(); // discard rule undo
		if (trace & (TRACE_MATCH|TRACE_PATTERN)) 
		{
			char* name = GetTopicName(currentTopicID);
			if (*name == '^') Log(STDUSERTABLOG,"Result: %s Plan: %s \r\n",ResultCode(result),name);
			else Log(STDUSERTABLOG,"Result: %s Topic: %s \r\n",ResultCode(result),name);
		}
		if (pushed) PopTopic();
		if (result & ENDTOPIC_BIT) 
		{
			FlushMark(); // drop our access to this space, we are as done as we can get on this rule
			break;	// we SUCCEEDED, the plan is done
		}
		//   flush any deeper stack back to spot we started
		if (result & FAILCODES) topicIndex = tindex; 
		//   or remove topics we matched on so we become the new master path
		RestoreMark(); // undo failed plan
		sprintf(end,"%d",++n);
		plan = FindWord(name);
		result =  (!plan) ? FAILRULE_BIT : 0;
		if (!result && trace & (TRACE_MATCH|TRACE_PATTERN)) Log(STDUSERTABLOG,"NextPlan %s\r\n",name);
	}
	RESTOREOLDCONTEXT()

	if (debugger) Debugger(EXIT_TOPIC,result);
	ChangeDepth(-1,"PlanCode");
	if (globalDepth != holdd) ReportBug("PlanCode didn't balance");
	
	if (*currentPlanBuffer == ' ') *currentPlanBuffer = 0; // remove trailing space

	// revert to callers environment
	planning = oldplan;
	currentPlanBuffer = oldCurrentPlanBuffer;
	withinLoop = oldWithinLoop;
	backtrackable = oldbacktrackable;
	stringPlanBase = oldStringPlanBase;
	backtrackPoint = oldbacktrackPoint;
	return result & (-1 ^ (ENDTOPIC_BIT|ENDRULE_BIT)); // these are swallowed
}

char* DoFunction(char* name,char* ptr,char* buffer,unsigned int &result) // DoCall(
{
	WORDP D = FindWord(name,0,LOWERCASE_LOOKUP);
	if (!D || !(D->systemFlags & FUNCTION_NAME))
    {
		result = UNDEFINED_FUNCTION;
		return ptr; 
	}
	result = 0;
	char word[MAX_WORD_SIZE];
    ptr = ReadCompiledWord(ptr,word); // swallow ( of argument list
	bool oldecho = echo;
	if (D->internalBits & TRACE_MACRO) echo = true;
	SystemFunctionInfo* info = NULL;
	unsigned int oldArgumentBase = callArgumentBase;
	unsigned int oldArgumentIndex = callArgumentIndex;
	if (D->x.codeIndex && !(D->systemFlags & (IS_PLAN_MACRO|IS_TABLE_MACRO))) // system function --  macroFlags are also on codeindex, but IS_TABLE_MACRO distinguishes  but PLAN also has a topicindex which is a codeindex
	{
		callArgumentBase = callArgumentIndex - 1;
		if (trace & TRACE_OUTPUT) Log(STDUSERTABLOG, "System Call %s(",name);
		info = &systemFunctionSet[D->x.codeIndex];
		char* start = ptr;
		while (ptr && *ptr != ')' && *ptr != ENDUNIT) // read arguments
		{
			if (info->argumentCount != STREAM_ARG) ptr = ReadShortCommandArg(ptr,callArgumentList[callArgumentIndex],result,OUTPUT_NOTREALBUFFER|OUTPUT_EVALCODE|OUTPUT_UNTOUCHEDSTRING);
			else // swallow unevaled arg stream
			{
				ptr = BalanceParen(start - 2,false);  // start at (, point after closing ) if one can, to next token
				size_t len = ptr - start; // length of argument bytes
				if (*ptr && *ptr != ENDUNIT && *ptr != ' ') // is a token pointer
				{
					ptr -= 2;  // ptr to )
					len -= 2;
				}
				else if (*--ptr != ')') --ptr; // aim back at ) // len may include a blank or not

				strncpy(callArgumentList[callArgumentIndex],start,len);
				char* tail = &callArgumentList[callArgumentIndex][len];
				*tail = 0;
				if (len && *(tail-1) == ' ')  *(tail-1) = 0; // remove any trailing blank
			}
			if (trace & TRACE_OUTPUT || D->internalBits & TRACE_MACRO) Log(STDUSERLOG,"%s, ",callArgumentList[callArgumentIndex]);
			if (++callArgumentIndex >= MAX_ARG_LIST) // too many arguments
			{
				result = FAILRULE_BIT;
				echo = oldecho;
				return ptr; 
			}
			if (info->argumentCount == STREAM_ARG) break; // end of arguments
		}
		*callArgumentList[callArgumentIndex] = 0; //  mark end of arg list
		if (trace & TRACE_OUTPUT  || D->internalBits & TRACE_MACRO) Log(STDUSERLOG,") = ");
		if (result & ENDCODES); // failed during argument processing
		else result = (*info->fn)(buffer);
	} 
	else //   user function (plan macro, inputmacro, outputmacro, tablemacro)) , eg  ^call (_10 ^2 it ^call2 (3 ) )  spot each token has 1 space separator 
	{
		unsigned int oldFnVarBase = fnVarBase;
		if (trace & TRACE_OUTPUT || D->internalBits & TRACE_MACRO) Log(STDUSERTABLOG, "Execute %s(",name);
		unsigned char* definition = D->w.fndefinition + 1;
        while (*ptr && *ptr != ')') //   ptr is after opening (and before an arg but may have white space
        {
			char* arg = callArgumentList[callArgumentIndex++];
			if (currentRule == NULL) //   this is a table function- DONT EVAL ITS ARGUMENTS AND... keep quoted item intact
			{
				ptr = ReadCompiledWord(ptr,arg); // return dq args as is
#ifndef DISCARDSCRIPTCOMPILER
				if (compiling && ptr == NULL) BADSCRIPT("TABLE-11 Arguments to %s ran out",name)
#endif
			}
			else ptr = ReadArgument(ptr,arg); //   ptr returns on next significant char
			
			//   within a function, seeing function argument as an argument (limit 9 calling Arguments)
			//   switch to incoming arg now, later callArgumentBase will be wrong
			if (*arg == '^' && IsDigit(arg[1]) ) strcpy(arg,callArgumentList[atoi(arg+1) + fnVarBase]); 
			if (*arg == '"' && arg[1] == '`') // internal special quoted item, remove markers.
			{
				size_t len = strlen(arg);
				if (arg[len-2] == '`')
				{
					arg[len-2] = 0;
					memmove(arg,arg+2,len-1);
				}
			}
			if (trace & TRACE_OUTPUT || D->internalBits & TRACE_MACRO) 
			{
				Log(STDUSERLOG, "%s",arg);
				if (*arg == '$') Log(STDUSERLOG,"(%s)",GetUserVariable(arg));
				Log(STDUSERLOG, ", ");
			}
		}
		if (trace & TRACE_OUTPUT || D->internalBits & TRACE_MACRO) Log(STDUSERLOG, ")\n");
		fnVarBase = callArgumentBase = oldArgumentIndex; 
	
		//   run the definition
		unsigned int oldtrace = trace;
		if (D->internalBits & TRACE_MACRO) trace = (unsigned int) -1;
		ChangeDepth(1,"HandleCall");
		if (debugger) Debugger(ENTER_CALL,0,(char*)definition);
		if (definition)
		{
			ChangeDepth(1,"DoFunction");
			Output((char*)definition,buffer,result,OUTPUT_NOTREALBUFFER);
			ChangeDepth(-1,"DoFunction");
		}
		else if ((D->systemFlags & FUNCTION_BITS) == IS_PLAN_MACRO) result = PlanCode(D,buffer); // run a plan
		if (debugger) Debugger(EXIT_CALL,0,0);
		ChangeDepth(-1,"HandleCall");
		trace = oldtrace;
		fnVarBase = oldFnVarBase;
	}

	if (callArgumentIndex > (MAX_ARGUMENT_COUNT - 20))
	{
		ReportBug("Function nesting too deep");
		result = FAILRULE_BIT;
	}
	//   pop argument list
	callArgumentIndex = oldArgumentIndex;	 
	callArgumentBase = oldArgumentBase;

	if (trace & TRACE_OUTPUT || D->internalBits & TRACE_MACRO) 
	{
		if (info && info->properties & SAMELINE) Log(STDUSERLOG,"%s (%s)\r\n",ResultCode(result),name);	// stay on same line to save visual space in log
		else Log(STDUSERTABLOG,"%s (%s)\r\n",ResultCode(result),name);
	}
	echo = oldecho;
	if (*ptr == ')') // skip ) and space
	{
		if (ptr[1] != ENDUNIT && ptr[1]) return ptr+2; // if this is a pattern comparison, this will NOT be a space, but will be a comparison op instead missing it
		return ptr+1;	// ptr to the end unit
	}
	else return ptr;
}

void DumpFunctions()
{
	unsigned int k = 0;
	SystemFunctionInfo *fn;
	while ( (fn = &systemFunctionSet[++k])  && fn->word )
	{
		if (*fn->word != '^') Log(STDUSERLOG,"%s\r\n",fn->word);
		else Log(STDUSERLOG,"%s - %s\r\n",fn->word,fn->comment);
	}
}

//////////////////////////////////////////////////////////
/// FUNCTION UTILITIES
//////////////////////////////////////////////////////////

char* ResultCode(unsigned int result)
{
	char* ans = "OK";
	if (result & ENDRULE_BIT) ans = "ENDRULE";
	else if (result & FAILRULE_BIT) ans = "FAILRULE";
	else if (result & RETRYRULE_BIT) ans = "RETRYRULE";
	else if (result & RETRYTOPRULE_BIT) ans = "RETRYTOPRULE";

	else if (result & ENDTOPIC_BIT) ans = "ENDTOPIC";
	else if (result & FAILTOPIC_BIT) ans = "FAILTOPIC";
	else if (result & RETRYTOPIC_BIT) ans = "RETRYTOPIC";

	else if (result & ENDSENTENCE_BIT) ans = "ENDSENTENCE";
	else if (result & FAILSENTENCE_BIT) ans = "FAILSENTENCE";
	else if (result & RETRYSENTENCE_BIT) ans = "RETRYSENTENCE";

	else if (result & ENDINPUT_BIT) ans = "ENDINPUT";
	else if (result & FAILINPUT_BIT) ans = "FAILINPUT";
	else if (result & FAIL_MATCH) ans = "FAILMATCH";
	return ans;
}

 static void AddInput(char* buffer)
{
	char* copy = AllocateBuffer();
	strcpy(copy,nextInput);
	strcpy(nextInput,"... "); // system separator
	char* ptr = nextInput + 4;
	unsigned int n = BurstWord(buffer);
	for (unsigned int i = 0; i < n; ++i)
	{
        strcpy(ptr,GetBurstWord(i));
		ptr += strlen(ptr);
		strcpy(ptr," ");
		++ptr;
	}
	strcpy(ptr,copy);
	FreeBuffer();
	if (strlen(nextInput) > 1000) nextInput[1000] = 0;	// overflow
}

static unsigned int ComputeSyllables(char* word)
{
	char copy[MAX_WORD_SIZE];
	MakeLowerCopy(copy,word);
	size_t len = strlen(copy);
	if (len <= 3) return 1;

	char* ptr = copy-1;
	unsigned int vowels = 0;
	int series = 0;
	while (*++ptr)
	{
		if (!IsVowel(*ptr)) 
		{
			if (series >= 4) --vowels; 
			series = 0;
		}
		else 
		{
			++vowels;
			++series;
		}
	}
	// silent e
	if (copy[len-1] == 'e' && !IsVowel(copy[len-2]) && IsVowel(copy[len-3])) --vowels;	// silent e
	
	// silent es or ed
	if ((copy[len-1] == 'd' || copy[len-1] == 's') && copy[len-2] == 'e' && !IsVowel(copy[len-3]) && IsVowel(copy[len-4])) --vowels;	// silent e

	return vowels;
}

static unsigned int RandomMember(char* buffer,char* answer) 
{
#ifdef INFORMATION
returns a random member of a set or class

returns FAILRULE if a bad set is given.

The value is recursive. If the random member chosen is a set or class, the
link is followed and a random member from the next level is chosen, and so on. 
If the value is a wordnet reference you get the synset node-- fix this sometime.

#endif
	WORDP members[3000];
loop:
	WORDP D = FindWord(answer);
	if (!D ) return FAILRULE_BIT;

    unsigned int index = 0;
    FACT* F = GetObjectHead(D);
    while (F && index < 2999)
    {
        if (F->verb == Mmember) members[index++] = Meaning2Word(F->subject);
        F = GetObjectNext(F);
    }
    if (!index) return FAILRULE_BIT; //   none found

	//   pick one at random
    D = members[random(index)];
    answer = D->word;
    if (*answer == '~') goto loop; //   member is a subset or class, get from it
    if (*answer == '<') ++answer; //   interjections have < in front
	strcpy(buffer,answer);
    return 0;
}

unsigned int FLR(char* buffer,char which)
{  
	unsigned int store;
	*buffer = 0;
	char* word = ARGUMENT(1);
	if (*word != '@') 
	{
		ReportBug("bad store id")
		return FAILRULE_BIT;
	}
	store = GetSetID(word);

	unsigned int count = FACTSET_COUNT(store);
	if (!count) 
	{
		if (impliedWild != ALREADY_HANDLED)
		{
			SetWildCardIndexStart(impliedWild);
			SetWildCard("","",0,0); // subject
			SetWildCard("","",0,0);	// verb
			SetWildCard("","",0,0);	// object
			SetWildCard("","",0,0);	// flags
		}
		impliedWild = ALREADY_HANDLED;
		return ENDRULE_BIT; //   terminates but does not cancel output
	}
	
	if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"[%d] => ",count);

	if (!withinLoop && planning && (which != 'n') && *GetTopicName(currentTopicID) == '^' && !backtrackable) backtrackable = true;
	
	// pick fact
	unsigned int item;
	if (which == 'l') item = count; //   last
	else if (which == 'f') item = 1; //   first
	else if (which == 'n') // next
	{
		item = ++factSetNext[store];
		if (count < item) return FAILRULE_BIT; 
	}
	else item = random(count) + 1;    // random
	FACT* F = factSet[store][item];

	// remove fact from set, but next does not alter set
	if (which != 'n')
	{
		SET_FACTSET_COUNT(store,(count-1));
		memmove(&factSet[store][item],&factSet[store][item+1],sizeof(FACT*) * (count - item)); 
	}		

	char type = *GetSetType(word);

	// transfer fact pieces appropriately
	MEANING Mfirst = 0;
	MEANING Mlast = 0;
	uint64 factSubject = 0;
	uint64 factObject = 0;
	if (!type || type == 'f') // want entire fact as index
	{
		if (impliedSet == ALREADY_HANDLED) sprintf(buffer,"%d",Fact2Index(F)); 
		else AddFact(impliedSet,F);
	}
	else if (type == 's') // want subject
	{
		MEANING M = F->subject;
		if (F->flags & FACTSUBJECT) sprintf(buffer,"%d",M);
		else sprintf(buffer,"%s",Meaning2Word(M)->word);
	}
	else if (type == 'v') // want verb
	{
		MEANING M = F->verb;
		if (F->flags & FACTVERB) sprintf(buffer,"%d",M);
		else sprintf(buffer,"%s",Meaning2Word(M)->word);
	}
	else if (type == 'o') // want obect
	{
		MEANING M = F->object;
		if (F->flags & FACTOBJECT) sprintf(buffer,"%d",M);
		else sprintf(buffer,"%s",Meaning2Word(M)->word);
	}
	else if ( type == 'a' || type == '+'  || type == ' ' || !type) // want all, subject first
	{
		Mfirst = F->subject;
		factSubject = F->flags & FACTSUBJECT;
		Mlast = F->object;
		factObject = F->flags & FACTOBJECT;
	}
	else // want all, object first
	{
		Mlast = F->subject;
		factObject = F->flags & FACTSUBJECT;
		Mfirst = F->object;
		factSubject= F->flags & FACTOBJECT;
	}
	if (Mfirst) // spread
	{
		char factID[100];
		char* piece;
		if (factSubject) 
		{
			sprintf(factID,"%d",Mfirst);
			piece = factID;
		}
		else piece = Meaning2Word(Mfirst)->word;

		// _wildcard can take all, otherwise you get just a field
		// for variables. not legal for sets

		if (impliedWild == ALREADY_HANDLED) strcpy(buffer,piece);
		else 
		{
			SetWildCardIndexStart(impliedWild);
			SetWildCard(piece,piece,0,0); 

			 //   verb
			MEANING M = F->verb;
			if (F->flags & FACTVERB) 
			{
				sprintf(factID,"%d",M);
				piece = factID;
			}
			else piece = Meaning2Word(M)->word;
			SetWildCard(piece,piece,0,0);

			//   object
			if (factObject) 
			{
				sprintf(factID,"%d",Mlast);
				piece = factID;
			}
			else piece = Meaning2Word(Mlast)->word;
			SetWildCard(piece,piece,0,0); 

			if ( type == 'a') // all include flags on fact
			{
				sprintf(tmpWord,"0x%08x",F->flags);
				SetWildCard(tmpWord,tmpWord,0,0);
			}
		}
		impliedSet = impliedWild = ALREADY_HANDLED; // we spread the values out
	}
	if (trace & TRACE_OUTPUT && *buffer) Log(STDUSERLOG," %s  ",buffer);
	return 0;
}

bool RuleTest(char* data) // see if pattern matches
{
	char pattern[MAX_WORD_SIZE];
	GetPattern(data,NULL,pattern);
	unsigned int gap = 0;
	unsigned int wildcardSelector = 0;
	wildcardIndex = 0;
	unsigned int junk;
	blocked = true;
	bool answer =  Match(pattern+2,0,0,'(',true,gap,wildcardSelector,junk,junk); // start past the opening paren
	blocked = false;
	return answer;
}

unsigned int Callback(WORDP D,char* arguments) 
{
	if (! D || !(D->systemFlags & FUNCTION_NAME)) return FAILRULE_BIT;
	PushOutputBuffers();
	unsigned int oldtrace = trace;
	trace = 0;
	char args[MAX_WORD_SIZE];
	strcpy(args,arguments);
	unsigned int result;
	AllocateOutputBuffer();
	DoFunction(D->word,args,currentOutputBase,result);
	FreeOutputBuffer();
	PopOutputBuffers();
	trace = oldtrace;
	return result;
}

void ResetUser(char* input)
{
	unsigned int oldtopicid = currentTopicID;
	char* oldrule = currentRule;
	int oldruleid = currentRuleID;
	int oldruletopic = currentRuleTopic;
	
	ReadNewUser(); 
	userFirstLine = 1;
	responseIndex = 0;
	wasCommand = BEGINANEW;

	currentTopicID = oldtopicid;
	currentRule = oldrule;
	currentRuleID = oldruleid;
	currentRuleTopic = oldruletopic;
}

//////////////////////////////////////////////////////////
/// TOPIC FUNCTIONS
//////////////////////////////////////////////////////////

static unsigned int AddTopicCode(char* buffer) 
{     
	AddPendingTopic(FindTopicIDByName(ARGUMENT(1))); // does not fail, just may not become pending
	return 0;
}

static unsigned int ClearTopicsCode(char* buffer)
{
	ClearPendingTopics();
	return 0;
}

static unsigned int CountTopicCode(char* buffer) 
{     
	int topic = FindTopicIDByName(ARGUMENT(1));
	if (BlockedBotAccess(topic)) return FAILRULE_BIT;

	char* name = ARGUMENT(2);
	if (!strnicmp(name,"gambit",6)) sprintf(buffer,"%d", GAMBIT_MAX(topicMaxRule[topic])); 
	else if (!strnicmp(name,"rule",4)) sprintf(buffer,"%d", RULE_MAX(topicMaxRule[topic])); 
	else if (!stricmp(name,"used")) sprintf(buffer,"%d",TopicUsedCount(topic));
	else if (!stricmp(name,"available"))
	{
		unsigned int count = 0;
		unsigned int* map = gambitTagMap[topic];	
		unsigned int gambitID = *map;
		while (gambitID != NOMORERULES)
		{
			if (UsableRule(topic,gambitID)) ++count;
			gambitID = *++map;
		}
		sprintf(buffer,"%d",count); 
	}
	else return FAILRULE_BIT;
	return 0;
}

static unsigned int GambitCode(char* buffer) 
{ 
	if (planning) return FAILRULE_BIT;	// cannot call from planner

	// gambit(PENDING) means from interesting stack  
	// gambit(~name) means use named topic 
	// gambit(~) means current topic we are within now
	// gambit (word) means topic with that keyword
	// if a second argument exists (FAIL) then return failure code if doesnt generate
	unsigned int oldIndex = responseIndex;
	if (all) return FAILRULE_BIT; // dont generate gambits when doing all

	//  if "~", get current topic name to use for gambits
	char* word = ARGUMENT(1);
	char* arg2 = ARGUMENT(2);
	unsigned int topic;
	unsigned int result = FAILRULE_BIT;

   	if (!stricmp(word,"pending")) // pick topic from pending stack
	{
		unsigned int stack[MAX_TOPIC_STACK+1];
		memcpy(stack,pendingTopicList,pendingTopicIndex * sizeof(unsigned int)); // copy stack
		int index = pendingTopicIndex;
        while (index--) // walk topics, most recent first
		{
			topic = stack[index];
			int pushed =  PushTopic(topic);
			if (pushed < 0) return FAILRULE_BIT;
			ChangeDepth(1,"GambitCode");
			result = PerformTopic(GAMBIT,buffer);
			ChangeDepth(-1,"GambitCode");
			if (pushed) PopTopic();
			if (result & RESULTBEYONDTOPIC) return result;
			if (responseIndex > oldIndex)  return 0;
		}
		return 0;
	}

	 // do topic by name
	else if (*word == '~')
	{
		topic = FindTopicIDByName(word);
		if (topic && !(GetTopicFlags(topic) & TOPIC_BLOCKED))
		{
 			int pushed = PushTopic(topic);
			if (pushed < 0) return FAILRULE_BIT;
			ChangeDepth(1,"GambitCode1");
			result = PerformTopic(GAMBIT,buffer);
			ChangeDepth(-1,"GambitCode1");

			if (pushed) PopTopic();
		}
		if (!result && !stricmp(arg2,"FAIL") && responseIndex <= oldIndex)  return FAILRULE_BIT; // report failure
		return result;
	}
	
	// do topic by keyword
	else
	{
		WORDP D = FindWord(word);
		if (!D) return 0;
		FACT* F = GetSubjectHead(D);
		while (F) // find topics word is a direct member of
		{
			if (F->verb == Mmember)
			{
				WORDP E = Meaning2Word(F->object);
				if (E->systemFlags & TOPIC)
				{
					unsigned int topic = FindTopicIDByName(E->word);
					if (topic && !(GetTopicFlags(topic) & (TOPIC_BLOCKED|TOPIC_SYSTEM)))
					{
 						int pushed = PushTopic(topic);
						if (pushed < 0) return FAILRULE_BIT;
						ChangeDepth(1,"GambitCode2");
						result = PerformTopic(GAMBIT,buffer);
						ChangeDepth(-1,"GambitCode2");
						if (pushed) PopTopic();
						if (result & RESULTBEYONDTOPIC) return result;
						if (responseIndex > oldIndex)  return 0;
					}
				}
			}
			F = GetSubjectNext(F);
		}
		if (!stricmp(arg2,"FAIL"))  return FAILRULE_BIT; // report failure
	}
	return 0;
}

static unsigned int GetRuleCode(char* buffer) 
{     
	char* arg1 = ARGUMENT(1);
	char* arg2 = ARGUMENT(2);
	char* arg3 = ARGUMENT(3);
	unsigned int topic = currentTopicID;
	int id;
	char* rule;
	bool fulllabel = false;
	bool crosstopic = false;
	char* dot = strchr(arg2,'.');
	if (dot && IsDigit(dot[1])) rule = GetRuleTag(topic,id,arg2);
	else rule = GetLabelledRule(topic,arg2,arg3,fulllabel,crosstopic,id);
	if (!rule) return FAILRULE_BIT;
	if (!stricmp(arg1,"tag")) sprintf(buffer,"%s.%d.%d",GetTopicName(topic),TOPLEVELID(id),REJOINDERID(id));
	else if (!stricmp(arg1,"topic")) strcpy(buffer,GetTopicName(topic));
	else if (!stricmp(arg1,"label")) GetLabel(rule,buffer);
	else if (!stricmp(arg1,"type")) sprintf(buffer,"%c",*rule);
	else if (!stricmp(arg1,"pattern")) // use pattern notation so it can work with ^match and will not be harmed stored as a variable
	{
		*buffer = '"';
		buffer[1] = 0;
		GetPattern(rule,NULL,buffer+1);
		if (!buffer[1]) *buffer = 0;
		else strcat(buffer,"\"");
	}
	else if (!stricmp(arg1,"usable")) strcpy(buffer,(UsableRule(topic,id)) ? (char*) "1" : (char*) "");
	else // output
	{
		 rule = GetPattern(rule,NULL,NULL);
		 char* end = strchr(rule,ENDUNIT);  // will not be a useful output as blanks will become underscores, but can do ^reuse() to execute it
		 *end = 0;
		 strcpy(buffer,rule);
		 *end = ENDUNIT;
	}
	if (trace & TRACE_OUTPUT)
	{
		char word[MAX_WORD_SIZE];
		strncpy(word,buffer,50);
		word[50] = 0;
		Log(STDUSERLOG," %s ",word);
	}
	return 0;
}
	
static unsigned int HasGambitCode(char* buffer)
{
	// hasgambit(~topic) means does it have any unused gambits
	// hasgambit(~topic last) means is last gambit unused
	// hasgambit(~topic any) means does it have gambits used or unused
	char* name = ARGUMENT(1);
	unsigned int topic = FindTopicIDByName(name);
	if (!topic) return FAILRULE_BIT;
	unsigned int gambits = GAMBIT_MAX(topicMaxRule[topic]); // total gambits of topic
	if (!gambits) return FAILRULE_BIT;	

	char* arg = ARGUMENT(2);
	if (!stricmp(arg,"last")) return UsableRule(topic,gambitTagMap[topic][gambits-1]) ? 0 : FAILRULE_BIT; // is last gambit unused
	else if (!stricmp(arg,"any")) return 0;
	else return (HasGambits(topic) < 1) ? FAILRULE_BIT : 0;
}

static unsigned int KeepCode(char* buffer)
{
	if (planning) return FAILRULE_BIT;

	AddKeep(currentRule);
	return 0;
}

static unsigned int LastUsedCode(char* buffer)
{
	char* name = ARGUMENT(1);
	char* what = ARGUMENT(2);
	unsigned int topic = FindTopicIDByName(name);
	if (!topic)  return FAILRULE_BIT;  

	if (!strnicmp(what,"gambit",6)) sprintf(buffer,"%d",topicLastGambittedMap[topic]);
	else if (!strnicmp(what,"responder",8)) sprintf(buffer,"%d",topicLastResponderedMap[topic]);
	else if (!strnicmp(what,"rejoinder",6)) sprintf(buffer,"%d",topicLastRejoinderedMap[topic]);
	else // any 
	{
		unsigned int last = topicLastRejoinderedMap[topic];
		if (topicLastResponderedMap[topic] > last) last = topicLastResponderedMap[topic];
		if (topicLastGambittedMap[topic] > last) last = topicLastGambittedMap[topic];
		sprintf(buffer,"%d",last);
	}
	return 0;
}

static unsigned int PopTopicCode(char* buffer) // reconsider BUG
{     
	char* arg1 = ARGUMENT(1);
	if (*arg1 == '~') RemovePendingTopic(FindTopicIDByName(arg1)); // current topic may continue executing
	else if (!*arg1) // make current topic not interesting AND quit it
	{
		RemovePendingTopic(currentTopicID);
		return ENDTOPIC_BIT; 
	}
	else return FAILRULE_BIT;
	return 0;
}

static unsigned int RefineCode(char* buffer) 
{
	unsigned int result = 0;
 
	char* arg1 = ARGUMENT(1); // nothing or FAIL or label of rule or topic.label
	char* arg2 = ARGUMENT(2); 
	bool fail = false;
	if (!stricmp(arg1,"FAIL")) 
	{
		fail = true; 
		strcpy(arg1,arg2); // promote any 2nd argument
	}
	
	char* rule;
    int id = currentRuleID;
	unsigned int topic = currentTopicID;
	if (!*ARGUMENT(1)) rule = FindNextRule(NEXTRULE,currentRule,id); // default continue AFTER the current rule
	else // designated
	{
		bool fulllabel = false;
		bool crosstopic = false;
		char* dot = strchr(arg1,'.');
		if (dot && IsDigit(dot[1])) rule = GetRuleTag(topic,id,arg1);
		else rule = GetLabelledRule(topic,arg1,"",fulllabel,crosstopic,id);
	}

	if (!rule) return FAILRULE_BIT;

	// change context now
	SAVEOLDCONTEXT()
	currentRule = rule;
	currentRuleTopic = currentTopicID = topic;
	currentRuleID = id;
	char level = *currentRule;
	if (debugger) Debugger(ENTER_REFINE);
	while (currentRule && level == *currentRule) // try all choices
    {
		if (trace & TRACE_PATTERN)
		{
			char label[MAX_WORD_SIZE];
			GetLabel(currentRule,label);
			if (*label) id = Log(STDUSERTABLOG, "try %s: \\",label); // the \\ will block linefeed on next Log call
			else id = Log(STDUSERTABLOG, "try  \\");
		}
		ChangeDepth(1,"RefineCode");
 		result = TestRule(id,currentRule,buffer);
		ChangeDepth(-1,"RefineCode");
	    if (result != FAIL_MATCH) break;
		else result = 0;

		while (currentRule && *currentRule)
		{
			currentRule = FindNextRule(NEXTRULE,currentRule,id); 
			if (currentRule && (*currentRule <= level  || !Rejoinder(currentRule))) break;	// matches our level OR is earlier than it (end of a zone like refine of a: into b: zone)
		}
    }
	if (outputRejoinderRuleID == NO_REJOINDER) outputRejoinderRuleID = BLOCKED_REJOINDER; // refine values exist instead of real rejoinders, dont let calling rule do set rejoinder
	if (debugger) Debugger(EXIT_REFINE);
	RESTOREOLDCONTEXT()
	if ((!currentRule || level != *currentRule) && fail) result = FAILRULE_BIT;
	return result; // finding none does not fail unless told to fail
}

static unsigned int RejoinderCode(char* buffer)
{ 
	if (postProcessing)
	{
		ReportBug("Not legal to use ^rejoinder in postprocessing");
		return FAILRULE_BIT;
	}
    if (!unusedRejoinder) 
	{
		if (trace & TRACE_BASIC) Log(STDUSERLOG," disabled rejoinder\r\n\r\n");
		return 0; //   an earlier response handled this
	}

	if (inputRejoinderRuleID == NO_REJOINDER) 
	{
		if (trace & TRACE_PATTERN) Log(STDUSERLOG,"  rejoinder not set\r\n");
		return 0; // not a failure, just nothing done
	}

    //   we last made a QUESTIONWORD or statement, can his reply be expected for that? 
	unsigned int result = 0;
	int pushed = PushTopic(inputRejoinderTopic);
	if (pushed < 0) return FAILRULE_BIT;
	
    char* ptr = GetRule(inputRejoinderTopic,inputRejoinderRuleID);
    if (!ptr)  
	{
		if (trace & TRACE_BASIC) Log(STDUSERLOG," no rejoinder data for topic %s\r\n\r\n",GetTopicName(currentTopicID));
		if (pushed) PopTopic();
		return result;
	}

	unsigned int oldtrace = trace;
	if (trace & TRACE_BASIC) Log(STDUSERLOG,"  try rejoinder for: %s",GetTopicName(currentTopicID));

	int id = inputRejoinderRuleID;
	
    char level[400];
    char word[MAX_WORD_SIZE];
    ReadCompiledWord(ptr,level); //   what marks this level
	ChangeDepth(1,"RejoinderCode");
    while (ptr && *ptr) //   loop will search for a level answer it can use
    {
        ReadCompiledWord(ptr,word); // read responder type
        if (!*word) break; //   no more data
        if (TopLevelRule(word)) break; // failed to find rejoinder
        else if (*word < *level) break;  // end of local choices
        else if (!stricmp(word,level)) // check rejoinder
        {
			result = TestRule(id,ptr,buffer);
			if (result == FAIL_MATCH) result = FAILRULE_BIT; // convert 
			if (!result) // we found a match
			{
				unusedRejoinder = false;
				break; 
			}
			if (result & (RETRYTOPIC_BIT|RETRYSENTENCE_BIT|FAILTOPIC_BIT|ENDTOPIC_BIT|FAILSENTENCE_BIT|ENDSENTENCE_BIT|RETRYSENTENCE_BIT|ENDINPUT_BIT)) break;
			result = 0;
        }
       ptr = FindNextRule(NEXTRULE,ptr,id); //   wrong or failed responder, swallow this subresponder whole
    }
	if (pushed) PopTopic(); 
	ChangeDepth(-1,"RejoinderCode");

    if (inputSentenceCount) // this is the 2nd sentence that failed, give up
    {   
        inputRejoinderRuleID = NO_REJOINDER;
        unusedRejoinder = false;
    }
    trace = oldtrace;
	return  result & (-1 ^ (ENDRULE_BIT | FAILRULE_BIT | RETRYRULE_BIT | RETRYTOPRULE_BIT ));
}

static unsigned int RespondCode(char* buffer)
{  // failing to find a responder is not failure.

	if (planning) return FAILRULE_BIT;	// cannot call from planner

	char* name = ARGUMENT(1);
	char* arg2 = ARGUMENT(2);
	unsigned oldIndex = responseIndex;
	unsigned int topic = FindTopicIDByName(name);
	if (!topic)  return FAILRULE_BIT; 
	if (GetTopicFlags(topic) & TOPIC_BLOCKED) 
	{
		if (!stricmp(arg2,"FAIL") && responseIndex <= oldIndex)  return FAILRULE_BIT; // report failure
		return 0;
	}
	unsigned int oldTopic = currentTopicID;
	int pushed =  PushTopic(topic); 
	if (pushed < 0) return FAILRULE_BIT;
	ChangeDepth(1,"RespondCode");
	unsigned int result = PerformTopic(0,buffer);
	ChangeDepth(-1,"RespondCode");
	if (pushed) PopTopic();

	AddKeep(currentRule);  //   do not allow responders to erase his nest call whether or not he succeeds  BUG ???
	result &= -1 ^ (ENDTOPIC_BIT|ENDRULE_BIT); // these are swallowed
	currentTopicID = oldTopic;
	if (!result && !stricmp(arg2,"FAIL") && responseIndex <= oldIndex)  result = FAILRULE_BIT; // report failure
	return result; 
}

static unsigned int ReuseCode(char* buffer) 
{ 
	int id = 0;
	char* arg1 = ARGUMENT(1); // label of rule or topic.label
	if (!*arg1) return FAILRULE_BIT;

	unsigned int topic = currentTopicID;
	bool fulllabel = false;
	bool crosstopic = false;
	char* arg2 = ARGUMENT(2); // optional- if there not allowed to use erased rules
	char* arg3 = ARGUMENT(3); // possible fail value
	if (!stricmp(arg2,"FAIL")) // make it 3rd argument if it exists
	{
		strcpy(arg2,arg3);
		strcpy(arg3,"FAIL");
	}

	char* rule;
	char* dot = strchr(arg1,'.');
	if (dot && IsDigit(dot[1])) rule = GetRuleTag(topic,id,arg1);
	else rule = GetLabelledRule(topic,arg1,arg2,fulllabel,crosstopic,id);
	if (!rule) return FAILRULE_BIT; // unable to find labelled rule 
	int oldreuseid = currentReuseID;

	if (topic == currentTopicID) currentReuseID = currentRuleID; // LOCAL reuse

	// execute rule 
	SAVEOLDCONTEXT()
	currentRule = rule;
	currentRuleID = id;
	currentRuleTopic = currentTopicID = topic;
	
	unsigned int holdindex = responseIndex;
	ChangeDepth(1,"reuseCode");
	if (debugger)
	{
		if (oldTopic != currentTopicID) Debugger(ENTER_REUSE_TOPIC);
		Debugger(ENTER_RULE);
	}
	unsigned int result = ProcessRuleOutput(currentRule,currentRuleID,buffer); 
	if (debugger) Debugger(EXIT_RULE);
	ChangeDepth(-1,"reuseCode");
	if (crosstopic && responseIndex > holdindex) AddPendingTopic(topic); // restore caller topic as interesting
	if (debugger && oldTopic != currentTopicID) Debugger(EXIT_REUSE_TOPIC);
	RESTOREOLDCONTEXT()

	currentReuseID = oldreuseid;

	if (trace & TRACE_OUTPUT) Log(STDUSERTABLOG,""); //   restore index from lower level
	if (!result && holdindex == responseIndex && !stricmp(arg3,"FAIL")) return FAILRULE_BIT; // user wants notification of failure
	return result;
}

static unsigned int AvailableCode(char* buffer) 
{ 
	int id = 0;
	char* arg1 = ARGUMENT(1); // label of rule or topic.label
	if (!*arg1) return FAILRULE_BIT;

	unsigned int topic = currentTopicID;
	bool fulllabel = false;
	bool crosstopic = false;
	char* rule;
	char* dot = strchr(arg1,'.');
	if (dot && IsDigit(dot[1])) rule = GetRuleTag(topic,id,arg1);
	else rule = GetLabelledRule(topic,arg1,"",fulllabel,crosstopic,id);
	if (!rule) return FAILRULE_BIT; // unable to find labelled rule 
	unsigned int result = UsableRule(topic,id);
	if (!result && !stricmp(ARGUMENT(2),"FAIL")) return FAILRULE_BIT; // user wants notification of failure
	sprintf(buffer,"%d",result);
	return 0;
}

static unsigned int SetRejoinderCode(char* buffer)
{
	if (planning) return 0; // canot rejoinder inside a plan

	char* tag = ARGUMENT(1);

	unsigned int topic = currentTopicID;
	bool fulllabel = false;
	bool crosstopic = false;
	char* rule;
	char* dot = strchr(tag,'.');
	int id;
	if (dot && IsDigit(dot[1])) rule = GetRuleTag(topic,id,tag);
	else rule = GetLabelledRule(topic,tag,"",fulllabel,crosstopic,id);
	if (!rule) return FAILRULE_BIT; // unable to find labelled rule 
	outputRejoinderRuleID = id; 
 	outputRejoinderTopic = topic;
	if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"  **set rejoinder at %s.%d.%d\r\n",tag,TOPLEVELID(id),REJOINDERID(id));
	return 0;
}

static unsigned int TopicFlagsCode(char* buffer)
{
	sprintf(buffer,"%d",GetTopicFlags(FindTopicIDByName(ARGUMENT(1))));
	return 0;
}

//////////////////////////////////////////////////////////
/// TOPIC LISTS
//////////////////////////////////////////////////////////

static unsigned int GetTopicsWithGambitsCode(char* buffer)
{ 
    unsigned int topicid;
	unsigned int store = (impliedSet == ALREADY_HANDLED) ? 0 : impliedSet;
	SET_FACTSET_COUNT(store,0);
	*buffer = 0;

    unsigned int start = 0;
    while (++start <= lastTopic) 
    {
        topicid = start;
        if (topicid == currentTopicID || HasGambits(topicid) <= 0) continue;
		MEANING T = MakeMeaning(StoreWord(GetTopicName(topicid)));
		FACT* F = CreateFact(T, MgambitTopics,T,FACTTRANSIENT);
		AddFact(store,F);
	}
	if (impliedSet == ALREADY_HANDLED && FACTSET_COUNT(store) == 0) return FAILRULE_BIT;
	impliedSet = impliedWild = ALREADY_HANDLED;	
	return 0;
}

static int OrderTopics(unsigned short topicList[MAX_TOPIC_KEYS],unsigned int matches[MAX_TOPIC_KEYS]) // find other topics that use keywords
{
	bool newpass = topicList[1] != 0;
	unsigned int max = 2;
    unsigned int index = 0;
    unsigned int i;
	char currentTopic[MAX_WORD_SIZE];
	GetActiveTopicName(currentTopic); // current topic, not system or nostay.
	unsigned int baseid = FindTopicIDByName(currentTopic);

	//  value on each topic
    for (i = 1; i <= lastTopic; ++i) // value 0 means we havent computed it yet. Value 1 means it has been erased.
    {
		if (i == baseid || BlockedBotAccess(i)) continue;

        char* name = GetTopicName(i);
	    unsigned int val = topicList[i];
        if (!val) //   compute match value
        {
            char word[MAX_WORD_SIZE];
            strcpy(word,name);
			char* dot = strchr(word,'.');
			if (dot) *dot = 0;	// use base name of the topic, not topic family name.
            WORDP D = FindWord(word); //   go look up the ~word for it
            if (!D) continue; // topic not found -- shouldnt happen

			// Note- once we have found an initial match for a topic name, we dont want to match that name again...
			// E.g., we have a specific topic for a bot, and later a general one that matches all bots. We dont want that later one processed.
  			if (D->inferMark == inferMark) continue;	// already processed a topic of this name
			D->inferMark = inferMark;

            //   look at references for this topic
            int start = -1;
            while (GetIthSpot(D,++start)) // find matches in sentence
            {
                // value of match of this topic in this sentence
                for (unsigned int k = positionStart; k <= positionEnd; ++k)
                {
					if (trace & TRACE_PATTERN) Log(STDUSERLOG,"%s->%s ",wordStarts[k],word);
                    val += 10 + strlen(wordStarts[k]);   // each hit gets credit 10 and length of word as subcredit
					if (!stricmp(wordStarts[k],name+1) || !stricmp(wordCanonical[k],name+1)) val += 20; //  exact hit on topic name
                }
				if (positionEnd < positionStart) // phrase subcomponent
				{
					if (trace & TRACE_PATTERN)  Log(STDUSERLOG,"%s->%s",wordStarts[positionStart],word);
					val += 10;
  				}
            }

			//   Priority modifiers

			char priority = ' ';
			if (GetTopicFlags(i) & TOPIC_PRIORITY && val)
			{
				priority = '+';
				val  *= 3; //  raise its value
			}
  			else if (GetTopicFlags(i) & TOPIC_LOWPRIORITY && val)
			{
				priority = '-';
				val  /= 3; // lower its value
			}

			topicList[i] = (unsigned short)(val + 1); //  1 means we did compute it, beyond that is value
			if (trace & TRACE_PATTERN && val > 1) Log(STDUSERLOG,"%c(%d) ",priority,topicList[i]);
		} //   close if

        if (val >= max) //  find all best
        {
            if (val > max) // new high value
            {
                max = val;
                index = 0;
            }
            matches[++index] = i;
        }
    }
	if (trace & TRACE_PATTERN && newpass ) Log(STDUSERLOG,"\r\n");
	matches[0] = max;
    return index;
}

unsigned int KeywordTopicsCode(char* buffer)
{	//   find  topics best matching his input words - never FAILS but can return 0 items stored
    unsigned short topicList[MAX_TOPIC_KEYS];
    memset(topicList,0,MAX_TOPIC_KEYS * sizeof(short));
	
	int set = (impliedSet == ALREADY_HANDLED) ? 0 : impliedSet;
	SET_FACTSET_COUNT(set,0);

	bool onlyGambits =  (!stricmp(ARGUMENT(1),"gambit")); 

    //   now consider topics in priority order
	SET_FACTSET_COUNT(set,0);
	unsigned int index;
    unsigned int matches[MAX_TOPIC_KEYS];
	NextinferMark();
	while ((index = OrderTopics(topicList,matches))) //   finds all at this level. 1st call evals topics. other calls just retrieve.
    {
        //   see if equally valued topics found are feasible, if so, return one chosen at random
        while (index) // items are 1-based
        {
            unsigned int which = random(index) + 1; 
            unsigned int topic = matches[which];
            topicList[topic] = 1; 
            matches[which] = matches[index--]; // swap equally valued end back to fill in position

			unsigned int flags = GetTopicFlags(topic);
			if (onlyGambits && (flags & TOPIC_SYSTEM || !HasGambits(topic))) continue;
				
			char word[MAX_WORD_SIZE];
			strcpy(word,GetTopicName(topic,true));
			if (impliedSet == ALREADY_HANDLED) // just want one
			{
				strcpy(buffer,word);
				break;
			}

			char value[100];
			sprintf(value,"%d",matches[0]);
			MEANING M = MakeMeaning(StoreWord(word));
			AddFact(set,CreateFact(M,Mkeywordtopics,MakeMeaning(StoreWord(value)),FACTTRANSIENT));
        }   
    }
	if (impliedSet == ALREADY_HANDLED && FACTSET_COUNT(set) == 0) return FAILRULE_BIT;
	impliedSet = ALREADY_HANDLED;
    return 0;
}

static unsigned int PendingTopicsCode(char* buffer)
{
	int set = GetSetID(ARGUMENT(1));
	if (set < 0) return FAILRULE_BIT;
	PendingTopics(set);
	return 0;
}

static unsigned int QueryTopicsCode(char* buffer)
{
	if (impliedSet == ALREADY_HANDLED) // not in assignment
	{
		QueryTopicsOf(ARGUMENT(1),0,NULL); 
		return (FACTSET_COUNT(0)) ? 0 : FAILRULE_BIT;
	}
	return QueryTopicsOf(ARGUMENT(1),impliedSet,NULL); 
}

//////////////////////////////////////////////////////////
/// MARKINGS
//////////////////////////////////////////////////////////

static unsigned int GetParseCode(char* buffer) 
{  
#ifndef DISCARDPARSER
	char* original = buffer;
	char* ptr = ARGUMENT(1);
	char var[MAX_WORD_SIZE];
	ptr = ReadCompiledWord(ptr,var); // the locator _
	if (*var != '_') return FAILRULE_BIT;
	unsigned int id = GetWildcardID(var);
	unsigned int start = WILDCARD_START(wildcardPosition[id]);
	unsigned int end = WILDCARD_END(wildcardPosition[id]);
	
	ptr = ReadCompiledWord(ptr,var); // what we want
	unsigned int role = 0;
	if (!stricmp(var,"PHRASE"))
	{
		unsigned int phrase = phrases[start];
		if (!phrase) return FAILRULE_BIT;
		while (phrases[++end] == phrase){;}
		--end;
	}
	else if (!stricmp(var,"CLAUSE"))
	{
		unsigned int clause = clauses[start];
		if (!clause) return FAILRULE_BIT;
		while (clauses[++end] == clause){;}
		--end;
	}
	else if (!stricmp(var,"VERBAL"))
	{
		unsigned int verbal = verbals[start];
		if (!verbal) return FAILRULE_BIT;
		while (verbals[++end] == verbal){;}
		--end;
	}
	else if (!stricmp(var,"NOUNPHRASE"))
	{
		char* phrase = GetNounPhrase(start,"");
		if (*phrase == 0) return FAILRULE_BIT;
		sprintf(buffer,"%s",phrase);
		return 0;
	}
	if (*ptr) // hunting for this role
	{
		ReadCompiledWord(ptr,var); // the role
		role = (unsigned int) FindValue2ByName(var);
		if (!role) return FAILRULE_BIT;
	}

	ptr = buffer;
	while (start <= end)
	{
		if (role && !(roles[start] & role)) continue; // print out the role
		if (role & OBJECT2 && roles[start] & SUBJECT2) continue;	// this is clause subject where clause is object as a whole
		sprintf(buffer,"%s_",wordStarts[start++]);
		buffer += strlen(buffer);
		if (role) break;	 // just do one value of it (if coordinating conjunction exists)
	}
	if (buffer == original) return FAILRULE_BIT;

	*(--buffer) = 0; // remove trailing _
#endif
	return 0;
}

static unsigned int MarkCode(char* buffer) 
{  
	// argument1 is a word or ~set or missing
	// mark()  turn back on the unmark all system
	// mark(word _xxx) enable word mark at location of _xxx variable
	// mark(word  1) enables mark at specified location if within range of input
	// mark(word) enables mark at location 1 
	char* ptr = ARGUMENT(1);
	
	if (!*ptr) // mark() reenables global unmarking
	{
		if (oldunmarked[0]) // merge state back if have cached
		{
			memcpy(unmarked,oldunmarked,MAX_SENTENCE_LENGTH);
			oldunmarked[0] = 0;
		}
		return 0;
	}

	unsigned int result;
	char word[MAX_WORD_SIZE];
	ptr = ReadShortCommandArg(ptr,word,result); // what is being marked
	if (result & ENDCODES) return result;
	if (!*word) return FAILRULE_BIT; // missing arg

	char word1[MAX_WORD_SIZE];
	if (IsDigit(*ptr) || *ptr == '_') ptr = ReadCompiledWord(ptr,word1);  // the locator
	else ptr = ReadShortCommandArg(ptr,word1,result); // evaluate the locator
	
	unsigned startPosition;
	unsigned endPosition;
	if (!*word1 || *word1 == ')') startPosition = endPosition = 1; // default mark  (ran out or hit end paren of call
	else if (IsDigit(*word1)) endPosition = startPosition = atoi(word1); // named number as index
	else if (*word1 == '_') //  wildcard position designator
	{
		startPosition = wildcardPosition[GetWildcardID(word1)] & 0x0000ffff; // the match location
		endPosition = wildcardPosition[GetWildcardID(word1)] >> 16; 
	}
	else return FAILRULE_BIT;

	if (startPosition < 1) endPosition = startPosition = 1;
	if (startPosition > wordCount)  endPosition = startPosition = wordCount;
	MarkFacts(MakeMeaning(StoreWord(word)),startPosition,endPosition);
	return 0;
}

static unsigned int MarkedCode(char* buffer)
{
	char* arg1 = ARGUMENT(1);
	if (*ARGUMENT(1) == '$')  // indirect thru variable
	{
		char* at = GetUserVariable(ARGUMENT(1));
		if (at) arg1 = at;
	}

	WORDP D = FindWord(arg1);
	if (!D) return FAILRULE_BIT;
	if (!GetNextSpot(D,0,positionStart,positionEnd)) return FAILRULE_BIT;
	strcpy(buffer,  (char*) "1" );
	return 0;
}

static unsigned int PositionCode(char* buffer)
{
	char* ptr = ARGUMENT(1);
	unsigned int result;
	char word[MAX_WORD_SIZE];
	ptr = ReadShortCommandArg(ptr,word,result); // start or end
	if (result & ENDCODES) return result;
	char word1[MAX_WORD_SIZE];
	ptr = ReadCompiledWord(ptr,word1);  // the _ var
	if (*word1 == '^') strcpy(word1,callArgumentList[atoi(word1+1)+fnVarBase]); // swap to actual
	if (*word1 == '_') //  wildcard position designator
	{
		if (!stricmp(word,"start")) sprintf(buffer,"%d",WILDCARD_START(wildcardPosition[GetWildcardID(word1)]));  // the match location
		else if (!stricmp(word,"end")) sprintf(buffer,"%d", WILDCARD_END(wildcardPosition[GetWildcardID(word1)]));
		else if (!stricmp(word,"both")) sprintf(buffer,"%d", wildcardPosition[GetWildcardID(word1)]);
		else return FAILRULE_BIT;
	}
	else return FAILRULE_BIT;
	return 0;
}

static unsigned int SetPositionCode(char* buffer)
{
	char* ptr = ARGUMENT(1);
	unsigned int val = atoi(ptr);
	if (val == 0) return FAILRULE_BIT;
	positionStart = WILDCARD_START(val);
	unsigned int end = WILDCARD_END(val);
	positionEnd = (end) ? end : positionStart;
	return 0;
}

static unsigned int CapitalizedCode(char* buffer)
{
	if (IsDigit(*ARGUMENT(1)))
	{
		unsigned int n = atoi(ARGUMENT(1));
		if (n == 0 || n > wordCount) return FAILRULE_BIT;
		strcpy(buffer,(capState[n]) ? (char*) "1" : (char*) "0");
	}
	else if (IsAlpha(*ARGUMENT(1))) strcpy(buffer,(IsUpperCase(*ARGUMENT(1))) ? (char*) "1" : (char*) "0");
	else return FAILRULE_BIT;
	return 0;
}

static unsigned int KeepHistoryCode(char* buffer)
{
	unsigned int count = atoi(ARGUMENT(2));
	if (count >= (MAX_USED - 1)) count = MAX_USED - 1; 
	if (!stricmp(ARGUMENT(1),"BOT"))
	{
		if (count == 0) *chatbotSaid[0] = 0;
		if (count < chatbotSaidIndex)  chatbotSaidIndex = count;
	}
	if (!stricmp(ARGUMENT(1),"USER"))
	{
		if (count == 0)  *humanSaid[0] = 0;
		if (count < humanSaidIndex) humanSaidIndex = count;
	}

	return 0;
}

static unsigned int UnmarkCode(char* buffer)
{
	// unmark() // disable global unmarks
	// unmark(* 4)	 // global unmark
	// unmark(* _location) // global unmark
	// unmark(word 4)
	// unmark(word _location)

	char* ptr = ARGUMENT(1);

	if (!*ptr) // unmark all global disable marks
	{
		if (!oldunmarked[0]) // cache current disables
		{
			memcpy(oldunmarked,unmarked,MAX_SENTENCE_LENGTH);
			oldunmarked[0] = 1;
		}
		memset(unmarked,0,MAX_SENTENCE_LENGTH); // clear all mark suppression
		return 0;
	}
	
	char word[MAX_WORD_SIZE];
	unsigned int result;
	ptr = ReadShortCommandArg(ptr,word,result);// set
	if (result & ENDCODES) return result;

	char word1[MAX_WORD_SIZE];
	ptr = ReadCompiledWord(ptr,word1);  // the _data
	unsigned int startPosition = wordCount;
	unsigned int endPosition = 1;
	if (!*word1) startPosition = endPosition = 1;
	else if (IsDigit(*word1)) startPosition = endPosition = atoi(word1);
	else if (*word1 == '_') startPosition = WILDCARD_START(wildcardPosition[GetWildcardID(word1)]); // the match location
 	else  return FAILRULE_BIT;
	if (!startPosition || startPosition > wordCount) return 0;	// fail silently
	unsigned int endposition = WILDCARD_END(wildcardPosition[GetWildcardID(word1)]);
	if (*word == '*') // set unmark EVERYTHING -- BUG-- fail to extend unmark across the multiword
	{
		unmarked[startPosition] = 1;
		if (trace) Log(STDUSERLOG,"unmark all @word %d (%s) ",startPosition,wordStarts[startPosition]);
		for (unsigned int i = startPosition+1; i <= endposition; ++i) 
		{
			if (trace) Log(STDUSERLOG,"unmark %d %s ",i,wordStarts[i]);
			unmarked[i] = 1;
		}
	}
	else
	{
		WORDP D = FindWord(word); //   set or word to unmark
		if (D) RemoveMatchValue(D,startPosition);
	}
	return 0;
}

//////////////////////////////////////////////////////////
/// INPUT ROUTINES
//////////////////////////////////////////////////////////

static unsigned int InputCode(char* buffer) 
{      // when supplying multiple sentences, must do them in last first order
	if (inputCounter++ > 5) return FAILRULE_BIT;// limit per sentence reply
	if (totalCounter++ > 15) return FAILRULE_BIT; // limit per input from user

	if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"\r\n");
	unsigned int result;
	char* word = ARGUMENT(1);
	Output(word,buffer,result);
	if (strlen(buffer) >= INPUT_BUFFER_SIZE) buffer[INPUT_BUFFER_SIZE-1] = 0;	// might be smaller buffer
	Convert2Blanks(buffer); // break apart underscored words
	if (!strcmp(lastInputSubstitution,buffer)) return FAILRULE_BIT; // same result as before, apparently looping

	if (showInput || trace) Log(STDUSERLOG,"input: %s\r\n",buffer);
	AddInput(buffer);
	strcpy(lastInputSubstitution,buffer);
    *buffer = 0;
	return 0;
}

static unsigned int RemoveTokenFlagsCode(char* buffer)
{
	int64 flags;
	ReadInt64(ARGUMENT(1),flags);
	tokenFlags &= -1 ^ flags;
	return 0;
}

static unsigned int SetTokenFlagsCode(char* buffer)
{
	int64 flags;
	ReadInt64(ARGUMENT(1),flags);
	tokenFlags |= flags;
	return 0;
}


//////////////////////////////////////////////////////////
/// NUMBER FUNCTIONS
//////////////////////////////////////////////////////////

static unsigned int ComputeCode(char* buffer)
{
	int64 value = NOT_A_NUMBER;
	char* arg1 = ARGUMENT(1);
	char* op = ARGUMENT(2);
	char* arg2 = ARGUMENT(3);
	//   for long digits, move to float
	if (strlen(arg2) >= 11 || strlen(arg1) >= 11 || strchr(arg1,'.') || strchr(arg2,'.') || !stricmp(op,"divide") || !stricmp(op,"root") || !stricmp(op,"square_root") || !stricmp(op,"quotient") || *op == '/') //   float
	{
		float value = (float) NOT_A_NUMBER;
		float number1 = (strchr(arg1,'.')) ? (float) atof(arg1) : (float)Convert2Integer(arg1);
		float number2 = (strchr(arg2,'.')) ? (float) atof(arg2) :  (float)Convert2Integer(arg2);
		//   we must test case insenstive because arg2 might be capitalized (like add and ADD for attention deficit disorder)
		if (*op == '+' || !stricmp(op,"plus") || !stricmp(op,"add")|| !stricmp(op,"and")) value = number1 + number2; 
		else if (!stricmp(op,"minus") || !stricmp(op,"subtract")|| !stricmp(op,"deduct") || *op == '-' ) value = number1 - number2;
		else if (!stricmp(op,"x") || !strnicmp(op,"times",4) || !stricmp(op,"multiply") || *op == '*') value = number1 * number2;
		else if (!stricmp(op,"divide") || !stricmp(op,"quotient") || *op == '/' ) 
		{
			if (number2 == 0) 
			{
				strcpy(buffer,"infinity");
				return 0;
			}
			else value = number1 / number2;
		}
        else if (!stricmp(op,"remainder") || !stricmp(op,"modulo") || !stricmp(op,"mod") || *op == '%') 
		{
			ReportBug("illegal mod op in float")
			return FAILRULE_BIT;
		}
        else if (!stricmp(op,"random") )
		{
			ReportBug("illegal random op in float")
  			return FAILRULE_BIT;
		}
        else if (!stricmp(op,"root") || !stricmp(op,"square_root") ) value = (float) sqrt(number1);  
        else if (!stricmp(op,"^") || !stricmp(op,"power") || !stricmp(op,"exponent")) 
        {
			int power = (int)Convert2Integer(arg2);
            if (power >= 1 && power <= 10)
            {
				value = number1;
				while (--power) value *= number1;
			}
            else if (power == 0) value = 1;
		}
		if (value != NOT_A_NUMBER) 
		{
			int x = (int) value;
			strcpy(buffer,((float)x == value) ? StdIntOutput(x) : StdFloatOutput(value));
		}
		else sprintf(buffer," ?");
	}
	else //   integer
    {
		int64 value1 = Convert2Integer(arg1);
		int64 value2 = Convert2Integer(arg2);
		if (*op == '+' || !stricmp(op,"add")|| !stricmp(op,"and") || !stricmp(op,"plus")) value = value1 + value2;
		else if (*op == '-' || !stricmp(op,"deduct") || !stricmp(op,"minus") || !stricmp(op,"sub") || !stricmp(op,"subtract")) value = value1 - value2;
		else if (*op == '*' || !stricmp(op,"x") || !stricmp(op,"multiply") || !strnicmp(op,"times",4)) value = value1 * value2;
		else if ( *op == '%' || !stricmp(op,"mod") || !strcmp(op,"modulo") || !stricmp(op,"remainder")) value = value1 % value2;
		else if (!stricmp(op,"random")) value = random((unsigned int)(value2 - value1)) + value1; 
 		else if (*op == '<' && op[1] == '<')  value = value1 << value2;  // BUT FLAWED if shift >= 32
		else if (*op == '>' && op[1] == '>') value = value1 >> value2;
		else if (*op == '^' || !stricmp(op,"exponent") || !stricmp(op,"power"))
		{
			if (value2 >= 1 && value2 <= 10) // only do small powers
			{
				value = value1;
				while (--value2) value *= value1;
			}
			else if (value2 == 0) value = 1;
		}
        strcpy(buffer, (value == NOT_A_NUMBER) ? (char*)"?" : StdIntOutput((int)value));
	}
	return 0;
}

static unsigned int TimeFromSecondsCode(char* buffer)
{
	int64 seconds;
	char* word = ARGUMENT(1);
	ReadInt64(word,seconds);
	time_t sec = (time_t) seconds;

	// convert to text string
	strcpy(buffer,ctime(&sec));
	*strchr(buffer,'\n') = 0; // erase newline at end

	return 0;
}

//////////////////////////////////////////////////////////
/// DEBUG FUNCTIONS
//////////////////////////////////////////////////////////

static unsigned int LogCode(char* buffer)
{
	char* stream = ARGUMENT(1);
	uint64 flags;
	stream = ReadFlags(stream,flags); // try for flags
	if (flags && *stream == ')') ++stream; // skip end of flags
	char name[MAX_WORD_SIZE];
	*name = 0;
	unsigned int result;
	if (!strnicmp(stream,"FILE ",5)) // write data to this file
	{
		stream = ReadCompiledWord(stream,name); // FILE
		stream = ReadCommandArg(stream,name,result,OUTPUT_NOQUOTES|OUTPUT_EVALCODE|OUTPUT_NOTREALBUFFER); // name of file
		if (*name == '"') 
		{
			size_t len = strlen(name);
			name[len-1] = 0;	// remove trailing "
		}

		if (!strnicmp(stream,"new",3)) // start with a clean file
		{
			char junk[MAX_WORD_SIZE];
			stream = ReadCompiledWord(stream,junk);
			FILE* out = fopen((*name == '"') ? (name+1) : name,"wb");
			if (out) fclose(out);
			else return FAILRULE_BIT;
		}
	}

	*buffer = 0;
	++outputNest;
	Output(stream,buffer,result,OUTPUT_EVALCODE | (unsigned int) flags);
	--outputNest;
	if (*name)
	{
		FILE* out = fopen((*name == '"') ? (name+1) : name,"ab");
		if (out) 
		{
			fprintf(out,"%s",buffer);
			fclose(out);
		}
		else 
		{
			*buffer = 0;
			return FAILRULE_BIT;
		}
	}
	else Log(STDUSERLOG,"%s",buffer);
	if (flags & OUTPUT_ECHO && !echo) printf("%s",buffer);
	*buffer = 0;
	return 0;
}


//////////////////////////////////////////////////////////
/// OUTPUT FUNCTIONS
//////////////////////////////////////////////////////////

static unsigned int FlushOutputCode(char* buffer)
{
	if (planning) return FAILRULE_BIT;
	if (postProcessing)
	{
		ReportBug("Illegal to use ^FlushOutput during postprocessing");
		return FAILRULE_BIT;
	}
	AddResponse(currentOutputBase);
	return 0;
}

static unsigned int InsertOutput(char* stream, char* buffer, int index)
{
	// add at end, then alter order
	unsigned int result;
	Output(stream,buffer,result,OUTPUT_EVALCODE);
	if (AddResponse(buffer))
	{
		memmove(&responseOrder[index+1],&responseOrder[index],responseIndex - index); // shift order out 1
		responseOrder[index] = (unsigned char)(responseIndex-1);
	}
	return result;
}

static unsigned int InsertPrintCode(char* buffer) 
{     
	if (planning) return FAILRULE_BIT;
	if (postProcessing)
	{
		ReportBug("Illegal to use ^InsertPrePrint during postprocessing");
		return FAILRULE_BIT;
	}
	char* stream = ARGUMENT(1);
	uint64 flags;
	stream = ReadFlags(stream,flags); // try for flags
	if (flags) ++stream; // skip end of flags
	unsigned int result;
	char beforeIndex[MAX_WORD_SIZE];
	stream = ReadShortCommandArg(stream,beforeIndex,result); 
	int index = 0;
	
	if (*beforeIndex == '~') // put before 1st reference to this topic
	{
		unsigned int topic = FindTopicIDByName(beforeIndex);
		for (int i = responseIndex-1; i > 0; --i)
		{
			if (topic == responseData[responseOrder[i]].topic) index = responseOrder[i];
		}	
	}
	else if (IsDigit(*beforeIndex)) // numeric index he gives must be 1 based, eg before %response 
	{
		index = atoi(beforeIndex);
		if (index <= 0 || index > (int)responseIndex) return FAILRULE_BIT;
		index = responseOrder[index-1]; // the current location of the output
	}
	return InsertOutput(stream,buffer,index);
}

static unsigned int PrintCode(char* buffer) 
{     
	if (planning) return FAILRULE_BIT;
	if (postProcessing)
	{
		ReportBug("Illegal to use ^Print during postprocessing");
		return FAILRULE_BIT;
	}
	char* stream = ARGUMENT(1);
	uint64 flags;
	stream = ReadFlags(stream,flags); // try for flags
	if (flags && *stream == ')') ++stream; // skip end of flags

	unsigned int result;
	Output(stream,buffer,result,OUTPUT_EVALCODE | (unsigned int) flags);
	AddResponse(buffer);
	return result;
}

static unsigned int PrePrintCode(char* buffer)
{
	if (planning) return FAILRULE_BIT;
	if (postProcessing)
	{
		ReportBug("Illegal to use ^PrePrint during postprocessing");
		return FAILRULE_BIT;
	}
	char* stream = ARGUMENT(1); 
	uint64 flags;
	stream = ReadFlags(stream,flags); // try for flags
	if (flags) ++stream; // skip end of flags
	return InsertOutput(stream,buffer,0);
}

static unsigned int RepeatCode(char* buffer)
{ 
	if (postProcessing)
	{
		ReportBug("Illegal to use ^Repeat during postprocessing");
		return FAILRULE_BIT;
	}
	AddRepeatable(currentRule); // local repeats allowed this volley
	return 0;
}

static unsigned int SetPronounCode(char* buffer) 
{  
	// argument1 is a word to use
	// mark(word _xxx) enable word mark at location of _xxx variable
	char* ptr = ARGUMENT(1);
	if (!*ptr) return FAILRULE_BIT;

	unsigned int result;
	char word[MAX_WORD_SIZE];
	ptr = ReadShortCommandArg(ptr,word,result); // what is being marked
	if (result & ENDCODES) return result;
	if (!*word) return FAILRULE_BIT; // missing arg

	char word1[MAX_WORD_SIZE];
	ptr = ReadCompiledWord(ptr,word1);  // the locator

	unsigned startPosition;
	unsigned endPosition;
	if (!*word1 || *word1 == ')') startPosition = endPosition = 1; // default mark  (ran out or hit end paren of call
	else if (IsDigit(*word1)) endPosition = startPosition = atoi(word1); // named number as index
	else if (*word1 == '_') //  wildcard position designator
	{
		startPosition = wildcardPosition[GetWildcardID(word1)] & 0x0000ffff; // the match location
		endPosition = wildcardPosition[GetWildcardID(word1)] >> 16; 
	}
	else return FAILRULE_BIT;

	if (startPosition < 1) startPosition = 1;
	if (startPosition > wordCount)  startPosition = wordCount;
	WORDP D = StoreWord(word);
	MarkFacts(MakeMeaning(D),startPosition,startPosition);

	WORDP entry;
	WORDP canonical;
	uint64 sysflags = 0;
	uint64 cansysflags = 0;
	GetPosData(0,word,entry,canonical,sysflags,cansysflags,false); // NOT first try
	wordStarts[startPosition] = D->word; 
	wordCanonical[startPosition] = (canonical) ? canonical->word : D->word;	
	if (!wordCanonical[startPosition]) wordCanonical[startPosition] = D->word;

	uint64 bits = D->properties & (NOUN_PROPERTIES | NOUN_BITS|NOUN_INFINITIVE|LOWERCASE_TITLE);
	allOriginalWordBits[startPosition] = bits;
	finalPosValues[startPosition] = bits;
	MarkTags(startPosition);

	return 0;
}

//////////////////////////////////////////////////
/// OUTPUT ACCESS
//////////////////////////////////////////////////

static unsigned int ResponseCode(char* buffer)
{
	unsigned int index = atoi(ARGUMENT(1)) ;
	if (index > responseIndex || !index) return FAILRULE_BIT;
	sprintf(buffer,"%s",responseData[responseOrder[index-1]].response);
	return 0;
}

static unsigned int ResponseQuestionCode(char* buffer)
{
	unsigned int index = atoi(ARGUMENT(1)) - 1; // which response (1 based)
	if (index >= responseIndex) return FAILRULE_BIT;
	char* ptr = TrimSpaces(responseData[responseOrder[index]].response,false);
	strcpy(buffer,(ptr[strlen(ptr)-1] == '?') ? (char*) "1" : (char*) ""); 
	return 0;
}

static unsigned int ResponseRuleIDCode(char* buffer)
{
	unsigned int index = atoi(ARGUMENT(1));
	if (index > responseIndex || !index) return FAILRULE_BIT;
	int topic = responseData[responseOrder[index-1]].topic;
	sprintf(buffer,"%s%s",GetTopicName(topic),responseData[responseOrder[index-1]].id);
	return 0;
}

//////////////////////////////////////////////////////////
/// POSTPROCESSING FUNCTIONS
//////////////////////////////////////////////////////////

static unsigned int AnalyzeCode(char* buffer)
{
	if (postProcessing)
	{
		char* word = ARGUMENT(1);
		SAVEOLDCONTEXT()
		unsigned int result;
		Output(word,buffer,result);
		Convert2Blanks(buffer); // remove system underscoring back to blanks
		PrepareSentence(buffer,true,false); 
		*buffer = 0; // only wanted effect of script
		RESTOREOLDCONTEXT()
		return 0;
	}
	else 
	{
		ReportBug("Cannot use ^Analyze except in postprocessing");
		return FAILRULE_BIT;
	}
}

static unsigned int PostProcessPrintCode(char* buffer) // only works if post processing
{     
	if (!postProcessing) 
	{
		ReportBug("Cannot use ^PostProcessPrint except in postprocessing");
		return FAILRULE_BIT;
	}
	
	char* stream = ARGUMENT(1);		
	uint64 flags;
	stream = ReadFlags(stream,flags); // try for flags
	if (flags) ++stream; // skip end of flags

	unsigned int result;
	Output(stream,buffer,result,OUTPUT_EVALCODE| (unsigned int)flags);

	// prepend output 
	strcat(buffer," ");
	strcat(buffer,postProcessing);
	strcpy(postProcessing,buffer);
	*buffer = 0;
	return result;
}

static unsigned int ReviseOutputCode(char* buffer)
{
	if (postProcessing) return FAILRULE_BIT;
	char* arg1 = ARGUMENT(1); // index first, rest is output
	unsigned int index = atoi(arg1);
	if (!IsDigit(*arg1)) return FAILRULE_BIT;
	if (index > responseIndex) return FAILRULE_BIT;
	char* arg2 = ARGUMENT(2);
	strcpy(responseData[index-1].response,arg2);
	return 0;
}

//////////////////////////////////////////////////////////
/// COMMAND FUNCTIONS
//////////////////////////////////////////////////////////

static unsigned int CommandCode(char* buffer) 
{
	DoCommand(ARGUMENT(1),NULL,false);
	return 0;
}

unsigned int DebugCode(char* buffer) 
{	
	return 0;
}

static unsigned int EndCode(char* buffer)
{ //   good for stopping a loop w/o stopping the rule
	char* word = ARGUMENT(1);
	if (!stricmp(word,"RULE")) return ENDRULE_BIT;
	if (!stricmp(word,"TOPIC") || !stricmp(word,"PLAN")) return ENDTOPIC_BIT;
	if (!stricmp(word,"SENTENCE")) return ENDSENTENCE_BIT;
	if (!stricmp(word,"INPUT")) return ENDINPUT_BIT;
    return FAILRULE_BIT;
}

static unsigned int EvalCode(char* buffer) //  ??? needed with output eval instead?
{	
	unsigned int result;
	Output(ARGUMENT(1),buffer,result,OUTPUT_EVALCODE); 
	return result;
}

static unsigned int FailCode(char* buffer) 
{      
	char* word = ARGUMENT(1);
	if (!stricmp(word,"RULE")) return FAILRULE_BIT;
	if (!stricmp(word,"TOPIC") || !stricmp(word,"PLAN")) return FAILTOPIC_BIT;
	if (!stricmp(word,"SENTENCE")) return FAILSENTENCE_BIT;
	if (!stricmp(word,"INPUT")) return FAILINPUT_BIT;
	return FAILRULE_BIT;
}

unsigned int MatchCode(char* buffer) 
{     
	char word[MAX_WORD_SIZE];
	char word1[MAX_WORD_SIZE];
	char* at = ReadCompiledWord(ARGUMENT(1),word1);
	if (*word1 == '$' && !*at) strcpy(word,GetUserVariable(word1)); //   solitary user var, decode it  eg match($var)
	else if (*word1 == '_' && !*at) strcpy(word,wildcardCanonicalText[GetWildcardID(word1)]); //   solitary user var, decode it  eg match($var)
	else 
	{
		if (word1[0] == FUNCTIONSTRING && word1[1] == '(') strcpy(word,word1+1);
		else strcpy(word,word1); // otherwise it is what to say (like from idiom table)
		Convert2Blanks(word);
	}
	char* ptr = word;
	if (*word)  
	{
		size_t len = strlen(word);
		strcpy(word+len," )"); // insure it has a closing paren (even if it has);
		if (*word == '"') 
		{
			word[len-1] = ' '; // change closing " to space
			++ptr;	// skip opening "
			if (*ptr == FUNCTIONSTRING) ++ptr; // bypass the mark

			// now purify of any internal \" " marked strings
			char* x = strchr(ptr,'\\');
			while (x)
			{
				if (x[1] == '"') memmove(x,x+1,strlen(x));	// remove escape
				x = strchr(x + 1,'\\'); // next?
			}
		}
	}
	if (*ptr == FUNCTIONSTRING) ++ptr;	// skip compiled string mark
	if (*ptr == '(') ++ptr;		// skip opening paren of a pattern
	while (*ptr == ' ') ++ptr;	// prepare for start
	unsigned int gap = 0;
	unsigned int wildcardSelector = 0;
	wildcardIndex = 0;  //   reset wildcard allocation on top-level pattern match
	unsigned int junk;
	if (!*word) return FAILRULE_BIT;	// NO DATA?
	blocked = true;
    bool match = Match(ptr,0,0,'(',true,gap,wildcardSelector,junk,junk) != 0;  //   skip paren and treat as NOT at start depth, dont reset wildcards- if it does match, wildcards are bound
	blocked = false;
	if (!match) return FAILRULE_BIT;
	return 0;
}

static unsigned int NoFailCode(char* buffer)
{      
	char word[MAX_WORD_SIZE];
	char* ptr = ReadCompiledWord(ARGUMENT(1),word);
	unsigned int result;
	ChangeDepth(1,"noFailCode");
	Output(ptr,buffer,result);
	ChangeDepth(-1,"noFailCode");
	if (!stricmp(word,"RULE")) return result & (ENDTOPIC_BIT|FAILTOPIC_BIT|RETRYTOPIC_BIT|ENDSENTENCE_BIT|FAILSENTENCE_BIT|ENDINPUT_BIT|RETRYSENTENCE_BIT);
	else if (!stricmp(word,"TOPIC")) return result & (ENDSENTENCE_BIT|FAILSENTENCE_BIT|RETRYSENTENCE_BIT|ENDINPUT_BIT);
	else if (!stricmp(word,"SENTENCE") || !stricmp(word,"INPUT")) return 0;
	return FAILRULE_BIT; // not a legal choice
}

static unsigned int NotNullCode(char* buffer)
{
	unsigned int result;
	Output(ARGUMENT(1),buffer,result);
	if (*buffer) *buffer = 0;
	else return FAILRULE_BIT;
	return 0;
}

static unsigned int RetryCode(char* buffer)
{
	char* arg = ARGUMENT(1);
	if (!stricmp(arg,"TOPIC"))  return RETRYTOPIC_BIT;
	if (!stricmp(arg,"sentence"))  return RETRYSENTENCE_BIT;
	if (!stricmp(arg,"toprule"))  return RETRYTOPRULE_BIT;
	return RETRYRULE_BIT;
}

//////////////////////////////////////////////////////////
/// WORD MANIPULATION
//////////////////////////////////////////////////////////

static unsigned int BurstCode(char* buffer) //   take value and break into facts of burst-items as subjects
{//   ^burst(^cause : )   1: data source 2: burst character

	//   prepare spot to store pieces
	MEANING verb;
	MEANING object;
	if (impliedWild != ALREADY_HANDLED)  SetWildCardIndexStart(impliedWild); //   start of wildcards to spawn
	object = verb = Mburst;
	*buffer = 0;

	char* ptr = ARGUMENT(1); //   what to burst
	if (!*ptr) return 0;

	//   get string to search for. If quoted, remove the quotes
	char* scan = ARGUMENT(2);	//   how to burst
	if (!*scan) scan = "_"; // default
	else // clear any special characters
	{
		char* find;
		while ((find = strstr(scan,"\\r"))) // convert cr
		{
			*find = '\r';
			memmove(find+1,find+2,strlen(find)+1);
		}
		while ((find = strstr(scan,"\\n"))) // convert cr
		{
			*find = '\n';
			memmove(find+1,find+2,strlen(find)+1);
		}
		while ((find = strstr(scan,"\\t"))) // convert cr
		{
			*find = '\t';
			memmove(find+1,find+2,strlen(find)+1);
		}
	}
	if (*scan == '"' ) // if a quoted string, remove the quotes
	{
		++scan;
		size_t len = strlen(scan);
		if (scan[len-1] == '"') scan[len-1] = 0;
	}

	//   loop that splits into pieces and stores them

	char* hold = strstr(ptr,scan);
	size_t scanlen = strlen(scan);
	if (impliedSet != ALREADY_HANDLED) SET_FACTSET_COUNT(impliedSet,0);
	while (hold)
	{
		*hold = 0;	//   terminate first piece
		if (*ptr == 0) {;} // null piece - breaking here makes no sense at start
		//   store piece before scan marker
		else if (impliedWild != ALREADY_HANDLED)  SetWildCard(ptr,ptr,0,0);
		else if (impliedSet != ALREADY_HANDLED)
		{
			MEANING T = MakeMeaning(StoreWord(ptr));
			FACT* F = CreateFact(T, verb,object,FACTTRANSIENT);
			AddFact(impliedSet,F);
		}
		else //   dump straight to output buffer, first piece only
		{
			strcpy(buffer,ptr);
			break;
		}

		ptr = hold + scanlen; //   ptr after scan marker
		hold = strstr(ptr,scan); //   find next piece
	}

	//   assign the last piece
	if (impliedWild != ALREADY_HANDLED)  
	{
		SetWildCard(ptr,ptr,0,0);
		SetWildCard("","",0,0); // clear next one
	}
	else if (impliedSet != ALREADY_HANDLED)
	{
		if (*ptr) AddFact(impliedSet,CreateFact(MakeMeaning(StoreWord(ptr)), verb,object,FACTTRANSIENT));
	}
	else if (!*buffer) strcpy(buffer,ptr);
	impliedSet = impliedWild = ALREADY_HANDLED;	//   we did the assignment
	return 0;
}

static unsigned int ExplodeCode(char* buffer) //   take value and break into facts of burst-items as subjects
{
	//   prepare spot to store pieces
	MEANING verb;
	MEANING object;
	if (impliedWild != ALREADY_HANDLED)  SetWildCardIndexStart(impliedWild); //   start of wildcards to spawn
	object = verb = Mburst;
	*buffer = 0;

	char* ptr = ARGUMENT(1) - 1; //   what to explode
	char word[MAX_WORD_SIZE];
	word[1] = 0;
	SET_FACTSET_COUNT(impliedSet,0);
	while (*++ptr)
	{
		*word = *ptr;
		//   store piece before scan marker
		if (impliedWild != ALREADY_HANDLED)  SetWildCard(word,word,0,0);
		else if (impliedSet != ALREADY_HANDLED)
		{
			MEANING T = MakeMeaning(StoreWord(word));
			FACT* F = CreateFact(T, verb,object,FACTTRANSIENT);
			AddFact(impliedSet,F);
		}
		else //   dump straight to output buffer, first piece only
		{
			strcpy(buffer,word);
			break;
		}
	}
	impliedSet = impliedWild = ALREADY_HANDLED;	
	return 0;
}

static unsigned int FlagsCode(char* buffer)
{
	WORDP D = FindWord(ARGUMENT(1));
	if (!D) return FAILRULE_BIT;
	sprintf(buffer,"%lld",D->systemFlags);
	return 0;
}

static unsigned int UppercaseCode(char* buffer)
{
	strcpy(buffer, (IsUpperCase(ARGUMENT(1)[0])) ? (char*) "1" : (char*) "0");
	return 0;
}

static unsigned int PropertiesCode(char* buffer)
{
	WORDP D = FindWord(ARGUMENT(1));
	if (!D) return FAILRULE_BIT;
	sprintf(buffer,"%lld",D->properties);
	return 0;
}
static char* NextWord(char* ptr, WORDP& D,bool canon)
{
	char word[MAX_WORD_SIZE];
	ptr = ReadCompiledWord(ptr,word);
	MakeLowerCase(word);
	if (canon)
	{
		WORDP entry,canonical;
		uint64 sysflags = 0;
		uint64 cansysflags = 0;
		GetPosData(0,word,entry,canonical,sysflags,cansysflags); 
		if (canonical) strcpy(word,canonical->word);
		else if (entry) strcpy(word,entry->word);
	}
	MakeLowerCase(word);
	D = StoreWord(word);
	return ptr;
}

static unsigned int IntersectWordsCode(char* buffer)
{
	unsigned int store = (impliedSet == ALREADY_HANDLED) ? 0 : impliedSet;
	SET_FACTSET_COUNT(store,0);
	WORDP words[2000];
	int index = 0;

	char* arg1 = ARGUMENT(1);
	Convert2Blanks(arg1);
	char* at = arg1;
	while ((at = strchr(at,'~'))) *at = ' '; 

	char* arg2 = ARGUMENT(2); 
	Convert2Blanks(arg2);
	at = arg2;
	while ((at = strchr(at,'~'))) *at = ' '; 

	bool canon = (!stricmp(ARGUMENT(3),"canonical"));
	WORDP D;
	while (*arg1)
	{
		arg1 = NextWord(arg1,D,canon);
		AddInternalFlag(D,INTERNAL_MARK);
		words[++index] = D;
	}

	unsigned int count = 0;
	if (index) 
	{
		while (*arg2) 
		{
			arg2 = NextWord(arg2,D,canon);
			if (D->internalBits & INTERNAL_MARK)
			{
				FACT* old = factFree;
				FACT* F = CreateFact(MakeMeaning(D),Mintersect,MakeMeaning(D),FACTTRANSIENT);
				if (old != factFree) 
				{
					AddFact(store,F);
					count = 1;
				}
			}
		}
	
		while (index) RemoveInternalFlag(words[index--],INTERNAL_MARK);
	}

	if (impliedSet == ALREADY_HANDLED && count == 0) return FAILRULE_BIT;
	return 0;
}

static unsigned int JoinCode(char* buffer) 
{     
	char* original = buffer;
	char* ptr = ARGUMENT(1);
	bool autospace = false;
	if (!strnicmp(ptr,"AUTOSPACE",9))
	{
		autospace = true;
		ptr += 10;
	}
    while (ptr)
	{
		char word[MAX_WORD_SIZE];
		char* at = ReadCompiledWord(ptr,word); 
        if (*word == ')' || !*word) break; //   done
		if (*word == '"' && word[1] ==  FUNCTIONSTRING) // compiled code being joined
		{
			ReformatString(buffer,word+2);
			ptr = at;
		}
 		else 
		{
			unsigned int result;
			ptr = ReadShortCommandArg(ptr,word,result);
			if (result & ENDCODES) return result;
			strcpy(buffer,word);
		}
		if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"%s ",buffer);
		bool did = *buffer != 0;
		buffer += strlen(buffer);
		if (autospace && did) *buffer++ = ' '; 
    }
	if (autospace && original != buffer) *--buffer = 0;
	if (trace & TRACE_OUTPUT) Log(STDUSERLOG,") = %s ",original);
 	return 0;
}

static unsigned int POSCode(char* buffer)
{
	char* arg1 = ARGUMENT(1);
	char* arg2 = ARGUMENT(2);
	char* arg3 = ARGUMENT(3);

	if (!stricmp(arg1,"syllable"))
	{
		sprintf(buffer,"%d",ComputeSyllables(arg2));
		return 0;
	}

	if (!stricmp(arg1,"type"))
	{
		if (*arg2 == '~') strcpy(buffer,"concept");
		else if (IsDigit(*arg2)) strcpy(buffer,"number");
		else if (IsAlpha(*arg2)) strcpy(buffer,"word");
		else strcpy(buffer,"unknown");
		return 0;
	}

	if (!stricmp(arg1,"verb"))
	{
		if (!ARGUMENT(2)) return FAILRULE_BIT;
		char word[MAX_WORD_SIZE];
		MakeLowerCopy(word,ARGUMENT(2));
		char* infin = word; 
		if (!stricmp(arg3,"present_participle")) 
		{
			char* use = GetPresentParticiple(word);
			if (!use) return FAILRULE_BIT;
			strcpy(buffer,use);
		}
		else if (!stricmp(arg3,"past_participle")) 
		{
			char* use = GetPastParticiple(word);
			if (!use) return FAILRULE_BIT;
			strcpy(buffer,use);
		}
		else if (!stricmp(arg3,"infinitive")) 
		{
			char* verb = GetInfinitive(word,true);
			strcpy(buffer,verb);
		}
		else if (!stricmp(arg3,"past")) 
		{
			char* past = GetPastTense(infin);
			if (!past) return FAILRULE_BIT;
			strcpy(buffer,past);
		}
		else if (!stricmp(arg3,"match"))
		{
			char* arg4 = ARGUMENT(4);
			WORDP D = FindWord(arg4);
			char* plural = GetPluralNoun(D);
			char* verb;
			if (!plural || stricmp(plural,arg4)) // singular noun
			{
				verb = GetThirdPerson(arg2);
				if (verb)  strcpy(buffer,verb);
			}
			else // plural noun
			{
				verb = GetInfinitive(arg2,false);
				if (verb) 
				{
					if (!stricmp(verb,"be")) strcpy(buffer,"are");
					else strcpy(buffer,verb);
				}
			}
			if (!*buffer) strcpy(buffer,arg2);
		}
		if (IsUpperCase(ARGUMENT(2)[0])) *buffer = toUppercaseData[*buffer];
		return 0;
	}
	else if (!stricmp(arg1,"aux"))
	{
		if (!ARGUMENT(2)) return FAILRULE_BIT;
		char word[MAX_WORD_SIZE];
		MakeLowerCopy(word,ARGUMENT(2));
		char* result = word;
   
		if (!strcmp(arg2,"do")) //   present tense
		{
			if (strcmp(arg3,"I") && strcmp(arg3,"you")) result = "does"; 
			else result = "do";
		}
		else if (!strcmp(arg2,"have")) 
		{
			if (strcmp(arg3,"I") && strcmp(arg3,"you")) result = "has"; 
			else result = "have";
		}
		else if (!strcmp(arg2,"be")) 
		{
			if (!strcmp(arg3,"I") ) result = "am";
			else if (!strcmp(arg3,"you")) result = "are"; 
			else result = "is";
		}
		else if (!strcmp(arg2,"was") || !strcmp(arg2,"were")) //   past tense
		{
			if (!strcmp(arg3,"I") ) result = "was";
			result = "were";
		}
		else result = arg2;
		strcpy(buffer,result);
		if (IsUpperCase(ARGUMENT(2)[0])) *buffer = toUppercaseData[*buffer];
		return 0;
	}
	else if (!stricmp(arg1,"pronoun"))
	{
		if (!stricmp(arg3,"flip"))
		{
			if (!stricmp(arg2,"my")) strcpy(buffer,"your");
			else if (!stricmp(arg2,"your")) strcpy(buffer,"my");
			else if (!stricmp(arg2,"I")) strcpy(buffer,"you");
			else if (!stricmp(arg2,"you")) strcpy(buffer,"I");
			else strcpy(buffer,arg2);
			return 0;
		}
	}
	else if (!stricmp(arg1,"noun"))
	{
		if (!stricmp(arg3,"proper")) 
		{
			// we know the word, use its known casing for spelling
			WORDP D = FindWord(arg2,0,UPPERCASE_LOOKUP);
			if (D)
			{
				strcpy(buffer,D->word);
				return 0;
			}

			// synthesize appropriate casing
			unsigned int n = BurstWord(arg2);
			for (unsigned int i = 0; i < n; ++i)
			{
				char* word = GetBurstWord(i);
				WORDP D = FindWord(word,0,LOWERCASE_LOOKUP);
				if (D && D->properties & LOWERCASE_TITLE); //   allowable particles and connecting words that can be in lower case
				else *word = toUppercaseData[(unsigned char)*word];
				strcat(buffer,word);
				if (i != (n-1)) strcat(buffer," ");
			}
			return 0;
		}
		if (!stricmp(arg3,"lowercaseexist"))	// lower case legal?
		{
			WORDP D = FindWord(arg2,0,LOWERCASE_LOOKUP);
			return (D) ? 0 : FAILRULE_BIT;
		}
		if (!stricmp(arg3,"uppercaseexist"))	// upper case legal?
		{
			WORDP D = FindWord(arg2,0,UPPERCASE_LOOKUP);
			return (D) ? 0 : FAILRULE_BIT;
		}

		char* noun =  GetSingularNoun(arg2,true,false);
		if (!noun) return 0;
		if (!stricmp(arg3,"singular") || (atoi(arg3) == 1 && !strchr(arg3,'.'))) // allow number 1 but not float
		{
			strcpy(buffer,noun);
			return 0;		
		}
		else if (!stricmp(arg3,"plural") || IsDigit(arg3[0]) ) // allow number non-one
		{
			//   swallow the args. for now we KNOW they are wildcard references
			char* plural = GetPluralNoun(StoreWord(noun));
			if (!plural) return 0;
			strcpy(buffer,plural);
			return 0;
		}
		else if (!stricmp(arg3,"irregular") ) // generate a response only if plural is irregular from base (given)
		{
			//   swallow the args. for now we KNOW they are wildcard references
			char* plural = GetPluralNoun(StoreWord(noun));
			if (!plural) return 0;
			size_t len = strlen(noun);
			if (strnicmp(plural,noun,len)) strcpy(buffer,plural); // show plural when base not in it
			return 0;
		}
	}
	else if (!stricmp(arg1,"determiner")) //   DETERMINER noun
	{
		size_t len = strlen(arg2);
		if (arg2[len-1] == 'g' && GetInfinitive(arg2,false)) //   no determiner on gerund
		{
			strcpy(buffer,arg2);
			return 0;
		}
		//   already has one builtinto the word or phrase
		if (!strnicmp(arg2,"a_",2) || !strnicmp(arg2,"an_",3) || !strnicmp(arg2,"the_",4)) 
		{
			strcpy(buffer,arg2);
			return 0;
		}

		WORDP D = FindWord(arg2);
		if (D && D->properties & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL))  //no determiner, is mass or proper name
		{
			strcpy(buffer,arg2);
			return 0;
		}

		//   if a plural word, use no determiner
		char* s = GetSingularNoun(arg2,true,false);
		if (!s || stricmp(arg2,s)) //   if has no singular or isnt same, assume we are plural and add the
		{
			sprintf(buffer,"the %s",arg2);
			return 0;
		}

		//   provide the determiner now
		*buffer++ = 'a';
		*buffer = 0;
		if (IsVowel(*arg2)) *buffer++ = 'n'; //   make it "an"
		*buffer++ = ' ';	//   space before the word
		strcpy(buffer,arg2);
		return 0;
	}
	else if (!stricmp(arg1,"place"))
	{
		int value = (int)Convert2Integer(arg2);
		if ((value%10) == 1) sprintf(buffer,"%dst",value); 
		if ((value%10) == 2) sprintf(buffer,"%dnd",value);
		if ((value%10) == 3) sprintf(buffer,"%drd",value);
		else sprintf(buffer,"%dth",value);
		return 0;
	}
	else if (!stricmp(arg1,"capitalize") || !stricmp(arg1,"uppercase"))
	{
		strcpy(buffer,arg2);
		*buffer = toUppercaseData[*buffer];
		return 0;
	}
	else if (!stricmp(arg1,"lowercase"))
	{
		MakeLowerCopy(buffer,arg2);
		return 0;
	}
	else if (!stricmp(arg1,"canonical"))
	{
		WORDP entry,canonical;
		uint64 sysflags = 0;
		uint64 cansysflags = 0;
		GetPosData(0,arg2,entry,canonical,sysflags,cansysflags);
		if (canonical) strcpy(buffer,canonical->word);
		else if (entry) strcpy(buffer,entry->word);
		else strcpy(buffer,arg2);
		return 0;
	}

	else if (!stricmp(arg1,"integer"))
	{
		strcpy(buffer,arg2);
		char* period = strchr(arg2,'.');
		if (period)
		{
			float val = (float) atof(arg2);
			*period = 0;
			int vali = atoi(arg2);
			if ((float) vali == val) strcpy(buffer,arg2);
		}
		return 0;
	}
	return FAILRULE_BIT;
}

static unsigned int RhymeCode(char* buffer) 
{   
	char letter = ARGUMENT(1)[0];
	for (char i = 'a'; i <= 'z'; ++i)
	{
		if (i == letter || (i - 'a' + 'A') == letter) continue;    // don't repeat his word
		ARGUMENT(1)[0] = i;
		if (FindWord(ARGUMENT(1))) 
		{
			strcpy(buffer,ARGUMENT(1));
			break;
		}
	}
	return 0;
}

static unsigned int SubstituteCode(char* buffer) 
{ 
	bool wordMode = toLowercaseData[*ARGUMENT(1)] != 'c'; // is word or character

	// adjust substitution value
	char* substituteValue = ARGUMENT(4);
	size_t substituteLen = strlen(substituteValue);
	if (substituteLen > 1 && *substituteValue == '"' && substituteValue[substituteLen-1] == '"') // quoted expression means use the interior of it
	{
		substituteValue[substituteLen-1] = 0; 
		++substituteValue;
		substituteLen -= 2; 
	}
	Convert2Blanks(substituteValue);

	// what to search in
	char copy[MAX_WORD_SIZE * 4];
	*copy = ' '; // protective leading blank for -1 test
	strcpy(copy+1,ARGUMENT(2));
	char* target = copy+1;
	if (!*target) return FAILRULE_BIT; 

	// find value
	char* find = ARGUMENT(3);
  	if (!*find) return FAILRULE_BIT;
	size_t findLen = strlen(find);
	if (findLen > 1 && *find == '"' && find[findLen-1] == '"') // find of a quoted thing means use interior
	{
		find[findLen-1] = 0; 
		++find;
		findLen -= 2; 
	}

    char* found;
	bool changed = false;
	while ((found = strstr(target,find))) // case sensitive
    {
		// no partial matches
		if (wordMode)
		{
			char c = found[findLen];	
			if (IsAlphaOrDigit(c) || IsAlphaOrDigit(*(found-1))) // skip nonword match
			{
				target = found + findLen;
				continue;
			}
		}
		changed = true;

		// move the before
		size_t offset = found-target;
		strncpy(buffer,target,offset);   //   copy up to but not including pattern.
        buffer += offset;
        target += offset + findLen;

		// copy the replacement
		strcpy(buffer,substituteValue);
		buffer += substituteLen;
		*buffer = 0;
	}
	strcpy(buffer,target); // append the rest

	// check for FAIL request
	char* notify = ARGUMENT(5);
	if (*notify || impliedIf != ALREADY_HANDLED) return (changed) ? 0 : FAILRULE_BIT; // if user wants possible failure result
	return 0;
}

static void SpellOne(WORDP D, uint64 data)
{
	char* match = (char*) data;
	if (FACTSET_COUNT(spellSet) >= 500) return; //   limit

	if (!(D->properties & (NOUN | VERB | ADJECTIVE | ADVERB | DETERMINER_BITS | PRONOUN_BITS | CONJUNCTION_BITS | PREPOSITION | AUX_VERB ))) return;
	if (D->word && !IsAlpha(*D->word)) return;
	if (D->properties & (NOUN_PROPER_SINGULAR | NOUN_PROPER_PLURAL | NOUN_TITLE_OF_ADDRESS)) return;	// want ordinary words
	if (strchr(D->word,'_') ) return; // only normal words and not multi words either
	if (MatchesPattern(D->word,match))
	{
		WORDP E = StoreWord("1");
		AddFact(spellSet,CreateFact(MakeMeaning(E,0),MakeMeaning(FindWord("word")),MakeMeaning(D,0),FACTTRANSIENT));
	}
}

static unsigned int  Spell(char* match, unsigned int set)
{
	char pattern[MAX_WORD_SIZE];
	SET_FACTSET_COUNT(set,0);
	if (match[1] == '-') match[1] = 0;	// change 4-letter to 4
	MakeLowerCopy(pattern,match);
	spellSet = set;
	WalkDictionary(SpellOne,(uint64)pattern);
    return FACTSET_COUNT(set);
}

static unsigned int SpellCode(char* buffer) //- locates up to 100 words in dictionary matching pattern and stores them as facts in @0
{
#ifdef INFORMATION
Fails if no words are found. Words must begin with a letter and be marked as a part of speech
(noun,verb,adjective,adverb,determiner,pronoun,conjunction,prepostion).

Not all words are found in the dictionary. The system only stores singular nouns and base
forms of verbs, adverbs, and adjectives unless it is irregular.

Pattern is a sequence of characters, with * matching 0 or more characters and . matching
exactly one. Pattern must cover the entire string. Pattern may be prefixed with a number, which
indicates how long the word must be. E.g.

^spell("4*")	# retrieves 100 4-letter words
^spell("3a*")  # retrieves 3-letter words beginning with "a"
^spell("*ing") # retrieves words ending in "ing" 
#endif

	return (Spell(ARGUMENT(1),0)) ? 0 : FAILRULE_BIT;
}

static unsigned int SexedCode(char* buffer)
{
	WORDP D = FindWord(ARGUMENT(1));
	if (!D || !(D->properties & (NOUN_HE|NOUN_SHE))) strcpy(buffer,ARGUMENT(4)); //   it 
	else if (D->properties & NOUN_HE) strcpy(buffer,ARGUMENT(2)); //   he
	else strcpy(buffer,ARGUMENT(3)); //   she
	return 0;
}


//////////////////////////////////////////////////////////
/// DICTIONARY
//////////////////////////////////////////////////////////

static unsigned int GetPropertyCodes(char* who,char* ptr, uint64 &val, uint64 &sysval)
{
	while (ptr && *ptr)
	{
		char arg[MAX_WORD_SIZE];
		ptr = ReadCompiledWord(ptr,arg);
		if (!*arg || *arg == ')') break;
		if (!stricmp(arg,"CONCEPT")) 
		{
			if (*who != '~') return FAILRULE_BIT; // must be a concept name
			sysval = CONCEPT;
		}
	
		// fact marks
		else if (IsDigit(arg[0])) ReadInt64(arg,(int64&)sysval);
		else 
		{
			uint64 bits = FindValueByName(arg);
			if (bits) val |= bits;
			else {
				bits = FindValue2ByName(arg);
				if (!bits) 
					Log(STDUSERLOG,"Unknown addproperty value %s\r\n",arg);
				else sysval |= bits;
			}
		}
	}
	return (!sysval && !val) ? FAILRULE_BIT : 0;
}

static unsigned int AddPropertyCode(char* buffer)
{
	char* ptr = ARGUMENT(1);
	char arg1[MAX_WORD_SIZE];
	unsigned int result = 0;
	if (*ptr == '@') ptr = ReadCompiledWord(ptr,arg1); // dont eval a set
	else ptr = ReadCommandArg(ptr,arg1,result,OUTPUT_NOQUOTES|OUTPUT_EVALCODE|OUTPUT_NOTREALBUFFER);
	if (result) return result;
	if (!*arg1) return FAILRULE_BIT;
	WORDP D = NULL;
	unsigned int store = 0;
	unsigned int count = 0;
	if (*arg1 == '@') // add property to all facts in set either on a field or fact as a whole
	{
		store = GetSetID(arg1);
		count =  FACTSET_COUNT(store);
	}
	else  D = StoreWord(arg1,0); // add property to dictionary word
	char arg3 = *GetSetType(arg1);

	uint64 val = 0;
	uint64 sysval = 0;
	result = GetPropertyCodes(arg1,ptr,val,sysval);
	if (result) return result;
	if (D) // add to dictionary entry
	{
		if (sysval & (TOPIC|SUBSTITUTE_RECIPIENT|FUNCTION_NAME|FUNCTION_BITS)) return FAILRULE_BIT; // not allowed - nor are functions etc
		if (val & NOUN_SINGULAR && D->internalBits & UPPERCASE_HASH) //make it right
		{
			val ^= NOUN_SINGULAR;
			val |= NOUN_PROPER_SINGULAR;
		}
		AddProperty(D,val);
		AddSystemFlag(D,sysval);
		if (sysval & CONCEPT) AddInternalFlag(D,buildID);
	}
	else if (*arg1 == '@') // add to all properties of fact set
	{
		for (unsigned int i = 1; i <= count; ++i)
		{
			FACT* F = factSet[store][i];
			if (arg3 == 's') D = Meaning2Word(F->subject); 
			else if (arg3 == 'v') D = Meaning2Word(F->verb);
			else if (arg3 == 'o') D = Meaning2Word(F->object);
			else
			{
				F->flags |= val;
				if (trace & TRACE_INFER) TraceFact(F);
			}
			if (D)
			{
				uint64 val1 = val;
				if (val1 & NOUN_SINGULAR && D->internalBits & UPPERCASE_HASH) //make it right
				{
					val1 ^= NOUN_SINGULAR;
					val1 |= NOUN_PROPER_SINGULAR;
				}
				AddProperty(D,val1);
				AddSystemFlag(D,sysval);
				if (trace & TRACE_INFER) Log(STDUSERLOG," %s\n",D->word);
			}
		}
	}
	return 0;
}

static unsigned int DefineCode(char* buffer)
{ 
	char* w = ARGUMENT(1);
	WORDP D = FindWord(w,0);
	if (!D) return 0;

	bool noun = false;
	bool verb = false;
	bool adjective = false;
	bool adverb = false;
	char* which = ARGUMENT(2);
	for (unsigned int i = 1; i <= GetMeaningCount(D); ++i)
	{
		MEANING T = GetMaster(GetMeaning(D,i)) | (GetMeaning(D,i) & TYPE_RESTRICTION);
		unsigned int index = Meaning2Index(T);
		WORDP E = Meaning2Word(T);
		char* gloss = GetGloss(E,index);
		if (gloss && T & NOUN && !noun && (!*which || !stricmp(which,"NOUN")))
		{
			if (verb) sprintf(buffer,"As a noun it means %s. ",gloss);
			else sprintf(buffer,"As a noun, %s means %s. ",ARGUMENT(1),gloss);
			buffer += strlen(buffer);
			noun = true;
        }
		else if (gloss && T & VERB && !verb && (!*which || !stricmp(which,"VERB")))
		{
			if (noun) sprintf(buffer,"As a verb it means %s. ",gloss);
			else sprintf(buffer,"As a verb, %s means %s. ",ARGUMENT(1),gloss);
			buffer += strlen(buffer);
			verb = true;
        }
		else if (gloss && T & ADJECTIVE && !noun && !verb && !adjective && (!*which  || !stricmp(which,"ADJECTIVE")))
		{
			sprintf(buffer,"As an adjective, %s means %s. ",ARGUMENT(1),gloss);
			buffer += strlen(buffer);
			adjective = true;
        }
 		else if (gloss && T & ADVERB && !adverb && !noun && !verb && !adjective && (!*which  || !stricmp(which,"ADVERB")))
		{
			sprintf(buffer,"As an adverb, %s means %s. ",ARGUMENT(1),gloss);
			buffer += strlen(buffer);
			adverb = true;
        }
	}
    return 0;
}

static void ArgFlags(uint64& properties, uint64& flags)
{
	properties = FindValueByName(ARGUMENT(2));
	properties |= FindValueByName(ARGUMENT(3));
	properties |= FindValueByName(ARGUMENT(4));
	properties |= FindValueByName(ARGUMENT(5));
	properties |= FindValueByName(ARGUMENT(6));

	flags = FindValue2ByName(ARGUMENT(2));
	flags |= FindValue2ByName(ARGUMENT(3));
	flags |= FindValue2ByName(ARGUMENT(4));
	flags |= FindValue2ByName(ARGUMENT(5));
	flags |= FindValue2ByName(ARGUMENT(6));
}

static unsigned int HasAnyPropertyCode(char* buffer)
{
	WORDP D = FindWord(ARGUMENT(1));
	if (!D) return FAILRULE_BIT;
	uint64 properties;
	uint64 flags;
	ArgFlags(properties,flags);
	return (D->properties & properties || D->systemFlags & flags) ? 0 : FAILRULE_BIT;
}

static unsigned int HasAllPropertyCode(char* buffer)
{
	WORDP D = FindWord(ARGUMENT(1));
	if (!D) return FAILRULE_BIT;
	uint64 properties;
	uint64 flags;
	ArgFlags(properties,flags);
	if (!flags && !properties) return FAILRULE_BIT;
	return ((D->properties & properties) == properties && (D->systemFlags & flags) == flags) ? 0 : FAILRULE_BIT; // has all the bits given
}

static unsigned int RemovePropertyCode(char* buffer)
{
	char* ptr = ARGUMENT(1);
	char arg1[MAX_WORD_SIZE];
	unsigned int result = 0;
	if (*ptr == '@') ptr = ReadCompiledWord(ptr,arg1); // dont eval a set
	else ptr = ReadCommandArg(ptr,arg1,result,OUTPUT_NOQUOTES|OUTPUT_EVALCODE|OUTPUT_NOTREALBUFFER);
	if (result) return result;
	char arg3 = *GetSetType(arg1);
	if (!*arg1) return FAILRULE_BIT;
	WORDP D = NULL;
	unsigned int store = 0;
	unsigned int count = 0;
	if (*arg1 == '@') 
	{
		store = GetSetID(arg1);
		count = FACTSET_COUNT(store);
	}
	else  D = StoreWord(arg1,0); 

	uint64 val = 0;
	uint64 sysval = 0;
	result = GetPropertyCodes(arg1,ptr,val,sysval);
	if (result) return result;
	if (D) // remove to dictionary entry
	{
		RemoveProperty(D,val);
		RemoveSystemFlag(D,sysval);
	}
	else // remove to all properties of set
	{
		for (unsigned int i = 1; i <= count; ++i)
		{
			FACT* F = factSet[store][i];
			if (arg3 == 's') D = Meaning2Word(F->subject);
			else if (arg3 == 'v') D = Meaning2Word(F->verb);
			else if (arg3 == 'o') D = Meaning2Word(F->object); 
			else  
			{
				F->flags &= -1 ^ val;
				if (trace & TRACE_INFER) TraceFact(F);
			}
			if (D)
			{
				RemoveProperty(D,val);
				RemoveSystemFlag(D,sysval);
				if (trace & TRACE_INFER) Log(STDUSERLOG," %s\n",D->word);
			}
		}
	}
	return 0;
}


//////////////////////////////////////////////////////////
/// MULTIPURPOSE
//////////////////////////////////////////////////////////

static unsigned int DisableCode(char* buffer) 
{
	char* arg1 = ARGUMENT(1);
	char* arg2 = ARGUMENT(2);
	if (!stricmp(arg1,"topic"))
	{
		if (!*arg2) return FAILRULE_BIT;
		int id = FindTopicIDByName(ARGUMENT(2));
		if (id) 
		{
			if (GetTopicFlags(id) & TOPIC_SYSTEM) return FAILRULE_BIT;
			if (!(GetTopicFlags(id) & TOPIC_BLOCKED)) AddTopicFlag(id,TOPIC_BLOCKED|TOPIC_USED);
			return 0;       
		}
	}
	else if (!stricmp(arg1,"rule")) // 1st one found
	{
		if (planning) return FAILRULE_BIT;
		int id = 0;
		unsigned int topic = currentTopicID;
		bool fulllabel;
		bool crosstopic;
		char* rule;
		char* dot = strchr(arg2,'.');
		if (dot && IsDigit(dot[1])) rule = GetRuleTag(topic,id,arg2);
		else rule = GetLabelledRule(topic,arg2,"",fulllabel,crosstopic,id);
		if (!rule) return FAILRULE_BIT;
		SetRuleDisableMark(topic,id);
		return 0;
	}
	else if (!stricmp(arg1,"rejoinder"))
	{
		outputRejoinderRuleID = NO_REJOINDER;
		return 0;
	}
	return FAILRULE_BIT;
}

static unsigned int EnableCode(char* buffer)
{
	char* arg2 = ARGUMENT(2);
	if (!stricmp(ARGUMENT(1),"topic"))
	{
		 //   topic name to enable
		if (!*arg2) return FAILRULE_BIT;
		if (!stricmp(arg2,"all"))
		{
			unsigned int start = 0;
			while (++start <= lastTopic) 
			{
				if (GetTopicFlags(start) & TOPIC_SYSTEM) continue;
				RemoveTopicFlag(start,TOPIC_BLOCKED);
			}
			return 0;
		}
		int id = FindTopicIDByName(arg2);
		if (!id) return FAILRULE_BIT;
		if (GetTopicFlags(id) & TOPIC_SYSTEM) return FAILRULE_BIT;
		RemoveTopicFlag(id,TOPIC_BLOCKED);
		return 0;
	}
	else if (!stricmp(ARGUMENT(1),"rule")) 
	{
		if (planning) return FAILRULE_BIT;
		int id = 0;
		unsigned int topic = currentTopicID;
		bool fulllabel;
		bool crosstopic;
		char* rule;
		char* dot = strchr(arg2,'.');
		if (dot && IsDigit(dot[1])) rule = GetRuleTag(topic,id,arg2);
		else rule = GetLabelledRule(topic,arg2,ARGUMENT(3),fulllabel,crosstopic,id);
		if (!rule) return FAILRULE_BIT;
		UndoErase(rule,topic,id);
		AddTopicFlag(topic,TOPIC_USED); 
		return 0;
	}
	return FAILRULE_BIT;
}

static unsigned int LengthCode(char* buffer)
{
	char* word = ARGUMENT(1);
	if (*word == '@') 
	{
		unsigned int store = GetSetID(word);
		unsigned int count = FACTSET_COUNT(store);
		sprintf(buffer,"%d",count);
	}
	else if (*word == '~') // how many top level members in set
	{
		WORDP D = FindWord(word,0);
		if (!D) return FAILRULE_BIT;
		int count = 0;
		FACT* F = GetObjectHead(D);
		while (F)
		{
			if (F->verb == Mmember) ++count;
			F = GetObjectNext(F);
		}
		sprintf(buffer,"%d",count);
	}
	else sprintf(buffer,"%d",(int)strlen(ARGUMENT(1)));
	return 0;
}

static unsigned int NextCode(char* buffer)
{
	char word[MAX_WORD_SIZE];
	char* ptr = ReadCompiledWord(ARGUMENT(1),word);
	char* arg1 = ARGUMENT(1); // GAMBIT or RESPONDER or RULE OR FACT or INPUT
	if (!stricmp(word,"FACT")) 
	{
		strcpy(ARGUMENT(1),ptr);
		return FLR(buffer,'n');
	}
	if (!stricmp(word,"INPUT"))
	{
		SAVEOLDCONTEXT()
		*buffer = 0;
		while (ALWAYS) // revise inputs until prepass doesnt change them
		{
			if (!*nextInput) return FAILRULE_BIT;
			PrepareSentence(nextInput,true,true);
			if (!wordCount && (*nextInput | (responseIndex != 0))) // ignore this input
			{
				RESTOREOLDCONTEXT()
				return 0; 
			}
			if (!PrepassSentence(GetUserVariable("$prepass"))) break; // it was quiet
		}
 		if (!wordCount) return FAILRULE_BIT;
		++inputSentenceCount; //  sentence id of volley has moved on
		RESTOREOLDCONTEXT()
	}
	else  // gambit, responder, rule, REJOINDER
	{
		static char prior[MAX_WORD_SIZE];

		if (*ptr == '~' && !ptr[1]) strcpy(ptr,prior);
		bool gambit = (*arg1 == 'G' || *arg1 == 'g');
		bool responder = !stricmp(arg1,"responder");
		bool rejoinder = !stricmp(arg1,"rejoinder");
		unsigned int topic = currentTopicID;
		int id;
		bool fulllabel = false;
		bool crosstopic = false;
		char* rule;
		char* dot = strchr(ptr,'.');
		if (dot && IsDigit(dot[1])) rule = GetRuleTag(topic,id,ptr);
		else rule = GetLabelledRule(topic,ptr,ARGUMENT(3),fulllabel,crosstopic,id);
		if (!rule) return FAILRULE_BIT; // unable to find labelled rule 

		char* data = rule;
		while (data)
		{
			data = FindNextRule( (gambit || responder) ? NEXTTOPLEVEL : NEXTRULE,data,id);
			if (!data || !*data) break;
		
			if (gambit && TopLevelGambit(data)) break;
			else if (responder &&  (TopLevelStatement(data) || TopLevelQuestion(data))) break; 
			else if (rejoinder && Rejoinder(data)) break;
			else if (rejoinder) return FAILRULE_BIT;	// no more rejoinders
			else if (!gambit && !responder && !rejoinder) break;	// any next rule
		}
		if (!data || !*data) return FAILRULE_BIT;
		sprintf(buffer,"%s.%d.%d",GetTopicName(topic),TOPLEVELID(id),REJOINDERID(id));
		strcpy(prior,buffer);	// able to iterate easily
	}
	return 0;
}

static unsigned int FLRCodeR(char* buffer)
{
	char* word = ARGUMENT(1);
	char arg[MAX_WORD_SIZE];
	ReadCompiledWord(word,arg);
	word = arg;
	if (*word == '$') word = GetUserVariable(word);
	else if (*word == '_') word =  GetwildcardText(GetWildcardID(word), true);

	if (*word == '@') return FLR(buffer,'r');
	else if (*word == '~')  return RandomMember(buffer,word);
	else return FAILRULE_BIT;
}

static unsigned int ResetCode(char* buffer)
{
	char* word = ARGUMENT(1);
	if (!stricmp(word,"USER"))
	{
		if (planning) return FAILRULE_BIT;
		ResetUser(buffer);
#ifndef DISCARDTESTING
		wasCommand = false;	// lie so system will save revised user file
#endif
		return ENDINPUT_BIT;
	}
	else if (!stricmp(word,"TOPIC"))
	{
		word = ARGUMENT(2);
		unsigned int topic;
		if (*word == '*' && word[1] == 0) // all topics
		{
			if (!all) ResetTopics(); 
		}
		else if ((topic = FindTopicIDByName(word))) ResetTopic(topic);
		else return FAILRULE_BIT;
		return 0;
	}
	else if (*word == '@') // reset a fact set for browsing sequentially
	{
		unsigned int store = GetSetID(word);
		factSetNext[store] = 0;
		if (trace) Log(STDUSERLOG," @%d[%d] ",store,FACTSET_COUNT(store));
		return 0;
	}
	return FAILRULE_BIT;
}

//////////////////////////////////////////////////////////
/// EXTERNAL ACCESS
//////////////////////////////////////////////////////////

static unsigned int ExportFactCode(char* buffer)
{
	char* set = ARGUMENT(2);
	if (*set != '@') return FAILRULE_BIT;
	// optional 3rd argument is append or overwrite
	char* append = ARGUMENT(3);
	return (ExportFacts(ARGUMENT(1),GetSetID(set),append)) ? 0 : FAILRULE_BIT;
}

static unsigned int ImportFactCode(char* buffer)
{
	return (ImportFacts(ARGUMENT(1),ARGUMENT(2),ARGUMENT(3),ARGUMENT(4))) ? 0 : FAILRULE_BIT;
}

#ifdef JUNK
#ifdef WIN32
#pragma comment(lib,"Winmm.lib");
#endif
static unsigned int PlaySoundCode(char* buffer)
{
	char word[MAX_WORD_SIZE];
	ReadCompiledWord(buffer,word);
#ifdef WIN32
	mciSendString("open output.wma type mpegvideo alias myFile", NULL, 0, 0);  
	mciSendString("play myFile", NULL, 0, 0);  
#endif
	return 0;
}
#endif

static unsigned int PopenCode(char* buffer)
{
	char   psBuffer[MAX_WORD_SIZE];
	FILE   *pPipe;
	char arg[MAX_WORD_SIZE];
	char fn[MAX_WORD_SIZE];
	unsigned int result;
	char* function = ReadCommandArg(ARGUMENT(1),arg,result,OUTPUT_NOQUOTES|OUTPUT_EVALCODE|OUTPUT_NOTREALBUFFER); 
	ReadCommandArg(function,fn,result,OUTPUT_NOQUOTES|OUTPUT_EVALCODE|OUTPUT_NOTREALBUFFER); 

	// convert \" to " within params
	char* fix;
	while ((fix = strchr(arg,'\\'))) memmove(fix,fix+1,strlen(fix)); // remove protective backslash
	
	// adjust function reference name
	function = fn;
	if (*function == '\'') ++function; // skip over the ' 

#ifdef WIN32
   if( (pPipe = _popen(arg,"rb")) == NULL ) return FAILRULE_BIT; //  "dir *.c /on /p", "rt" 
#else
   if( (pPipe = popen(arg,"rb")) == NULL ) return FAILRULE_BIT; 
#endif
   psBuffer[0] = '(';
   psBuffer[1] = ' ';
   psBuffer[2] = '"'; // stripable string marker
   psBuffer[3] = '`'; // stripable string marker
   while( !feof( pPipe ) )
   {
		psBuffer[4] = 0;
		if( fgets( psBuffer+4, MAX_WORD_SIZE - 5, pPipe ) != NULL )
		 {
			unsigned int result;
			char* p;
			while ((p = strchr(psBuffer,'\r'))) *p = ' ';
			while ((p = strchr(psBuffer,'\n'))) *p = ' ';
			strcat(psBuffer,"`\" )"); // trailing quote and ending paren
			DoFunction(function,psBuffer,buffer,result); 
			buffer += strlen(buffer);
		}
   }
#ifdef WIN32
   _pclose( pPipe );
#else
   pclose( pPipe );
#endif
   return 0;
}

static unsigned int TCPOpenCode(char* buffer)
{
#ifdef INFORMATION
// POST http://de.sempar.ims.uni-stuttgart.de/parse HTTP/1.1
// Accept: text/html, application/xhtml+xml, */*
// Host: de.sempar.ims.uni-stuttgart.de
// Content-Type: application/x-www-form-urlencoded
// Content-Length: 31
//
// sentence=ich+bin&returnType=rdf

// e.g.  TCPOpen(POST "http://de.sempar.ims.uni-stuttgart.de/parse" "sentence=ich+bin&returnType=rdf" 'myfunc)
#endif

#ifdef DISCARDTCPOPEN
	return FAILRULE_BIT;
#else
	char url[MAX_WORD_SIZE];
	char directory[MAX_WORD_SIZE];
	char arg[MAX_WORD_SIZE];
	char fn[MAX_WORD_SIZE];
	char kind = 0;
	unsigned int result;

	char* ptr = ReadCompiledWord(ARGUMENT(1),url);
	if (!stricmp(url,"POST")) kind = 'P';
	else if (!stricmp(url,"GET")) kind = 'G';
	else return FAILRULE_BIT;

	ptr = ReadCommandArg(ptr,url,result,OUTPUT_NOQUOTES|OUTPUT_EVALCODE|OUTPUT_NOTREALBUFFER); 
	char* dot = strchr(url,'.');
	if (!dot) return FAILRULE_BIT;
	char* slash = strchr(dot,'/');
	if (slash) 
	{
		*slash = 0;
		strcpy(directory,slash+1);
	}
	else *directory = 0;
	ptr = ReadCommandArg(ptr,arg,result,OUTPUT_NOQUOTES|OUTPUT_EVALCODE|OUTPUT_NOTREALBUFFER); 
	ReadCommandArg(ptr,fn,result,OUTPUT_NOQUOTES|OUTPUT_EVALCODE|OUTPUT_NOTREALBUFFER); 

	// convert \" to " within params
	char* fix;
	while ((fix = strchr(arg,'\\'))) memmove(fix,fix+1,strlen(fix)); // remove protective backslash
	
	// adjust function reference name
	char* function = fn;
	if (*function == '\'') ++function; // skip over the ' 

	unsigned int port = 0;
	if (kind == 'P' || kind == 'G') port = 80;
	else
	{
		char* colon = strchr(url,':');
		if (colon)
		{
			*colon = 0;
			port = atoi(colon+1);
		}
	}
	int size = 0;
	char* tcpbuffer = AllocateBuffer();
	char* startContent = tcpbuffer;
	size_t len;
	try 
	{
		if (trace & TRACE_TCP) Log(STDUSERLOG,"TCP: %s %d %c %s",url,port,kind,arg);
		TCPSocket *sock = new TCPSocket(url, (unsigned short)port);
		if (kind == 'P')
		{
			if (*directory) sprintf(tcpbuffer,"POST /%s HTTP/1.1\r\n",directory);
			else sprintf(tcpbuffer,"POST HTTP/1.1\r\n");
			len = strlen(tcpbuffer);
			sock->send(tcpbuffer, len );
		}
		else if (kind == 'G')
		{
			sprintf(tcpbuffer,"GET %s?%s HTTP/1.1\r\n",directory,arg);
			len = strlen(tcpbuffer);
			sock->send(tcpbuffer, len );
		}

		strcpy(tcpbuffer,"Accept: text/html, application/xhtml+xml, */*\r\n");
		len = strlen(tcpbuffer);
		sock->send(tcpbuffer, len );

		sprintf(tcpbuffer,"Host: %s\r\n",url);
		len = strlen(tcpbuffer);
		sock->send(tcpbuffer, len );

		if (kind == 'P')
		{
			len = strlen(arg);
			sprintf(tcpbuffer,"Content-Type: application/x-www-form-urlencoded\r\nContent-Length: %d\r\n\r\n%s\r\n",(unsigned int) len,arg);
			len = strlen(tcpbuffer);
			sock->send(tcpbuffer, len );
		}

		unsigned int bytesReceived = 1;              // Bytes read on each recv()
		unsigned int totalBytesReceived = 0;         // Total bytes read
		char* base = tcpbuffer;
		*base = 0;
		bool hasContent = false;
		int allowedBytes = maxBufferSize - 10;
		while (bytesReceived > 0) 
		{
			// Receive up to the buffer size bytes from the sender
			bytesReceived = sock->recv(base, allowedBytes);
			allowedBytes -= bytesReceived;
			totalBytesReceived += bytesReceived;
			base += bytesReceived;
			if (!hasContent && (kind == 'P' || kind == 'G' ) ) // std POST/GET http formats
			{
				startContent = strstr(tcpbuffer,"\r\n\r\n"); // body separator
				if (!startContent) continue; // not found yet
				startContent += 4;

				char* len = strstr(tcpbuffer,"Content-length: "); // look for earlier size info
				char* at = SkipWhitespace(len+16);
				size = atoi(at); // size of body

				hasContent = true;
			}
			if (hasContent && (base-startContent) >= size) break;	// we have enough
		}
		delete(sock);
		*base++ = 0;
		*base++ = 0;
		// chatbot replies this
		Log(STDUSERLOG,"tcp received: %d %s",totalBytesReceived,tcpbuffer);
	}
	catch(SocketException e) { Log(STDUSERLOG,"failed to connect to server %s %d\r\n",url,port); FreeBuffer(); return FAILRULE_BIT;}

	// process http return for validity
	if (kind == 'P' || kind == 'G')
	{
		if (strnicmp(tcpbuffer,"HTTP",4)) return FAILRULE_BIT;
		char* space = strchr(tcpbuffer,' ');
		space = SkipWhitespace(space);	// go to end of whitespace
		if (trace & TRACE_TCP) Log(STDUSERLOG,"response: %s",space);
		if (*space != '2') return FAILRULE_BIT;	// failure code of some kind
	}
	
	userRecordSourceBuffer = startContent;
	char* buf1 = AllocateBuffer();
	buf1[0] = '(';
	buf1[1] = ' ';
	buf1[2] = '"'; // strippable string marker
	buf1[3] = '`'; // strippable string marker
	result = 0;
	while (!result)
	{
		if (!ReadALine(buf1+4,0)) break;
		if (!buf1[4]) continue;		// no content
		char* actual = TrimSpaces(buf1);
		strcat(actual,"`\" )"); // trailing quote and ending paren
		DoFunction(function,actual,buffer,result); 
		buffer += strlen(buffer);
   }
   FreeBuffer();
   FreeBuffer();
   return result;
#endif
}

static unsigned int SystemCode(char* buffer)
{
	char word[MAX_WORD_SIZE];
	*word = 0;
	int j = 0;
	while (*ARGUMENT(++j))
	{
		char* arg = ARGUMENT(j);
		strcat(word,arg);
		strcat(word," ");
	}
	sprintf(buffer,"%d",system(word));
	return  0;
}

//////////////////////////////////////////////////////////
/// FACTS
//////////////////////////////////////////////////////////

static unsigned int CreateFactCode(char* buffer)
{ 
	currentFact = NULL;
	char* arg = ARGUMENT(1);
	EatFact(arg); // PUTS NOTHING IN THE OUTPUT BUFFER but can be assigned from.
	return (currentFact) ? 0 : FAILRULE_BIT;
}

static unsigned int CreateAttributeCode(char* buffer)
{ 
	currentFact = NULL;
	EatFact(ARGUMENT(1),0,true);
	if (currentFact && !(currentFact->flags & FACTATTRIBUTE)) return FAILINPUT_BIT;	// kill the whole line.
	return (currentFact) ? 0 : FAILRULE_BIT; // fails if pre-existing fact cant be killed because used in fact
}

static unsigned int DeleteCode(char* buffer) //   delete all facts in collection
{
	int store = GetSetID(ARGUMENT(1));
	unsigned int count = FACTSET_COUNT(store);
	for (unsigned int i = 1; i <= count; ++i) KillFact(factSet[store][i]);
	return 0;
}

static unsigned int FlushFactsCode(char* buffer) // delete all facts after this one (presuming sentence failed)
{
	if (planning) return FAILRULE_BIT; // dont allow this in planner

	unsigned int f = atoi(ARGUMENT(1)); 
	FACT* F = factFree;
	if (f > Fact2Index(F)) return FAILRULE_BIT;
	while (Fact2Index(F) > f)
	{
		F->flags |= FACTDEAD;	// kill it. dont have to do it recursive (KillFact) because everything that might be using this is already killed by this loop
		--F;
	}
	return 0;
}

static unsigned int FieldCode(char* buffer) 
{	
	FACT* F;
	char* word = ARGUMENT(1);
	char word1[MAX_WORD_SIZE];
	if (*word == '@') return FAILRULE_BIT;
	F = FactTextIndex2Fact(word); 
	if (!F || F > factFree) return FAILRULE_BIT;

	WORDP xxs = Meaning2Word(F->subject); // for debugging
	WORDP xxv = Meaning2Word(F->verb);  // for debugging
	WORDP xxo = Meaning2Word(F->object);  // for debugging
	char* arg2 = ARGUMENT(2);
	if (*arg2 == 's' || *arg2 == 'S') 
	{
		if (F->flags & FACTSUBJECT) 
		{
			if (*arg2 == 's') sprintf(buffer,"%d",F->subject);
			else strcpy(buffer,WriteFact(Index2Fact(F->subject),false,word1,false,false));
		}
		else strcpy(buffer,WriteMeaning(F->subject));
	}
	else if (*arg2 == 'v' || *arg2 == 'V') 
	{
		if (F->flags & FACTVERB) 
		{
			if (*arg2 == 'v') sprintf(buffer,"%d",F->verb);
			else strcpy(buffer,WriteFact(Index2Fact(F->verb),false,word1,false,false));
		}
		else strcpy(buffer,WriteMeaning(F->verb));
	}
	else if (*arg2 == 'o' || *arg2 == 'O') 
	{
		if (F->flags & FACTOBJECT) 
		{
			if (*arg2 == 'o') sprintf(buffer,"%d",F->object);
			else strcpy(buffer,WriteFact(Index2Fact(F->object),false,word1,false,false));
		}
		else strcpy(buffer,WriteMeaning(F->object));
	}
	else return FAILRULE_BIT;
	return 0;
}

static unsigned int FindCode(char* buffer) // given a set, find the ordered position of the 2nd argument in it 
{   
	char word[MAX_WORD_SIZE];
	strcpy(word,JoinWords(BurstWord(ARGUMENT(2)),false)); //  the value to find
	WORDP D = FindWord(ARGUMENT(1));
	if (D && *D->word == '~')
	{
		int n = -1;
		FACT* F = GetObjectHead(D);  
		while (F ) // walks set MOST recent (right to left)
		{
			if (F->verb == Mmember) 
			{
				++n;
				WORDP item = Meaning2Word(F->subject);
				if (!stricmp(item->word,word))
				{
					sprintf(buffer,"%d",n);
					return 0;
				}
			}
			F = GetObjectNext(F);
		}
	}

	return FAILRULE_BIT; 
}

static unsigned int FindFactCode(char* buffer) // given a Simple fact
{   
	char* arg1 = ARGUMENT(1);
	char* arg2 = ARGUMENT(2);
	char* arg3 = ARGUMENT(3);
	FACT* F = FindFact(ReadMeaning(arg1,false),ReadMeaning(arg2,false),ReadMeaning(arg3,false),0); 
	if (!F) return FAILRULE_BIT;
	sprintf(buffer,"%d",Fact2Index(F));
	return 0;
}

static FACT* FindF(MEANING subject,WORDP verb,uint64 marker)
{ 
	FACT* F = GetSubjectHead(subject);
    while (F)
    {
		WORDP v = Meaning2Word(F->verb);
        if (v == verb) 
		{
			WORDP obj = Meaning2Word(F->object);
			if (marker != MARKED_WORD) // using a fact marking for find
			{
				if (F->flags & marker) return F;
			}
			else if (obj->systemFlags & marker) return F; // can use marked word flag as well
			FACT* G = FindF(F->object,verb,marker);
			if (G) return G;
		}
        F = GetSubjectNext(F);
    }

	return 0;
}

static unsigned int FindMarkedFactCode(char* buffer)
{ 
	WORDP subject = FindWord(ARGUMENT(1));
	if (!subject) return FAILRULE_BIT;
	WORDP verb = FindWord(ARGUMENT(2));
	if (!verb) return FAILRULE_BIT;
	char* mark = ARGUMENT(3);
	int64 marker;
	if (IsDigit(*mark)) ReadInt64(mark,marker);
	else marker = FindValueByName(mark); // a fact marker like MARKED_FACT  or word systemflag marker like MARKED_WORD
	if (!marker) return FAILRULE_BIT;

	FACT* F = FindF(MakeMeaning(subject),verb,marker);
	if (trace & TRACE_INFER) 
	{
		if (F) 
		{
			Log(STDUSERLOG,"FindMarkedFact found ");
			TraceFact(F);
		}
		else Log(STDUSERLOG,"FindMarkedFact not found ");
	}
	if (!F) return FAILRULE_BIT;

	sprintf(buffer,"%d",Fact2Index(F)); // return index
	return 0;
}

static unsigned int FLRCodeF(char* buffer)
{
	return FLR(buffer,'f');
}

static unsigned int IntersectFactsCode(char* buffer) 
{      
	char* word = ARGUMENT(1);
	char from[MAX_WORD_SIZE];
	char to[MAX_WORD_SIZE];
	unsigned int result;
	word = ReadShortCommandArg(word,from,result,OUTPUT_KEEPQUERYSET|OUTPUT_NOTREALBUFFER);
	word = ReadShortCommandArg(word,to,result,OUTPUT_KEEPQUERYSET|OUTPUT_NOTREALBUFFER);
	unsigned int store = (impliedSet == ALREADY_HANDLED) ? 0 : impliedSet;
    SET_FACTSET_COUNT(store,0);

    WORDP D;
    FACT* F;
    unsigned int usedMark = NextinferMark();
    unsigned int i;
	char toKind = 's';

	if (*to != '@') // mark word
	{
		D = FindWord(to);
		if (D) D->inferMark = usedMark;
	}
	else //  mark set
	{
		unsigned toset = GetSetID(to);
		toKind = toLowercaseData[*GetSetType(to)]; // s v o null
		unsigned int limit = FACTSET_COUNT(toset);
		for (i = 1; i <= limit; ++i)
		{
			WORDP D;
			F = factSet[toset][i];
			if (trace & TRACE_INFER)   TraceFact(F);
			if (toKind == 's') Meaning2Word(F->subject)->inferMark = usedMark;
 			else if (toKind == 'v') Meaning2Word(F->verb)->inferMark = usedMark;
 			else if (toKind == 'o') Meaning2Word(F->object)->inferMark = usedMark;
			else // mark all pieces
			{
				D = Meaning2Word(F->subject);
				D->inferMark = usedMark;
				D = Meaning2Word(F->verb);
				D->inferMark = usedMark;
				D = Meaning2Word(F->object);
				D->inferMark = usedMark;
				F->flags |= MARKED_FACT;
			}
		}
	}

    // look for matches
	unsigned int where = GetSetID(from); 
	char fromKind = toLowercaseData[*GetSetType(from)]; // s v o null
    unsigned int limit = FACTSET_COUNT(where);
  	if (trace & TRACE_INFER) Log(STDUSERLOG," // ");
	for (i = 1; i <= limit; ++i)
    {
        F = factSet[where][i];
 		if (trace & TRACE_INFER)   TraceFact(F);
 		if (fromKind == 's' && Meaning2Word(F->subject)->inferMark == usedMark) AddFact(store,F);
 		else if (fromKind == 'v' && Meaning2Word(F->verb)->inferMark == usedMark) AddFact(store,F);
		else if (fromKind == 'o' && Meaning2Word(F->object)->inferMark == usedMark) AddFact(store,F);
		else 
		{
			// entire fact found
			if (toKind != 's' && toKind != 'v' && toKind != 'o' &&  F->flags & MARKED_FACT) AddFact(store,F);
			// some piece found
			else if (Meaning2Word(F->subject)->inferMark == usedMark || Meaning2Word(F->verb)->inferMark == usedMark || Meaning2Word(F->object)->inferMark == usedMark) AddFact(store,F);
		}
    }
 	unsigned int count = FACTSET_COUNT(store);
	if (trace & TRACE_INFER)
	{
		Log(STDUSERLOG,"Found %d in IntersectFact\r\n",count);
		for (i = 1; i <= count; ++i) TraceFact(factSet[store][i]);
	}
	if (impliedSet == ALREADY_HANDLED && !count) return FAILRULE_BIT;
	impliedSet = ALREADY_HANDLED;
    return 0;
}

static unsigned int IteratorCode(char* buffer)
{// ? is std iterator ?? is recursive
	char* arg1 = ARGUMENT(1);
	char* arg2 = ARGUMENT(2);
	char* arg3 = ARGUMENT(3);
	WORDP verb = FindWord(arg2);
	if (!verb) return FAILRULE_BIT;
	MEANING v = MakeMeaning(verb);
	FACT* F;
	WORDP D;
	FACT* holdIterator = NULL;
	if (currentIterator) // this is a return to iteration- either a normal fact or a special fact containing both hieararcy and normal fact data
	{
		F = Index2Fact(currentIterator);
		if (F->flags & ITERATOR_FACT) 
		{
			holdIterator = F;
			F = Index2Fact(F->object);
		}
		F = (*arg1 == '?') ?  GetObjectNext(F) : GetSubjectNext(F);
	}
	else // this is a start of iteration
	{
		if (*arg1 == '?') 
		{
			D = FindWord(arg3); // simple word, not meaning
			F = (D) ? GetObjectHead(D) : NULL;
		}
		else
		{
			D = FindWord(arg1); // simple word, not meaning
			F = (D) ? GetSubjectHead(D) : NULL;
		}
	}
	retry: // level return if any
	while (F)
	{
		if (F->verb == v)
		{
			if (arg1[1] == '?' || arg3[1] == '?') // recursive on concepts?
			{
				MEANING field = (*arg1 == '?') ? F->subject : F->object;
				WORDP E = Meaning2Word(field);
				if (*E->word == '~') // going to nest within
				{
					FACT* G = SpecialFact(holdIterator ? (holdIterator->verb) : 0,Fact2Index(F),ITERATOR_FACT); // remember where we were
					F = (*arg1 == '?') ? GetObjectHead(E) : GetSubjectHead(E);
					if (!holdIterator) holdIterator = SpecialFact(Fact2Index(G),Fact2Index(F),ITERATOR_FACT); // we return this as holding current level and prior level tree
					else holdIterator->verb = Fact2Index(G);
					continue;	// resume hunting at lower level
				}
			}
			break; // found one
		}
		F = (*arg1 == '?') ?  GetObjectNext(F) : GetSubjectNext(F);
	}
	if (!F) // ran dry
	{
		if (holdIterator) // back out of recursive on concepts?
		{
			F = Index2Fact(holdIterator->verb);  // this is a special fact also
			if (!F) return FAILRULE_BIT;		// levels ran dry
			holdIterator->verb = F->verb;		// hold now points higher
			F = Index2Fact(F->object);			// where we were at the higher level
			F = (*arg1 == '?') ?  GetObjectNext(F) : GetSubjectNext(F);
			goto retry;
		}
		return FAILRULE_BIT;
	}
	MEANING M = (*arg1 == '?') ? F->subject : F->object;
	sprintf(buffer,"%s",WriteMeaning(M));
	if (!withinLoop && planning && !backtrackable) backtrackable = true;

	if (holdIterator)
	{
		holdIterator->object = Fact2Index(F); // alter we are pair of hierarchy return and current
		F = holdIterator;
	}
	currentIterator = Fact2Index(F); 
	return 0;
}

static unsigned int MakeRealCode(char* buffer)
{
	FACT* at = factFree+1;
	while (--at > factLocked) // user facts
	{
		if (at->flags & FACTTRANSIENT) at->flags ^= FACTTRANSIENT;
	}
	
	return 0;
}

static unsigned int FLRCodeL(char* buffer)
{
	return FLR(buffer,'l');
}

static unsigned int QueryCode(char* buffer)
{ //   kind, s, v, o, count,  from, to, propogate, mark 
	unsigned int count = 0;
	char* ptr = ARGUMENT(1);
	int argcount = 0;
	while (ptr && *ptr) // break apart arguments, but leave any quoted arg UNEVALED.
	{
		argcount++;
		char word[MAX_WORD_SIZE];
		ptr = ReadCompiledWord(ptr,word);
		if (*word != '\'')
		{
			unsigned int result = 0;
			ReadShortCommandArg(word,ARGUMENT(argcount),result);
			if (result) return 0;
		}
		else strcpy(ARGUMENT(argcount),word);
	}

	for (unsigned int i = argcount+1; i <= 9; ++i) strcpy(ARGUMENT(i),""); // default rest of args to ""
	if (IsDigit(ARGUMENT(5)[0])) ReadInt(ARGUMENT(5),count); // defaults to ? if not given
	if (count == 0) count = (unsigned int) -1; // infinite

	if (argcount < 9) while (++argcount <= 9) strcpy(ARGUMENT(argcount),"?"); //   default rest of calling Arguments
	char set[50];
	char* arg1 = ARGUMENT(1);
	char* subject = ARGUMENT(2);
	char* verb = ARGUMENT(3);
	char* object = ARGUMENT(4);
	char* from = ARGUMENT(6);
	char* to = ARGUMENT(7);
	char* arg8 = ARGUMENT(8);
	char* arg9 = ARGUMENT(9);

	if (impliedSet != ALREADY_HANDLED) 
	{
		sprintf(set,"@%d",impliedSet); 
		to = set;
	}
	unsigned int result = Query(arg1, subject, verb, object, count, from, to,arg8, arg9);
	// result was a count. now convert to a fail code
	if (impliedSet != ALREADY_HANDLED) result = 0;
	else result = (result != 0) ? 0 : FAILRULE_BIT; 
	impliedSet = ALREADY_HANDLED;
	return result;
}

static unsigned int SortCode(char* buffer)
{
	SortFacts(ARGUMENT(1));
	return 0;
}

static unsigned int SaveCode(char* buffer)
{
	if (ARGUMENT(1)[0] != '@') return FAILRULE_BIT;
	uint64 set = GetSetID(ARGUMENT(1));
	if (*ARGUMENT(2) == '0' || !stricmp(ARGUMENT(2),"false")) setControl &= -1 ^ (1 << set);
	else setControl |= (uint64) (1 << set);
	return 0;
}

static unsigned int UnduplicateCode(char* buffer)
{
	if (impliedSet == ALREADY_HANDLED) return FAILRULE_BIT;

	int from = GetSetID(ARGUMENT(1));
	if (impliedSet == from) return FAILRULE_BIT; // cant do in-place
	unsigned int count = FACTSET_COUNT(from);
	SET_FACTSET_COUNT(impliedSet,0);

	// copy unmarked facts to to
	unsigned int i;
	for (i = 1; i <= count; ++i) 
	{
		FACT* F = factSet[from][i];
		if (!(F->flags & MARKED_FACT))
		{
			AddFact(impliedSet,F);
			F->flags |= MARKED_FACT;
		}
	}

	// erase marks
	count = FACTSET_COUNT(impliedSet);
	for (i = 1; i <= count; ++i) factSet[impliedSet][i]->flags ^= MARKED_FACT; 

	if (trace & TRACE_INFER) Log(STDUSERLOG,"Unduplicated %d entries\r\n",count);
	impliedSet = ALREADY_HANDLED;
	return 0;
}

static unsigned int UnpackFactRefCode(char* buffer)
{
	if (impliedSet == ALREADY_HANDLED) return FAILRULE_BIT;
	char* arg1 = ARGUMENT(1);
	int from = GetSetID(arg1);
	int count = FACTSET_COUNT(from);
	char* type = GetSetType(arg1);
	SET_FACTSET_COUNT(impliedSet,0);
	FACT* G;
	for (int i = 1; i <= count; ++i)
	{
		FACT* F = factSet[from][i];
		if (F->flags & FACTSUBJECT && *type != 'v' && *type != 'o') 
		{
			G = Index2Fact(F->subject);
			if (trace & TRACE_INFER) TraceFact(G);
			AddFact(impliedSet,G);
		}
		if (F->flags & FACTVERB && *type != 's' && *type != 'o') 
		{
			G = Index2Fact(F->verb);
			if (trace & TRACE_INFER) TraceFact(G);
			AddFact(impliedSet,G);
		}
		if (F->flags & FACTOBJECT && *type != 's' && *type != 'v') 
		{
			 G = Index2Fact(F->object);
			if (trace & TRACE_INFER) TraceFact(G);
			AddFact(impliedSet,G);
		}
	}
	impliedSet = ALREADY_HANDLED;
	return 0;
}

SystemFunctionInfo systemFunctionSet[] =
{
	{"",0,0,0,""},

	{"\r\n---- Topic",0,0,0,""},
	{"^addtopic",AddTopicCode,1,SAMELINE,"note a topic as interesting"}, //O
	{"^available",AvailableCode,VARIABLE_ARGS,0,"is rule still available or has it been disabled"}, 
	{"^cleartopics",ClearTopicsCode,0,SAMELINE,"remove all interesting topics in queue"},
	{"^counttopic",CountTopicCode,2,SAMELINE,"provide topic and count requested: GAMBIT, AVAILABLE, RULE, USED"}, 
	{"^gambit",GambitCode,VARIABLE_ARGS,0,"execute topic in gambit mode, naming ~ ~topicname PENDING or keyword"}, 
	{"^getrule",GetRuleCode,VARIABLE_ARGS,0,"get the requested data (TAG,TYPE,LABEL,PATTERN,OUTPUT,TOPIC,USABLE) for rule tag or label"},
	{"^topicflags",TopicFlagsCode,1,SAMELINE,"Get topic control bits"}, 
	{"^lastused",LastUsedCode,2,SAMELINE,"Get input count of last topic access - GAMBIT, RESPONDER, REJOINDER, ANY"}, 
	{"^hasgambit",HasGambitCode,VARIABLE_ARGS,0,"name of topic to test for an unexpired gambit, LAST/ANY/"}, 
	{"^keep",KeepCode,0,SAMELINE,"do not erase rule after use"}, 
	{"^poptopic",PopTopicCode,VARIABLE_ARGS,0,"remove current or named topic from interesting set"}, 
	{"^refine",RefineCode,VARIABLE_ARGS,0,"execute continuations until one matches"}, 
	{"^rejoinder",RejoinderCode,0,0,"try to match a pending rejoinder - not legal in postprocessing"}, 
	{"^respond",RespondCode,VARIABLE_ARGS,0,"execute a topic's responders"}, 
	{"^reuse",ReuseCode,VARIABLE_ARGS,0,"jump to a rule label or tag and execute output section"}, 
	{"^setrejoinder",SetRejoinderCode,1,0,"Set rejoinder mark to this tag"}, 

	{"\r\n---- Topic Lists",0,0,0,""},
	{"^gambittopics",GetTopicsWithGambitsCode,0,0,"get all topics that have usable gambits that are not current topic"}, 
	{"^keywordtopics",KeywordTopicsCode,VARIABLE_ARGS,0,"get facts of topics that cover keywords mentioned in input"}, 
	{"^pendingtopics",PendingTopicsCode,1,0,"return list of currently pending topics as facts in 1st arg"}, 
	{"^querytopics",QueryTopicsCode,1,0,"get topics of which 1st arg is a keyword?"}, 

	{"\r\n---- Marking & Parser Info",0,0,0,""},
	{"^getparse",GetParseCode,STREAM_ARG,SAMELINE,"get parse chunk or data"},
	{"^mark",MarkCode,STREAM_ARG,SAMELINE,"mark word/concept in sentence"},
	{"^marked",MarkedCode,1,SAMELINE,"BOOLEAN - is word/concept marked in sentence"}, 
	{"^position",PositionCode,STREAM_ARG,SAMELINE,"get FIRST or LAST position of an _ var"}, 
	{"^setposition",SetPositionCode,1,SAMELINE,"set absolute match position"}, 
	{"^setpronoun",SetPronounCode,STREAM_ARG,SAMELINE,"replace pronoun with word"}, 
	{"^unmark",UnmarkCode,STREAM_ARG,SAMELINE,"remove a mark on a word/concept in the sentence"}, 

	{"\r\n---- Input",0,0,0,""},
	{"^capitalized",CapitalizedCode,1,SAMELINE,"given index of word in sentence return 1 or 0 for whether user capitalized it"}, 
	{"^input",InputCode,STREAM_ARG,0,"submit stream as input immediately after current input"},
	{"^removetokenflags",RemoveTokenFlagsCode,1,SAMELINE,"remove value from tokenflags"}, 
	{"^settokenflags",SetTokenFlagsCode,1,SAMELINE,"add value to tokenflags"}, 
	
	{"\r\n---- Numbers",0,0,0,""},
	{"^compute",ComputeCode,3,SAMELINE,"perform a numerical computation"}, 
	{"^timefromseconds",TimeFromSecondsCode,1,SAMELINE,"given time/date in seconds, return the timeinfo string corresponding to it"}, 

	{"\r\n---- Debugging",0,0,0,""},
	{"^debug",DebugCode,0,SAMELINE,"only useful for debug code breakpoint"}, 
	{"^log",LogCode,STREAM_ARG,0,"add to logfile"}, 

	{"\r\n---- Output Generation - not legal in post processing",0,0,0,""},
	{"^flushoutput",FlushOutputCode,0,SAMELINE,"force existing output out"}, 
	{"^insertprint",InsertPrintCode,STREAM_ARG,0,"add output before named responseIndex"},
	{"^keephistory",KeepHistoryCode,2,SAMELINE,"trim history of USER or BOT to number of entries given"}, 
	{"^print",PrintCode,STREAM_ARG,0,"isolated output message from current stream"}, 
	{"^preprint",PrePrintCode,STREAM_ARG,0,"add output before existing output"}, 
	{"^repeat",RepeatCode,0,SAMELINE,"set repeat flag so can repeat output"}, 
	{"^reviseoutput",ReviseOutputCode,2,0,"takes index and output, replacing output at that index"}, 

	{"\r\n---- Output Access",0,0,0,""},
	{"^response",ResponseCode,1,0,"raw text for this response, including punctuation"},
	{"^responsequestion",ResponseQuestionCode,1,SAMELINE,"BOOLEAN - 1 if response ends in ?  0 otherwise"}, 
	{"^responseruleid",ResponseRuleIDCode,1,SAMELINE,"rule tag generating this response"},
	
	{"\r\n---- Postprocessing functions - only available in postprocessing",0,0,0,""},
	{"^analyze",AnalyzeCode,STREAM_ARG,0,"Take an output stream and do preparation on it like it was user input"}, 
	{"^postprocessprint",PostProcessPrintCode,STREAM_ARG,0,"add to front of output stream"}, 

	{"\r\n---- Control Flow",0,0,0,""},
	{"^command",CommandCode,STREAM_ARG,0,"execute a : command"}, 
	{"^end",EndCode,1,SAMELINE,"cease current processing thru this level"}, 
	{"^eval",EvalCode,STREAM_ARG,0,"evaluate stream"}, 
	{"^fail",FailCode,1,SAMELINE,"return a return code of some kind - allowed to erase facts on sentence fail"}, 
	{"^match",MatchCode,STREAM_ARG,0,"Perform given pattern match"},
	{"^nofail",NoFailCode,STREAM_ARG,0,"execute script but ignore all failures thru some level"}, 
	{"^notnull",NotNullCode,STREAM_ARG,0,"tests that output of stream argument is not null, fails otherwise"}, 
	{"^retry",RetryCode,VARIABLE_ARGS,SAMELINE,"reexecute a rule with a later match or retry  input"},

	{"\r\n---- Word Manipulation",0,0,0,""},
	{"^burst",BurstCode,VARIABLE_ARGS,0,"break a string into component words"}, 
	{"^explode",ExplodeCode,1,0,"break a word into component letters"}, 
	{"^flags",FlagsCode,1,0,"get flag values of word"}, 
	{"^uppercase",UppercaseCode,1,0,"boolean return 1 if word was entered uppercase, 0 if not"}, 
	{"^properties",PropertiesCode,1,0,"get property values of word"}, 
	{"^intersectwords",IntersectWordsCode,VARIABLE_ARGS,0,"see if words in arg 1 are in arg2"},
	{"^join",JoinCode,STREAM_ARG,OWNTRACE,"merge words into one"}, 
	{"^pos",POSCode,VARIABLE_ARGS,0,"compute some part of speech value"},
	{"^rhyme",RhymeCode,1,0,"find a rhyming word"}, 
	{"^substitute",SubstituteCode,VARIABLE_ARGS,0,"alter a string by substitution"}, 
	{"^spell",SpellCode,1,0,"find words matching pattern and store as facts"}, 
	{"^sexed",SexedCode,4,0,"pick a word based on sex of given word"}, 
		
	{"\r\n---- Dictionary",0,0,0,""},
	{"^addproperty",AddPropertyCode,STREAM_ARG,0,"Add value to dictionary entry properies or systemFlags or facts of factset properties"}, 
	{"^define",DefineCode,VARIABLE_ARGS,0,"get dictionary gloss of  word"}, 
	{"^hasanyproperty",HasAnyPropertyCode,VARIABLE_ARGS,0,"argument 1 has any of property or systemflags of argument2 .. argumentn"}, 
    {"^hasallproperty",HasAllPropertyCode,VARIABLE_ARGS,0,"argument 1 has all of the properties or systemflags of argument2 .. argumentn"}, 
	{"^removeproperty",RemovePropertyCode,STREAM_ARG,0,"remove value to dictionary entry properies or systemFlags or facts of factset properties"},
	
	{"\r\n---- MultiPurpose Functions",0,0,0,""},
	{"^disable",DisableCode,VARIABLE_ARGS,SAMELINE,"stop a rule or topic or rejoinder"}, 
	{"^enable",EnableCode,VARIABLE_ARGS,SAMELINE,"allow a rule or topic"}, 
	{"^length",LengthCode,1,SAMELINE,"counts characters in a word or members of a fact set or top level concept members"}, 
	{"^next",NextCode,STREAM_ARG,0,"FACT- walk a factset without erasing it  GAMBIT,RESPONDER,RULE,REJOINDER with tag or label for next one  INPUT to go to next sentence"}, 
	{"^pick",FLRCodeR,STREAM_ARG,0,"randomly select and remove an element from a fact set or randomly select from a concept"}, 
	{"^reset",ResetCode,VARIABLE_ARGS,0,"reset a topic or all topics or user back to initial state "}, 

	{"\r\n---- Functions on facts",0,0,0,""},
	{"^createattribute",CreateAttributeCode,STREAM_ARG,OWNTRACE,"create a triple where the 3rd field is exclusive"}, 
	{"^createfact",CreateFactCode,STREAM_ARG,OWNTRACE,"create a triple"}, 
	{"^delete",DeleteCode,1,0,""}, 
	{"^field",FieldCode,2,0,"get a field of a fact"}, 
	{"^find",FindCode,2,0,"Given set, find ordinal position of item within it"},
	{"^findfact",FindFactCode,3,0,"given simple non-facts subject verb object, see if fact exists of it"},
	{"^findmarkedfact",FindMarkedFactCode,3,0,"given a subject,a verb, and a mark, return a marked fact that can be found propogating from subject using verb  or null"},
	{"^first",FLRCodeF,STREAM_ARG,0,"get first element of a set and remove it"},
	{"^flushfacts",FlushFactsCode,1,0,"erase all facts created after here"}, 
	{"^intersectfacts",IntersectFactsCode,STREAM_ARG,0,"find facts common to two sets, based on fields"},
	{"^iterator",IteratorCode,3,0,"walk facts of some thing"},
	{"^makereal",MakeRealCode,0,0,"make all transient facts non-transient"},

	{"^last",FLRCodeL,STREAM_ARG,0,"get last element of a set and remove it"},
	{"^query",QueryCode,STREAM_ARG,0,"hunt for fact in fact database"},
	{"^sort",SortCode,STREAM_ARG,0,"sort facts on named set-field (presumed number) low to high"},
	{"^save",SaveCode,2,0,"mark fact set to be saved into user data"},
	{"^unduplicate",UnduplicateCode,1,0,"remove duplicate facts"},
	{"^unpackfactref",UnpackFactRefCode,1,0,"copy out fields which are facts"}, 

	{"\r\n---- External Access",0,0,0,""},
	{"^export",ExportFactCode,VARIABLE_ARGS,SAMELINE,"write fact set to a file"},
	{"^import",ImportFactCode,4,SAMELINE,"read fact set from a file"}, 
	{"^system",SystemCode,STREAM_ARG,SAMELINE,"send command to the operating system"},
	// {"^playsound",PlaySoundCode,1,0,"play a sound file"},
	{"^popen",PopenCode,STREAM_ARG,SAMELINE,"send command to the operating system and read reply strings"},
	{"^tcpopen",TCPOpenCode,STREAM_ARG,SAMELINE,"send command to website and read reply strings"},

	{0,0,0,0,""}	
};
// infer.cpp - handles queries into fact data

#include "common.h"

#define MAX_PARENTS 9980
#define MAX_QUEUE 10000
#define FOLLOW_LIMIT 50

static MEANING parents[MAX_PARENTS+20];	// nodes above where we are now
static int parentIndex = 0;		// add into parents at here
static int parentWalk = 0;		// retrieve from parents starting here. when reach parentIndex you have run out

unsigned int inferMark = 0;				// primary "been-here" mark for all inferencing and tree traversals
static unsigned int saveMark = 0;		// tertiary mark - used in zone 1 control
static unsigned int ignoremark = 0;		// mark on entries to ignore
static unsigned int whichSet = 0;
static WORDP fact = 0;

#define ORIGINALWORD 0x00000001
#define NORMAL		 0x00000002    //   class and set are a group (recursive)
#define QUOTED		 0x00000004   //   class and set are simple words
#define PREMARK		 0X00000008   //   marking but save word not meaning so wont use as scan
#define NOQUEUE		 0X00000010   //   just marked with mark, not queued
#define QUEUE		 0X00000020	//    add to q
#define NOTOPIC		 0X00000040	//   dont follow topic/set names
#define BLOCKMEANING 0X00000080
#define FACTTYPE	 0X00000100
#define FINDTOPIC	 0X00000200
#define UPDICTIONARY 0X00000400
#define USERFACTS					0X00000800
#define SYSTEMFACTS					0X00001000
// 2 4 8 unused
#define USE_ORIGINAL_SUBJECT			0x00010000 // use subject as fact source
#define USE_ORIGINAL_OBJECT			0x00020000 // use object as fact source
#define RICCOCHET_USING_SUBJECT				0x00040000 
#define RICCOCHET_USING_OBJECT				0x00080000
#define RICCOCHET_BITS ( USE_ORIGINAL_SUBJECT | USE_ORIGINAL_OBJECT | RICCOCHET_USING_SUBJECT | RICCOCHET_USING_OBJECT )

// queued entries pending scanning
static MEANING queue[MAX_QUEUE+20]; 
static unsigned int queueIndex;

// answers from inferences go in these sets
FACT* factSet[MAX_FIND_SETS][MAX_FIND+1]; 
unsigned int factSetNext[MAX_FIND_SETS];		// when walking a set over time, which index to continue from

static void AddSet2Scan(unsigned int flags,WORDP D,int depth);

unsigned int NextinferMark() // set up for a new inference
{
    return ++inferMark;
}

#define MAX_BACKTRACK 5000
static MEANING backtracks[MAX_BACKTRACK+1];
static int backtrackIndex = 0;

static void SetFactBack(WORDP D, MEANING M)
{
	MEANING* set = GetTemps(D);
	if (set && !set[FACTBACK]) 
	{
		if (backtrackIndex < MAX_BACKTRACK)
		{
			set[FACTBACK] = M; 
			backtracks[backtrackIndex++] = MakeMeaning(D);
		}
	}
}

static void ClearBacktracks()
{
	while (backtrackIndex-- > 0) 
	{
		MEANING* set = GetTemps(Meaning2Word(backtracks[backtrackIndex]));
		if (set) set[FACTBACK] = 0;
	}
}

static bool IsExcluded(WORDP set,WORDP item)
{
	if (!(set->internalBits & HAS_EXCLUDE)) return false;
	FACT* F = GetObjectHead(set);
	while (F)
	{
		if (F->verb == Mexclude && Meaning2Word(F->subject) == item) break;
		F = GetObjectNext(F);
	}
	return (F) ? true : false;
}

bool SetContains(MEANING set,MEANING M, unsigned int depth) 
{
	if (!M || !set) return false;

	// the word
	WORDP D = Meaning2Word(M);
	unsigned int index = Meaning2Index(M);
	D->inferMark = inferMark;
	FACT* F = GetSubjectHead(D);

	WORDP D1 = Meaning2Word(set);

	// we walk up the tree from the word and see if it runs into D1, the set.
	if (depth == 0) 
	{
		SetFactBack(D,0); 
		if (trace & TRACE_INFER) Log(STDUSERLOG," SetContains %s %s : ",D->word,D1->word);
	}
	while (F)
	{
		if (index != 0 && F->subject != M); // fact doesnt apply
		else if (F->verb == Mmember) 
		{
			// if this topic or concept has exclusions, check to see if this is a marked exclusion
			bool blocked = false;
			WORDP object = Meaning2Word(F->object);
			if (object->internalBits & HAS_EXCLUDE) 
			{
				FACT* G = GetObjectHead(object);
				while (G && !blocked)
				{
					if (G->verb == Mexclude && Meaning2Word(G->subject)->inferMark == inferMark) blocked = true;
					else G = GetObjectNext(G);
				}
			}

			// since this is not a marked exclusion, we can say it is a member
			if (F->object == set && !blocked) 
			{
				if (trace & TRACE_INFER) // show the path from set back to word
				{
					Log(STDUSERLOG,"\r\nwithin: %s ",D1->word);
					WORDP path = Meaning2Word(F->subject); 
					while (path)
					{
						Log(STDUSERLOG," %s ",path->word);
						FACT* prior = Index2Fact(GetFactBack(path));
						path = (prior) ? Meaning2Word(prior->subject) : 0;
					}
					Log(STDUSERLOG,"\r\n");
				}

				return true;
			}
			if (!blocked && object->inferMark != inferMark)
			{
				SetFactBack(object,Fact2Index(F));
				if (SetContains(set,F->object,depth + 1)) return true;
			}
		}
		else if (F->verb == Mis) // a link up the wordnet ontology
		{
			if (F->object == set)  return true;
			WORDP object = Meaning2Word(F->object);
			if (object->inferMark != inferMark)
			{
				SetFactBack(object,Fact2Index(F));
				if (SetContains(set,F->object,depth + 1)) return true;
			}
		}
		F = GetSubjectNext(F);
	}
	if (trace & TRACE_INFER && depth == 0) Log(STDUSERLOG," not within\r\n ");
	return false;
}

static bool AllowedMember(FACT* F, unsigned int i,unsigned int is,unsigned int index)
{
	if (trace & TRACE_INFER)  TraceFact(F);
    unsigned int localIndex = Meaning2Index(F->subject);
	unsigned int pos = GetMeaningType(F->subject);
	bool bad = false;
	if (!i && pos ) 
	{
            if (pos & VERB && is & NOUN)  
            {
				bad = true;
            }
            else if (pos & NOUN && is & VERB)  
            {
				bad = true;
            }
            else if ((pos & ADJECTIVE || localIndex & ADVERB) && is & (NOUN|VERB))  
            {
				bad = false;
            }
 	}
	else if (index && pos && pos != index) bad = true;
	return !bad;
}

static void QueryFacts(WORDP original, WORDP D,unsigned int index,unsigned int store,char* kind,MEANING A)
{
    if (!D || D->inferMark == inferMark) return;
    D->inferMark = inferMark; 
    FACT* F;
    FACT* G = GetSubjectHead(D); 
    unsigned int count = 20000;
    unsigned int restriction = 0;
	if (kind) //   limitation on translation of word as member of a set
	{
		if (!strnicmp(kind,"subject",7)) restriction = NOUN;
		else if (!strnicmp(kind,"verb",4)) restriction = VERB;
		else if (!strnicmp(kind,"object",7)) restriction = NOUN;
	}
	while (G)
    {
        F = G;
        G = GetSubjectNext(G);
        if (trace & TRACE_INFER ) TraceFact(F);

        if (!--count) 
		{
			ReportBug("matchfacts infinite loop")
			break;
		}
        uint64 flags = F->flags;
        unsigned int fromindex = Meaning2Index(F->subject);
        if (fromindex == index || !fromindex); //   we allow penguins to go up to bird, then use unnamed bird to go to ~topic
        else if (index ) continue;  //   not following this path
        else if (flags & ORIGINALWORD) continue; //   you must match exactly- generic not allowed to match specific wordnet meaning- hierarchy BELOW only

		if (F->verb == Mmember  && !AllowedMember(F,0,restriction,0)) continue; // POS doesn't match
        if (F->verb == Mmember && !(flags & ORIGINALWORD))
        {
            WORDP object = Meaning2Word(F->object);
            if (object->inferMark != inferMark) 
            {
				if (*object->word == '~') // set, not a word association
                {
					if (IsExcluded(object,original)) continue; // explicitly excluded from this set

					if (object->systemFlags & TOPIC)
					{
						unsigned int topic = FindTopicIDByName(object->word);
						if (topic && !(GetTopicFlags(topic) & TOPIC_SYSTEM) && HasGambits(topic)) AddFact(store,CreateFact(MakeMeaning(object,0),A,MakeMeaning(object,0),FACTTRANSIENT));
					}
                }
                QueryFacts(original,object,0,store,kind,A);
            }
         }
    }
}

unsigned int QueryTopicsOf(char* word,unsigned int store,char* kind) // find topics referred to by word
{
	SET_FACTSET_COUNT(store,0);
    NextinferMark(); 
    WORDP D = FindWord(word,0);
    QueryFacts(D,D,0,store,kind,MakeMeaning(FindWord("a")));
    if (trace & TRACE_INFER) Log(STDUSERLOG,"QueryTopics: %s %d ",word,FACTSET_COUNT(store));
	impliedSet = ALREADY_HANDLED;
	return  0;
}

static bool AddWord2Scan(int flags,MEANING M,MEANING from,int depth,unsigned int type) // mark (and maybe queue) this word + implied wordnet up hierarchy + auto-equivalences
{
    if (queueIndex >= MAX_QUEUE || !M) return false; 
	if (type && !(M & type) && M & TYPE_RESTRICTION) return false;	// not valid type restriction

	// mark word or abandon marking
    WORDP D = Meaning2Word(M);
	unsigned int index = Meaning2Index(M);
	if (D->inferMark == saveMark || (ignoremark &&  D->inferMark == ignoremark)) return false; // marked with a current mark
	if (depth > FOLLOW_LIMIT)
	{
		ReportBug("Exceeding follow limit %s\r\n",D->word)
		return false;	
	}

	// concept set has exclusions, so if excluded is already marked, do not allow this topic to be marked
	if (D->internalBits & HAS_EXCLUDE)
	{
		FACT* G = GetObjectHead(D);
		while (G)
		{
			if (G->verb == Mexclude && Meaning2Word(G->subject)->inferMark == saveMark) return false;
			G = GetObjectNext(G);
		}
	}

	D->inferMark = saveMark; 
	if (flags & QUEUE) queue[queueIndex++] = M;

	if (trace & TRACE_QUERY) 
	{
		static char last[1000];
		if (from)
		{
			char* mean = WriteMeaning(from);
			if (stricmp(last,mean))
			{
				Log(STDUSERLOG,"\r\n(%s=>) ",mean);
				strcpy(last,mean);
			}
		}
		Log(STDUSERLOG,(flags & QUEUE) ? " %s+" : " %s. ",WriteMeaning(M));
	}

    // auto check all equivalences as well
    FACT* F = GetSubjectHead(D);
    while (F)
    {
        if (F->verb == Mmember) // can be member of an ordinary word (like USA member United_States_of_America), creates equivalence
		{
			WORDP D = Meaning2Word(F->object);
			if (*D->word != '~') AddWord2Scan(flags,F->object,F->subject,depth+1,type); // member is not to a set, but to a word. So it's an equivalence
		}
        F = GetSubjectNext(F);
    }

	// and if item is generic, all synsets
	if (index == 0 && !(flags & ORIGINALWORD))
	{
		unsigned int count = GetMeaningCount(D);
		for (unsigned int i = 1; i <= count; ++i) AddWord2Scan(flags,GetMeaning(D,i),M,depth+1,type);
	}

	return true;
}

static void AddWordOrSet2Scan(unsigned int how, char* word,int depth)
{
	++depth;
	if (!(how & ORIGINALWORD) && *word == '~' && word[1]) //   recursive on set and all its members
    {
		WORDP D = FindWord(word,0);
		if (D)
		{
			if (how & NOTOPIC && D->systemFlags & TOPIC) {;} 
			else if (AddWord2Scan(how, MakeMeaning(D,0),0,depth,0)) AddSet2Scan(how,D,depth);  //   mark the original name and then follow its members
		}
	}
	else 
	{
		if (*word == '\'') ++word;
		AddWord2Scan(how, ReadMeaning(word,true,true),0,depth,0);
	}
}

static void AddSet2Scan(unsigned int how,WORDP D,int depth)
{
	++depth;
	FACT* F = GetObjectHead(D);
	while (F)
	{
		if (F->verb == Mmember) AddWordOrSet2Scan(how | (F->flags & ORIGINALWORD),Meaning2Word(F->subject)->word,depth);
		F = GetObjectNext(F);
	}
}

// used by query setup - scans noun hierarchies upwards for inference
static void ScanHierarchy(MEANING T,int savemark,unsigned int flowmark,bool up,unsigned int flag, unsigned int type)
{
	if (!T) return;
	if (trace & TRACE_INFER) Log(STDUSERLOG,"\r\nHierarchy: (%s=>) ",WriteMeaning(T));
	if (!AddWord2Scan(flag,T,0,0,type)) return;

	parentIndex = parentWalk  = 0;
	parents[parentIndex++] = T;

	WORDP A = Meaning2Word(T);

	int index = Meaning2Index(T);
	int start = 1;

	//   find its wordnet ontological meanings, they then link synset head to synset head
	//   automatically store matching synset heads to this also -- THIS APPLIES ONLY TO THE ORIGINAL WORDP
	MEANING* onto = GetMeaningsFromMeaning(T);
	unsigned int size = GetMeaningCount(A);
	if (!up || flag & BLOCKMEANING ) size = 0;//   we are a specific meaning already, so are the synset head of something - or are going down
	else if (index) start= size = index;	//   do JUST this one
	else if (!size) size = 1; //   even if no ontology, do it once for 
	for  (unsigned int k = start; k <= size; ++k) // for each meaning of this word, mark its synset heads
	{
		MEANING T1;
		if (GetMeaningCount(A)) 
		{
			T1 = (MEANING)(ulong_t)onto[k]; //   this is the synset ptr.
			if (T1 & SYNSET_MARKER) T1 = MakeMeaning(A,k) | SYNSET_MARKER;
			else T1 = GetMaster(T1);

			if (type && !(T1 & type)) continue;	
			if (! AddWord2Scan(flag,T1,T,0,type)) continue; //   either already marked OR to be ignored
			parents[parentIndex++] = T1;	
		}
	}

	while (parentWalk < parentIndex) //   walk up its chains in stages
	{
		T = parents[parentWalk++];
		if (!T) continue;
		if (parentIndex > MAX_PARENTS) break;	//   overflow may happen. give up
		WORDP D = Meaning2Word(T);
		unsigned int index = Meaning2Index(T);
		
		// now follow facts of the synset head itself or the word itself.
		FACT* F = GetSubjectHead(D);
		while (F)
		{
			WORDP verb = Meaning2Word(F->verb); 
			FACT* G = F;
			if (trace & TRACE_INFER) TraceFact(F);
			F = GetSubjectNext(F);
			if (verb->inferMark !=  flowmark) continue;

			//   if the incoming ptr is generic, it can follow out any generic or pos_generic reference.
			//   It cannot follow out a specific reference of a particular meaning.
			//   An incoming non-generic ptr is always specific (never pos_generic) and can only match specific exact.
			if (index && T !=  G->subject) continue; //   generic can run all meanings out of here
			MEANING x = G->object; 
			if (type && G->subject & TYPE_RESTRICTION && !(type & G->subject)) continue;  // fact has bad type restriction on subject
			if (!AddWord2Scan(flag,x,G->subject,0,type)) continue;	//   either already marked OR to be ignored
			parents[parentIndex++] = x;
		}
	}

	if (trace & TRACE_INFER) Log(STDUSERLOG,"\r\n");
}

static bool Riccochet(unsigned int baseFlags, FACT* G,unsigned int set,unsigned int limit,unsigned int rmarks,unsigned int rmarkv, unsigned int rmarko)
{// use two fields to select a third. Then look at facts of that third to find a matching verb.
	FACT* F;
	WORDP D1;
	if (G->flags & (FACTSUBJECT|FACTOBJECT)) // we cant get here if the wrong field is a fact.
	{
		D1 = fact;
		F = (baseFlags & USE_ORIGINAL_SUBJECT) ? Index2Fact(G->subject) : Index2Fact(G->object);
	}
	else
	{
		D1 = (baseFlags & USE_ORIGINAL_SUBJECT) ? Meaning2Word(G->subject) : Meaning2Word(G->object);
		F  = (baseFlags & RICCOCHET_USING_SUBJECT) ? GetSubjectHead(D1) : GetObjectHead(D1);
	}
	if (trace & TRACE_QUERY) 
	{
		WORDP S = (G->flags & FACTSUBJECT) ? fact : Meaning2Word(G->subject);
		WORDP V = (G->flags & FACTVERB) ? fact : Meaning2Word(G->verb);
		WORDP O = (G->flags & FACTOBJECT) ? fact : Meaning2Word(G->object);
		char* use = (baseFlags & RICCOCHET_USING_SUBJECT) ? (char*) "subjectfield" : (char*) "objectfield";
		if (baseFlags & USE_ORIGINAL_SUBJECT) Log(STDUSERLOG,"Riccochet incoming %s %s %s via subject %s using %s\r\n",S->word,V->word,O->word,D1->word,use);
		else Log(STDUSERLOG,"Riccochet incoming %s %s %s via object %s using %s\r\n",S->word,V->word,O->word,D1->word,use);
	}

	// walk all facts at node testnig for riccochet
	while (F)	 // walk_of_S3
	{
		if (trace & TRACE_QUERY) TraceFact(F);
		FACT* I = F; 
		if (D1 == fact) F = NULL; // only the 1 main fact
		else F = (baseFlags & RICCOCHET_USING_SUBJECT)  ? GetSubjectNext(F) : GetObjectNext(F);
		if (I->flags & FACTDEAD) continue;	 // cannot use this

		// reasons this fact is no good
		if (I->flags & MARKED_FACT) continue; // already seen this answer
		if ((baseFlags & SYSTEMFACTS && I > factLocked) || (baseFlags & USERFACTS && I <= factLocked) ) continue; // restricted by owner of fact
		if (rmarks && (I->flags & FACTSUBJECT || Meaning2Word(I->subject)->inferMark != rmarks)) continue; // mark must match
		if (rmarkv && (I->flags & FACTVERB || Meaning2Word(I->verb)->inferMark != rmarkv)) continue; // mark must match
		if (rmarko && (I->flags & FACTOBJECT || Meaning2Word(I->object)->inferMark != rmarko)) continue; // mark must match

		I->flags |= MARKED_FACT;
		AddFact(set,I); 
		if (trace & TRACE_QUERY) 
		{
			Log(STDUSERLOG,"    Found:");
			TraceFact(I);
		}
		if (FACTSET_COUNT(set) >= limit) return false;
	}
	return true;
}

unsigned int Query(char* kind, char* subjectword, char* verbword, char* objectword, unsigned int count, char* fromset, char* toset, char* propogate, char* match)
{
	if (trace & TRACE_INFER) Log(STDUSERTABLOG,"QUERY: %s ",kind);
	WORDP C = FindWord(kind,0);
	if (!C || !(C->internalBits & QUERY_KIND)) 
	{
		ReportBug("Illegal query control %s",kind)
		return 0;
	}
	char copy[MAX_WORD_SIZE];	// hold the actual control value, so we can overwrite it
	char* control = NULL;
	if (C->w.userValue && *C->w.userValue) 
	{	
		strcpy(copy,C->w.userValue);
		control = copy;
	}
	else 
	{
		ReportBug("query control lacks data %s",kind)
		return 0;
	}

	// get correct forms of arguments - _ is an empty argument, but legal
	char word[MAX_WORD_SIZE];
    int n = BurstWord(subjectword);
	if (n > 1) strcpy(subjectword,JoinWords(n,false));
    n = BurstWord(verbword);
	if (n > 1) strcpy(verbword,JoinWords(n,false));
    n = BurstWord(objectword);
	if (n > 1) strcpy(objectword,JoinWords(n,false));
	n = BurstWord(match);
	if (n > 1) strcpy(match,JoinWords(n,false));
	n = BurstWord(propogate);
	if (n > 1) strcpy(propogate,JoinWords(n,false));
	if (trace & TRACE_INFER) 
	{
		Log(STDUSERTABLOG," control: %s  s/v/o:[%s %s %s] count:%d ",control,subjectword,verbword,objectword,count);   
		if (*fromset != '?') Log(STDUSERLOG,"fromset:%s ",fromset);   
		if (*toset != '?') Log(STDUSERLOG,"toset:%s ",toset);   
		if (*propogate != '?') Log(STDUSERLOG,"propogate:%s",propogate);   
		if (*match != '?') Log(STDUSERLOG,"match:%s",match);   
		Log(STDUSERLOG,"\r\n");   
	}

	//   handle what sets are involved
	int store = GetSetID(toset);
	if (store < 0) store = 0;
	SET_FACTSET_COUNT(store,0);
	int from = GetSetID(fromset);
	if (from < 0) from = 0;
	SET_FACTSET_COUNT(store,0);
	unsigned int baseFlags = 0;

	if (!stricmp(fromset,"user")) baseFlags |= USERFACTS;
	if (!stricmp(fromset,"system")) baseFlags |= SYSTEMFACTS;

	queueIndex = 0; 
	ignoremark = 0;
	unsigned int baseMark = inferMark; //   offsets of this value

	//   process initialization
nextsearch:  //   can do multiple searches, thought they have the same basemark so can be used across searchs (or not) up to 9 marks

#ifdef INFORMATION
# first segment describes what to initially mark and initially queue for processing (sources of facts)
#	Values:
#		1..9  = set global tag to this label - 0 means turn off global tag
#		i =  use argument tag on words to ignore during a  tag or queue operation 
#			Next char is tag label. 0 means no ignoremark
#		s/v/o/p/m/~set/tick-word  = use subject/verb/object/progogate/match/factset argument as item to process or use named set or given word 
#			This is automatically marked using the current mark and is followed by 
#				q  = queue items (sets will follow to all members recursively)
#				t  = tag (no queue) items
#				e  = expandtag (no queue) (any set gets all things below it tagged)
#				h  = tag propogation from base (such propogation might be large)
#					1ST char after h is mark on verbs to propogate thru
#					2nd char is t or q (for tag or mark/queue)
#					3rd char (< >) after h is whether to propogate up from left/subject to object or down/right from object to subject when propogating
#		n = implied all topics marked to ignore on object
#		f = use given facts in from as items to process -- f@n  means use this set
#			This is followed by 
#			s/v/o/f	= use corresponding field of fact or entire fact
#		the value to process will be marked AND may or may not get stored, depending on following flag being q or m
#endif

	//   ZONE 1 - mark and queue setups
	int baseOffset = 0; //   facts come from this side, and go out the verb or other side
	char* choice;
	char* at;
	int qMark = 0;
	int mark = 0;
	unsigned int whichset = 0;
	fact = FindWord("fact");

	char maxmark = '0'; // deepest mark user has used
	if (trace & TRACE_QUERY) 
	{
		// convert all _ and periods to spaces for easier viewing
		char* underscore;
		while ((underscore = strchr(control,'_'))) *underscore = ' ';

		char* colon = strchr(control,':');
		if (colon) *colon = 0;
		Log(STDUSERLOG,"@@@ Control1 mark/queue: %s\r\n",control);
		if (colon) *colon = ':';
	}
	--control;
	bool facttype = false;
	while (*++control && *control != ':' )
	{
		choice = NULL;
		switch(*control)
		{
			case '_': case '.': case ' ': // does nothing per se
				continue;	
			case '0':  // means NO savemark
				saveMark = 0; 
				continue;
			case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': //   set current marks
				saveMark = baseMark + *control - '0';
				if (*control > maxmark) maxmark = *control;
				continue;
			case 'n':  // ignore all member facts involving topic as object
				if (trace & TRACE_QUERY) Log(STDUSERLOG," ignore all member facts w topics as objects ");
				++control; 
				baseFlags |= NOTOPIC;
				continue;
			case '~': case '\'': //   use named set or named word
				choice = control; 
				at = strchr(control,'.'); //   set name ends with _ or . or space (generated)
				if (!at) at = strchr(control,'_');
				if (!at) at = strchr(control,' ');
				if (!at) 
				{
					ReportBug("Couldnt find end of name %s in control",control)
					return 0; // couldn't find end of name
				}
				*at = 0;
				control = at;	// skip past to end
				break;
			case 'i': 
				++control;
				if (trace & TRACE_QUERY) Log(STDUSERLOG," ignore #%c results ", *control);
				ignoremark = (*control == '0') ? 0 : (baseMark + (*control - '0'));
				break;
			case 's': 
				choice = subjectword; 
				mark = 0; 
				break;
			case 'S':
				choice = subjectword;
				mark = 0;
				facttype = true;
				break;
			case 'v': // automatically quote verbs. NEVER let them wander
				*word = '\''; 
				strcpy(word+1,verbword);
				choice = word; 
				mark = 1; 
				break;
			case 'V':
				choice = verbword;
				mark = 1;
				facttype = true;
				break;
			case 'o': 
				choice = objectword; 
				mark = 2; 
				break;
			case 'O':
				choice = objectword;
				mark = 2;
				facttype = true;
				break;
			case 'p': 
				choice = propogate; 
				break;
			case 'm': 
				choice = match; 
				break;
			case 'f':  //   we have incoming facts to use 
				whichset = (control[1] == '@') ? GetSetID(++control) : from; // only allowed sets 1-9
				break;
			default: 
				ReportBug("Bad control code for query init %s", control)
				return 0;
		}
		if (choice) // we have something to follow
		{
			++control; // now see flags on the choice
			unsigned int flags = baseFlags;
			if (choice[0] == '\'')  //dont expand this beyond its first leve --   $$tmp would come in with its value, which if set would fan out.  '$$tmp gets just its value
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG," don't expand ");
				flags |= ORIGINALWORD;
				++choice;
			}
			if (choice[0] == '^') // replace the function arg
			{
				strcpy(word,callArgumentList[atoi(choice+1)+fnVarBase]);
				choice = word;
			}
			// dynamic choices
			if (choice[0] == '_') 
			{
				int wild = GetWildcardID(choice);
				if (wild < 0){;}
				else if (flags != 0)
				{
					choice = wildcardOriginalText[wild];
					if (*choice != '~') flags = 0; // '_0 treated as normal word unquoted (original meaning) unless its a set, then it must not expand instead
				}
				else choice = wildcardCanonicalText[wild];
			}
			else if (choice[0] == '$') choice = GetUserVariable(choice);
			else if (choice[0] == '%' ) choice = SystemVariable(choice,NULL);
			else if (choice[0] == '@' )
			{
				if (trace & TRACE_QUERY)  Log(STDUSERLOG,"\r\n FactField: %c(%d) ",saveMark-baseMark+'0',saveMark);
				choice = NULL;
				for (unsigned int j = 1; j <= FACTSET_COUNT(whichset); ++j) 
				{
					FACT* F = factSet[whichset][j];
					if (F->flags & FACTDEAD) continue;	 // cannot use this

					MEANING M;
					if (*control == 'f') //   whole fact can be queued. It cannot be marked as on the queue
					{
						queue[queueIndex++] = Fact2Index(F);
						continue;
					}
					else if (*control == 's') M = F->subject; 
					else if (*control == 'v') M = F->verb; 
					else if (*control == 'o') M = F->object; 
					else 
					{
						ReportBug("bad control for query %s",control)
						return 0;
					}
					if (trace & TRACE_QUERY)  Log(STDUSERLOG," %s ",WriteMeaning(M));
					AddWord2Scan((control[1] == 'q') ? (QUEUE|flags) : flags,M,0,0,0);
				}
				continue;
			}
			else if (facttype) // choice is a fact
			{
				if (!IsDigit(*choice)) return 0; // illegal fact reference
				unsigned int f = atoi(choice);
				if (atoi(choice) > (int) Fact2Index(factFree)) return 0;	// beyond legal range
				// we can q it but we dont mark it....
				queue[queueIndex++] = f;
				baseFlags |= FACTTYPE; 
				facttype = false;
				continue;
			}
			if (choice[0] == '\\')  // accept this unchanged
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG," raw ");
				++choice;
			}

			// for non-factset values of choice
			char buf[1000];
			if (trace & TRACE_QUERY) sprintf(buf,"%s #%c(%d)",choice,saveMark-baseMark+'0',saveMark);
			if (*control == 'q') 
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG,"\r\n Tag+Queue: %s ",buf);
				qMark = saveMark;	//   if we q more later, use this mark by default
				if (*choice) AddWordOrSet2Scan(QUEUE|flags,choice,0); //   mark and queue items
			}
			else  if (*control == 't') 
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG,"\r\n Tag: %s ",buf);
				if (!*choice);
				else if (*choice == '\'') AddWord2Scan(flags, ReadMeaning(choice+1,true,true),0,0,0); // ignore unneeded quote
				else AddWord2Scan(flags, ReadMeaning(choice,true,true),0,0,0);
			}
			else  if (*control == 'e') 
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG,"\r\n ExpandTag: %s ",buf);
				if (*choice) AddWordOrSet2Scan(flags,choice,0); // tag but dont queue
			}
			else if (*control == '<' || *control == '>') //   chase hierarchy (exclude VERB hierarchy-- we infer on nouns)
			{ //   callArgumentList are:  flowverbs,  queue or mark, 
				char kind = *control; //< or > 
				int flows = baseMark + *++control - '0'; // mark for flow
				unsigned int flag = (*++control == 'q') ? QUEUE : 0;
				if (trace & TRACE_QUERY) 
				{
					if (flag) Log(STDUSERLOG," Tag+Queue Propogate %c ",kind);
					else Log(STDUSERLOG," Tag Propogate %c ",kind);
				}
				// if (flag & QUEUE) flag |= BLOCKMEANING;
				// mark subject 0 and object 2 are nouns, 1 is verb
				if (*choice) ScanHierarchy(ReadMeaning(choice,true,true),saveMark,flows,kind == '<',flag, (mark != 1) ? NOUN : VERB);
			}
			else 
			{
				ReportBug("bad follow argument %s",control)
				return 0;
			}
			if (trace & TRACE_QUERY) Log(STDUSERLOG,"\r\n");
		}
	}
	inferMark += maxmark - '0';	//   update to use up marks we have involved
	ignoremark = 0;				//   require be restated if a matching requirement

	//   ZONE 2 - how to use contents of the queue
	//   given items in queue, what field from a queued entry to use facts from 
	if (!strncmp(control,":queue",6)) control += 5; // just a label defining the field
	if (trace & TRACE_QUERY) 
	{
		char* colon = strchr(control+1,':');
		if (colon) *colon = 0;
		Log(STDUSERLOG,"@@@ Control2 queue use: %s\r\n",control+1);
		if (colon) *colon = ':';
	}
	if (*control) while (*++control && *control != ':' )
	{
		switch (*control)
		{
		case '_': case '.':  case ' ': // does nothing per se
			continue;
		case 's': 
			baseOffset = 0; 
			break;
		case 'v': 
			baseOffset = 1; 
			break;
		case 'o': 
			baseOffset = 2; 
			break;
		case 'f': 
			baseFlags |= FACTTYPE; 
			break; //   queued items are facts instead of meaning
		default:
			ReportBug("Bad control code for #2 (queue test) %s",control)
			return 0;
		}
	}

	whichset = store;

	//   ZONE 3 - how to detect facts we can return as answers and where they go
	//   set marks to compare on (test criteria for saving an answer)
	bool sentences = false;
	bool sentencev = false;
	bool sentenceo = false;
	unsigned int marks = 0, markv = 0, marko = 0;
	unsigned int markns = 0, marknv = 0, markno = 0;
	unsigned int rmarks = 0, rmarkv = 0, rmarko = 0;
	unsigned int intersectMark = 0, propogateVerb = 0;
	saveMark = qMark;	//   default q value is what we used before
	if (!strncmp(control,":match",6)) control += 5;  // just a comment label defining what the field does
	if (trace & TRACE_QUERY && *control && control[1]) 
	{
		char* colon = strchr(control+1,':');
		if (colon) *colon = 0;
		if ((colon && colon != (control + 2)) || !colon ) Log(STDUSERLOG,"@@@ Control3 match requirements: %s\r\n",control+1); // if there is data
		if (colon) *colon = ':';
	}
	if (*control) while (*++control && *control != ':' )
	{
		switch (*control)
		{
		case '_': case '.':  case ' ':  // does nothing per se
			continue;
		case '!': //   do NOT match this
			++control;
			if (*control == 's')  
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG," don't match subjects #%c ",*control);
				markns = baseMark + (*++control - '0');
			}
			if (*control == 'v')  
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG," don't match verbs #%c ",*control);
				marknv = baseMark + (*++control - '0');
			}
			if (*control == 'o')  
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG," don't match objects #%c ",*control);
				markno = baseMark + (*++control - '0');
			}
			break;
		case 'x': // field after has sentence mark
			++control;
			if (*control == 's')  sentences = true; 
			else if (*control == 'v')   sentencev = true; 
			else if (*control == 'o')   sentenceo = true; 
			break;

			//   normal tests of fact fields
		case 's': 
			marks = baseMark + (*++control - '0'); 
			if (trace & TRACE_QUERY) Log(STDUSERLOG," subject must be #%c ",*control);
			break;
		case 'v': 
			markv = baseMark + (*++control - '0'); 
			if (trace & TRACE_QUERY) Log(STDUSERLOG," verb must be #%c ",*control);
			break;
		case 'o': 
			marko = baseMark + (*++control - '0'); 
			if (trace & TRACE_QUERY) Log(STDUSERLOG," object must be #%c ",*control);
			break;
			
		//   dont pay attention to this value during search (opposite the baseOffset)
		case 'i': 
			++control;
			if (trace & TRACE_QUERY) Log(STDUSERLOG," ignore results with #%c ",*control);
			ignoremark = (*control == '0') ? 0 : (baseMark + (*control - '0'));
			break;
		//   future queuing uses this mark (hopefully same as original queued)
		case 'q': 
			saveMark = baseMark + (*++control - '0');  
			break;
		case '~': 
			intersectMark = baseMark + (*++control - '0'); //   label to intersect to in propogation
			break;
		case 't': 
			baseFlags |= FINDTOPIC;
			break;
		case '<':  case '>': 
			if (trace & TRACE_QUERY) Log(STDUSERLOG," propogate on verb #%c ",*control);
			propogateVerb = baseMark + (*++control - '0'); //   label of verbs to propogate on
			break;
		case '@': //   where to put answers (default is store)
			if (trace & TRACE_QUERY) Log(STDUSERLOG," store facts in @%c",*control);
			whichset = *++control - '0';
			break;
		case '^':
			baseFlags |= UPDICTIONARY;
			break;	// rise up dominant dictionary meaning 
		default: 
			ReportBug("Bad control code for Zone 3 test %s",control)
			return 0;
		}
	}

	//   ZONE 4- how to migrate around the graph and save new queue entries
	//   now examine riccochet OR other propogation controls (if any)
	//   May say to match another field, and when it matches store X on queue
	if (!strncmp(control,":walk",5)) control += 4;
	if (trace & TRACE_QUERY && *control && control[1]) 
	{
		char* colon = strchr(control+1,':');
		if (colon) *colon = 0;
		Log(STDUSERLOG,"@@@ Control4 riccochet: %s\r\n",control+1);
		if (colon) *colon = ':';
	}
	if (*control) while (*++control && *control != '|')
	{
		switch (*control)
		{
		case '_':  case '.': case ' ': // does nothing per se
			continue;
		//   tests on riccochet fields
		case 'S': 
			if (trace & TRACE_QUERY) Log(STDUSERLOG,"Riccochet on Subject #%c ",*control);
			rmarks = baseMark + (*++control - '0'); 
			break;
		case 'V': 
			if (trace & TRACE_QUERY) Log(STDUSERLOG,"Riccochet on Verb #%c ",*control);
			rmarkv = baseMark + (*++control - '0'); 
			break;
		case 'O': 
			if (trace & TRACE_QUERY) Log(STDUSERLOG,"Riccochet on Object #%c ",*control);
			rmarko = baseMark + (*++control - '0'); 
			break;

		//   fields to access as next element from a NORMAL fact - 1st reference is base fact, second is riccochet fact
		case  's': //   MEANING offsets into a fact to get to subject,verb,object
			baseFlags |= USE_ORIGINAL_SUBJECT | RICCOCHET_USING_OBJECT;  // requires using object list of facts
			break; 
		case  'v':
			ReportBug("bad riccochet field")
			return 0; 
		case  'o': 
			baseFlags |= USE_ORIGINAL_OBJECT | RICCOCHET_USING_SUBJECT; // requires using subject list of facts
			break;
		default: 
			ReportBug("Bad control code for Zone 4 test %s",control)
			return 0;
		}
	}
	if (trace & TRACE_QUERY) Log(STDUSERLOG,"Start processing loop\r\n");
	
	//   now perform the query
	FACT* F;
	unsigned int  scanIndex = 0;
	unsigned int pStart,pEnd;
	while (scanIndex < queueIndex)
	{
		MEANING next = queue[scanIndex++];
		next &= SIMPLEMEANING; // no type bits, just word ref
        unsigned int index;

		//   get node which has fact list on it
		if (baseFlags & FACTTYPE) // q data is facts
		{
			F = Index2Fact(next);
			if (baseOffset == 0) F = GetSubjectHead(F);
			else if (baseOffset == 1) F = GetVerbHead(F);
			else  F = GetObjectHead(F);
			index = 0;
		}
		else // q data is meanings
		{
			WORDP D = Meaning2Word((ulong_t)next);
			if (baseOffset == 0) F = GetSubjectHead(D);
			else if (baseOffset == 1) F = GetVerbHead(D);
			else  F = GetObjectHead(D);
			index = Meaning2Index(next);
		}

		bool once = false;
		while (F)
		{
			if (trace & TRACE_QUERY) TraceFact(F,true);

			//   prepare for next fact to walk
			FACT* G = F;

			MEANING INCOMING;
			MEANING OUTGOING;
			// what fields do we process by default
			if (baseOffset == 0) 
			{
				F = GetSubjectNext(F);
				INCOMING = G->subject;
				OUTGOING = G->object;
			}
			else if (baseOffset == 1)  
			{
				F = GetVerbNext(F);
				INCOMING = G->verb;
				OUTGOING = G->object;
			}
			else 
			{
				F = GetObjectNext(F);
				INCOMING = G->object;
				OUTGOING = G->subject;
			}
			if (G->flags & FACTDEAD) continue;	 // cannot use this
			if (baseFlags & USERFACTS && G <= factLocked) continue; // restricted by kind of fact
			if (baseFlags & SYSTEMFACTS && G > factLocked) continue;

			INCOMING &= SIMPLEMEANING;
			OUTGOING &= SIMPLEMEANING;
			//   is this fact based on what we were checking for? (we store all specific instances on the general dictionary)
			if (index && INCOMING != next) continue;
			WORDP OTHER = Meaning2Word(OUTGOING);

			WORDP S = (G->flags & FACTSUBJECT) ? fact : Meaning2Word(G->subject);
			WORDP V = (G->flags & FACTVERB) ? fact : Meaning2Word(G->verb);
			WORDP O = (G->flags & FACTOBJECT) ? fact : Meaning2Word(G->object);

			//   if this is part of ignore set, ignore it (not good if came via verb BUG)
			if (ignoremark && OTHER->inferMark == ignoremark ) 
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG,"ignore ");
				continue;
			}
			// pay no attention to topic facts
			if (baseFlags & NOTOPIC && O->systemFlags & TOPIC)
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG,"notopic ");
				continue;
			}
			
			bool match = true;

			// follow dictionary path?
			if (baseFlags & UPDICTIONARY && G->verb == Mis && !once)
			{
				once = true;
				if (AddWord2Scan(QUEUE,OUTGOING,INCOMING,0,0)){;} // add object onto queue
				continue;
			}

			//   field validation fails on some field?
			if (marks && S->inferMark != marks)  match = false;
			else if (markns && S->inferMark == markns)  match = false;
			if (markv && V->inferMark != markv) match = false;
			else if (marknv && V->inferMark == marknv)  match = false;
			if (marko && O->inferMark != marko)  match = false;
			else if (markno && O->inferMark == markno)  match = false;
			if (sentences && !GetNextSpot(S,0,pStart,pEnd)) match = false;
			if (sentencev && !GetNextSpot(V,0,pStart,pEnd)) match = false;
			if (sentenceo && !GetNextSpot(O,0,pStart,pEnd)) match = false;
			if (intersectMark && OTHER->inferMark != intersectMark) match = false;// we have not reached requested intersection

			//   if search is riccochet, we now walk facts of riccochet target
			if (match && baseFlags & RICCOCHET_BITS )
			{
				if (!Riccochet(baseFlags,G,whichSet,count,rmarks,rmarkv,rmarko))
				{
					scanIndex = queueIndex; //   end outer loop 
					F = NULL;
				}
			} // end riccochet
			else if (match && !(G->flags & MARKED_FACT)) //   find unique fact -- it was not rejected by anything
			{
				G->flags |= MARKED_FACT;
				AddFact(whichset,G);
				if (trace & TRACE_QUERY ) 
				{
					Log(STDUSERLOG,"    Found:");
					TraceFact(G);
				}
				if (FACTSET_COUNT(whichset) >= count) 
				{
					scanIndex = queueIndex; //   end outer loop 
					F = NULL;
					break;
				}
				if (count == 1 && intersectMark) // create backtract in next set
				{
					unsigned int set1 = whichset + 1;
					if (set1 == MAX_FIND_SETS) set1 = 0;	// wrap around end
					WORDP D = Meaning2Word(INCOMING);
					unsigned int count = 0;
					while (D)
					{
						factSet[set1][++count] = CreateFact(INCOMING,MakeMeaning(D),OUTGOING,FACTTRANSIENT);
						D = Meaning2Word(GetFactBack(D));
						OUTGOING = INCOMING;
						INCOMING = MakeMeaning(D);
					}
					SET_FACTSET_COUNT(set1,count);
				}
			}

			//   if propogation is enabled, queue appropriate choices
			if (!match && propogateVerb && V->inferMark == propogateVerb && !(G->flags & MARKED_FACT)) // this is not a fact to check, this is a fact to propogate on
			{
				if (trace & TRACE_QUERY) Log(STDUSERLOG,"\r\n propogate ");
				if (baseFlags & FINDTOPIC && OTHER->systemFlags & TOPIC) // supposed to find a topic
				{
					G->flags |= MARKED_FACT;
					AddFact(whichset,G); 
					if (trace & TRACE_QUERY ) 
					{
						Log(STDUSERLOG,"    Found:");
						TraceFact(G);
					}
					if (FACTSET_COUNT(whichset) >= count) 
					{
						scanIndex = queueIndex; //   end outer loop 
						F = NULL;
						break;
					}
				}
				else if (AddWord2Scan(QUEUE,OUTGOING,INCOMING,0,0)) SetFactBack(OTHER,INCOMING);  // add object onto queue and provide traceback
				if (trace & TRACE_QUERY) Log(STDUSERLOG,"\r\n");
			}
		} // end loop on facts
	} // end loop on scan queue
	
	//   clear marks for duplicates
	unsigned int counter = FACTSET_COUNT(whichset);
	for (unsigned int i = 1; i <= counter; ++i) factSet[whichset][i]->flags &= -1 ^ MARKED_FACT;
	factSetNext[store] = 0;
    if (trace & TRACE_INFER) 
	{
		char word[MAX_WORD_SIZE];
		if (counter) Log(STDUSERTABLOG," result: @%d[%d] e.g. %s\r\n",whichset,counter,WriteFact(factSet[whichset][1],false,word));
		else Log(STDUSERTABLOG," result: @%d none found \r\n",whichset);
	}
	ClearBacktracks();

	if (*control++ == '|') goto nextsearch; //   chained search, do the next
	return counter;
}
#include "common.h"
char* version = "3.81";

clock_t startTimeInfo;							// start time of current volley

char revertBuffer[INPUT_BUFFER_SIZE];			// copy of user input so can :revert if desired
 
char* postProcessing = 0;						// copy of output generated during MAIN control. Postprocessing can prepend to it
unsigned int tokenCount;						// for document mode

char inBuffer[INPUT_BUFFER_SIZE];				// user input buffer - ptr to primaryInputBuffer
char outBuffer[MAX_BUFFER_SIZE];				// main user output buffer  BUG??? why not direct
char* readBuffer;								// main scratch reading buffer (files, etc)

unsigned int startSystem;						// time chatscript started

int always = 1;									// just something to stop the complaint about a loop based on a constant

// server data
#ifdef DISCARDSERVER
bool server = false;
#else
std::string interfaceKind = "0.0.0.0";
#ifdef WIN32
bool server = false;	// default is standalone on Windows
#elif IOS
bool server = true; // default is server on LINUX
#else
bool server = true; // default is server on LINUX
#endif
#endif
unsigned int port = 1024;						// server port

int prepareMode = NO_MODE;						// controls what processing is done in preparation NO_MODE, POS_MODE, PREPARE_MODE
bool noReact = false;

// :source:document data
bool documentMode = false;						// read input as a document not as chat
FILE* sourceFile = NULL;						// file to use for :source
unsigned int echoSource = 0;					// for :source, echo that input to nowhere, user, or log

// status of user input
unsigned int inputCount = 0;					// which user volley is this
bool moreToComeQuestion = false;				// is there a ? in later sentences
bool moreToCome = false;						// are there more sentences pending
uint64 tokenControl = 0;					// results from tokenization and prepare processing
char* nextInput;								// ptr to rest of users input after current sentence
char oldInputBuffer[INPUT_BUFFER_SIZE];			//  copy of the sentence we are processing
char currentInput[INPUT_BUFFER_SIZE];			// the sentence we are processing  BUG why both

// general display and flow controls
bool quitting = false;							// intending to exit chatbot
bool systemReset = false;						// intending to reload system
bool autonumber = false;						// display number of volley to user
bool showWhy = false;							// show user rules generating his output
bool showTopic = false;							// show resulting topic on output
bool showTopics = false;						// show all relevant topics
bool showInput = false;							// Log internal input additions
bool all = false;								// generate all possible answers to input
bool regression = false;						// regression testing in progress
unsigned int trace = 0;							// current tracing flags
bool debugger = false;							// intercept things to the debugger
bool shortPos = false;							// display pos results as you go

int oktest = 0;									// auto response test

char respondLevel = 0;							// rejoinder level of a random choice block

int inputCounter = 0;							// protecting ^input from cycling
int totalCounter = 0;							// protecting ^input from cycling

static char userPrefix[MAX_WORD_SIZE];			// label prefix for user input
static char botPrefix[MAX_WORD_SIZE];			// label prefix for bot output

bool unusedRejoinder;							// inputRejoinder has been executed, blocking further calls to ^Rejoinder

// outputs generated
RESPONSE responseData[MAX_RESPONSE_SENTENCES+1];
unsigned char responseOrder[MAX_RESPONSE_SENTENCES+1];
unsigned int responseIndex;

unsigned int inputSentenceCount;				// which sentence of volley is this

///////////////////////////////////////////////
/// SYSTEM STARTUP AND SHUTDOWN
///////////////////////////////////////////////

void InitStandalone()
{
	startSystem =  clock()  / CLOCKS_PER_SEC;
	*currentFilename = 0;	//   no files are open (if logging bugs)
	tokenControl = 0;
	*computerID = 0; // default bot
}

void CreateSystem()
{
	char* os;

#ifdef WIN32
	os = "Windows";
#elif IOS
	os = "IOS";
#elif __MACH__
	os = "MACH";
#else
	os = "LINUX";
#endif
	printf("ChatScript Version %s  %ld bit %s  %s\r\n    ",version,(long int)(sizeof(char*) * 8),os,language);
#ifdef DISCARDSERVER 
	printf("Server disabled.  ");
#endif
#ifdef DISCARDSCRIPTCOMPILER
	printf("Script compiler disabled.  ");
#endif
#ifdef DISCARDTESTING
	printf("Testing disabled.  ");
#endif
#ifdef DISCARDDICTIONARYBUILD
	printf("Dictionary building disabled.  ");
#endif

	printf("\r\n");

	if (!stricmp(language,"ENGLISH"))
	{
		//  assign language code 
		P_GetAdjectiveBase = English_GetAdjectiveBase;   
		P_GetAdverbBase = English_GetAdverbBase;
		P_GetPastTense = English_GetPastTense;   
		P_GetPastParticiple = English_GetPastParticiple;   
		P_GetPresentParticiple = English_GetPresentParticiple;   
		P_GetThirdPerson = English_GetThirdPerson;   
		P_GetInfinitive = English_GetInfinitive;   
		P_GetSingularNoun = English_GetSingularNoun;   
		P_GetPluralNoun = English_GetPluralNoun;   
		P_TagIt = English_TagIt;
		P_SetSentenceTense = English_SetSentenceTense;
	}

	if (!buffers) // restart asking for new memory allocations
	{
		maxBufferSize = (maxBufferSize + 63);
		maxBufferSize &= 0xffffffC0; // force 64 bit align
		unsigned int total = maxBufferLimit * maxBufferSize;
		buffers = (char*) malloc(total); // have it around already for messages
		if (!buffers)
		{
			printf("cannot allocate buffer space");
			exit(1);
		}
		bufferIndex = 0;
		logmainbuffer = AllocateAlignedBuffer();
		readBuffer = AllocateBuffer();
		joinBuffer = AllocateBuffer();
		newBuffer = AllocateBuffer();
		baseBufferIndex = bufferIndex;
	}

	int old = trace; // in case trace turned on by default
	trace = 0;

	InitScriptSystem();
	InitVariableSystem();
	ReloadSystem();			// builds layer1 facts and dictionary (from wordnet)
	LoadTopicSystem();		// dictionary reverts to wordnet zone
	InitSpellCheck();
	*currentFilename = 0;
	computerID[0] = 0;
	loginName[0] = loginID[0] = 0;
	*botPrefix = *userPrefix = 0;

	unsigned int factUsedMemKB = ( factFree-factBase) * sizeof(FACT) / 1000;
	unsigned int factFreeMemKB = ( factEnd-factFree) * sizeof(FACT) / 1000;
	unsigned int dictUsedMemKB = ( dictionaryFree-dictionaryBase) * sizeof(WORDENTRY) / 1000;
	// dictfree shares text space
	unsigned int textUsedMemKB = ( stringBase-stringFree)  / 1000;
	char* endDict = (char*)(dictionaryBase + maxDictEntries);
	unsigned int textFreeMemKB = ( stringFree- endDict) / 1000;
	unsigned int bufferMemKB = (maxBufferLimit * maxBufferSize) / 1000;
	
	unsigned int used =  factUsedMemKB + dictUsedMemKB + textUsedMemKB + bufferMemKB;
	used +=  (userTopicStoreSize + userTableSize) /1000;
	unsigned int free = factFreeMemKB + textFreeMemKB;

	unsigned int bytes = (tagRuleCount * MAX_TAG_FIELDS * sizeof(uint64)) / 1000;
	used += bytes;

	char buf2[MAX_WORD_SIZE];
	char buf1[MAX_WORD_SIZE];
	char buf[MAX_WORD_SIZE];
	strcpy(buf,StdIntOutput(factFree-factBase));
	strcpy(buf2,StdIntOutput(textFreeMemKB));
	printf("Params dict:%ld fact:%ld text:%ldkb hash:%ld \r\n",(long int)maxDictEntries,(long int)maxFacts,(long int)(maxStringBytes/1000),(long int)maxHashBuckets);
	printf("       buffer:%dx%dkb cache:%dx%dkb userfacts:%d\r\n",(int)maxBufferLimit,(int)(maxBufferSize/1000),(int)userCacheCount,(int)(userCacheSize/1000),(int)userFactCount);

	printf("Used %dMB: dict %s (%dkb) fact %s (%dkb) text %dkb\r\n",
		used/1000,
		StdIntOutput(dictionaryFree-dictionaryBase), 
		dictUsedMemKB,
		buf,
		factUsedMemKB,
		textUsedMemKB);
	printf("           buffer (%dkb) cache (%dkb) POS: %d (%dkb)\r\n",
		bufferMemKB,
		(userTopicStoreSize + userTableSize)/1000,
		tagRuleCount,
		bytes);
	strcpy(buf,StdIntOutput(factEnd-factFree)); // unused facts
	strcpy(buf1,StdIntOutput(textFreeMemKB)); // unused text
	strcpy(buf2,StdIntOutput(free/1000));
	printf("Free %sMB: dict %s fact %s text %sKB \r\n",buf2,StdIntOutput(maxDictEntries-(dictionaryFree-dictionaryBase)),buf,buf1);
	trace = old;
}

void ReloadSystem()
{//   reset the basic system through wordnet but before topics
	InitFacts(); 
	InitDictionary();
	// make sets for the part of speech data
	LoadDictionary();
	InitFunctionSystem();
#ifndef DISCARDTESTING
	InitCommandSystem();
#endif
	ExtendDictionary(); // store labels of concepts onto variables.
	DefineSystemVariables();
	ClearUserVariables();

	if (!ReadBinaryFacts(FopenStaticReadOnly(UseDictionaryFile("facts.bin")))) 
	{
		WORDP safeDict = dictionaryFree;
		ReadFacts(UseDictionaryFile("facts.txt"),0);
		if ( safeDict != dictionaryFree) myexit("dict changed on read of facts");
		WriteBinaryFacts(fopen(UseDictionaryFile("facts.bin"),"wb"),factBase);
	}
	char name[MAX_WORD_SIZE];
	sprintf(name,"%s/systemfacts.txt",livedata);
	ReadFacts(name,0); // part of wordnet, not level 0 build 
	ReadLiveData();  // considered part of basic system before a build
	WordnetLockDictionary();
}

void ReadParams()
{
	char name[100];
	sprintf(name,"%s.txt",language);
	FILE* in = FopenStaticReadOnly(name); // is there a param file for this language
	if (in)
	{
		char word[MAX_WORD_SIZE];
		char buffer[MAX_WORD_SIZE];
		while (fgets(buffer,MAX_WORD_SIZE,in)) // using fgets doesnt require buffers be set up yet
		{
			char* eol = strchr(buffer,'\r');
			if (eol) *eol = 0;
			eol = strchr(buffer,'\n');
			if (eol) *eol = 0;
			eol = strchr(buffer,'=');
			if (eol) *eol = 0;		
			char* ptr = ReadCompiledWord(buffer,word);
			if (!stricmp(word,"hash")) maxHashBuckets = atoi(ptr);
			if (!stricmp(word,"dict")) maxDictEntries = atoi(ptr);
			if (!stricmp(word,"fact")) maxFacts = atoi(ptr);
			if (!stricmp(word,"text")) maxStringBytes = atoi(ptr) * 1000;
			if (!stricmp(word,"buffer"))
			{
				maxBufferLimit = atoi(ptr);
				eol = strchr(ptr,'x');
				if (eol) maxBufferSize = atoi(eol+1) * 1000;
			}
			if (!stricmp(word,"cache"))
			{
				userCacheCount = atoi(ptr);
				eol = strchr(ptr,'x');
				if (eol) userCacheSize = atoi(eol+1) * 1000;
			}
			if (!stricmp(word,"userfacts")) userFactCount = atoi(ptr);
		}
		fclose(in);
	}
}

unsigned int InitSystem(int argc, char * argv[],char* unchangedPath, char* readablePath, char* writeablePath)
{ // this work mostly only happens on first startup, not on a restart
	InitFileSystem(unchangedPath,readablePath,writeablePath);

	// default language English
	P_GetAdjectiveBase = English_GetAdjectiveBase;   
	P_GetAdverbBase = English_GetAdverbBase;
	P_GetPastTense = English_GetPastTense;   
	P_GetPastParticiple = English_GetPastParticiple;   
	P_GetPresentParticiple = English_GetPresentParticiple;   
	P_GetThirdPerson = English_GetThirdPerson;   
	P_GetInfinitive = English_GetInfinitive;   
	P_GetSingularNoun = English_GetSingularNoun;   
	P_GetPluralNoun = English_GetPluralNoun;   
	P_TagIt = English_TagIt;
	P_SetSentenceTense = English_SetSentenceTense;
	strcpy(language,"ENGLISH");

	strcpy(livedata,"LIVEDATA"); // default directory for dynamic stuff
	
	// set default parameters from file if there
	FILE* in = FopenStaticReadOnly("language.txt");
	if (in)
	{
		char buffer[MAX_WORD_SIZE];
		if (fgets(buffer,MAX_WORD_SIZE,in)) 
		{
			char* eol = strchr(buffer,'\r');
			if (eol) *eol = 0;
			eol = strchr(buffer,'\n');
			if (eol) *eol = 0;
			strcpy(language,buffer);
		}
		fclose(in);
	}
	ReadParams();	// default params associated with language form (kept outside of createsystem)
	
    char *evsrv_arg = 0;

	for (int i = 1; i < argc; ++i)
	{
		if (!strnicmp(argv[i],"buffer=",7))  // number of large buffers available  8x80000
		{
			maxBufferLimit = atoi(argv[i]+7); 
			char* size = strchr(argv[i]+7,'x');
			if (size) maxBufferSize = atoi(size+1) *1000;
			if (maxBufferSize < OUTPUT_BUFFER_SIZE)
			{
				printf("Buffer cannot be less than OUTPUT_BUFFER_SIZE of %d\r\n",OUTPUT_BUFFER_SIZE);
				myexit("buffer size less than output buffer size");
			}
		}
	}

	// need buffers for things that run ahead like servers and such.
	maxBufferSize = (maxBufferSize + 63);
	maxBufferSize &= 0xffffffc0; // force 64 bit align on size  
	unsigned int total = maxBufferLimit * maxBufferSize;
	buffers = (char*) malloc(total); // have it around already for messages
	if (!buffers)
	{
		printf("cannot allocate buffer space");
		return 1;
	}
	bufferIndex = 0;
	logmainbuffer = AllocateAlignedBuffer();
	readBuffer = AllocateBuffer();
	joinBuffer = AllocateBuffer();
	newBuffer = AllocateBuffer();
	baseBufferIndex = bufferIndex;

	InitTextUtilities();

    logFilename[0] = 0; 
    sprintf(logFilename,"serverlog%d.txt",port);
    echo = true;

	bool portGiven = false;
	for (int i = 1; i < argc; ++i)
	{
		if (!stricmp(argv[i],"trace")) trace = (unsigned int) -1; 
		else if (!strnicmp(argv[i],"dir=",4)) 
		{
#ifdef WIN32
			if (!SetCurrentDirectory(argv[i]+4))
			{
				printf("unable to change to %s\r\n",argv[i]+4);
			}
#else
			chdir(argv[i]+5);
#endif
		}
		else if (!strnicmp(argv[i],"save=",5)) volleyLimit = atoi(argv[i]+5);

		// memory sizings
		else if (!strnicmp(argv[i],"hash=",5)) 
		{
			maxHashBuckets = atoi(argv[i]+5); // size of hash
			setMaxHashBuckets = true;
		}
		else if (!strnicmp(argv[i],"dict=",5)) maxDictEntries = atoi(argv[i]+5); // how many dict words allowed
		else if (!strnicmp(argv[i],"mark=",5)) maxRefSentence = atoi(argv[i]+5) * 2; // how many xrefs 
		else if (!strnicmp(argv[i],"fact=",5)) maxFacts = atoi(argv[i]+5);  // fact entries
		else if (!strnicmp(argv[i],"text=",5)) maxStringBytes = atoi(argv[i]+5) * 1000; // string bytes in pages
		else if (!strnicmp(argv[i],"cache=",6)) // value of 10x0 means never save user data
		{
			userCacheSize = atoi(argv[i]+6) * 1000;
			char* number = strchr(argv[i]+6,'x');
			if (number) userCacheCount = atoi(number+1);
		}
		else if (!strnicmp(argv[i],"userfacts=",10)) userFactCount = atoi(argv[i]+10); // how many user facts allowed
		else if (!strnicmp(argv[i],"livedata=",9) ) strcpy(livedata,argv[i]+9);
		else if (!strnicmp(argv[i],"language=",9) )
		{
			MakeUpperCopy(language,argv[i]+9);
		}
#ifndef DISCARDCLIENT
		else if (!strnicmp(argv[i],"client=",7)) // client=1.2.3.4:1024  or  client=localhost:1024
		{
			server = false;
			char buffer[MAX_WORD_SIZE];
			strcpy(serverIP,argv[i]+7);
		
			char* portVal = strchr(serverIP,':');
			if ( portVal)
			{
				*portVal = 0;
				port = atoi(portVal+1);
			}

			printf("\r\nEnter client user name: ");
			ReadALine(buffer,stdin);
			printf("\r\n");
			Client(buffer);
			myexit("client ended");
		}  
#endif
#ifndef DISCARDSERVER
        else if (!strnicmp(argv[i], "evsrv:", 6))  evsrv_arg = argv[i];
		else if (!stricmp(argv[i],"local")) server = false; // local standalone
		else if (!stricmp(argv[i],"nouserlog")) userLog = 0;
		else if (!stricmp(argv[i],"userlog")) userLog = 1;
		else if (!stricmp(argv[i],"noserverlog")) serverLog = 0;
		else if (!stricmp(argv[i],"serverlog")) serverLog = 1;
		else if (!strnicmp(argv[i],"interface=",10)) interfaceKind = string(argv[i]+10); // specify interface
		else if (!strnicmp(argv[i],"port=",5))  // be a server
		{
#ifndef EVSERVER
			if (volleyLimit == -1) volleyLimit = DEFAULT_VOLLEY_LIMIT;
#else
            volleyLimit = 0;
#endif
            port = atoi(argv[i]+5); // accept a port=
 #ifndef EVSERVER
            portGiven = true;
            GrabPort(); 
#ifdef WIN32
            PrepareServer();
#endif
#endif
		}
#endif	
	}
#ifndef DISCARDSERVER
#ifdef EVSERVER
    if (server && evsrv_init(interfaceKind, port, evsrv_arg) < 0)  myexit("evsrv_init failed");
#else
#ifndef WIN32
    if (!portGiven && server) GrabPort(); 
#endif
#endif
#endif
	// defaults where not specified
	if (server)
	{
		if (userLog == LOGGING_NOT_SET) userLog = 0;	// default OFF for user if unspecified
		if (serverLog == LOGGING_NOT_SET) serverLog = 1; // default ON for server if unspecified
	}
	else
	{
		if (userLog == LOGGING_NOT_SET) userLog = 1;	// default ON for nonserver if unspecified
		if (serverLog == LOGGING_NOT_SET) serverLog = 1; // default on for nonserver 
	}
#ifndef EVSERVER
	if (volleyLimit == -1) volleyLimit = 1; // write every volley
#else
    volleyLimit = 0;
#endif

	CreateSystem();

	for (int i = 1; i < argc; ++i)
	{
#ifndef DISCARDSCRIPTCOMPILER
		if (!strnicmp(argv[i],"build0=",7))
		{
			sprintf(logFilename,"USERS/build0_log.txt");
			FILE* in = FopenUTF8Write(logFilename);
			if (in) fclose(in);
			ReadTopicFiles(argv[i]+7,BUILD0,NO_SPELL);
 			myexit("build0 complete");
		}  
		if (!strnicmp(argv[i],"build1=",7))
		{
			sprintf(logFilename,"USERS/build1_log.txt");
			FILE* in = FopenUTF8Write(logFilename);
			if (in) fclose(in);
			ReadTopicFiles(argv[i]+7,BUILD1,NO_SPELL);
 			myexit("build1 complete");
		}  
#endif
		if (!stricmp(argv[i],"trace")) trace = (unsigned int) -1; // make trace work on login
	}

#ifndef EVSERVER
	if (server)  Log(SERVERLOG, "\r\n\r\n======== Began server %s on port %d at %s\r\n",version,port,GetTimeInfo());
#else
	if (server) Log(SERVERLOG, "\r\n\r\n======== Began EV server %s on port %d at %s\r\n",version,port,GetTimeInfo());
#endif

	echo = false;

	InitStandalone();
	return 0;
}

void CloseSystem()
{
	FreeAllUserCaches(); // user system
    CloseDictionary();	// dictionary system
    CloseFacts();		// fact system
	CloseBuffers();		// memory system
}


////////////////////////////////////////////////////////
/// INPUT PROCESSING
////////////////////////////////////////////////////////

void ProcessInputFile()
{
	#ifdef WIN32
	DWORD time = 0;
#endif
	while (ALWAYS)
    {
		if (oktest) // self test using OK or WHY as input
		{
			printf("%s\r\n    ",UTF2ExtendedAscii(outBuffer));
			strcpy(inBuffer,(oktest == OKTEST) ? (char*) "OK" : (char*)"why?");
		}
		else if (quitting) return; 
		else if (systemReset) 
		{
			printf("%s\r\n",UTF2ExtendedAscii(outBuffer));
			*computerID = 0;	// default bot
			*inBuffer = 0;		// restart conversation
		}
		else 
		{
			if ((!documentMode || *outBuffer)  && !silent) // if not in doc mode OR we had some output to say - silent when no response
			{
				// output bot response
				if (*botPrefix) printf("%s ",botPrefix);
				if (autonumber) printf("%d: ",inputCount);
			}
			if (showTopic)
			{
				GetActiveTopicName(tmpWord); // will show currently the most interesting topic
				printf("(%s) ",tmpWord);
			}
			if (!silent) printf("%s",UTF2ExtendedAscii(outBuffer));
			if ((!documentMode || *outBuffer) && !silent) printf("\r\n");

			if (showWhy) printf("\r\n"); // line to separate each chunk

			//output user prompt
			if (documentMode || silent) {;} // no prompt in document mode
			else if (*userPrefix) printf("%s ",userPrefix);
			else printf("   >");

			*inBuffer = ' '; // distinguish EMPTY from conversation start 
			
			if (documentMode)
			{
				if (!ReadDocument(inBuffer,sourceFile)) break;
			}
			else if (!ReadALine(inBuffer+1,sourceFile,INPUT_BUFFER_SIZE-1)) break; // end of input

			// reading from file
			if (sourceFile != stdin)
			{
				char word[MAX_WORD_SIZE];
				ReadCompiledWord(inBuffer,word);
				if (!stricmp(word,"#exit") || !stricmp(word,"#stop") || !stricmp(word,"#end")|| !stricmp(word,":exit")  || !stricmp(word,":stop") || !stricmp(word,":end")) break;
				if ((!*word && !documentMode) || *word == '#') continue;
				if (echoSource == SOURCE_ECHO_USER) printf("< %s\r\n",inBuffer);
			}
		}
		PerformChat(loginID,computerID,inBuffer,NULL,outBuffer); // no ip
    }
	fclose(sourceFile);  // to get here, must have been a source file that ended
}

void MainLoop() //   local machine loop
{
    printf("\r\nEnter user name: ");
    ReadALine(inBuffer,stdin);
	printf("\r\n");
	PerformChat(inBuffer,computerID,"",NULL,outBuffer); // unknown bot, no input,no ip
	
	sourceFile = stdin; // keep up the conversation indefinitely
retry:
	ProcessInputFile();
	sourceFile = stdin;
	*inBuffer = 0;
	inBuffer[1] = 0;
	if (!quitting) goto retry;
}

void ResetToPreUser() // prepare for multiple sentences being processed - data lingers over multiple sentences
{
	// limitation on how many sentences we can internally resupply
	globalDepth = 0;
	inputCounter = 0;
	totalCounter = 0;
	itAssigned = theyAssigned = 0;

	//  Revert to pre user-loaded state, fresh for a new user
	ReturnToFreeze();  // dict/fact/strings reverted
	ReestablishBotVariables();
	ResetTopicSystem();
	ResetUser();
	ResetFunctionSystem();
	ResetTokenSystem();

 	//   ordinary locals
	inputSentenceCount = 0;
	globalDepth = 0;
}

void ResetSentence() // read for next sentence to process from raw system level control only
{
	ResetFunctionSystem();
	respondLevel = 0; 
	currentRuleID = NO_REJOINDER;	//   current rule id
 	currentRule = 0;				//   current rule being procesed
	currentRuleTopic = -1;
	ruleErased = false;	
}

void FinishVolley(char* incoming,char* output,char* postvalue)
{
	// massage output going to user
	if (!documentMode)
	{
		strcpy(output,ConcatResult());
		postProcessing = output;
		++outputNest; // this is not generating new output
		OnceCode("$control_post",postvalue);
		--outputNest;
		postProcessing = 0;
		debugger = false; // must be over now

		// nothing he said generated a useful output
		if (!*output && !prepareMode && incoming && *incoming && *incoming != ':' && !regression && !all) 
		{
		}
	
		if (!server) // refresh prompts from a loaded bot since mainloop happens before user is loaded
		{
			WORDP dBotPrefix = FindWord("$botprompt");
			strcpy(botPrefix,(dBotPrefix && dBotPrefix->w.userValue) ? dBotPrefix->w.userValue : (char*)"");
			WORDP dUserPrefix = FindWord("$userprompt");
			strcpy(userPrefix,(dUserPrefix && dUserPrefix->w.userValue) ? dUserPrefix->w.userValue : (char*)"");
		}
		time_t curr = time(0);
		if (regression) curr = 44444444; 
		char* when = GetMyTime(curr);
		if (*incoming) strcpy(timePrior,GetMyTime(curr)); // when we did the last volley
		WriteUserData(curr); 
		// Log the results
		if (userLog)
		{
			GetActiveTopicName(tmpWord); // will show currently the most interesting topic
			if (*incoming && regression) Log(STDUSERLOG,"(%s) %s ==> %s ",tmpWord,TrimSpaces(incoming),TrimSpaces(output)); // simpler format for diff
			else if (!*incoming) Log(STDUSERLOG,"Start: user:%s bot:%s ip:%s rand:%d (%s) %d ==> %s  When:%s Version:%s Build0:%s Build1:%s 0:%s F:%s P:%s ",loginID,computerID,callerIP,randIndex,tmpWord,inputCount,output,when,version,timeStamp0,timeStamp1,timeturn0,timeturn15,timePrior); // conversation start
			else 
			{
				Log(STDUSERLOG,"Respond: user:%s bot:%s ip:%s (%s) %d  %s ==> %s  When:%s ",loginID,computerID,callerIP,tmpWord,inputCount,incoming,output,when);  // normal volley
				if (inputCount == 15 && timeturn15[1]) Log(STDUSERLOG," F:%s ",timeturn15);
			}
			if (!regression && responseIndex)
			{
				Log(STDUSERLOG,"Why: ");
				for (unsigned int i = 0; i < responseIndex; ++i) 
				{
					unsigned int order = responseOrder[i];
					if (!responseData[order].topic) continue;
					char label[MAX_WORD_SIZE];
					unsigned int id = atoi(responseData[order].id+1);
					char* dot = strchr(responseData[order].id+1,'.');
					id |= MAKE_REJOINDERID(atoi(dot+1));
					char* rule = GetRule(responseData[order].topic,id);
					GetLabel(rule,label);
					Log(STDUSERLOG,"%s%s %s ",GetTopicName(responseData[order].topic),responseData[order].id,label);
				}
			}
				Log(STDUSERLOG,"\r\n");
			if (shortPos) 
			{
				Log(STDUSERLOG,"%s",DumpAnalysis(1,wordCount,posValues,"Tagged POS",false,true));
				Log(STDUSERLOG,"\r\n");
			}
		}

		// now convert output separators between rule outputs to space from | for user display result (log has |, user sees space) 
		char* sep = output;
		while ((sep = strchr(sep,'`'))) *sep = ' ';
	}
	else *output = 0;
	if (!documentMode) ResetToPreUser(); // back to empty state before any user
}

void PerformChat(char* user, char* usee, char* incoming,char* ip,char* output)
{ //   primary entrypoint for chatbot -- null incoming treated as conversation start.

    output[0] = 0;
	output[1] = 0;
	*currentFilename = 0;
	bufferIndex = baseBufferIndex; // return to default basic buffers used so far, in case of crash and recovery

    //   case insensitive logins
    static char caller[MAX_WORD_SIZE];
	static char callee[MAX_WORD_SIZE];
	callee[0] = 0;
    caller[0] = 0;
	MakeLowerCopy(callee, usee);
    if (user) 
	{
		strcpy(caller,user);
		//   allowed to name callee as part of caller name
		char* separator = strchr(caller,':');
		if (separator) *separator = 0;
		if (separator && !*usee) MakeLowerCopy(callee,separator+1); // override the bot
		strcpy(loginName,caller); // original name as he typed it

		MakeLowerCopy(caller,caller);
	}
	bool hadIncoming = *incoming != 0 || documentMode;
	while (incoming && *incoming == ' ') ++incoming;	// skip opening blanks

	if (incoming[0] && incoming[1] == '#' && incoming[2] == '!') // naming bot to talk to- and whether to initiate or not - e.g. #!Rosette#my message
	{
		char* next = strchr(incoming+3,'#');
		if (next)
		{
			*next = 0;
			MakeLowerCopy(callee,incoming+3); // override the bot name (including future defaults if such)
			strcpy(incoming+1,next+1);	// the actual message.
			if (!*incoming) incoming = 0;	// login message
		}
	}

    if (trace & TRACE_MATCH) Log(STDUSERLOG,"Incoming data- %s | %s | %s\r\n",caller, (*callee) ? callee : " ", (incoming) ? incoming : "");
 
	bool fakeContinue = false;
	if (callee[0] == '&') // allow to hook onto existing conversation w/o new start
	{
		*callee = 0;
		fakeContinue = true;
	}
    Login(caller,callee,ip); //   get the participants names

	if (systemReset) // drop old user
	{
		systemReset = false;
		ReadNewUser(); 
	}
	else if (!documentMode) 
	{
		// preserve file status reference across this read use of ReadALine
		int BOMvalue = -1; // get prior value
		char oldc;
		int oldCurrentLine;	
		BOMAccess(BOMvalue, oldc,oldCurrentLine); // copy out prior file access and reinit user file access

		char* ptr = GetFileRead(loginID,computerID); // read user file, if any, or get it from cache
		ReadUserData(ptr);		//   now bring in user state
		BOMAccess(BOMvalue, oldc,oldCurrentLine); // restore old BOM values
	}
	// else documentMode
	if (fakeContinue) return;

	if (!ip) ip = "";

	unsigned int ok = true;
    if (!*incoming && !hadIncoming) StartConversation(output); //   begin a conversation
    else  
	{
		if (*incoming == '\r' || *incoming == '\n' || !*incoming) // incoming is blank, make it so
		{
			*incoming = ' ';
			incoming[1] = 0;
		}

		static char copy[INPUT_BUFFER_SIZE];
		strcpy(copy,incoming); // so input trace not contaminated by input revisions
		ok = ProcessInput(copy,output);
	}
	if (!ok) return; // command processed

	FinishVolley(incoming,output,NULL);
}

int Reply() 
{
	withinLoop = 0;
	ResetOutput();
	ResetTopicReply();
	if (documentMode) tokenCount += wordCount;

	if (trace) 
	{
		Log(STDUSERLOG,"\r\n\r\nReply input: ");
		for (unsigned int i = 1; i <= wordCount; ++i) Log(STDUSERLOG,"%s ",wordStarts[i]);
		Log(STDUSERLOG,"\r\n  Pending topics: %s\r\n",ShowPendingTopics());
	}
	unsigned int result = 0;
	int pushed = PushTopic(FindTopicIDByName(GetUserVariable("$control_main")));
	if (pushed < 0) return FAILRULE_BIT;
	if (debugger) DebugHeader("Main");
	AllocateOutputBuffer();
	result = PerformTopic(0,currentOutputBase); //   allow control to vary
	FreeOutputBuffer();
	currentRuleOutputBase = currentOutputBase = NULL;
	if (pushed) PopTopic();
	if (globalDepth) ReportBug("Main code global depth not 0");
	return result;
}

unsigned int ProcessInput(char* input,char* output)
{
	startTimeInfo =  ElapsedMilliseconds();
	lastInputSubstitution[0] = 0;

	//   precautionary adjustments
	char* p = input;
	while ((p = strchr(p,ENDUNIT))) *p = '\'';
  
	char *buffer = TrimSpaces(input);
	size_t len = strlen(buffer);
	if (!len)
	{
		*buffer = ' ';
		buffer[1] = 0;
	}

	if (len >= MAX_MESSAGE) buffer[MAX_MESSAGE-1] = 0; 
#ifndef DISCARDTESTING
	if (*buffer == ':' && IsAlpha(buffer[1]))
	{
		int commanded = COMMANDED;
		Log(STDUSERLOG,"Command: %s\r\n",buffer);
		commanded = DoCommand(buffer,output);

		if (!strnicmp(buffer,":debug",6))
		{
			memmove(input,buffer+7,strlen(buffer));
			if (!stricmp(input,":revert") || !stricmp(input,"revert")) strcpy(input,revertBuffer); 
			buffer = SkipWhitespace(input);
		}
		else if (!strnicmp(buffer,":retry",6) )
		{
			memmove(buffer,buffer+6,strlen(buffer+6) + 1);
			char* more = SkipWhitespace(buffer);
			if (!*more)
			{
				strcpy(input,revertBuffer); 
				buffer = SkipWhitespace(input);
			}
		}
		else if (commanded == BEGINANEW)  
		{ 
			ResetToPreUser();	// back to empty state before user
			StartConversation(buffer);
			return 2; 
		}
		else if (commanded == COMMANDED ) 
		{
			return false; 
		}
		else if (commanded == OUTPUTASGIVEN) return true; 
	}
#endif
	++inputCount;
	if (trace) Log(STDUSERLOG,"\r\n\r\nInput: %d to %s: %s \r\n",inputCount,computerID,input);
	strcpy(currentInput,input);	//   this is what we respond to, literally.

	if (!strncmp(buffer,"... ",4)) buffer += 4;	// a marker from ^input
	else if (!strncmp(buffer,". ",2)) buffer += 2;	//   maybe separator after ? or !

	//   process input now
	char prepassTopic[MAX_WORD_SIZE];
	strcpy(prepassTopic,GetUserVariable("$prepass"));
	nextInput = buffer;

	if (!documentMode) 
	{
		responseIndex = 0;	// clear out data (having left time for :why to work)
		AddHumanUsed(buffer);
		OnceCode("$control_pre");
		if (responseIndex != 0) ReportBug("Not expecting PRE to generate a response")
	}

 	int loopcount = 0;
	while (nextInput && *nextInput && loopcount < 50) // loop on user input sentences
	{
		topicIndex = currentTopicID = 0; // precaution
		DoSentence(prepassTopic); // sets nextInput to next piece
		++inputSentenceCount;
	}
	if (++loopcount > 50) ReportBug("loopcount excess %d %s",loopcount,nextInput)
  
#ifndef DISCARDTESTING
	if (!server) strcpy(revertBuffer,currentInput); // for a possible revert
#endif
	return true;
}

bool PrepassSentence(char* prepassTopic)
{
	if (prepassTopic && *prepassTopic)
	{
		unsigned int topic = FindTopicIDByName(prepassTopic);
		if (topic && !(GetTopicFlags(topic) & TOPIC_BLOCKED))  
		{
			int pushed =  PushTopic(topic); 
			if (pushed < 0) return false;
			ChangeDepth(1,"PrepassSentence");
			PushOutputBuffers();
			if (debugger) DebugHeader("SentencePrePass");
			AllocateOutputBuffer();
			unsigned int result = PerformTopic(0,currentOutputBase); 
			FreeOutputBuffer();
			PopOutputBuffers();
			ChangeDepth(-1,"PrepassSentence");
			if (pushed) PopTopic();
			//   subtopic ending is not a failure.
			if (result & (ENDSENTENCE_BIT | FAILSENTENCE_BIT| ENDINPUT_BIT)) 
			{
				if (result & ENDINPUT_BIT) nextInput = "";
				--inputSentenceCount; // abort this input
				return true; 
			}
			if (prepareMode == PREPARE_MODE || trace || prepareMode == POS_MODE || (prepareMode == PENN_MODE && trace & TRACE_POS)) DumpTokenFlags(); // show revised from prepass
		}
	}
	return false;
}

void DoSentence(char* prepassTopic)
{
	char input[INPUT_BUFFER_SIZE];  // complete input we received
	strcpy(input,nextInput);

	if (all) Log(STDUSERLOG,"\r\n\r\nInput: %s\r\n",input);
	unsigned int oldtrace = trace;
	bool oldecho = echo;
	if (prepareMode == PREPARE_MODE)  echo = true;

    //    generate reply by lookup first
	bool retried = false;
retry:  
	char* start = nextInput; // where we read from
	ResetSentence();			//   ready to accept interjection data from raw system control level
 	PrepareSentence(nextInput,true,true); // user input.. sets nextinput up to continue
	if (PrepassSentence(prepassTopic))  // user input revise and resubmit?  -- COULD generate output and set rejoinders
	{
		trace = oldtrace;
		echo = oldecho;
		return;
	}
	if (prepareMode == PREPARE_MODE) // just do prep work, no actual reply
	{
		trace = oldtrace;
		echo = oldecho;
		return; 
	}

    if (!wordCount && responseIndex != 0) return; // nothing here and have an answer already. ignore this

	if (showTopics)
	{
		bool oldEcho = echo;
		echo = true;
		impliedSet = 0;
		KeywordTopicsCode(NULL);
		for (unsigned int i = 1; i <=  FACTSET_COUNT(0); ++i)
		{
			FACT* F = factSet[0][i];
			WORDP D = Meaning2Word(F->subject);
			WORDP N = Meaning2Word(F->object);
			unsigned int topic = FindTopicIDByName(D->word);
			char* name = GetTopicName(topic);
			Log(STDUSERLOG,"%s (%s) : ",name,N->word);
			//   look at references for this topic
			int start = -1;
			while (GetIthSpot(D,++start)) // find matches in sentence
			{
				// value of match of this topic in this sentence
				for (unsigned int k = positionStart; k <= positionEnd; ++k) 
				{
					if (k != positionStart) Log(STDUSERLOG,"_");
					Log(STDUSERLOG,"%s",wordStarts[k]);
				}
				Log(STDUSERLOG," ");
			}
			Log(STDUSERLOG,"\r\n");
		}
		impliedSet = ALREADY_HANDLED;
		echo = oldEcho;
	}

	if (noReact) return;
	int result =  Reply();
	if (result & RETRYSENTENCE_BIT && !retried) 
	{
		retried = true;	 // allow ONE retry -- issues with this
		--inputSentenceCount;
		char* buf = AllocateBuffer();
		strcpy(buf,nextInput);	// protect future input
		strcpy(start,oldInputBuffer); // copy back current input
		strcat(start," "); 
		strcat(start,buf); // add back future input
		nextInput = start; // retry old input
		FreeBuffer();
		goto retry; // try input again -- maybe we changed token controls...
	}
	if (result & FAILSENTENCE_BIT)  --inputSentenceCount;
	if (result == ENDINPUT_BIT) nextInput = ""; // end future input
}

void OnceCode(const char* which,char* function) //   run before doing any of his input
{
	withinLoop = 0;
	topicIndex = currentTopicID = 0; 
	char* name = (!function || !*function) ? GetUserVariable(which) : function;
	int topic = FindTopicIDByName(name);
	if (!topic) return;
	if (trace & TRACE_MATCH) 
	{
		if (!stricmp(which,"$control_pre")) 
		{
			Log(STDUSERLOG,"\r\nPrePass\r\n");
			if (trace & TRACE_VARIABLE) DumpVariables();
		}
		else 
		{
			Log(STDUSERLOG,"\r\n\r\nPostPass\r\n");
			Log(STDUSERLOG,"Pending topics: %s\r\n",ShowPendingTopics());
		}
	}

	int pushed = PushTopic(topic);
	if (pushed < 0) return;
	if (debugger) DebugHeader(!stricmp(which,"$control_pre") ? (char*) "PrePass" : (char*)"PostPass");
	ruleErased = false;	
	AllocateOutputBuffer();
	PerformTopic(GAMBIT,currentOutputBase);
	FreeOutputBuffer();
	currentRuleOutputBase = currentOutputBase =  NULL;

	if (pushed) PopTopic();
	if (topicIndex) ReportBug("topics still stacked")
	if (globalDepth) ReportBug("Once code %s global depth not 0",name);
	topicIndex = currentTopicID = 0; // precaution
}
		
void AddHumanUsed(const char* reply)
{
	if (humanSaidIndex >= MAX_USED) humanSaidIndex = 0; // chop back //  overflow is unlikely but if he inputs >10 sentences at once, could
    unsigned int i = humanSaidIndex++;
    *humanSaid[i] = ' ';
	size_t len = strlen(reply);
	if (len >= SAID_LIMIT) // too long to save in user file
	{
		strncpy(humanSaid[i]+1,reply,SAID_LIMIT); 
		humanSaid[i][SAID_LIMIT] = 0; 
	}
	else strcpy(humanSaid[i]+1,reply); 
}

void AddBotUsed(const char* reply,unsigned int len)
{
	if (chatbotSaidIndex >= MAX_USED) chatbotSaidIndex = 0; // overflow is unlikely but if he could  input >10 sentences at once
	unsigned int i = chatbotSaidIndex++;
    *chatbotSaid[i] = ' ';
	if (len >= SAID_LIMIT) // too long to save in user file
	{
		strncpy(chatbotSaid[i]+1,reply,SAID_LIMIT); 
		chatbotSaid[i][SAID_LIMIT] = 0; 
	}
	else strcpy(chatbotSaid[i]+1,reply); 
}

bool HasAlreadySaid(char* msg)
{
    if (!*msg) return true; 
    if (Repeatable(currentRule) || GetTopicFlags(currentTopicID) & TOPIC_REPEAT) return false;
	msg = TrimSpaces(msg);
	size_t actual = strlen(msg);
    for (unsigned int i = 0; i < chatbotSaidIndex; ++i) // said in previous recent  volleys
    {
		size_t len = strlen(chatbotSaid[i]+1);
		if (actual > (SAID_LIMIT-3)) actual = len;
        if (!strnicmp(msg,chatbotSaid[i]+1,actual+1)) return true; // actual sentence is indented one (flag for end reads in column 0)
    }
	for (unsigned int i = 0; i  < responseIndex; ++i) // already said this turn?
	{
		size_t len = strlen(responseData[i].response);
		if (actual > (SAID_LIMIT-3)) actual = len;
         if (!strnicmp(msg,responseData[i].response,actual+1)) return true; 
	}
    return false;
}

static void SaveResponse(char* msg)
{
    strcpy(responseData[responseIndex].response,msg); // the response
    responseData[responseIndex].responseInputIndex = inputSentenceCount; // which sentence of the input was this in response to
	responseData[responseIndex].topic = currentTopicID; // what topic wrote this
	sprintf(responseData[responseIndex].id,".%d.%d",TOPLEVELID(currentRuleID),REJOINDERID(currentRuleID));
	if (currentReuseID != -1)
	{
		size_t len = strlen(responseData[responseIndex].id);
		sprintf(responseData[responseIndex].id + len,".%d.%d",TOPLEVELID(currentReuseID),REJOINDERID(currentReuseID));
	}
	responseOrder[responseIndex] = (unsigned char)responseIndex;
    
	unsigned int id = atoi(responseData[responseIndex].id+1);
	char* dot = strchr(responseData[responseIndex].id+1,'.');
	id |= MAKE_REJOINDERID(atoi(dot+1));
		
	responseIndex++;
	if (responseIndex == MAX_RESPONSE_SENTENCES) --responseIndex;

	// now mark rule as used up if we can since it generated text
	SetErase(true); // top level rules can erase whenever they say something
	
	if (showWhy)
	{
		bool oldecho = echo;
		echo = true;
		Log(STDUSERLOG,"=> %s %s%d.%d  %s\r\n",(!UsableRule(currentTopicID,currentRuleID)) ? "-" : "", GetTopicName(currentTopicID,false),TOPLEVELID(currentRuleID),REJOINDERID(currentRuleID),ShowRule(currentRule));
		echo = oldecho;
	}
}

bool AddResponse(char* msg)
{
	if (!msg || !*msg) return false;
	char* buffer = AllocateBuffer();
    size_t len = strlen(msg);
 	if (len > OUTPUT_BUFFER_SIZE)
	{
		ReportBug("response too big %s",msg)
		strcpy(msg+OUTPUT_BUFFER_SIZE-5,"..."); //   prevent trouble
		len = strlen(msg);
	}

    strcpy(buffer,msg);
	Convert2Underscores(buffer,false); // leave new lines alone
	Convert2Blanks(buffer);	// dont keep underscores in output regardless
	*buffer = toUppercaseData[(unsigned char)*buffer]; 

	//   remove spaces before commas (geofacts often have them in city_,_state)
	char* ptr = buffer;
	while (ptr && *ptr)
	{
		char* comma = strchr(ptr,',');
		if (comma && comma != buffer )
		{
			if (*--comma == ' ') memmove(comma,comma+1,strlen(comma));
			ptr = comma+2;
		}
		else if (comma) ptr = comma+1;
		else ptr = 0;
	}

    if (all || HasAlreadySaid(buffer) ) // dont really do this, either because it is a repeat or because we want to see all possible answers
    {
		if (all)
		{
			bool oldecho = echo;
			echo = true;
			Log(STDUSERLOG,"Choice: %s (%s %s)\r\n",buffer,GetTopicName(currentTopicID,false),ShowRule(currentRule));
			echo = oldecho;
		}
        else if (trace) Log(STDUSERLOG,"Rejected: %s already said\r\n",buffer);
        memset(msg,0,len+1); //   kill partial output
		FreeBuffer();
        return false;
    }
    if (trace & TRACE_OUTPUT) Log(STDUSERTABLOG,"Message: %s\r\n",buffer);
	if (debugger) 
	{
		int count = globalDepth;
		while (count--) printf(" ");
		printf("Message: %s\r\n",buffer);
	}

    SaveResponse(buffer);
    memset(msg,0,len+1); // erase all of original message, +  1 extra as leading space
	FreeBuffer();
    return true;
}

char* ConcatResult()
{
    static char  result[OUTPUT_BUFFER_SIZE];
    result[0] = 0;
	for (unsigned int i = 0; i < responseIndex; ++i) 
    {
		unsigned int order = responseOrder[i];
        if (responseData[order].response[0]) 
		{
			char* reply = responseData[order].response;
			size_t len = strlen(reply);
			if (len >= OUTPUT_BUFFER_SIZE)
			{
				ReportBug("overly long reply %s",reply)
				reply[OUTPUT_BUFFER_SIZE-50] = 0;
			}
			AddBotUsed(reply,len);
		}
    }

	//   now join up all the responses as one output into result
	unsigned int size = 0;
	char* starts = AllocateBuffer();
	char* copy = AllocateBuffer();
	for (unsigned int i = 0; i < responseIndex; ++i) 
    {
		unsigned int order = responseOrder[i];
        if (!responseData[order].response[0]) continue;
		char* piece = responseData[order].response;
		size_t len = strlen(piece);
		if ((len + size) >= OUTPUT_BUFFER_SIZE) break;
		if (*result) // add separating space from last unit
		{	
			strcpy(result+size,"`");
			++size;
		}

		// each sentence becomes a transient fact
		char* start = piece;
		char* ptr = piece;

		while (ptr && *ptr) // find sentences of response
		{
			start = ptr;
			char* old = ptr;
			unsigned int count;
			ptr = Tokenize(ptr,count,(char**) starts,false,true);   //   only used to locate end of sentence but can also affect tokenFlags (no longer care)
			char c = *ptr; // is there another sentence after this?
			char d = 0;
			if (c) 
			{
				d = *(ptr-1); // save to restore later
				*(ptr-1) = 0; // kill the separator temporarily
			}

			//   save sentences as facts
			char* out = copy;
			char* at = old-1;
			while (*++at) // copy message and alter some stuff like space or cr lf
			{
				if (*at == '\r' || *at == '\n') {;}
				else *out++ = (*at == ' ') ? '_' : *at;  // fact words want no spaces
			}
			*out = 0;
			if (*copy) // we did copy something, make a fact of it
			{
				char name[MAX_WORD_SIZE];
				sprintf(name,"%s.%s",GetTopicName(responseData[order].topic),responseData[order].id);
				CreateFact(MakeMeaning(StoreWord(copy)),Mchatoutput,MakeMeaning(StoreWord(name)),FACTTRANSIENT);
			}

			// now add data to result to user
			if (c) *(ptr-1) = d; // restore
			len = ptr - start;
			strncpy(result+size,start,len); // no leading or trailing blanks except between sentences.
			size += len;
			result[size] = 0;
		}	
	}

	FreeBuffer();
	FreeBuffer();
    return result;
}

void PrepareSentence(char* input,bool mark,bool user) // set currentInput and nextInput
{
	char* original[MAX_SENTENCE_LENGTH];
	unsigned int mytrace = trace;
	if (prepareMode == PREPARE_MODE) mytrace = 0;
  	ClearWhereInSentence(false);
	memset(unmarked,0,MAX_SENTENCE_LENGTH);
	ResetTokenSystem();

	char* ptr = input;
	tokenFlags |= (user) ? USERINPUT : 0; // remove any question mark

	// skip the ... from ^input() joining
	ptr = SkipWhitespace(ptr);
	if (!strncmp(ptr,"... ",4)) ptr += 4;  
    ptr = Tokenize(ptr,wordCount,wordStarts); 

 	if (tokenFlags & ONLY_LOWERCASE) // force lower case
	{
		for (unsigned int i = 1; i <= wordCount; ++i) 
		{
			if (wordStarts[i][0] != 'I' || wordStarts[i][1]) MakeLowerCase(wordStarts[i]);
		}
	}
	
	// this is the input we currently are processing.
	*oldInputBuffer = 0;
	char* at = oldInputBuffer;
	for (unsigned int i = 1; i <= wordCount; ++i)
	{
		strcpy(at,wordStarts[i]);
		at += strlen(at);
		*at++ = ' ';
	}
	*at = 0;

	// force Lower case on plural start word which has singular meaning (but for substitutes
	if (wordCount)
	{
		char word[MAX_WORD_SIZE];
		MakeLowerCopy(word,wordStarts[1]);
		size_t len = strlen(word);
		if (strcmp(word,wordStarts[1]) && word[1] && word[len-1] == 's') // is a different case and seemingly plural
		{
			WORDP O = FindWord(word,len,UPPERCASE_LOOKUP);
			WORDP D = FindWord(word,len,LOWERCASE_LOOKUP);
			if (D && D->properties & PRONOUN_BITS) {;} // dont consider hers and his as plurals of some noun
			else if (O && O->properties & NOUN) {;}// we know this noun (like name James)
			else
			{
				char* singular = GetSingularNoun(word,true,false);
				D = FindWord(singular);
				if (D && stricmp(singular,word)) // singular exists different from plural, use lower case form
				{
					D = StoreWord(word); // lower case plural form
					if (D->internalBits & UPPERCASE_HASH) AddProperty(D,NOUN_PROPER_PLURAL|NOUN);
					else AddProperty(D,NOUN_PLURAL|NOUN);
					wordStarts[1] = D->word;
				}
			}
		}
	}
 	if (mytrace || prepareMode == PREPARE_MODE)
	{
		if (tokenFlags & USERINPUT) Log(STDUSERLOG,"\r\nOriginal User Input: %s\r\n",input);
		else Log(STDUSERLOG,"\r\nOriginal Chatbot Output: %s\r\n",input);
		Log(STDUSERLOG,"Tokenized: ");
		for (unsigned int i = 1; i <= wordCount; ++i) Log(STDUSERLOG,"%s  ",wordStarts[i]);
		Log(STDUSERLOG,"\r\nTokenControl: ");
		DumpTokenControls(tokenControl);
		Log(STDUSERLOG,"\r\n");
	}
	unsigned int originalCount = wordCount;
	if (mytrace || prepareMode) memcpy(original+1,wordStarts+1,wordCount * sizeof(char*));	// replicate for test

	if (tokenControl & (DO_SUBSTITUTE_SYSTEM|DO_PRIVATE))  
	{
		ProcessSubstitutes();
 		if (mytrace || prepareMode == PREPARE_MODE)
		{
			int changed = 0;
			if (wordCount != originalCount) changed = true;
			for (unsigned int i = 1; i <= wordCount; ++i) if (original[i] != wordStarts[i]) changed = i;
			if (changed)
			{
				Log(STDUSERLOG,"Substituted: ");
				for (unsigned int i = 1; i <= wordCount; ++i) Log(STDUSERLOG,"%s  ",wordStarts[i]);
				Log(STDUSERLOG,"\r\n");
				memcpy(original+1,wordStarts+1,wordCount * sizeof(char*));	// replicate for test
			}
			originalCount = wordCount;
		}
	}
	// test for punctuation not done by substitutes
	char c = (wordCount) ? *wordStarts[wordCount] : 0;
	if (c == '?' || c == '!') 
	{
		tokenFlags |= (c == '?') ? QUESTIONMARK : EXCLAMATIONMARK;
		--wordCount;
	}  
	
	// if 1st token is an interjection DO NOT allow this to be a question
	if (wordCount && wordStarts[1] && *wordStarts[1] == '~' && !(tokenControl & NO_INFER_QUESTION)) 
		tokenFlags &= -1 ^ QUESTIONMARK;

	// special lowercasing of 1st word if it COULD be AUXVERB and is followed by pronoun - avoid DO and Will and other confusions
	if (wordCount > 1 && IsUpperCase(*wordStarts[1]))
	{
		WORDP X = FindWord(wordStarts[1],0,LOWERCASE_LOOKUP);
		if (X && X->properties & AUX_VERB)
		{
			WORDP Y = FindWord(wordStarts[2]);
			if (Y && Y->properties & PRONOUN_BITS) wordStarts[1] = X->word;
		}
	}

	if (tokenControl & DO_PROPERNAME_MERGE && wordCount)  ProcessCompositeName();   
 	if (tokenControl & DO_NUMBER_MERGE && wordCount)  ProcessCompositeNumber(); //   numbers AFTER titles, so they dont change a title
 	if (mytrace || prepareMode == PREPARE_MODE) 
	{
		int changed = 0;
		if (wordCount != originalCount) changed = true;
		for (unsigned int i = 1; i <= wordCount; ++i) if (original[i] != wordStarts[i]) changed = i;
		if (changed)
		{
			if ((tokenControl & (DO_PROPERNAME_MERGE | DO_NUMBER_MERGE)) == (DO_PROPERNAME_MERGE | DO_NUMBER_MERGE)) 
				Log(STDUSERLOG,"Name/Number-merged Input: ");
			else if (tokenControl & DO_PROPERNAME_MERGE) Log(STDUSERLOG,"Name-merged: ");
			else Log(STDUSERLOG,"Number-merged Input: ");
			for (unsigned int i = 1; i <= wordCount; ++i) Log(STDUSERLOG,"%s  ",wordStarts[i]);
			Log(STDUSERLOG,"\r\n");
			memcpy(original+1,wordStarts+1,wordCount * sizeof(char*));	// replicate for test
			originalCount = wordCount;
		}
	}

	// spell check unless 1st word is already a known interjection. Will become standalone sentence
	if (tokenControl & DO_SPELLCHECK && wordCount && *wordStarts[1] != '~')  
	{
		if (SpellCheckSentence())
		{
			tokenFlags |= DO_SPELLCHECK;
			if (tokenControl & (DO_SUBSTITUTE_SYSTEM|DO_PRIVATE))  ProcessSubstitutes();
		}
 		if (mytrace || prepareMode == PREPARE_MODE)
		{
 			int changed = 0;
			if (wordCount != originalCount) changed = true;
			for (unsigned int i = 1; i <= wordCount; ++i) if (original[i] != wordStarts[i]) changed = i;
			if (changed)
			{
				Log(STDUSERLOG,"Spelling fixed: ");
				for (unsigned int i = 1; i <= wordCount; ++i) Log(STDUSERLOG,"%s  ",wordStarts[i]);
				Log(STDUSERLOG,"\r\n");
			}
		}
	}

	if (echoSource == SOURCE_ECHO_LOG) 
	{
		bool oldecho = echo;
		echo = true;
		Log(STDUSERLOG,"  => ");
		for (unsigned int i = 1; i <= wordCount; ++i) Log(STDUSERLOG,"%s  ",wordStarts[i]);
		Log(STDUSERLOG,"\r\n");
		echo = oldecho;
	}
	nextInput = ptr;	//   allow system to overwrite input here
 
	if (tokenControl & DO_INTERJECTION_SPLITTING && wordCount > 1 && *wordStarts[1] == '~') // interjection. handle as own sentence
	{
		// formulate an input insertion
		char buffer[BIG_WORD_SIZE];
		*buffer = 0;
		for (unsigned int i = 2; i <= wordCount; ++i)
		{
			strcat(buffer,wordStarts[i]);
			strcat(buffer," ");
		}
		if (tokenFlags & QUESTIONMARK) strcat(buffer,"? ");
		else if (tokenFlags & EXCLAMATIONMARK) strcat(buffer,"! ");
		else strcat(buffer,". ");
		char* end = buffer + strlen(buffer);
		strcpy(end,nextInput); // a copy of rest of input
		strcpy(nextInput,buffer); // unprocessed user input is here
		ptr = nextInput;
		wordCount = 1;
		tokenFlags |= DO_INTERJECTION_SPLITTING;
	}

	wordStarts[wordCount+1] = 0; // visible end of data in debug display
	wordStarts[wordCount+2] = 0;

    if (mark && wordCount) MarkAllImpliedWords();

	nextInput = SkipWhitespace(nextInput);
    moreToCome = strlen(nextInput) > 0;	   
	moreToComeQuestion = (strchr(nextInput,'?') != 0);
	char nextWord[MAX_WORD_SIZE];
	ReadCompiledWord(nextInput,nextWord);
	WORDP next = FindWord(nextWord);
	if (next && next->properties & QWORD) moreToComeQuestion = true; // assume it will be a question (misses later ones in same input)
	if (prepareMode == PREPARE_MODE || trace || prepareMode == POS_MODE || (prepareMode == PENN_MODE && trace & TRACE_POS)) DumpTokenFlags();
}

#ifndef NOMAIN
int main(int argc, char * argv[]) 
{
	if (InitSystem(argc,argv)) myexit("failed to load memory\r\n");

    if (!server) MainLoop();
#ifndef DISCARDSERVER
    else
    {
#ifdef EVSERVER
        if (evsrv_run() == -1) Log(SERVERLOG, "evsrv_run() returned -1");
#else
        InternetServer();
#endif
    }
#endif
	CloseSystem();
	myexit("shutdown complete");
}
#endif
// markSystem.cpp - annotates the dictionary with what words/concepts are active in the current sentence

#include "common.h"

#ifdef INFORMATION

For every word in a sentence, the word knows it can be found somewhere in the sentence, and there is a 64-bit field of where it can be found in that sentence.
The field is in a hashmap and NOT in the dictionary word, where it would take up excessive memory.

Adjectives occur before nouns EXCEPT:
	1. object complement (with some special verbs)
	2. adjective participle (sometimes before and sometimes after)

In a pattern, an author can request:
	1. a simple word like bottle
	2. a form of a simple word non-canonicalized like bottled or apostrophe bottle
	3. a WordNet concept like bottle~1 
	4. a set like ~dead or :dead

For #1 "bottle", the system should chase all upward all sets of the word itself, and all
WordNet parents of the synset it belongs to and all sets those are in. 

Marking should be done for the original and canonical forms of the word.

For #2 "bottled", the system should only chase the original form.

For #3 "bottle~1", this means all words BELOW this in the wordnet hierarchy not including the word
"bottle" itself. This, in turn, means all words below the particular synset head it corresponds to
and so instead becomes a reference to the synset head: "0173335n" or some such.

For #4 "~dead", this means all words encompassed by the set ~dead, not including the word ~dead.

So each word in an input sentence is scanned for marking. 
the actual word gets to see what sets it is in directly. 
Thereafter the system chases up the synset hierarchy fanning out to sets marked from synset nodes.

#endif
static unsigned int whereFreeList = 0;
static unsigned int tempList = 0;
static unsigned int triedFreeList = 0;

unsigned int maxRefSentence = MAX_XREF_SENTENCE  * 2;

// mark debug tracing
bool showMark = false;
static unsigned int markLength = 0; // prevent long lines in mark listing trace
#define MARK_LINE_LIMIT 80

char unmarked[MAX_SENTENCE_LENGTH]; // can completely disable a word from mark recognition
unsigned int tempc = 0;
MEANING* GetTemps(WORDP D)
{
	if (D->temps) return (MEANING*) Index2String(D->temps); // we have an active temp (valid for duration of VOLLEY)

	unsigned char* data = (unsigned char*) AllocateString(NULL,4 * sizeof(MEANING),false,true); // factback ptr, whereinfo for words, linked list of temps allocated
	if (!data) return NULL;
	++tempc;
	MEANING* means = (MEANING*)data;
	means[FACTBACK] = 0;
	means[WHEREINSENTENCE] = 0;
	means[USEDTEMPSLIST] = tempList;		// link back - we have a list threaded thru the temps triples
	means[TRIEDBITS] = 0;
	tempList = MakeMeaning(D);  
	D->temps = String2Index((char*)data);

	return means;
}

void FreeTemps() // release the temps list ptrs
{
	while (tempList) // list of words that have templist attached
	{
		WORDP D = Meaning2Word(tempList);
		unsigned int mean = D->temps;
		if (!mean)
		{
			tempList = 0;
			break;
		}
		MEANING* means = (MEANING*) Index2String(mean); // the temp set
		tempList = means[USEDTEMPSLIST];
		D->temps = 0;
		--tempc;
	}
	tempc =  0;
}

unsigned char* AllocateWhereInSentence(WORDP D)
{
	MEANING* set = GetTemps(D);
	if (!set) return NULL;
		
	// get where chunk
	unsigned char* data;
	if (whereFreeList)
	{
		data = (unsigned char*) Index2String(whereFreeList);
		unsigned int* tmp = (unsigned int*) data;
		whereFreeList = *tmp;
	}
	else 
	{
		data = (unsigned char*) AllocateString(NULL,maxRefSentence,0,false);
		if (!data) return NULL;
		++xrefCount;
	}
	memset(data,0xff,maxRefSentence);

	// store where in the temps data
	set[WHEREINSENTENCE] = String2Index((char*) data);

	return data; // returns past hidden field
}

unsigned char* GetWhereInSentence(WORDP D) 
{
	if (!D->temps) return NULL; // where cache is not up to date
	MEANING* set = GetTemps(D);
	if (!set) return NULL;
	unsigned int index = set[WHEREINSENTENCE];
	if (!index) return NULL;
	return (unsigned char*) Index2String(index); 
}
static void ClearTemps(WORDP D, uint64 junk)
{
	D->temps = 0;
}

char* holdFreeString = 0;
WORDP holdFreeDict = 0;

void ClearWhereInSentence(bool fullClear) // erases both the WHEREINSENTENCE and the TRIEDBITS forms
{
	unsigned int xlist = tempList;
	unsigned int freedWhereCount = 0;
	unsigned int freedTriedCount = 0;
	while (xlist) // list of words that have templist attached (some have where info and some may have factback info)
	{
		WORDP D = Meaning2Word(xlist);
		unsigned int mean = D->temps;
		if (!mean)
		{
			static int did = false;
			if (!did) ReportBug("Bad freeing of xlist\r\n");
			did = true;
			triedFreeList = whereFreeList = 0;
			WalkDictionary(ClearTemps,0); // drop all transient data completely
			break;
		}
		MEANING* tempset = (MEANING*) Index2String(mean); // the temp set
		xlist = tempset[USEDTEMPSLIST];

		// do the WHEREINSENTENCE chunks
		MEANING where = tempset[WHEREINSENTENCE];
		if (where) // clear them and hook them up
		{
			tempset[WHEREINSENTENCE] = 0; // cleared
			MEANING* means = (MEANING*) Index2String(where);
			*means = whereFreeList;
			whereFreeList = where;
			++freedWhereCount; 
		}

		// do the TRIEDBITS chunks
		where = tempset[TRIEDBITS];
		if (where) // clear them and hook them up
		{
			++freedTriedCount;
			tempset[TRIEDBITS] = 0; // cleared
			MEANING* means = (MEANING*) Index2String(where);
			*means = triedFreeList;
			triedFreeList = where;
		}
	}

	if (fullClear) triedFreeList = whereFreeList = 0;
	holdFreeString = stringFree;
	holdFreeDict = dictionaryFree;
xrefCount = 0;
}

void SetTried(WORDP D,uint64 bits)
{
	unsigned char* data;
	MEANING* list = GetTemps(D);
	if (!list) return;
	if (list[TRIEDBITS]) // have one, just update it 
	{
		data = (unsigned char*) Index2String(list[TRIEDBITS]);
		uint64* data1 = (uint64*) data;
		*data1 = bits;
		return;
	}
	
	// allocate a new one
	if (triedFreeList) // reusable ones
	{
		data = (unsigned char*) Index2String(triedFreeList);
		unsigned int* tmp = (unsigned int*) data;
		triedFreeList = *tmp;
	}
	else  data = (unsigned char*) AllocateString(NULL,64,0,true);
	if (!data) return;

	// store where in the temps data
	list[TRIEDBITS] = String2Index((char*) data);

	uint64* data1 = (uint64*) data;
	*data1 = bits;
}

uint64 GetTried(WORDP D)
{
	if (!D->temps) return 0; // where cache is not up to date
	MEANING* set = GetTemps(D);
	if (!set) return 0;
	unsigned int index = set[TRIEDBITS];
	if (!index) return 0;
	unsigned char* data = (unsigned char*) Index2String(index); 
	uint64* bits = (uint64*) data;
	return *bits;
}

void RemoveMatchValue(WORDP D, unsigned int position)
{
	unsigned char* data = GetWhereInSentence(D);
	if (!data) return;
	for (unsigned int i = 0; i < maxRefSentence; i += 2)
	{
		if (data[i] == position) 
		{
			if (trace) Log(STDUSERLOG,"unmark %s @word %d  ",D->word,position);
			memmove(data+i,data+i+2,(maxRefSentence - i - 2)); 
			break;
		}
	}
}

void MarkWordHit(WORDP D, unsigned int start,unsigned int end)
{	//   keep closest to start at bottom, when run out, drop later ones 
    if (!D || !D->word) return;
	if (end > wordCount) end = wordCount;    
	if (start > wordCount) 
	{
		ReportBug("save position is too big")
		return;
	}
	// diff < 0 means peering INSIDE a multiword token before last word
	// we label END as the word before it (so we can still see next word) and START as the actual multiword token
 	unsigned char* data = GetWhereInSentence(D);
    if (!data) data = AllocateWhereInSentence(D);
	if (!data) return;

	bool added = false;
	for (unsigned int i = 0; i < maxRefSentence; i += 2)
	{
		if (data[i] == 0) // CANNOT BE TRUE
		{
			static bool did = false;
			if (!did) ReportBug("illegal whereref for %s at %d\r\n",D->word,inputCount);
			did = true;
		}
		if (data[i] == start) 
		{
			if (end > data[i+1])
			{
				data[i+1] = (unsigned char)end; 
				added = true;
			}
			break; // we are already here
		}
		else if (data[i] > start) 
		{
			memmove(data+i+2,data+i,maxRefSentence - i - 2);
			data[i] = (unsigned char)start;
			data[i+1] = (unsigned char)end;
			added = true;
			break; // data inserted here
		}
	}

	if (( trace & (TRACE_PREPARE|TRACE_HIERARCHY)  || prepareMode == PREPARE_MODE ) && added)  
	{
		markLength += D->length;
		if (markLength > MARK_LINE_LIMIT)
		{
			markLength = 0;
			Log(STDUSERLOG,"\r\n");
			Log(STDUSERTABLOG,"");
		}
		Log(STDUSERLOG,(D->systemFlags & TOPIC) ? " +T%s " : " +%s",D->word);
		Log(STDUSERLOG,(start != end) ? "(%d-%d)": "(%d) ",start,end);
	}
}

unsigned int GetIthSpot(WORDP D,unsigned int i)
{
    if (!D) return 0; //   not in sentence
	unsigned char* data = GetWhereInSentence(D);
	if (!data) return 0;
	i *= 2;
	if (i >= maxRefSentence) return 0; // at end
	positionStart = data[i];
	if (positionStart == 0xff) return 0;
	positionEnd = data[i+1];
	if (positionEnd > wordCount)
	{
		static bool did = false;
		if (!did) ReportBug("Getith out of range %s at %d\r\n",D->word,inputCount);
		did = true;
	}
    return positionStart;
}

unsigned int GetNextSpot(WORDP D,int start,unsigned int &positionStart,unsigned int& positionEnd, bool reverse)
{//   spot can be 1-31,  range can be 0-7 -- 7 means its a string, set last marker back before start so can rescan
	//   BUG - we should note if match is literal or canonical, so can handle that easily during match eg
	//   '~shapes matches square but not squares (whereas currently literal fails because it is not ~shapes
    if (!D) return 0; //   not in sentence
	unsigned char* data = GetWhereInSentence(D);
	if (!data) return 0;
	
	unsigned int i;
	positionStart = 0;
	for (i = 0; i < maxRefSentence; i += 2)
	{
		unsigned char at = data[i];
		if (unmarked[at]){;}
		else if (reverse)
		{
			if (at < start) 
			{
				positionStart = at;
				positionEnd = data[i+1];
				if (positionEnd > wordCount)
				{
					static bool did = false;
					if (!did) ReportBug("Getith out of range %s at %d\r\n",D->word,inputCount);
					did = true;
				}
			}
			else return positionStart;
		}
		else if (at > start)
		{
			if (at == 0xff) return 0; // end of data going forward
			positionStart = at;
			positionEnd = data[i+1];
			if (positionEnd > wordCount)
			{
				static bool did = false;
				if (!did) ReportBug("Getith out of range %s at %d\r\n",D->word,inputCount);
				did = true;
			}
			return positionStart;
		}
	}
    return 0;
}

static int MarkSetPath(MEANING M, unsigned int start, unsigned  int end, unsigned int depth, bool canonical) //   walks set hierarchy
{//   travels up concept/class sets only, though might start out on a synset node or a regular word
	unsigned int flags = M & ESSENTIAL_FLAGS;
	if (!flags) flags = ESSENTIAL_FLAGS;
	WORDP D = Meaning2Word(M);
	unsigned int index = Meaning2Index(M); // always 0 for a synset or set
	
	// check for any repeated accesses of this synset or set or word
	uint64 offset = 1 << index;
	uint64 tried = GetTried(D);
 	if (D->inferMark == inferMark) // been thru this word recently
	{
		if (*D->word == '~') return -1;	// branch is marked
		if (tried & offset)	return -1;	// word synset done this branch already
	}
	else //   first time accessing, note recency and clear tried bits
	{
		D->inferMark = inferMark;
		if (*D->word != '~') 
		{
			SetTried(D,0);
			tried = 0;
		}
	}
 	if (*D->word != '~') SetTried(D,tried |offset);

	int result = 0;
	FACT* F = GetSubjectHead(D); 
	while (F)
	{
		if (F->verb == Mmember) // ~concept members and word equivalent
		{
			char word[MAX_WORD_SIZE];
			char* fact;
			if (trace == TRACE_HIERARCHY)  
			{
				fact = WriteFact(F,false,word); // just so we can see it
				unsigned int hold = globalDepth;
				globalDepth = depth;
				Log(STDUSERTABLOG,"%s   ",fact); // \r\n
				globalDepth = hold;
			}
			unsigned int restrict = F->subject & TYPE_RESTRICTION;
			if (restrict && !(restrict & flags)) {;} // type restriction in effect for this concept member
			else if (canonical && F->flags & ORIGINAL_ONLY) {;} // incoming is not original words and must be

			//   index meaning restriction (0 means all)
			else if (index == Meaning2Index(F->subject)) // match generic or exact subject 
			{
				// test for word not included in set
				WORDP E = Meaning2Word(F->object); // this is a topic or concept
				bool mark = true;
				if (E->internalBits & HAS_EXCLUDE) // set has some members it does not want
				{
					FACT* G = GetObjectHead(E);
					while (G)
					{
						if (G->verb == Mexclude) // see if this is marked for this position, if so, DONT trigger topic
						{
							WORDP S = Meaning2Word(G->subject);
							unsigned int positionStart,positionEnd;
							if (GetNextSpot(S,start-1,positionStart,positionEnd) && positionStart == start && positionEnd == end)
							{
								mark = false;
								break;
							}
						}
						G = GetObjectNext(G);
					}
				}

				if (mark)
				{
					MarkWordHit(E,start,end);
					if (MarkSetPath(F->object,start,end,depth+1,canonical) != -1) result = 1; // someone marked
				}
			}
		}
		F = GetSubjectNext(F);
	}
	return result;
}

static void RiseUp(MEANING M,unsigned int start, unsigned int end,unsigned int depth,bool canonical) //   walk wordnet hierarchy above a synset node
{	// M is always a synset head 
	M &= -1 ^ SYNSET_MARKER;
	unsigned int index = Meaning2Index(M);
	WORDP D = Meaning2Word(M);
	WORDP X;
	char word[MAX_WORD_SIZE];
	sprintf(word,"%s~%d",D->word,index);
	X = FindWord(word,0,PRIMARY_CASE_ALLOWED);
	if (X) 	MarkWordHit(X,start,end); // direct reference in a pattern

	// now spread and rise up
	if (MarkSetPath(M,start,end,depth,canonical) == -1) return; // did the path
	FACT* F = GetSubjectHead(D); 
	while (F)
	{
		if (F->verb == Mis && (index == 0 || F->subject == M)) RiseUp(F->object,start,end,depth+1,canonical); // allowed up
		F = GetSubjectNext(F);
	}
}

static void MarkSequenceTitleFacts(MEANING M, unsigned int start, unsigned int end,bool canonical) // title phrases in sentence
{
    if (!M) return;
	WORDP D = Meaning2Word(M);
	if (D->properties & NOUN_TITLE_OF_WORK && canonical) return; // accidental canonical match. not intended

	if (D->properties & PART_OF_SPEECH) // mark pos data
	{
		uint64 bit = START_BIT;
		for (int j = 63; j >= 0; --j)
		{
			if (D->properties & bit) MarkFacts(posMeanings[j],start,end,canonical,(D->properties & NOUN_TITLE_OF_WORK && !canonical) ? false : true); // treat original title as a full normal word
			bit >>= 1;
		}
	}

	MarkFacts(M,start,end,canonical,true);
}

void MarkFacts(MEANING M,unsigned int start, unsigned int end,bool canonical,bool sequence) 
{ // M is always a word or sequence from a sentence

    if (!M) return;
	WORDP D = Meaning2Word(M);
	if (!sequence || D->properties & (PART_OF_SPEECH|NOUN_TITLE_OF_WORK|NOUN_HUMAN) || D->systemFlags & PATTERN_WORD) MarkWordHit(D,start,end); // if we want the synset marked, RiseUp will do it.
	int result = MarkSetPath(M,start,end,0,canonical); // generic membership of this word all the way to top
	if (sequence && result == 1) MarkWordHit(D,start,end); // if we want the synset marked, RiseUp will do it.
	WORDP X;
	char word[MAX_WORD_SIZE];
	if (M & NOUN) // BUG- this wont work up the ontology, only at the root of what the script requests
	{
		sprintf(word,"%s~n",D->word);
		X = FindWord(word,0,PRIMARY_CASE_ALLOWED);
		if (X) 	MarkWordHit(X,start,end); // direct reference in a pattern
	}
	if (M & VERB)
	{
		sprintf(word,"%s~v",D->word);
		X = FindWord(word,0,PRIMARY_CASE_ALLOWED);
		if (X) 	MarkWordHit(X,start,end); // direct reference in a pattern
	}
	if (M & ADJECTIVE)
	{
		sprintf(word,"%s~a",D->word);
		X = FindWord(word,0,PRIMARY_CASE_ALLOWED);
		if (X) 	MarkWordHit(X,start,end); // direct reference in a pattern
	}
	if (M & ADVERB)
	{
		sprintf(word,"%s~b",D->word);
		X = FindWord(word,0,PRIMARY_CASE_ALLOWED);
		if (X) 	MarkWordHit(X,start,end); // direct reference in a pattern
	}
	if (M & PREPOSITION)
	{
		sprintf(word,"%s~p",D->word);
		X = FindWord(word,0,PRIMARY_CASE_ALLOWED);
		if (X) 	MarkWordHit(X,start,end); // direct reference in a pattern
	}

	//   now follow out the allowed synset hierarchies 
	unsigned int index = Meaning2Index(M);
	unsigned int size = GetMeaningCount(D);
	uint64 flags = M & ESSENTIAL_FLAGS;
	if (!flags) flags = ESSENTIAL_FLAGS; // unmarked ptrs can rise all branches
	for  (unsigned int k = 1; k <= size; ++k) 
	{
		M = GetMeaning(D,k); // it is a flagged meaning unless it self points

		// walk the synset words and see if any want vague concept matching like dog~~
		MEANING T = M; // starts with basic meaning
		unsigned int n = (index && k != index) ? 80 : 0;	// only on this meaning or all synset meanings 
		while (n < 50) // insure not infinite loop
		{
			WORDP X = Meaning2Word(T);
			unsigned int ind = Meaning2Index(T);
			sprintf(word,"%s~~",X->word);
			WORDP V = FindWord(word,0,PRIMARY_CASE_ALLOWED);
			if (V) 	MarkWordHit(V,start,end); // direct reference in a pattern
			if (!ind) break;	// has no meaning index
			T = GetMeanings(X)[ind];
			if (!T)
				break;
			if ((T & MEANING_BASE) == (M & MEANING_BASE)) break; // end of loop
			++n;
		}

		M = (M & SYNSET_MARKER) ? MakeMeaning(D,k) : GetMaster(M); // we are the master itself or we go get the master
		RiseUp(M,start,end,0,canonical); // allowed meaning pos (self ptrs need not rise up)
	}
}

static void SetSequenceStamp() //   mark words in sequence, original and canonical (but not mixed) - detects proper name potential up to 5 words
{
	char* rawbuffer = AllocateBuffer();
	char* canonbuffer1 = AllocateBuffer();
	unsigned int oldtrace = trace;
	unsigned int usetrace = trace;
	char* buffer2 = AllocateBuffer();
	if (trace & TRACE_PREPARE || prepareMode == PREPARE_MODE) 
	{
		Log(STDUSERLOG,"\r\n    sequences=\r\n");
		usetrace = (unsigned int) -1;
	}

	//   consider all sets of up to 3-in-a-row 
	int limit = ((int)endSentence) - 1;
	for (int i = startSentence; i <= limit; ++i)
	{
		if (!IsAlphaOrDigit(*wordStarts[i])) continue; // we only composite words, not punctuation or quoted stuff

		//   set base phrase
		*rawbuffer = 0;
		canonbuffer1[0] = 0;
		strcat(rawbuffer,wordStarts[i]);
		strcat(canonbuffer1,wordCanonical[i]);
       
		//   fan out for addon pieces
		unsigned int k = 0;
		int index = 0;
		uint64 logbase = logCount; // see if we logged anything
		while ((++k + i) <= endSentence)
		{
	
			strcat(rawbuffer,"_");
			strcat(canonbuffer1,"_");
			strcat(rawbuffer,wordStarts[i+k]);
			strcat(canonbuffer1,wordCanonical[i+k]);

			if (!IsAlphaOrDigit(*wordStarts[i+k])) break; // we only composite words, not punctuation or quoted stuff except we can include them as part of something
			NextinferMark();

			// for now, accept upper and lower case forms of the decomposed words for matching
			// storeword instead of findword because we normally dont store keyword phrases in dictionary
			MakeLowerCopy(buffer2,rawbuffer);
			WORDP D = FindWord(buffer2,0,LOWERCASE_LOOKUP); 
			if (D)
			{
				trace = (D->subjectHead || D->systemFlags & PATTERN_WORD || D->properties & PART_OF_SPEECH)  ? usetrace : 0; // being a subject head means belongs to some set. being a marked word means used as a keyword
				MarkFacts(MakeMeaning(D),i,i+k,false,true); 
			}
			MakeUpperCopy(buffer2,rawbuffer);
			D = FindWord(buffer2,0,UPPERCASE_LOOKUP);
			if (D)
			{
				trace = (D->subjectHead || D->systemFlags & PATTERN_WORD || D->properties & PART_OF_SPEECH)  ? usetrace : 0;
				MarkSequenceTitleFacts(MakeMeaning(D),i,i+k,false);
			}
			MakeLowerCopy(buffer2,canonbuffer1);
			D = FindWord(buffer2,0,LOWERCASE_LOOKUP);
			if (D) 
			{
				trace = (D->subjectHead  || D->systemFlags & PATTERN_WORD || D->properties & PART_OF_SPEECH)  ? usetrace : 0;
				MarkFacts(MakeMeaning(D),i,i+k,true,true); 
			}
			MakeUpperCopy(buffer2,canonbuffer1);
			D = FindWord(buffer2,0,UPPERCASE_LOOKUP);
			if (D)
			{
				trace = (D->subjectHead  || D->systemFlags & PATTERN_WORD || D->properties & PART_OF_SPEECH)  ? usetrace : 0;
				MarkSequenceTitleFacts(MakeMeaning(D),i,i+k,true); 
			}
			if (logCount != logbase && usetrace)  Log(STDUSERLOG,"\r\n"); // if we logged something, separate
			
			if (++index >= SEQUENCE_LIMIT) break; //   up thru 5 words in a phrase
		}
	}
	trace = oldtrace;
	FreeBuffer();
	FreeBuffer();
	FreeBuffer();
}

static void StdMark(MEANING M, unsigned int start, unsigned int end) 
{
	if (!M) return;
	MarkFacts(M,start,end);		//   the basic word
	WORDP D = Meaning2Word(M);
	if (D->systemFlags & TIMEWORD && !(D->properties & PREPOSITION)) MarkFacts(MakeMeaning(Dtime),start,end);
}

void MarkAllImpliedWords()
{
	ChangeDepth(1,"MarkAllImpliedWords");
	unsigned int i;
 	for (i = 1; i <= wordCount; ++i)  capState[i] = IsUpperCase(*wordStarts[i]); // note cap state
	TagIt(); // pos tag and maybe parse

	if ( prepareMode == POS_MODE || prepareMode == PENN_MODE || prepareMode == POSVERIFY_MODE  || prepareMode == POSTIME_MODE || tokenControl & NO_MARK) 
	{
		ChangeDepth(-1,"MarkAllImpliedWords");
		return;
	}

    if (trace & TRACE_PREPARE || prepareMode == PREPARE_MODE) Log(STDUSERLOG,"\r\nConcepts: \r\n");
 	if (showMark) Log(STDUSERLOG,"----------------\r\n");
	markLength = 0;
	
	//   now mark every word in sentence
    for (i = startSentence; i <= endSentence; ++i) //   mark that we have found this word, either in original or canonical form
    {
		if (ignoreWord[i]) continue;
		char* original =  wordStarts[i];

		if (showMark) Log(STDUSERLOG,"\r\n");
		NextinferMark(); // blocks circular fact marking.
 		if (trace  & (TRACE_HIERARCHY | TRACE_PREPARE) || prepareMode == PREPARE_MODE) Log(STDUSERLOG,"\r\n%d: %s raw= ",i,original);
	
		uint64 flags = posValues[i];
		if (flags & ADJECTIVE_NOUN) // transcribe back to noun
		{
			MarkFacts(MadjectiveNoun,i,i); 
			flags &= -1 ^ ADJECTIVE_NOUN;
			if (originalLower[i]) flags |= originalLower[i]->properties & (NOUN_SINGULAR|NOUN_PLURAL|NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL);
		}
		finalPosValues[i] = flags; // these are what we finally decided were correct pos flags from tagger
		// put back non-tagger generalized forms of bits
		if (flags & NOUN_BITS) finalPosValues[i] |= NOUN;
		if (flags & (VERB_TENSES | NOUN_INFINITIVE| NOUN_GERUND)) finalPosValues[i] |= VERB;
		if (flags & AUX_VERB_BITS) finalPosValues[i] |= AUX_VERB;
		if (flags & ADJECTIVE_BITS) finalPosValues[i] |= ADJECTIVE;
		if (flags & ADVERB_BITS) finalPosValues[i] |= ADVERB;

		MarkTags(i);
#ifndef DISCARDPARSER
		MarkRoles(i);
#endif
	
		// mark general number property
		if (finalPosValues[i] & ( NOUN_NUMBER | ADJECTIVE_NUMBER))  
		{
			MarkFacts(Mnumber,i,i); 
			//   handle finding fractions as 3 token sequence  mark as placenumber 
			if (*wordStarts[i+1] == '/' && wordStarts[i+1][1] == 0 && finalPosValues[i+2] & (NOUN_NUMBER | ADJECTIVE_NUMBER))
			{
				MarkFacts(MakeMeaning(Dplacenumber),i,i);  
				if (trace & TRACE_PREPARE || prepareMode == PREPARE_MODE) Log(STDUSERLOG,"=%s/%s \r\n",wordStarts[i],wordStarts[i+2]);
			}
			else if (finalPosValues[i] & (NOUN_NUMBER | ADJECTIVE_NUMBER) && IsPlaceNumber(wordStarts[i]))
			{
				MarkFacts(MakeMeaning(Dplacenumber),i,i);  
			}
			// special temperature property
			char c = GetTemperatureLetter(original);
			if (c)
			{
				if (c == 'F') MarkFacts(MakeMeaning(StoreWord("~fahrenheit")),i,i);
				else if (c == 'C') MarkFacts(MakeMeaning(StoreWord("~celsius")),i,i);
				else if (c == 'K')  MarkFacts(MakeMeaning(StoreWord("~kelvin")),i,i);
				MarkFacts(Mnumber,i,i);
				char number[MAX_WORD_SIZE];
				sprintf(number,"%d",atoi(original));
				canonicalLower[i] =  StoreWord(number,(NOUN_NUMBER | ADJECTIVE_NUMBER));
				if (canonicalLower[i]) wordCanonical[i] = canonicalLower[i]->word;
			}

			// special currency property
			char* number;
			char* currency = GetCurrency(wordStarts[i],number); 
			if (currency) 
			{
				char tmp[MAX_WORD_SIZE];
				strcpy(tmp,currency);
				MarkFacts(Mmoney,i,i); 
				if (*currency == '$') tmp[1] = 0;
				else if (*currency == 0xe2 && currency[1] == 0x82 && currency[2] == 0xac) tmp[3] = 0;
				else if (*currency == 0xc2 && currency[1] == 0xa5 ) tmp[2] = 0;
				else if (*currency == 0xc2 && currency[1] == 0xa3 ) tmp[2] = 0;
				MarkFacts(MakeMeaning(StoreWord(tmp)),i,i);
			}
		}
	
        WORDP OL = originalLower[i];
		WORDP CL = canonicalLower[i];
 		WORDP OU = originalUpper[i]; 
        WORDP CU = canonicalUpper[i]; 
		if (!OU && !OL) OU = FindWord(original,0,UPPERCASE_LOOKUP);	 // can this ever work?
		if (!CU && original[1]) // dont convert single letters to upper case "a" if it hasnt already decided its not a determiner
		{
			CU = FindWord(original,0,UPPERCASE_LOOKUP);	// try to find an upper to go with it, in case we can use that, but not as a human name
			if (OU); // it was originally uppercase or there is no lower case meaning
			else if (CU && CU->properties & (NOUN_FIRSTNAME|NOUN_HUMAN)) CU = NULL;	// remove accidental names 
		}
	
		if (!OL && (!OU || !OU->properties) && !CL && (!CU || !CU->properties)) // allow unknown proper names to be marked unknown
		{
			MarkFacts(MakeMeaning(Dunknown),i,i); // unknown word
			MarkFacts(MakeMeaning(StoreWord(original)),i,i);		// allowed word
		}
		
		StdMark(MakeTypedMeaning(OL,0,(unsigned int)(finalPosValues[i] & TYPE_RESTRICTION)), i, i);
        if (trace & TRACE_PREPARE || prepareMode == PREPARE_MODE) Log(STDUSERLOG," // "); //   close original meanings lowercase

		markLength = 0;
		StdMark(MakeTypedMeaning(OU,0,(unsigned int)(finalPosValues[i] & TYPE_RESTRICTION)), i, i);
		
		if (trace & TRACE_PREPARE || prepareMode == PREPARE_MODE) 
		{
			if (CL) Log(STDUSERLOG,"\r\n%d: %s canonical= ", i,CL->word ); //    original meanings lowercase
			else Log(STDUSERLOG,"\r\n%d: %s canonical= ", i,(CU) ? CU->word : "" ); //    original meanings uppercase
		}

		//   canonical word
  		StdMark(MakeTypedMeaning(CL,0, (unsigned int)(finalPosValues[i] & TYPE_RESTRICTION)), i, i);

 		markLength = 0;
	    if (trace & TRACE_PREPARE || prepareMode == PREPARE_MODE) Log(STDUSERLOG," // "); //   close canonical form lowercase
 		
		StdMark(MakeTypedMeaning(CU,0, (unsigned int)(finalPosValues[i] & TYPE_RESTRICTION)), i, i);

		// canonical word is a number (maybe we didn't register original right) eg. "how much is 24 and *seven"
		if (canonicalLower[i] && IsDigit(*canonicalLower[i]->word) && IsNumber(canonicalLower[i]->word)) MarkFacts(Mnumber,i,i);  

		if (trace & TRACE_PREPARE || prepareMode == PREPARE_MODE) Log(STDUSERLOG," "); //   close canonical form uppercase
		markLength = 0;
	
        //   peer into multiword expressions  (noncanonical), in case user is emphasizing something so we dont lose the basic match on words
        //   accept both upper and lower case forms . 
		// But DONT peer into something proper like "Moby Dick"
		unsigned int  n = BurstWord(wordStarts[i]); // peering INSIDE a single token....
		WORDP D,E;
		if (finalPosValues[i] & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL)) n = 1;
		if (tokenControl & NO_WITHIN);  // peek within hypenated words
        else if (n >= 2 && n <= 4) //   longer than 4 is not emphasis, its a sentence - we do not peer into titles
        {
			static char words[5][MAX_WORD_SIZE];
			unsigned int k;
			for (k = 0; k < n; ++k) strcpy(words[k],GetBurstWord(k)); // need local copy since burstwords might be called again..

            for (unsigned int k = 0; k < n; ++k)
            {
  				unsigned int prior = (k == (n-1)) ? i : (i-1); //   -1  marks its word match INSIDE a string before the last word, allow it to see last word still
                E = FindWord(words[k],0,PRIMARY_CASE_ALLOWED); 
                if (E)
				{
					if (!(E->properties & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL))) StdMark(MakeMeaning(E),i,prior);
					else MarkFacts(MakeMeaning(E),i,prior);
				}
                E = FindWord(words[k],0,SECONDARY_CASE_ALLOWED); 
				if (E)
				{
					if (!(E->properties & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL))) StdMark(MakeMeaning(E),i,prior);
					else MarkFacts(MakeMeaning(E),i,prior);
				}
           }
        }

		// now look on either side of a hypenated word
		char* hypen = strchr(wordStarts[i],'-');
		if (hypen) 
		{
			MarkFacts(MakeMeaning(StoreWord(hypen)),i,i); // post form -colored
			char word[MAX_WORD_SIZE];
			strcpy(word,wordStarts[i]);
			word[hypen+1-wordStarts[i]] = 0;
			MarkFacts(MakeMeaning(StoreWord(word)),i,i); // pre form  light-
		}
		
		D = (CL) ? CL : CU; //   best recognition
		char* last;
		if (D && D->properties & NOUN && !(D->internalBits & UPPERCASE_HASH) && (last = strrchr(D->word,'_')) && finalPosValues[i] & NOUN) StdMark(MakeMeaning(FindWord(last+1,0)), i, i); //   composite noun, store last word as referenced also

        if (trace & TRACE_PREPARE || prepareMode == PREPARE_MODE) Log(STDUSERLOG,"\r\n");
    }
 
	//   check for repeat input by user - but only if more than 2 words or are unknown (we dont mind yes, ok, etc repeated)
	//   track how many repeats, for escalating response
	unsigned int sentenceLength = endSentence - startSentence + 1;
	bool brief = (sentenceLength > 2);
	if (sentenceLength == 1 && !FindWord(wordStarts[startSentence])) brief = true;
    unsigned int counter = 0;
    if (brief && humanSaidIndex) for (int j = 0; j < (int)(humanSaidIndex-1); ++j)
    {
        if (strlen(humanSaid[j]) > 5 && !stricmp(humanSaid[humanSaidIndex-1],humanSaid[j])) //   he repeats himself
        {
            ++counter;
            char buf[100];
			strcpy(buf,"~repeatinput");
			buf[12] = (char)('0' + counter);
			buf[13] = 0;
 			MarkFacts(MakeMeaning(FindWord(buf,0,PRIMARY_CASE_ALLOWED)),1,1); //   you can see how many times
        }
    }

	//   now see if he is repeating stuff I said
	counter = 0;
    if (sentenceLength > 2) for (int j = 0; j < (int)chatbotSaidIndex; ++j)
    {
        if (humanSaidIndex && strlen(chatbotSaid[j]) > 5 && !stricmp(humanSaid[humanSaidIndex-1],chatbotSaid[j])) //   he repeats me
        {
			if (counter < sentenceLength) ++counter;
			MarkFacts(MakeMeaning(FindWord("~repeatme",0,PRIMARY_CASE_ALLOWED)),counter,counter); //   you can see how many times
        }
    }

    //   handle phrases now
	markLength = 0;
    SetSequenceStamp(); //   sequences of words

	ChangeDepth(-1,"MarkAllImpliedWords");
}
#include "common.h"

static char staticPath[MAX_WORD_SIZE]; // files that never change
static char readPath[MAX_WORD_SIZE];   // readonly files that might be overwritten from outside
static char writePath[MAX_WORD_SIZE];  // files written by app
int currentFileLine = 0;				// line number in file being read
char currentFilename[MAX_WORD_SIZE];	// name of file being read

char serverLogfileName[200];				// file to log server to
char logFilename[MAX_WORD_SIZE];			// file to user log to
bool logUpdated = false;					// has logging happened
char* logmainbuffer = 0;					// where we build a log line
static bool pendingWarning = false;			// log entry we are building is a warning message
static bool pendingError = false;			// log entry we are building is an error message

int userLog = LOGGING_NOT_SET;				// do we log user
int serverLog = LOGGING_NOT_SET;			// do we log server
bool echo = false;							// show log output onto console as well
bool silent = false;						// dont display outputs of chat

char* testOutput = NULL;					// testing commands output reroute

unsigned char memDepth[256];				// memory usage at depth
bool hasUpperCharacters;
bool hasUTF8Characters;

// buffer information
#define MAX_BUFFER_COUNT 15
unsigned int maxBufferLimit = MAX_BUFFER_COUNT;		// default number of system buffers for AllocateBuffer
unsigned int maxBufferSize = MAX_BUFFER_SIZE;		// how big std system buffers from AllocateBuffer should be
unsigned int maxBufferUsed = 0;						// worst case buffer use - displayed with :variables
unsigned int bufferIndex = 0;				//   current allocated index into buffers[]  
unsigned baseBufferIndex = 0;				// preallocated buffers at start
char* buffers = 0;							//   collection of output buffers
#define MAX_OVERFLOW_BUFFERS 20
static char* overflowBuffers[MAX_OVERFLOW_BUFFERS];	// malloced extra buffers if base allotment is gone
static unsigned int overflowLimit = 0;
unsigned int overflowIndex = 0;

// error recover 
jmp_buf scriptJump[5];
int jumpIndex = -1;

unsigned int randIndex = 0;


/////////////////////////////////////////////////////////
/// EXCEPTION/ERROR
/////////////////////////////////////////////////////////

void JumpBack()
{
	if (jumpIndex < 0) return;	// not under handler control
	globalDepth = 0;
	longjmp(scriptJump[jumpIndex], 1);
}

void myexit(char* msg)
{	
	FILE* in = fopen("LOGS/exitlog.txt","ab");
	if (in) 
	{
		fprintf(in,"%s called myexit\r\n",msg);
		fclose(in);
	}
	exit(0);
}

/////////////////////////////////////////////////////////
/// MEMORY SYSTEM
/////////////////////////////////////////////////////////

void ResetBuffers()
{
	bufferIndex = baseBufferIndex;
	memset(memDepth,0,256); 
}

void CloseBuffers()
{
	while (overflowLimit > 0) free(overflowBuffers[--overflowLimit]);
	free(buffers);
	buffers = 0;
}

bool showmem = false;

char* AllocateBuffer()
{// CANNOT USE LOG INSIDE HERE, AS LOG ALLOCATES A BUFFER
	char* buffer = buffers + (maxBufferSize * bufferIndex); 
	if (showmem) Log(STDUSERLOG,"BUff alloc %d\r\n",bufferIndex);
	if (++bufferIndex >= maxBufferLimit ) // want more than nominally allowed
	{
		--bufferIndex;

		// try to acquire more space, permanently
		if (overflowIndex >= overflowLimit) 
		{
			overflowBuffers[overflowLimit] = (char*) malloc(maxBufferSize);
			if (!overflowBuffers[overflowLimit])  myexit("out of buffers");
			overflowLimit++;
			if (overflowLimit >= MAX_OVERFLOW_BUFFERS) myexit("Out of overflow buffers\r\n");
			printf("Allocated extra buffer\r\n");
		}
		buffer = overflowBuffers[overflowIndex++];
	}
	else if (bufferIndex > maxBufferUsed) maxBufferUsed = bufferIndex;
	*buffer++ = 0;	//   prior value
	*buffer = 0;	//   empty string
	return buffer;
}

char* AllocateAlignedBuffer()
{
	return AllocateBuffer() - 1;
}

void FreeBuffer()
{
	if (overflowIndex) --overflowIndex; // keep the dynamically allocated memory for now..
	else if (bufferIndex)  --bufferIndex; 
	else ReportBug("Buffer allocation underflow")
	if (showmem) Log(STDUSERLOG,"BUff free %d\r\n",bufferIndex);
}

/////////////////////////////////////////////////////////
/// FILE SYSTEM
/////////////////////////////////////////////////////////

void InitFileSystem(char* untouchedPath,char* readablePath,char* writeablePath)
{
	if (readablePath) strcpy(readPath,readablePath);
	else *readPath = 0;
	if (writeablePath) strcpy(writePath,writeablePath);
	else *writePath = 0;
	if (untouchedPath) strcpy(staticPath,untouchedPath);
	else *staticPath = 0;
}

void StartFile(const char* name)
{
	currentFileLine = 0;
	strcpy(currentFilename,name); // in case name is simple

	char* at = strrchr((char*) name,'/');	// last end of path
	if (at) strcpy(currentFilename,at+1);
	at = strrchr(currentFilename,'\\');		// windows last end of path
	if (at) strcpy(currentFilename,at+1);
}

FILE* FopenStaticReadOnly(const char* name) // static data file read path, never changed
{
	StartFile(name);
	char path[MAX_WORD_SIZE];
	if (*readPath) sprintf(path,"%s/%s",staticPath,name);
	else strcpy(path,name);
	return fopen(path,"rb");
}

FILE* FopenReadOnly(const char* name) // read-only potentially changed data file read path
{
	StartFile(name);
	char path[MAX_WORD_SIZE];
	if (*readPath) sprintf(path,"%s/%s",readPath,name);
	else strcpy(path,name);
	return fopen(path,"rb");
}

FILE* FopenReadNormal(char* name) // normal C read unrelated to special paths
{
	StartFile(name);
	FILE* f = fopen(name,"rb");
	return f;
}

FILE* FopenWrite(const char* name, const char* how) // writeable file path
{
	char path[MAX_WORD_SIZE];
	if (*writePath) sprintf(path,"%s/%s",writePath,name);
	else strcpy(path,name);
	return fopen(path,how);
}

FILE* FopenReadWritten(const char* name) // read from files that have been written by us
{
	StartFile(name);
	char path[MAX_WORD_SIZE];
	if (*writePath) sprintf(path,"%s/%s",writePath,name);
	else strcpy(path,name);
	return fopen(path,"rb");
}

FILE* FopenUTF8Write(const char* filename) // insure file has BOM for UTF8
{
	char path[MAX_WORD_SIZE];
	if (*writePath) sprintf(path,"%s/%s",writePath,filename);
	else strcpy(path,filename);

	FILE* in = fopen(path,"rb"); // see if file already exists
	if (in) fclose(in);
	FILE* out = fopen(path,"wb");
	if (out && !in) // mark file as UTF8 if new
	{
		unsigned char bom[3];
		bom[0] = 0xEF;
		bom[1] = 0xBB;
		bom[2] = 0xBF;
		fwrite(bom,1,3,out);
	}
	return out;
}

FILE* FopenUTF8WriteAppend(const char* filename) 
{
	char path[MAX_WORD_SIZE];
	if (*writePath) sprintf(path,"%s/%s",writePath,filename);
	else strcpy(path,filename);

	FILE* in = fopen(path,"rb"); // see if file already exists
	if (in) fclose(in);
	FILE* out = fopen(path,"ab");
	if (out && !in) // mark file as UTF8 if new
	{
		unsigned char bom[3];
		bom[0] = 0xEF;
		bom[1] = 0xBB;
		bom[2] = 0xBF;
		fwrite(bom,1,3,out);
	}
	return out;
}

#ifndef WIN32
int getdir (string dir, vector<string> &files)
{
    DIR *dp;
    struct dirent *dirp;
    if((dp  = opendir(dir.c_str())) == NULL) {
        cout << "Error(" << errno << ") opening " << dir << endl;
        return errno;
    }
    while ((dirp = readdir(dp)) != NULL) files.push_back(string(dirp->d_name));
    closedir(dp);
    return 0;
}
#endif

void WalkDirectory(char* directory,FILEWALK function, uint64 flags) 
{
	char name[MAX_WORD_SIZE];
	size_t len = strlen(directory);
	if (directory[len-1] == '/') directory[len-1] = 0;	// remove the / since we add it 

#ifdef WIN32 // do all files in src directory
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	DWORD dwError;
	LPSTR DirSpec;
	DirSpec = (LPSTR) malloc (MAX_PATH);
   
	  // Prepare string for use with FindFile functions.  First, 
	  // copy the string to a buffer, then append '\*' to the 
	  // directory name.
	strcpy(DirSpec,directory);
	strcat(DirSpec,"/*");
	// Find the first file in the directory.
	hFind = FindFirstFile(DirSpec, &FindFileData);

	if (hFind == INVALID_HANDLE_VALUE) 
	{
		printf ("Invalid file handle. Error is %u.\n", GetLastError());
		return;
	} 
	else 
	{
		if (FindFileData.cFileName[0] != '.' && stricmp(FindFileData.cFileName,"bugs.txt"))
		{
			sprintf(name,"%s/%s",directory,FindFileData.cFileName);
			(*function)(name,flags);
		}
		while (FindNextFile(hFind, &FindFileData) != 0) 
		{
			if (FindFileData.cFileName[0] == '.' || !stricmp(FindFileData.cFileName,"bugs.txt")) continue;
			sprintf(name,"%s/%s",directory,FindFileData.cFileName);
			(*function)(name,flags);
		}
		dwError = GetLastError();
		FindClose(hFind);
		if (dwError != ERROR_NO_MORE_FILES) 
		{
			printf ("FindNextFile error. Error is %u.\n", dwError);
			return;
		}
	}
	free(DirSpec);
#else
    string dir = string(directory);
    vector<string> files = vector<string>();
    getdir(dir,files);
	for (unsigned int i = 0;i < files.size();i++) 
	{
		const char* file = files[i].c_str();
		if (*file != '.' && stricmp(file,"bugs.txt")) 
		{
			sprintf(name,"%s/%s",directory,file);
			(*function)(name,flags);
		}
     }
    return;
#endif
}

string GetUserPathString(const string &loginID)
{
    string userPath;
    if (loginID.length() == 0)  return userPath; // empty string
	size_t len = loginID.length();
	if (len > 3) len = 3;
    for (size_t i = 0; i < len; i++) 
	{
        userPath.append(1, loginID.c_str()[i]);
        userPath.append(1, '/');
    }
    return userPath;
}

#ifdef USERPATHPREFIX
static int MakePath(const string &rootDir, const string &path)
{
#ifndef WIN32
    struct stat st;
    if (stat((rootDir + "/" + path).c_str(), &st) == 0)  return 1;
#endif
    string pathToCreate(rootDir);
    size_t previous = 0;
    for (size_t next = path.find('/'); next != string::npos; previous = next + 1, next = path.find('/', next + 1)) 
	{
        pathToCreate.append("/");
        pathToCreate.append(path.substr(previous, next - previous));
#ifdef WIN32
        if (_mkdir(pathToCreate.c_str()) == -1 && errno != EEXIST) return 0;
#elif EVSERVER
  		if (mkdir(pathToCreate.c_str(), S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) == -1 && errno != EEXIST) return 0;
#else
  		if (mkdir(pathToCreate.c_str(), S_IRWXU | S_IRWXG) == -1 && errno != EEXIST) return 0;
#endif
    }
    return 1;
}
#endif

char* GetUserPath(char* login)
{
	static string userPath;
	char* path = "";
#ifdef USERPATHPREFIX
	if (server) // complex path only for a server who has to access lots of files
	{
		userPath = GetUserPathString(login);
		MakePath("USERS", userPath);
		path = (char*) userPath.c_str();
	}
#endif
	return path;
}

/////////////////////////////////////////////////////////
/// TIME FUNCTIONS
/////////////////////////////////////////////////////////

char* GetTimeInfo() //   Www Mmm dd hh:mm:ss yyyy Where Www is the weekday, Mmm the month in letters, dd the day of the month, hh:mm:ss the time, and yyyy the year. Sat May 20 15:21:51 2000
{
    time_t curr = time(0);
    if (regression) curr = 44444444; 
    char *mytime = ctime(&curr);
    mytime[strlen(mytime)-1] = 0; //   remove newline4
    return mytime;
}

char* GetMyTime(time_t curr)
{
	char *mytime = ctime(&curr); //	Www Mmm dd hh:mm:ss yyyy
	static char when[40];
	strncpy(when,mytime+4,3); // mmm
	strncpy(when+3,mytime+8,2); // dd
	when[5] = '\'';
	strncpy(when+6,mytime+22,2); // yy
	when[8] = '-';
	strncpy(when+9,mytime+11,8); // hh:mm:ss
	when[17] = 0;
	return when;
}

#ifdef IOS
#elif __MACH__ 
void clock_get_mactime(struct timespec &ts)
{
	clock_serv_t cclock; 
	mach_timespec_t mts; 
	host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock); 
	clock_get_time(cclock, &mts); 
	mach_port_deallocate(mach_task_self(), cclock); 
	ts.tv_sec = mts.tv_sec; 
	ts.tv_nsec = mts.tv_nsec; 
}
#endif

clock_t ElapsedMilliseconds()
{
	clock_t count;
#ifdef WIN32
	count = GetTickCount();
#elif IOS
	struct timeval x_time; 
	gettimeofday(&x_time, NULL); 
	count = x_time.tv_sec * 1000; 
	count += x_time.tv_usec / 1000; 
#elif __MACH__
	struct timespec abs_time; 
	clock_get_mactime( abs_time);
	count = abs_time.tv_sec * 1000; 
	count += abs_time.tv_nsec / 1000000; 
#else // LINUX
	struct timeval x_time;
	gettimeofday(&x_time, NULL);
	count = x_time.tv_sec * 1000; 
	count += x_time.tv_usec / 1000;
#endif
	return count;
}

#ifndef WIN32
unsigned int GetFutureSeconds(unsigned int seconds)
{
	struct timespec abs_time; 
#ifdef __MACH__
	clock_get_mactime(abs_time);
#else
	clock_gettime(CLOCK_REALTIME,&abs_time); 
#endif
	return abs_time.tv_sec + seconds; 
}
#endif

////////////////////////////////////////////////////////////////////////
/// RANDOM NUMBERS
////////////////////////////////////////////////////////////////////////



#define X64(n) (n##ULL)
uint64 X64_Table[256] = //   hash table randomizer
{
       X64(0x0000000000000000), X64(0x42f0e1eba9ea3693),       X64(0x85e1c3d753d46d26), X64(0xc711223cfa3e5bb5),
       X64(0x493366450e42ecdf), X64(0x0bc387aea7a8da4c),       X64(0xccd2a5925d9681f9), X64(0x8e224479f47cb76a),
       X64(0x9266cc8a1c85d9be), X64(0xd0962d61b56fef2d),       X64(0x17870f5d4f51b498), X64(0x5577eeb6e6bb820b),
       X64(0xdb55aacf12c73561), X64(0x99a54b24bb2d03f2),       X64(0x5eb4691841135847), X64(0x1c4488f3e8f96ed4),
       X64(0x663d78ff90e185ef), X64(0x24cd9914390bb37c),       X64(0xe3dcbb28c335e8c9), X64(0xa12c5ac36adfde5a),
       X64(0x2f0e1eba9ea36930), X64(0x6dfeff5137495fa3),       X64(0xaaefdd6dcd770416), X64(0xe81f3c86649d3285),
       X64(0xf45bb4758c645c51), X64(0xb6ab559e258e6ac2),       X64(0x71ba77a2dfb03177), X64(0x334a9649765a07e4),
       X64(0xbd68d2308226b08e), X64(0xff9833db2bcc861d),       X64(0x388911e7d1f2dda8), X64(0x7a79f00c7818eb3b),
       X64(0xcc7af1ff21c30bde), X64(0x8e8a101488293d4d),       X64(0x499b3228721766f8), X64(0x0b6bd3c3dbfd506b),
       X64(0x854997ba2f81e701), X64(0xc7b97651866bd192),       X64(0x00a8546d7c558a27), X64(0x4258b586d5bfbcb4),
       X64(0x5e1c3d753d46d260), X64(0x1cecdc9e94ace4f3),       X64(0xdbfdfea26e92bf46), X64(0x990d1f49c77889d5),
       X64(0x172f5b3033043ebf), X64(0x55dfbadb9aee082c),       X64(0x92ce98e760d05399), X64(0xd03e790cc93a650a),
       X64(0xaa478900b1228e31), X64(0xe8b768eb18c8b8a2),       X64(0x2fa64ad7e2f6e317), X64(0x6d56ab3c4b1cd584),
       X64(0xe374ef45bf6062ee), X64(0xa1840eae168a547d),       X64(0x66952c92ecb40fc8), X64(0x2465cd79455e395b),
       X64(0x3821458aada7578f), X64(0x7ad1a461044d611c),       X64(0xbdc0865dfe733aa9), X64(0xff3067b657990c3a),
       X64(0x711223cfa3e5bb50), X64(0x33e2c2240a0f8dc3),       X64(0xf4f3e018f031d676), X64(0xb60301f359dbe0e5),
       X64(0xda050215ea6c212f), X64(0x98f5e3fe438617bc),       X64(0x5fe4c1c2b9b84c09), X64(0x1d14202910527a9a),
       X64(0x93366450e42ecdf0), X64(0xd1c685bb4dc4fb63),       X64(0x16d7a787b7faa0d6), X64(0x5427466c1e109645),
       X64(0x4863ce9ff6e9f891), X64(0x0a932f745f03ce02),       X64(0xcd820d48a53d95b7), X64(0x8f72eca30cd7a324),
       X64(0x0150a8daf8ab144e), X64(0x43a04931514122dd),       X64(0x84b16b0dab7f7968), X64(0xc6418ae602954ffb),
       X64(0xbc387aea7a8da4c0), X64(0xfec89b01d3679253),       X64(0x39d9b93d2959c9e6), X64(0x7b2958d680b3ff75),
       X64(0xf50b1caf74cf481f), X64(0xb7fbfd44dd257e8c),       X64(0x70eadf78271b2539), X64(0x321a3e938ef113aa),
       X64(0x2e5eb66066087d7e), X64(0x6cae578bcfe24bed),       X64(0xabbf75b735dc1058), X64(0xe94f945c9c3626cb),
       X64(0x676dd025684a91a1), X64(0x259d31cec1a0a732),       X64(0xe28c13f23b9efc87), X64(0xa07cf2199274ca14),
       X64(0x167ff3eacbaf2af1), X64(0x548f120162451c62),       X64(0x939e303d987b47d7), X64(0xd16ed1d631917144),
       X64(0x5f4c95afc5edc62e), X64(0x1dbc74446c07f0bd),       X64(0xdaad56789639ab08), X64(0x985db7933fd39d9b),
       X64(0x84193f60d72af34f), X64(0xc6e9de8b7ec0c5dc),       X64(0x01f8fcb784fe9e69), X64(0x43081d5c2d14a8fa),
       X64(0xcd2a5925d9681f90), X64(0x8fdab8ce70822903),       X64(0x48cb9af28abc72b6), X64(0x0a3b7b1923564425),
       X64(0x70428b155b4eaf1e), X64(0x32b26afef2a4998d),       X64(0xf5a348c2089ac238), X64(0xb753a929a170f4ab),
       X64(0x3971ed50550c43c1), X64(0x7b810cbbfce67552),       X64(0xbc902e8706d82ee7), X64(0xfe60cf6caf321874),
       X64(0xe224479f47cb76a0), X64(0xa0d4a674ee214033),       X64(0x67c58448141f1b86), X64(0x253565a3bdf52d15),
       X64(0xab1721da49899a7f), X64(0xe9e7c031e063acec),       X64(0x2ef6e20d1a5df759), X64(0x6c0603e6b3b7c1ca),
       X64(0xf6fae5c07d3274cd), X64(0xb40a042bd4d8425e),       X64(0x731b26172ee619eb), X64(0x31ebc7fc870c2f78),
       X64(0xbfc9838573709812), X64(0xfd39626eda9aae81),       X64(0x3a28405220a4f534), X64(0x78d8a1b9894ec3a7),
       X64(0x649c294a61b7ad73), X64(0x266cc8a1c85d9be0),       X64(0xe17dea9d3263c055), X64(0xa38d0b769b89f6c6),
       X64(0x2daf4f0f6ff541ac), X64(0x6f5faee4c61f773f),       X64(0xa84e8cd83c212c8a), X64(0xeabe6d3395cb1a19),
       X64(0x90c79d3fedd3f122), X64(0xd2377cd44439c7b1),       X64(0x15265ee8be079c04), X64(0x57d6bf0317edaa97),
	   X64(0xd9f4fb7ae3911dfd), X64(0x9b041a914a7b2b6e),       X64(0x5c1538adb04570db), X64(0x1ee5d94619af4648),
       X64(0x02a151b5f156289c), X64(0x4051b05e58bc1e0f),       X64(0x87409262a28245ba), X64(0xc5b073890b687329),
       X64(0x4b9237f0ff14c443), X64(0x0962d61b56fef2d0),       X64(0xce73f427acc0a965), X64(0x8c8315cc052a9ff6),
       X64(0x3a80143f5cf17f13), X64(0x7870f5d4f51b4980),       X64(0xbf61d7e80f251235), X64(0xfd913603a6cf24a6),
       X64(0x73b3727a52b393cc), X64(0x31439391fb59a55f),       X64(0xf652b1ad0167feea), X64(0xb4a25046a88dc879),
       X64(0xa8e6d8b54074a6ad), X64(0xea16395ee99e903e),       X64(0x2d071b6213a0cb8b), X64(0x6ff7fa89ba4afd18),
       X64(0xe1d5bef04e364a72), X64(0xa3255f1be7dc7ce1),       X64(0x64347d271de22754), X64(0x26c49cccb40811c7),
       X64(0x5cbd6cc0cc10fafc), X64(0x1e4d8d2b65facc6f),       X64(0xd95caf179fc497da), X64(0x9bac4efc362ea149),
       X64(0x158e0a85c2521623), X64(0x577eeb6e6bb820b0),       X64(0x906fc95291867b05), X64(0xd29f28b9386c4d96),
       X64(0xcedba04ad0952342), X64(0x8c2b41a1797f15d1),       X64(0x4b3a639d83414e64), X64(0x09ca82762aab78f7),
       X64(0x87e8c60fded7cf9d), X64(0xc51827e4773df90e),       X64(0x020905d88d03a2bb), X64(0x40f9e43324e99428),
       X64(0x2cffe7d5975e55e2), X64(0x6e0f063e3eb46371),       X64(0xa91e2402c48a38c4), X64(0xebeec5e96d600e57),
       X64(0x65cc8190991cb93d), X64(0x273c607b30f68fae),       X64(0xe02d4247cac8d41b), X64(0xa2dda3ac6322e288),
       X64(0xbe992b5f8bdb8c5c), X64(0xfc69cab42231bacf),       X64(0x3b78e888d80fe17a), X64(0x7988096371e5d7e9),
       X64(0xf7aa4d1a85996083), X64(0xb55aacf12c735610),       X64(0x724b8ecdd64d0da5), X64(0x30bb6f267fa73b36),
       X64(0x4ac29f2a07bfd00d), X64(0x08327ec1ae55e69e),       X64(0xcf235cfd546bbd2b), X64(0x8dd3bd16fd818bb8),
       X64(0x03f1f96f09fd3cd2), X64(0x41011884a0170a41),       X64(0x86103ab85a2951f4), X64(0xc4e0db53f3c36767),
       X64(0xd8a453a01b3a09b3), X64(0x9a54b24bb2d03f20),       X64(0x5d45907748ee6495), X64(0x1fb5719ce1045206),
       X64(0x919735e51578e56c), X64(0xd367d40ebc92d3ff),       X64(0x1476f63246ac884a), X64(0x568617d9ef46bed9),
       X64(0xe085162ab69d5e3c), X64(0xa275f7c11f7768af),       X64(0x6564d5fde549331a), X64(0x279434164ca30589),
       X64(0xa9b6706fb8dfb2e3), X64(0xeb46918411358470),       X64(0x2c57b3b8eb0bdfc5), X64(0x6ea7525342e1e956),
       X64(0x72e3daa0aa188782), X64(0x30133b4b03f2b111),       X64(0xf7021977f9cceaa4), X64(0xb5f2f89c5026dc37),
       X64(0x3bd0bce5a45a6b5d), X64(0x79205d0e0db05dce),       X64(0xbe317f32f78e067b), X64(0xfcc19ed95e6430e8),
       X64(0x86b86ed5267cdbd3), X64(0xc4488f3e8f96ed40),       X64(0x0359ad0275a8b6f5), X64(0x41a94ce9dc428066),
       X64(0xcf8b0890283e370c), X64(0x8d7be97b81d4019f),       X64(0x4a6acb477bea5a2a), X64(0x089a2aacd2006cb9),
       X64(0x14dea25f3af9026d), X64(0x562e43b4931334fe),       X64(0x913f6188692d6f4b), X64(0xd3cf8063c0c759d8),
       X64(0x5dedc41a34bbeeb2), X64(0x1f1d25f19d51d821),       X64(0xd80c07cd676f8394), X64(0x9afce626ce85b507)
};

uint64 Hashit(unsigned char * data, int len)
{
	hasUpperCharacters = hasUTF8Characters = false;
	uint64 crc = 0;
	while (len-- > 0)
	{ 
		unsigned char c = *data++;
		if (!c) break;
		if (c & 0x80) hasUTF8Characters = true;
		if (IsUpperCase(c)) 
		{
			c = toLowercaseData[(unsigned char) c];
			hasUpperCharacters = true;
		}
		crc = X64_Table[(crc >> 56) ^ c ] ^ (crc << 8 );
	}
	return crc;
} 

unsigned int random(unsigned int range)
{
	if (regression) return 0;
	return (range <= 1) ? 0 : (unsigned int)(X64_Table[randIndex++ % MAXRAND] % range);
}

/////////////////////////////////////////////////////////
/// LOGGING
/////////////////////////////////////////////////////////
extern bool showd;

uint64 logCount = 0;

void ChangeDepth(int value,char* where)
{
	if (value < 0)
	{
		if (memDepth[globalDepth] != bufferIndex)
		{
			ReportBug("depth %d not closing bufferindex correctly\r\n",globalDepth);
			memDepth[globalDepth] = 0;
		}
		globalDepth += value;
	}
	if (showd) 
	{
		for (int i = 0; i <= globalDepth; ++i) Log(STDUSERLOG,"  ");
		Log(STDUSERLOG,"%s %d => %d\r\n",where,value,globalDepth);
	}
	if (value > 0) 
	{
		globalDepth += value;
		memDepth[globalDepth] = (unsigned char) bufferIndex;
	}
	if (globalDepth < 0) ReportBug("bad global depth in %s",where);
}

unsigned int Log(unsigned int channel,const char * fmt, ...)
{
	static unsigned int id = 1000;
	if (quitting) return id;
	if (server && !userLog && (channel == STDUSERLOG || channel > 1000 || channel == id) && !testOutput) return id;
    if (!fmt || !logmainbuffer)  return id; // no format or no buffer to use
	if ((channel == BUGLOG || channel == SERVERLOG) && server && !serverLog)  return id; // not logging server data

	static char last = 0;
	char* buffer = logmainbuffer;
    char* at = buffer;
    *at = 0;
    va_list ap; 
    va_start(ap,fmt);
	++logCount;

    char* s;
    int i;
    const char *ptr = fmt - 1;

	//   when this channel matches the ID of the prior output of log,
	//   we dont force new line on it.
	if (channel == id) //   join result code onto intial description
	{
		channel = 1;
		strcpy(at,"    ");
		at += 4;
	}
	//   any channel above 1000 is same as 101
	else if (channel > 1000) channel = STDUSERTABLOG; //   force result code to indent new line

	//   channels above 100 will indent when prior line not ended
	if (channel >= STDUSERTABLOG && last != '\\') //   indented by call level and not merged
	{ //   STDUSERTABLOG 101 is std indending characters  201 = attention getting
		if (last != '\n') 
		{
			*at++ = '\r'; //   close out this prior thing
			*at++ = '\n';
		}
		while (ptr[1] == '\n' || ptr[1] == '\r') // we point BEFORE the format
		{
			*at++ = *++ptr;
		}

		int n = globalDepth;
		if (n < 0) n = 0; //   just in case
		for (int i = 0; i < n; i++)
		{
			if (channel == STDUSERATTNLOG) *at++ = (i == 1) ? '*' : ' ';
			else *at++ = (i == 4 || i == 9) ? ',' : '.';
			*at++ = ' ';
		}
 	}
	channel %= 100;
    while (*++ptr)
    {
        if (*ptr == '%')
        {
			++ptr;
            if (*ptr== 'c') sprintf(at,"%c",(char) va_arg(ap,int)); // char
            else if (*ptr== 'd') sprintf(at,"%d",va_arg(ap,int)); // int %d
            else if (*ptr== 'I') //   I64
            {
#ifdef WIN32
				sprintf(at,"%I64d",va_arg(ap,uint64));
#else
				sprintf(at,"%lld",va_arg(ap,uint64)); 
#endif
				ptr += 3; 
            }
            else if (*ptr== 'l' && ptr[1] == 'd') // ld
            {
                sprintf(at,"%ld",va_arg(ap,long int));
				ptr += 2; 
            }
            else if (*ptr== 'l' && ptr[1] == 'l') // lld
            {
                sprintf(at,"%lld",va_arg(ap,long long int));
				ptr += 3;
            }
            else if (*ptr == 'p') sprintf(at,"%p",va_arg(ap,char*)); // ptr
            else if (*ptr == 's') // string
            {
                s = va_arg(ap,char*);
				if (s) sprintf(at,"%s",s);
            }
            else if (*ptr == 'x') sprintf(at,"%x",(unsigned int)va_arg(ap,unsigned long)); // hex 
 			else if (IsDigit(*ptr)) // int %2d
            {
				i = va_arg(ap,int);
				unsigned int precision = atoi(ptr);
				while (*ptr && *ptr != 'd') ++ptr;
				if (precision == 2) sprintf(at,"%2d",i);
				else if (precision == 3) sprintf(at,"%3d",i);
				else if (precision == 4) sprintf(at,"%4d",i);
				else if (precision == 5) sprintf(at,"%5d",i);
				else if (precision == 6) sprintf(at,"%6d",i);
				else sprintf(at," Bad int precision %d ",precision);
            }
            else
            {
                sprintf(at,"unknown format ");
				ptr = 0;
            }
        }
        else  sprintf(at,"%c",*ptr);

        at += strlen(at);
		if (!ptr) break;
    }
    *at = 0;
    va_end(ap); 

	last = *(at-1); //   ends on NL?
	if (last == '\\') *--at = 0;	//   dont show it (we intend to merge lines)
	bool bug = false;
		
	if (pendingWarning)
	{
		AddWarning(buffer);
		pendingWarning = false;
	}
	else if (!strnicmp(buffer,"*** Warning",11)) 
		pendingWarning = true;// replicate for easy dump later
	
	if (pendingError)
	{
		AddError(buffer);
		pendingError= false;
	}
	else if (!strnicmp(buffer,"*** Error",9)) 
		pendingError = true;// replicate for easy dump later

#ifndef DISCARDSERVER
#ifndef EVSERVER
    if (server) GetLogLock();
#endif
#endif	
	logUpdated = true; // in case someone wants to see if intervening output happened

	size_t bufLen = at - logmainbuffer;
 
	if (channel == STDPUBLOG) // :document
	{
		FILE* pub = FopenUTF8WriteAppend("LOGS/pub.txt");
		fwrite(buffer,1,bufLen,pub);
		fclose(pub);
		return 0;
	}

	if (channel == BADSCRIPTLOG || channel == BUGLOG) 
	{
		Bug();
		bug = true;
		FILE* bug = FopenUTF8WriteAppend("LOGS/bugs.txt");
		char located[MAX_WORD_SIZE];
		*located = 0;
		if (currentTopicID && currentRule) sprintf(located,"%s.%d.%d",GetTopicName(currentTopicID),TOPLEVELID(currentRuleID),REJOINDERID(currentRuleID));
		if (bug) //   write to a bugs file
		{
			if (*currentFilename) fprintf(bug,"   in %s at %d: %s\r\n",currentFilename,currentFileLine,readBuffer);
			if (channel == BUGLOG && *currentInput) fprintf(bug,"input:%d %s %s caller:%s callee:%s in sentence: %s at %s\r\n",inputCount,GetTimeInfo(),buffer,loginID,computerID,currentInput,located);
			fwrite(buffer,1,bufLen,bug);
			fclose(bug);

			if (debugger && channel == BUGLOG) printf("**** BUG: %s at %s\r\n",buffer,located);

		}
		if (echo && !silent)
		{
			if (*currentFilename) fprintf(stdout,"\r\n   in %s at %d: %s\r\n    ",currentFilename,currentFileLine,readBuffer);
			else if (*currentInput) fprintf(stdout,"\r\n%d %s in sentence: %s \r\n    ",inputCount,GetTimeInfo(),currentInput);
		}
		strcat(buffer,"\r\n");	//   end it
		channel = 1;	//   use normal logging as well
	}
    if ((echo && channel == STDUSERLOG) || (channel == STDDEBUGLOG)) fwrite(buffer,1,bufLen,stdout);
    FILE* out = NULL;

	if (server && trace) channel = SERVERLOG;	// force traced server to go to server log

    if (logFilename[0] != 0 && channel != SERVERLOG)  out =  FopenUTF8WriteAppend(logFilename); 
    else out = FopenUTF8WriteAppend(serverLogfileName); 
    if (out) 
    {
        fwrite(buffer,1,bufLen,out);
		if (!bug);
 		else if (*currentFilename) fprintf(out,"   in %s at %d: %s\r\n    ",currentFilename,currentFileLine,readBuffer);
		else if (*currentInput) fprintf(out,"%d %s in sentence: %s \r\n    ",inputCount,GetTimeInfo(),currentInput);
		fclose(out);
		if (channel == SERVERLOG && echoServer) printf("%s",buffer);
    }

	if (testOutput && server) // command outputs
	{
		size_t len = strlen(testOutput);
		if ((len + bufLen) < (maxBufferSize - 10)) strcat(testOutput,buffer);
	}

#ifndef DISCARDSERVER
#ifndef EVSERVER
    if (server) ReleaseLogLock();
#endif
#endif

	return ++id;
}

void Bug()
{
	int i = 0; // just a place to debug catch errors
	i = i - 1;
}
#include "common.h"

unsigned int currentOutputLimit = MAX_BUFFER_SIZE;	// max size of current output base
char* currentOutputBase = NULL;		// current base of buffer which must not overflow
char* currentRuleOutputBase = NULL;	// the partial buffer within outputbase started for current rule, whose output can be canceled.

#define MAX_OUTPUT_NEST 50
static char* oldOutputBase[MAX_OUTPUT_NEST];
static char* oldOutputRuleBase[MAX_OUTPUT_NEST];
static unsigned int oldOutputLimit[MAX_OUTPUT_NEST];
static int oldOutputIndex = 0;
unsigned int outputNest = 0;

#ifdef JUNK
Special strings:

When you put ^"xxxx" as a string in a normal output field, it is a format string. By definition you didnt need it compileable.
It will be treated...

When you use it as an argument to a function (top level), it is compiled.

When you put ^"xxxx" as a string in a table, it will be compiled and be either a pattern compile or an output compile.   
Internally that becomes "^xxx" which is fully executable.


#endif

void ResetOutput()
{
	outputNest = 0;
}

void PushOutputBuffers()
{
	oldOutputBase[oldOutputIndex] = currentOutputBase;
	oldOutputRuleBase[oldOutputIndex] = currentRuleOutputBase;
	oldOutputLimit[oldOutputIndex] = currentOutputLimit;
	++oldOutputIndex;
	if (oldOutputIndex == MAX_OUTPUT_NEST) --oldOutputIndex; // just fail it
}

void PopOutputBuffers()
{
	--oldOutputIndex;
	if (oldOutputIndex < 0) ++oldOutputIndex;
	currentOutputBase = oldOutputBase[oldOutputIndex];
	currentRuleOutputBase = oldOutputRuleBase[oldOutputIndex];
	currentOutputLimit = oldOutputLimit[oldOutputIndex];
}

void AllocateOutputBuffer()
{
	currentRuleOutputBase = currentOutputBase = AllocateBuffer();
	currentOutputLimit = maxBufferSize;
}

void FreeOutputBuffer()
{
	FreeBuffer(); // presumed the current buffer allocated via AllocateOutputBuffer
}

static int CountParens(char* start) 
{
	int paren = 0;
	start--;		//   back up so we can start at beginning
	while (*++start) if (*start == '"') ++paren; 
	return paren;
}

static bool IsAssignmentOperator(char* word)
{
	if ((*word == '<' || *word == '>') && word[1] == *word && word[2] == '=') return true;	 // shift operators
	return ((*word == '=' && word[1] != '=' && word[1] != '>') || (*word && *word != '!' && *word != '\\' && *word != '=' && word[1] == '='   )); // x = y, x *= y
}

char* ReadCommandArg(char* ptr, char* buffer,unsigned int& result,unsigned int control)
{
	if (control == 0) control |= OUTPUT_KEEPSET | OUTPUT_NOTREALBUFFER | OUTPUT_ONCE | OUTPUT_NOCOMMANUMBER;
	else control |= OUTPUT_ONCE | OUTPUT_NOCOMMANUMBER;
	return FreshOutput(ptr,buffer,result,control);
}

char* ReadShortCommandArg(char* ptr, char* buffer,unsigned int& result,unsigned int control)
{
	if (control == 0) control |= OUTPUT_KEEPSET | OUTPUT_NOTREALBUFFER | OUTPUT_ONCE | OUTPUT_NOCOMMANUMBER;
	else control |= OUTPUT_ONCE | OUTPUT_NOCOMMANUMBER;
	return FreshOutput(ptr,buffer,result,control,MAX_WORD_SIZE);
}

static char* AddFormatOutput(char* what, char* output)
{
	size_t len = strlen(what);
	if ((output - currentOutputBase + len) > (currentOutputLimit - 50)) 
		ReportBug("format string revision too big %s\r\n",output) // buffer overflow
	else
	{
		strcpy(output,what);
		output += len;
	}
	return output;
}

void ReformatString(char* output, char* input,unsigned int controls) // take ^"xxx" format string and perform substitutions on variables within it
{
	size_t len = strlen(input) - 1;
	char c = input[len];
	input[len] = 0;	// remove closing "
	if (*input == ':') // has been compiled by script compiler. safe to execute fully. actual string is "^:xxxxx" 
	{
		++input;
		unsigned int result;
 		Output(input,output,result,controls|OUTPUT_EVALCODE); // directly execute the content
		input[len] = c;
		return;
	}

	char* start = output;
	*output = 0;
	char mainValue[3];
	mainValue[1] = 0;
	while (*input)
	{
		if (*input == '$' && !IsDigit(input[1])) // user variable
		{
			char* base = input;
			while (*++input && !IsWhiteSpace(*input) && *input != '.') // find end of variable name
			{
				if (*input != '$' && !IsLegalNameCharacter(*input)) 
				{
					char* at = IsUTF8(input);
					if (at) input = at-1;
					else break;
				}
			}
			c = *input;
			*input = 0;
			char* value = GetUserVariable(base);
			*input = c;
			output = AddFormatOutput(value, output); 
		}
		if (*input == '%' && IsAlpha(input[1])) // system variable
		{
			char* base = input;
			while (*++input && IsAlpha(*input) && *input != '.') {;} // find end of variable name
			c = *input;
			*input = 0;
			char* value = SystemVariable(base,NULL);
			if (*value) output = AddFormatOutput(value, output); 
			else if (!FindWord(base)) output = AddFormatOutput(base, output); // not a system variable
			*input = c;
		}
		else if (*input == '_' && IsDigit(input[1])) // canonical match variable
		{
			char* base = input++;
			if (IsDigit(*input)) ++input; // 2nd digit
			output = AddFormatOutput(GetwildcardText(GetWildcardID(base),true), output); 
		}
		else if (*input == '\'' && input[1] == '_' && IsDigit(input[2])) // quoted match variable
		{
			char* base = ++input;
			++input;
			if (IsDigit(*input)) ++input; // 2nd digit
			output = AddFormatOutput(GetwildcardText(GetWildcardID(base),false), output);
		}
		else if (*input == '@' && IsDigit(input[1])) // factset
		{
			// get end of reference
			char* base = input;
			input = GetSetType(input);
			size_t len = 0;
			if (!strnicmp(input,"subject",7)) len = 7;
			else if (!strnicmp(input,"verb",4)) len = 4;
			else if (!strnicmp(input,"object",6)) len = 6;
			input += len;
			
			// go get value of reference and copy over
			char c = *input;
			char* value = AllocateBuffer();
			unsigned int result;
			*input = 0;
			ReadCommandArg(base,value,result);
			*input = c;
			output = AddFormatOutput(value, output);
			FreeBuffer();
			if (result & ENDCODES) 
			{
				output = start + 1;  // null return
				break;
			}
		}
		else if (*input == '^' && IsDigit(input[1])) // function variable
		{
			char* base = input; 
			while (*++input && IsDigit(*input)){;} // find end of function variable name (expected is 1 digit)
			char* tmp = callArgumentList[atoi(base+1)+fnVarBase];
			// if tmp turns out to be $var or _var %var, need to recurse to get it

			if (*tmp == '$' && !IsDigit(tmp[1])) // user variable
			{
				char* value = GetUserVariable(tmp);
				output = AddFormatOutput(value, output); 
			}
			else if (*tmp == '_' && IsDigit(tmp[1])) // canonical match variable
			{
				char* base = tmp++;
				if (IsDigit(*tmp)) ++tmp; // 2nd digit
				output = AddFormatOutput(GetwildcardText(GetWildcardID(base),true), output); 
			}
			else if (*tmp == '\'' && tmp[1] == '_' && IsDigit(tmp[2])) // quoted match variable
			{
				char* base = ++tmp;
				++tmp;
				if (IsDigit(*tmp)) ++tmp; // 2nd digit
				output = AddFormatOutput(GetwildcardText(GetWildcardID(base),false), output);
			}
			else if (*tmp == '%' && IsAlpha(tmp[1])) // system variable
			{
				char* value = SystemVariable(tmp,NULL);
				if (*value) output = AddFormatOutput(value, output); 
				else if (!FindWord(tmp)) output = AddFormatOutput(tmp, output); // not a system variable
			}		
			else output = AddFormatOutput(tmp, output); 
		}
		else if (*input == '\\')
		{
			if (*++input == 'n') *output++ = '\n';
			else if (*input == 't') *output++ = '\t';
			else if (*input == 'r') *output++ = '\r';
			else *output++ = *input;
			++input;
		}
		else // ordinary character
		{
			mainValue[0] = *input++;
			output = AddFormatOutput(mainValue, output);
		}
	}
	*output = 0; // when failures, return the null string
}

static void StdNumber(char* word,char* buffer,int controls) // text numbers may have sign and decimal
{
    size_t len = strlen(word);
    if (!IsDigitWord(word) || strchr(word,':')) // either its not a number or its a time - leave unchanged
    {
        strcpy(buffer,word);  
        return;
    }
    char* dot = strchr(word,'.'); // float?
    if (dot) 
    {
        *dot = 0; 
        len = dot-word; // integral prefix
    }

    if (len < 5 || controls & OUTPUT_NOCOMMANUMBER) // no comma with <= 4 digit, e.g., year numbers
    {
        if (dot) *dot = '.'; 
        strcpy(buffer,word);  
        return;
    }

	// add commas between number triples
    char* ptr = word;
    unsigned int offset = len % 3;
    len = (len + 2 - offset) / 3; 
    strncpy(buffer,ptr,offset); 
    buffer += offset;
    ptr += offset;
    if (offset && len) *buffer++ = ','; 
    while (len--)
    {
        *buffer++ = *ptr++;
        *buffer++ = *ptr++;
        *buffer++ = *ptr++;
        if (len) *buffer++ = ',';
    }
	if (dot) 
	{
		*buffer++ = '.';
		strcpy(buffer,dot+1);
	}
	else *buffer = 0;
}

char* StdIntOutput(int n)
{
	char buffer[50];
	static char answer[50];
	*answer = 0;
	sprintf(buffer,"%lld",(long long int) n);
	StdNumber(buffer,answer,0);
	return answer;
}

char* StdFloatOutput(float n)
{
	char buffer[50];
	static char answer[50];
	*answer = 0;
	sprintf(buffer,"%.2f",n);
	StdNumber(buffer,answer,0);
	return answer;
}

static char* ProcessChoice(char* ptr,char* buffer,unsigned int &result,int controls) //   given block of  [xx] [yy] [zz]  randomly pick one
{
	char* choice[CHOICE_LIMIT];
	char** choiceset = choice;
	int count = 0;
    char* endptr = 0;

	//   gather choices
	while (*ptr == '[') // get next choice for block
	{
		//   find closing ]
		endptr = ptr-1;
		while (ALWAYS) 
		{
			endptr = strchr(endptr+1,']'); // find a closing ] 
			if (!endptr) // failed
			{
				respondLevel = 0;
				return 0;
			}
			if (*(endptr-1) != '\\') break; // ignore literal \[
		}
        // choice can be simple: [ xxx ]  or conditional [ $var1 xxx] but avoid assignment [ $var1 = 10 xxx ] 
		char word[MAX_WORD_SIZE];
		char* base = ptr + 2; // start of 1st token within choice
		char* simpleOutput = ReadCompiledWord(base,word);
		char* var = word;
		bool notted = false;
		if (*word == '!')
		{
			notted = true;
			++var;
		}
		if (*var == '$' && IsAlpha(var[1])) // user variable given
		{
			ReadCompiledWord(simpleOutput,tmpWord);
			if (*tmpWord == '=' || tmpWord[1] == '=') choiceset[count++] = base; //  some kind of assignment, it's all simple output
			else if (!notted && !*GetUserVariable(var)) {;}	// user variable test fails
			else if (notted && *GetUserVariable(var)) {;}	// user variable test fails
			else choiceset[count++] = simpleOutput;
		}
		else choiceset[count++] = base;

		ptr = endptr + 1;   // past end of choice
		if (*ptr == ' ') ++ptr;	 // start of next token
	}

	//   pick a choice randomly
	respondLevel = 0;
	while (count > 0)
	{
		int r = random(count);
		char* ptr = choiceset[r];
		if (*ptr == ']') break; // choice does nothing by intention
		if (ptr[1] == ':' && ptr[2] == ' ') ptr += 3; // skip special rejoinder
		Output(ptr,buffer,result,controls);
		if (result & ENDCODES) break; // declared done
		
		// is choice a repeat of something already said... if so try again
		if (*buffer && HasAlreadySaid(buffer)) 
		{
			if (trace) Log(STDUSERLOG,"Choice %s already said\r\n",buffer);
			*buffer = 0;
		}
		else 
		{
			if (choiceset[r][1] == ':' && choiceset[r][2] == ' ') respondLevel = *choiceset[r];
			break; // if choice didnt fail, it has completed, even if it generates no output
		}
		choiceset[r] = choiceset[--count];
	}
	return endptr+2; //   skip to end of rand past the ] and space
}

char* FreshOutput(char* ptr,char* buffer,unsigned int &result,int controls,unsigned int limit)
{
	++outputNest;
	PushOutputBuffers();
	if (limit == MAX_WORD_SIZE) AllocateOutputBuffer(); // where he wants to put it is SMALL and we're not ready for that. allocate a big bufer can copy later
	else currentRuleOutputBase = currentOutputBase = buffer; // is a normal buffer
	ptr = Output(ptr,currentOutputBase,result,controls);
	if (limit == MAX_WORD_SIZE) // someone's small local buffer
	{
		if (strlen(currentOutputBase) >= limit) *buffer = 0;	// cannot accept this
		else strcpy(buffer,currentOutputBase);
		FreeOutputBuffer();
	}
	PopOutputBuffers();
	--outputNest;
	return ptr;
}

#define CONDITIONAL_SPACE() if (space) {*buffer++ = ' '; *buffer = 0;}

#ifdef INFORMATION
There are two kinds of output streams. The ONCE only stream expects to read an item and return.
If a fail code is hit when processing an item, then if the stream is ONCE only, it will be done
and return a ptr to the rest. If a general stream hits an error, it has to flush all the remaining
tokens and return a ptr to the end.
#endif

char* Output_Percent(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result,bool once)
{			
	// Handles system variables:  %date
	// Handles any other % item - %
	if (IsAlpha(word[1])) // must be a system variable
    {
		if (!once && IsAssignmentOperator(ptr)) return PerformAssignment(word,ptr,result); //   =  or *= kind of construction
		strcpy(word,SystemVariable(word,NULL));
	}
	if (*word) 
	{
 		CONDITIONAL_SPACE();
		strcpy(buffer,word); 
	}
	return ptr;
}

char* Output_Backslash(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result)
{
	// handles newline:  \n
	// handles backslashed strings: \"testing"  means 
	// handles backslashed standalone double quote - \"  - means treat as even/odd pair and on 2nd one (closing) do not space before it
	// handles any other backslashed item:  \help  means just put out the item without the backslash
	if (word[1] == 'r' && !word[2]) return ptr;		// ignore \r (built into \n)
	if (word[1] == 'n' && !word[2])  //   \n
	{
		CONDITIONAL_SPACE();
#ifdef WIN32
		strcpy(buffer,"\r\n");
#else
		strcpy(buffer,"\n");
#endif
	}
    else //   some other random backslashed content, including \" 
    {
 		if (word[1] != '"' || !(controls & OUTPUT_DQUOTE_FLIP)) CONDITIONAL_SPACE(); // no space before paired closing dquote 
		strcpy(buffer,word+1); 
    }
	return ptr;
}

char* Output_Function(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result,bool once)
{
	if (IsDigit(word[1]))  //   function variable
	{
		if (!once && IsAssignmentOperator(ptr))  ptr = PerformAssignment(word,ptr,result); //   =  or *= kind of construction
		else //  replace function variable with its content, treating it as though the original content had been supplied
		{
			size_t len = strlen(callArgumentList[atoi(word+1)+fnVarBase]);
			size_t size = (buffer - currentOutputBase);
			if ((size + len) >= (currentOutputLimit-50) ) 
			{
				result = FAILRULE_BIT;
				return ptr;
			}

			strcpy(buffer,callArgumentList[atoi(word+1)+fnVarBase]);
			*word = '`';	// marker for retry
			word[1] = '^';	// additional marker for function variables
		}
	}
	else if (word[1] == '"') // functional string, uncompiled.  DO NOT USE function calls within it
	{
		CONDITIONAL_SPACE();
		ReformatString(buffer,word+2);
	}
	else  if (word[1] == '$' || word[1] == '_' || word[1] == '\'') // ^$$1 = null or ^_1 = null or ^'_1 = null is indirect user assignment
	{
		Output(word+1,buffer,result,controls|OUTPUT_NOTREALBUFFER); // no leading space
		if (!once && IsAssignmentOperator(ptr)) 
		{
			strcpy(word,buffer);
			*buffer = 0;
			return PerformAssignment(word,ptr,result); //   =  or *= kind of construction
		}
		*word = '`';	// marker for retry
	}
	else if (word[1] == '^') // if and loop
	{
		if (!strcmp(word,"^^if")) ptr = HandleIf(ptr,buffer,result);  
		else if (!strcmp(word,"^^loop")) ptr = HandleLoop(ptr,buffer,result); 
		else result = FAILRULE_BIT;
	}
	else // functions or ordinary words
	{
		if (*ptr != '(' || !word[1]) // a non function
		{
			CONDITIONAL_SPACE();
			strcpy(buffer,word);
		}
		else // ordinary function
		{
			ptr =  DoFunction(word,ptr,buffer,result); 
			if (result == UNDEFINED_FUNCTION) {;} 
			else if (space && *buffer && *buffer != ' ') // we need to add a space
			{
				memmove(buffer+1,buffer,strlen(buffer) + 1);
				*buffer = ' ';
			}
		}
	}
	return ptr;
}

char* Output_AttachedPunctuation(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result)
{
	// Handles spacing after a number:  2 .  
	// Handles not spacing before common punctuation:   . ? !  ,  :  ; 
	if (*word == '.' && controls & OUTPUT_ISOLATED_PERIOD) // if period after a number, always space after it (to be clear its not part of the number)
	{
		if (IsDigit(*(buffer-1))) *buffer++ = ' ';
	}
	strcpy(buffer,word); 
	return ptr;
}

char* Output_Text(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result)
{
	// handles text or script
	if (*ptr != '(' || controls & OUTPUT_FACTREAD || IsDigit(*word)) //   SIMPLE word  - paren if any is a nested fact read, or number before ( which cant be ^number
	{
		CONDITIONAL_SPACE();
		StdNumber(word,buffer,controls);
	}
	else  //   function call missing ^
	{
		memmove(word+1,word,strlen(word)+1);
		*word = '^';  // supply ^
		ptr = Output_Function(ptr,word,space,buffer, controls,result,false);
		if (result == UNDEFINED_FUNCTION) // wasnt a function after all.
		{
			CONDITIONAL_SPACE();
			StdNumber(word+1,buffer,controls);			
		}
	}
	return ptr;
}

char* Output_AtSign(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result,bool once)
{
	// handles factset assignement: @3 = @2
	// handles factset field: @3object
	if (!once && IsAssignmentOperator(ptr)) ptr = PerformAssignment(word,ptr,result);
	else if (impliedSet != ALREADY_HANDLED)
	{
		CONDITIONAL_SPACE();
		strcpy(buffer,word);
	}
    else if (IsDigit(word[1]) && IsAlpha(*GetSetType(word)) && !(controls & OUTPUT_KEEPQUERYSET)) //   fact set reference
    {
		unsigned int store = GetSetID(word);
		unsigned int count = FACTSET_COUNT(store);
		if (!count || count >= MAX_FIND) return ptr;
		FACT* F = factSet[store][1]; // use but don't use up most recent fact
		MEANING T;
		uint64 flags;
		char type = *GetSetType(word);
		if (type  == 's' ) 
		{
			T = F->subject;
			flags = F->flags & FACTSUBJECT;
		}
		else if (type== 'v')
		{
			T = F->verb;
			flags = F->flags & FACTVERB;
		}
		else if (type == 'a' && impliedWild != ALREADY_HANDLED)
		{
			strcpy(ARGUMENT(1), word);
			result = FLR(buffer,'l');
			return ptr;
		}
		else 
		{
			T = F->object;
			flags = F->flags & FACTOBJECT;
		}
		char* answer;
		char buf[100];
		if (flags) 
		{
			sprintf(buf,"%d",T);
			answer = buf;
		}
		else  answer = Meaning2Word(T)->word;
		CONDITIONAL_SPACE();
 		Output(answer,buffer,result,controls|OUTPUT_NOTREALBUFFER|OUTPUT_EVALCODE);
	}
	else 
	{
		CONDITIONAL_SPACE();
		strcpy(buffer,word);
	}
    return ptr;
 }

char* Output_Bracket(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result)
{
	// handles normal token: [ice 
	// handles choice: [ this is data ]
	if (word[1] || controls & OUTPUT_NOTREALBUFFER || !*ptr) StdNumber(word,buffer,controls); // normal token
	else ptr = ProcessChoice(ptr-2,buffer,result,controls);      
	return ptr;
}

char* Output_Quote(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result)
{
	// handles possessive: 's
	// handles original wildcard: '_2
	// handles quoted variable: '$hello
	if (word[1] == 's' && !word[2])	strcpy(buffer,"'s");	// possessive
	else if (word[1] == '_')			// original wildcard
	{
		int index = GetWildcardID(word+1); //   which one
		char* at = wildcardOriginalText[index];
		if (*at)  CONDITIONAL_SPACE();
		StdNumber(at,buffer,controls);
	}
	else if (word[1] == '$')  //    variable quoted, means dont reeval its content
	{
		strcpy(buffer,word+1);
	}
	else if (word[1] == '^' && IsDigit(word[2]))  //   function variable quoted, means dont reeval its content
	{
		size_t len = strlen(callArgumentList[atoi(word+2)+fnVarBase]);
		size_t size = (buffer - currentOutputBase);
		if ((size + len) >= (currentOutputLimit-50) ) 
		{
			result = FAILRULE_BIT;
			return ptr;
		}

		strcpy(buffer,callArgumentList[atoi(word+2)+fnVarBase]);
	}
	else 
	{
		CONDITIONAL_SPACE();
		StdNumber(word,buffer,controls);
	}
	return ptr;
}


char* Output_String(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result)
{
	// handles function string: "^ .... "  which means go eval the contents of the string
	// handles simple string: "this is a string"  which means just put it out (with or without quotes depending on controls)
	size_t len;
	CONDITIONAL_SPACE();
	if (controls & OUTPUT_UNTOUCHEDSTRING) strcpy(buffer,word);
	else if (word[1] == FUNCTIONSTRING && controls & OUTPUT_EVALCODE) // treat as format string
	{
		ReformatString(buffer,word+2,controls);
	}
	else if (controls & OUTPUT_NOQUOTES)
	{
		strcpy(buffer,word+1);
		len = strlen(buffer);
		if  (buffer[len-1] == '"') buffer[len-1] = 0; // remove end quote
	}
	else strcpy(buffer,word);
	return ptr;
}
	
char* Output_Underscore(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result,bool once)
{
	// handles wildcard assigment: _10 = hello
	// handles wildcard: _19
	// handles simple _ or _xxxx 
	if (!once && IsAssignmentOperator(ptr)) ptr = PerformAssignment(word,ptr,result); 
	else if (IsDigit(word[1])) // wildcard 
	{
		int id = GetWildcardID(word);
		if (id >= 0)
		{
			if (*wildcardCanonicalText[id]) { CONDITIONAL_SPACE();}
			StdNumber(wildcardCanonicalText[id],buffer,controls);
		}
	}
	else // stand-alone _ or some non wildcard
	{
		CONDITIONAL_SPACE();
		strcpy(buffer,word);
	}
	return ptr;
}

char* Output_Dollar(char* ptr, char* word, bool space,char* buffer, unsigned int controls,unsigned int& result,bool once)
{
	// handles user variable assignment: $myvar = 4
	// handles user variables:  $myvar
	// handles US money: $1000.00
	if (word[1] && !IsDigit(word[1])) // variable
    {
		if (controls & OUTPUT_EVALCODE && !(controls & OUTPUT_KEEPVAR)) 
		{
			char* answer = GetUserVariable(word);
			if (*answer == '$') strcpy(word,answer); // force nested indirect on var of a var value
		}

		if (!once && IsAssignmentOperator(ptr)) ptr = PerformAssignment(word,ptr,result); 
		else
		{
			char* value = GetUserVariable(word);
			if (value && *value) {CONDITIONAL_SPACE();} 
			StdNumber(value,buffer,controls);
		}
	}	
    else // money or simple $
    {
		CONDITIONAL_SPACE();
		StdNumber(word,buffer,controls);
	}
	return ptr;
}

char* Output(char* ptr,char* buffer,unsigned int &result,int controls)
{ 
	//   an output stream consists of words, special words, [] random zones, commands, C-style script. It autoformats whitespace.
	*buffer = 0; 
    result = 0;
	if (!*ptr) return NULL;	
	bool once = false;
	if (controls & OUTPUT_ONCE) // do one token
	{
		once = true;
		controls ^= OUTPUT_ONCE;
	}
	if (buffer < currentOutputBase || (size_t)(buffer - currentOutputBase) >= (size_t)(currentOutputLimit-200)) // output is wrong or in danger already?
	{
		result =  (unsigned int) (buffer - currentOutputBase); // debug info
		result = FAILRULE_BIT;
		return ptr;
	}

	char* start = buffer;
    bool quoted = false;
    char word[MAX_WORD_SIZE];
	int paren = 0;

    while (ptr)
    {
		if (!*ptr || *ptr == ENDUNIT) break; // out of data
		char* hold = ptr;
        ptr = ReadCompiledWord(ptr,word); 
 		if ((!*word || (*word == ')' || *word == ']' || *word == '}'))  && !paren  ) break; // end of data or choice or body
		if (debugger) Debugger(PARSING_OUTPUT,0,hold); // a real thing to print gets debugged, not just a closer
	
		//   determine whether to space before item or not. Don't space at start but normally space after existing output tokens with exceptions.
		bool space = false;
		if (!once)
		{
			char before;
			if (start == buffer && controls & OUTPUT_NOTREALBUFFER) {;} // there is no before in this buffer and we are at start
			else
			{
				before = *(buffer-1);
				// dont space after $  or # or [ or ( or " or / or newline
				space = before && before != '(' && before != '[' && before != '{'  && before != '$' && before != '#' && before != '"' && before != '/' && before != '\n';
				if (before == '"') space = !(CountParens(currentOutputBase) & 1); //   if parens not balanced, add space before opening doublequote
			}
		}
retry:
		if (!outputNest && !*currentOutputBase && buffer != currentOutputBase) start = buffer = currentOutputBase;	// buffer may have been flushed and needs reset
		switch (*word)
        {
		// groupings
		case ')':  case ']': case '}':  // ordinary output closers, never space before them
			*buffer++ = *word;
			*buffer = 0;
            break;
		case '(': case '{':
			CONDITIONAL_SPACE();
			if (word[1]) StdNumber(word,buffer,controls); // its a full token like (ice)_ is_what
			else 
			{
				++paren;
				*buffer++ = *word;
				*buffer = 0;
			}
            break;
 		case '[':  //   random choice. process the choice area, then resume in this loop after the choice is made
			ptr = Output_Bracket(ptr, word, space, buffer, controls,result);
			break;

		// variables of various flavors
        case '$': //   user variable or money
			ptr = Output_Dollar(ptr, word, space, buffer, controls,result,once);
            break;
 		case '_': //   wildcard or standalone _ OR just an ordinary token
			ptr = Output_Underscore(ptr, word, space, buffer, controls,result,once);
			break;
        case '%':  //   system variable
	 		ptr = Output_Percent(ptr, word, space, buffer, (quoted) ? (controls | OUTPUT_DQUOTE_FLIP)  : controls,result,once);
			break;
		case '@': //   a fact set reference like @9 @1subject @2object or something else
			ptr = Output_AtSign(ptr, word, space, buffer, controls,result,once);
			break;

		// sets, functions, strings
		case '~':	//concept set 
			CONDITIONAL_SPACE();
			strcpy(buffer,word);
            break;
 		case '^': //   function call or function variable or FORMAT string (by definition uncompiled)
			if (*currentRuleOutputBase && (!strcmp(word,"^gambit") || !strcmp(word,"^respond") || !strcmp(word,"^reuse") )) // leaving current rule
			{
				AddResponse(currentRuleOutputBase);
				buffer = currentRuleOutputBase;	
				*buffer = 0;
			}

			ptr = Output_Function(ptr, word, space, buffer, controls,result,once);
			if (*word == '`') // retry marker from ^$var substitution loop back and handle it
			{
				if (!*buffer) result = FAILRULE_BIT;
				else if (once && word[1] != '^') break;	// have our answer (unless it was a function variable substitution)
				else
				{
					strcpy(word,buffer);
					*buffer = 0;
					goto retry; 
				}
			}
			break;
        case '"': // string of some kind
			ptr = Output_String(ptr, word, space, buffer, controls,result);
			break;

		// prefixes:  quote, backslash
		case '\\':  //   backslash needed for new line  () [ ]   
  			ptr = Output_Backslash(ptr, word, space, buffer, (quoted) ? (controls | OUTPUT_DQUOTE_FLIP)  : controls,result);
			if (word[1] == '"') quoted = !quoted;
            break;
		case '\'': //   quoted item
			ptr = Output_Quote(ptr, word, space, buffer, controls,result);
			break;

		// punctuation which should not be spaced   .  ,  :  ;  !  ?  
		case '.': case '?': case '!': case ',':  case ';':  //   various punctuation wont want a space before
			ptr = Output_AttachedPunctuation(ptr, word, space, buffer, (buffer >= start) ? (controls | OUTPUT_ISOLATED_PERIOD)  : controls,result);
			break;
		case ':': // a debug command?
		{
#ifndef DISCARDTESTING
			WORDP D = FindWord(word);
			if (D && D->x.debugIndex) 
			{
				unsigned int oldtopicid = currentTopicID;
				char* oldrule = currentRule;
				int oldruleid = currentRuleID;
				int oldruletopic = currentRuleTopic;
				Command(ptr - strlen(word) - 1,NULL);
				currentTopicID = oldtopicid;
				currentRule = oldrule;
				currentRuleID = oldruleid;
				currentRuleTopic = oldruletopic;
				ptr = NULL;
				break; // just abort flow after this
			}
#endif
			// ordinary :
			ptr = Output_AttachedPunctuation(ptr, word, space, buffer, (buffer >= start) ? (controls | OUTPUT_ISOLATED_PERIOD)  : controls,result);
			break;
		}
		// DROP THRU if not debug command
        default: //  text or C-Script
			ptr = Output_Text(ptr, word, space, buffer, controls,result);
        }

		if (!outputNest && *buffer) // generated top level output
		{
			if (buffer == start) // this is our FIRST output
			{
				buffer = start;  // debug stop
			}
			if (trace & (TRACE_OUTPUT|TRACE_MATCH) &&  !(controls &OUTPUT_SILENT)) Log(STDUSERLOG," =:: %s ",buffer);
		}
		//   update location and check for overflow
		buffer += strlen(buffer);
		unsigned int size = (buffer - currentOutputBase);
        if (size >= (currentOutputLimit-200) && !(result  & FAILCODES)) 
		{
			result = FAILRULE_BIT;
		}

		if (result & (RETRYRULE_BIT|RETRYTOPRULE_BIT|ENDCODES))
		{
			if (result & FAILCODES && !(controls & OUTPUT_LOOP)) *start = 0; //  kill output
			if (!once) ptr = BalanceParen(ptr,true); // swallow excess input BUG - does anyone actually care
			break;
		}
		if (once) break;    
	}

    return ptr;
}
#include "common.h"

#define INFINITE_MATCH (unsigned int)(-(200 << 8)) // allowed to match anywhere

#define GAPPASSBACK  0X0000FFFF
#define NOT_BIT 0X00010000
#define FREEMODE_BIT 0X00020000
#define QUOTE_BIT 0X00080000
#define WILDGAP 0X00100000
#define WILDSPECIFIC 0X00200000

unsigned int positionStart;		// where current match token started
unsigned int positionEnd;		// where most recent matched token ended

// function calling data
static unsigned int functionNest = 0;	// recursive depth of macro calling
#define MAX_PAREN_NEST 50
static char* ptrStack[MAX_PAREN_NEST];
static int argStack[MAX_PAREN_NEST];
static int baseStack[MAX_PAREN_NEST];
static int fnVarBaseStack[MAX_PAREN_NEST];

bool MatchesPattern(char* word, char* pattern) //   does word match pattern of characters and *
{
	if (!*pattern && *word) return false;	// no more pattern but have more word so fails 
	size_t len = 0;
	while (IsDigit(*pattern)) len = (len * 10) + *pattern++ - '0'; //   length test leading characters can be length of word
	if (len && strlen(word) != len) return false; // length failed
	char* start = pattern;
	--pattern;
	while (*++pattern && *pattern != '*' && *word) //   must match leading non-wild exactly
	{
		if (*pattern != '.' &&  *pattern != toLowercaseData[*word]) return false; // accept a single letter either correctly OR as 1 character wildcard
		++word;
	}
	if (pattern == start && len) return true;	// just a length test, no real pattern
	if (!*word) return !*pattern || (*pattern == '*' && !pattern[1]);	// the word is done. If pattern is done or is just a trailing wild then we are good, otherwise we are bad.
	if (*word && !*pattern) return false;		// pattern ran out w/o wild and word still has more

	// Otherwise we have a * in the pattern now and have to match it against more word
	
	//   wildcard until does match
	char find = *++pattern; //   the characters AFTER wildcard
	if (!find) return true; // pattern ended on wildcard - matches all the rest of the word including NO rest of word

	// now resynch
	--word;
	while (*++word)
	{
		if (*pattern == toLowercaseData[*word] && MatchesPattern(word + 1,pattern + 1)) return true;
	}
	return false; // failed to resynch
}

static bool SysVarExists(char* ptr) //   %system variable
{
	char* sysvar = SystemVariable(ptr,NULL);
	if (!*sysvar) return false;
	return (*sysvar) ? true : false;	// value != null
}

static bool FindPartialInSentenceTest(char* test, unsigned int start,unsigned int originalstart,bool reverse)
{
	if (!test || !*test) return false;
	if (reverse)
	{
		for (unsigned int i = originalstart-1; i >= 1; --i)
		{
			char word[MAX_WORD_SIZE];
			MakeLowerCopy(word,wordStarts[i]);
			if (unmarked[i] || !MatchesPattern(word,test)) continue;	// if universally unmarked, skip it. Or if they dont match
			// we have a match of a word
			positionStart = i;
			positionEnd = i;
			return true;
		}
	}
	else
	{
		for (unsigned int i = start+1; i <= wordCount; ++i)
		{
			char word[MAX_WORD_SIZE];
			MakeLowerCopy(word,wordStarts[i]);
			if (unmarked[i] || !MatchesPattern(word,test)) continue;	// if universally unmarked, skip it. Or if they dont match
			// we have a match of a word
			positionStart = i;
			positionEnd = i;
			return true;
		}
	}
	return false;
}

static bool MatchTest(bool reverse,WORDP D, unsigned int start,char* op, char* compare,int quote) // is token found somewhere after start?
{
	while (GetNextSpot(D,start,positionStart,positionEnd,reverse)) // find a spot later where token is in sentence
    {
        start = positionStart; // where to try next if fail on test
        if (op) // we have a test to perform
        {
			char* word;
			if (D->word && IsAlpha(*D->word)) word = D->word; //   implicitly all normal words are relation tested as given
			else word = quote ? wordStarts[positionStart] : wordCanonical[positionStart];
			unsigned int id;
			if (HandleRelation(word,op,compare,false,id) & ENDCODES) continue; // failed 
        }
        if (!quote) return true; // can match canonical or original
		if (*D->word == '~') return true; // sets dont have canonical to worry about

        //   we have a match, but prove it is a original match, not a canonical one
		if (positionEnd < positionStart) continue;	// trying to match within a composite. 
        if (positionStart == positionEnd && !stricmp(D->word,wordStarts[positionStart])) return true;   // literal word match
		else // match a phrase literally
		{
			char word[MAX_WORD_SIZE];
			char* at = word;
			for (unsigned int i = positionStart; i <= positionEnd; ++i)
			{
				strcpy(at,wordStarts[i]);
				at += strlen(wordStarts[i]);
				if (i != positionEnd) *at++ = '_';
			}
			*at = 0;
			if (!stricmp(D->word,word)) return true;
		}
    } 
    return false;
}

bool FindPhrase(char* word, unsigned int start,bool reverse)
{   // Phrases are dynamic, might not be marked, so have to check each word separately. -- faulty in not respecting ignored(unmarked) words
	bool matched = false;
	positionEnd = start;
	unsigned int oldend;
	oldend = start = 0; // allowed to match anywhere or only next

	unsigned int n = BurstWord(word);
	for (unsigned int i = 0; i < n; ++i) // use the set of burst words - but "Andy Warhol" might be a SINGLE word.
	{
		WORDP D = FindWord(GetBurstWord(i));
		matched = MatchTest(reverse,D,positionEnd,NULL,NULL,0);
		if (matched)
		{
			if (oldend > 0 && positionStart != (oldend + 1)) // do our words match in sequence
			{
				matched = false;
				break;
			}
			if (i == 1) start = positionStart;
			oldend = positionEnd;
		}
		else break;
	}
	if (matched) positionStart = start;
	return matched;
}

bool Match(char* ptr, unsigned int depth, int startposition, char kind, bool wildstart,unsigned int& gap,unsigned int& wildcardSelector,unsigned int &returnstart, unsigned int& returnend,bool reverse)
{//   always STARTS past initial opening thing ( [ {  and ends with closing matching thing
	ChangeDepth(1,"Match");
    char word[MAX_WORD_SIZE];
	char* orig = ptr;
	int statusBits = 0; //   turns off: not, quote, startedgap, freemode, gappassback,wildselectorpassback
    if (trace & TRACE_PATTERN) Log(STDUSERTABLOG, "%c ",kind); //   start on new indented line
    int matched;
	unsigned int startNest = functionNest;
	unsigned int result;
    unsigned int hold;
    WORDP D;
	unsigned int oldtrace = trace;
	bool oldecho = echo;
	bool success = false;
	bool retried = false;
    char* compare;
	bool returned = false;	// came back from a nesting, if we dont start a new nesting, we need to restore tab on this level
    int firstMatched = -1; //   ()  should return spot it started (firstMatched) so caller has ability to bind any wild card before it
    if (wildstart)  positionStart = INFINITE_MATCH; //   INFINITE_MATCH means we are in initial startup, allows us to match ANYWHERE forward to start
    positionEnd = startposition; //   we scan starting 1 after this
 	unsigned int basicStart = startposition;	//   we must not match real stuff any earlier than here
    char* argumentText = NULL; //   pushed original text from a function arg -- function arg never decodes to name another function arg, we would have expanded it instead
   
	while (ALWAYS) //   we have a list of things, either () or { } or [ ].  We check each item until one fails in () or one succeeds in  [ ] or { }
    {
        unsigned int oldp = positionStart; //  allows us to restore if we fail, and confirm legality of position advance.
        unsigned int olde = positionEnd;
		unsigned int id;

		ptr = ReadCompiledWord(ptr,word);

		if (trace & TRACE_PATTERN)
		{
			if (*word && *word != '(' && *word != '[' && *word != '{') 
			{
				char* at = word;
				if (*word == '=') at += 2; //   skip = flag and accelerator
				
				if (*word == '\'' || *word == '!' || (*word == '_' && !IsDigit(word[1]))) Log(STDUSERLOG,"%c ",*word); // prefix always resumes on rest of its word
				else if (returned) Log(STDUSERTABLOG,"%s ",at); //   restore indent level from before
				else Log(STDUSERLOG,"%s ",at);
			}
			returned = false;
		}

		char c = *word;
        switch(c) 
        {
			// prefixs on tokens
            case '!': //   NOT condition - not a stand-alone token, attached to another token
				ptr -= strlen(word); // back up to remove rest of token
				if (*ptr == '!') ++ptr; // normally ptr points past a space after token. But if end of input then it wont.
				statusBits |= NOT_BIT;
				continue;
			case '\'': //   single quoted item    
				statusBits |= QUOTE_BIT;
				ptr -= strlen(word); 
				if (*ptr == '\'') ++ptr; // normally ptr points past a space after token. But if end of input then it wont.
				continue;
			case '_': //     memorization coming - there can be up-to-two memorizations in progress: _* and _xxx  OR  simply names a memorized value like _8
				
				// a wildcard id?
				if (IsDigit(word[1]))
				{
					matched = GetwildcardText(GetWildcardID(word),false)[0]; // simple _2  means is it defined
					break;
				}
				
				// if we are going to memorize something AND we previously matched inside a phrase, we need to move to after...
				if ((positionStart - positionEnd) == 1) positionEnd = positionStart; // If currently matched a phrase, move to end. 
				
				wildcardSelector |= (word[1] == '*' && !IsDigit(word[2]) && word[2] != '-') ? WILDGAP :  WILDSPECIFIC; // select duration of memorization
				ptr -= strlen(word); 
				if (*ptr == '_') ++ptr; // normally ptr points past a space after token. But if end of input then it wont.
				continue;
			case '.': // use wild position - simple period cannot be matched since is punctuation ending sentence  // .<_0  or .>_0    
				matched = false;
				positionEnd = (word[1] == '<' ) ? WILDCARD_START(wildcardPosition[GetWildcardID(word+2)]) : WILDCARD_END(wildcardPosition[GetWildcardID(word+2)]) ; // set to start <  or end >  
				if (!positionEnd) break;
				continue;
			case '@': // factset ref
				if (word[1] == '_') // set positional reference  _20++ or _0++
				{
					positionStart = WILDCARD_START(wildcardPosition[GetWildcardID(word+1)]);
					positionEnd = WILDCARD_END(wildcardPosition[GetWildcardID(word+1)]);
					olde = positionEnd; // forced match ok
					oldp = positionStart;
					matched = true;

					if (word[3] == '+') reverse = false;
					else if (word[3] == '-') reverse = true;
				}
				else matched = FACTSET_COUNT(GetSetID(word)) != 0;
				break;
   			case '<': //   sentence start marker OR << >> set
				if (word[1] == '<') //   << 
				{
					statusBits |= FREEMODE_BIT;
					positionStart = INFINITE_MATCH;
					positionEnd = startposition;  //   allowed to pick up after here - oldp/olde synch automatically works
				}
                else 
				{
					if (gap) // close to end of sentence 
					{
						positionStart = wordCount + 1; // pretend to match at end of sentence
						int start = gap & 0x000000ff;
						unsigned int limit = (gap >> 8);
						gap = 0;   //   turn off
  						if ((positionStart - start) > limit) //   too long til end
						{
							matched = false;
 							wildcardSelector &= -1 ^ WILDGAP;
							break;
						}
						if (wildcardSelector & WILDGAP) 
						{
							SetWildCard(start,wordCount);  //   legal swallow of gap //   request memorize
 							wildcardSelector &= -1 ^ WILDGAP;
						}
					}
					positionStart = positionEnd = 0; //   idiom < * and < _* handled under *
				}
                continue;
            case '>': //   sentence end marker
				if (word[1] == '>') //   >> closer
				{
					statusBits &= -1 ^ FREEMODE_BIT; //   positioning left for a start of sentence
					continue;
				}

                if (statusBits & NOT_BIT) //   asks that we NOT be at end of sentence
                {
					statusBits &= -1 ^ NOT_BIT;
                    matched =  positionEnd != wordCount; 
                }
                else //   declares a match at end (position ptr set there)
                {
					//   if a wildcard started, end it... eg _* > 
					if (gap)
					{
						int start = (gap & 0x000000ff);
						int limit = gap >> 8;
						int diff = (wordCount + 1) - start;  //   ended - spot it started
						/// BUG - does not respect the unmark system
						gap = 0;   //   turn off
						if (diff > limit) //   too long til end
						{
							matched = false;
							wildcardSelector &= -1 ^ WILDGAP;
							break;
						}

						if (wildcardSelector & WILDGAP)  
						{
							if ( diff ) SetWildCard(start,wordCount);  //   legal swallow of gap
							else SetWildCard("", "",NULL,wordCount);
						}
						wildcardSelector &= -1 ^ WILDGAP;
						olde = oldp = wordCount;	//   insure we synch up correctly
						positionStart = positionEnd = wordCount + 1; //   pretend to match a word off end of sentence
						matched = true;
					}
					else if (positionEnd == wordCount) 
					{
						positionStart = positionEnd = wordCount + 1; //   pretend to match a word off end of sentence
						matched = true; 
					}
					else matched = false;
				}
                break;
             case '*': //   GAP - accept anything (perhaps with length restrictions)
				if (word[1] == '-') //   backward gap, -1 is word before now -- BUG does not respect unmark system
				{
					int at = positionEnd - (word[2] - '0') - 1; // limited to 9 back
					if (at >= 0) //   no earlier than pre sentence start
					{
						olde = at; //   set last match BEFORE our word
						positionStart = positionEnd = at + 1; //   cover the word now
						matched = true; 
					}
					else matched = false;
				}
				else if (IsDigit(word[1]))  // fixed length gap
                {
					unsigned int at;
					unsigned int count = word[1] - '0';	// how many to swallow
					if (reverse)
					{
						at = positionStart; // start here
						while (count-- && --at >= 1) // can we swallow this (not an ignored word)
						{
							if (unmarked[at]) ++count;	// ignore this word
						}
						if (at >= 1 ) // pretend match
						{ 
							positionEnd = positionStart - 1 ; // pretend match here -  wildcard covers the gap
							positionStart = at; 
							matched = true; 
						}
						else  matched = false;
					}
					else
					{
						at = positionEnd; // start here
						while (count-- && ++at <= wordCount) // can we swallow this (not an ignored word)
						{
							if (unmarked[at]) ++count;	// ignore this word
						}
						if (at <= wordCount ) // pretend match
						{ 
							positionStart = positionEnd + 1 ; // pretend match here -  wildcard covers the gap
							positionEnd = at; 
							matched = true; 
						}
						else  matched = false;
					}
                }
				else if (IsAlpha(word[1])) matched = FindPartialInSentenceTest(word+1,(positionEnd < basicStart && firstMatched < 0) ? basicStart : positionEnd,positionStart,reverse); // wildword match like st*m* matches steamroller
                else // variable gap
                {
                    if (word[1] == '~') gap = (word[2]-'0') << 8; // *~3 - limit 9 back
                    else // I * meat
					{
						gap = 200 << 8;  // 200 is a safe infinity
						if (positionStart == 0) positionStart = INFINITE_MATCH; // < * resets to allow match anywhere
					}
                    gap |= (reverse) ? (positionStart  - 1) : (positionEnd  + 1);
					continue;
                }
                break;
            case '$': // is user variable defined
				matched = (HandleRelation(word,"!=","",false,id) & ENDCODES) ? 0 : 1;
                break;
            case '^': //   function call, function argument  or indirect function variable assign ref like ^$$tmp = null
                if  (IsDigit(word[1]) || word[1] == '$' || word[1] == '_') //   macro argument substitution or indirect function variable
                {
                    argumentText = ptr; //   transient substitution of text

					if (IsDigit(word[1]))  ptr = callArgumentList[word[1]-'0'+fnVarBase];  // nine argument limit
					else if (word[1] == '$') ptr = GetUserVariable(word+1); // get value of variable and continue in place
					else ptr = wildcardCanonicalText[GetWildcardID(word+1)]; // ordinary wildcard substituted in place (bug)?
					continue;
                }
                
				D = FindWord(word,0); // find the function
				if (!D || !(D->systemFlags & FUNCTION_NAME)) matched = false; // shouldnt fail
				else if (D->x.codeIndex) // system function - execute it
                {
					char* old = currentOutputBase;
					char* oldrule = currentRuleOutputBase;
					currentRuleOutputBase = currentOutputBase = AllocateBuffer(); // start an independent buffer
					ptr = DoFunction(word,ptr,currentOutputBase,result);
					matched = !(result & ENDCODES); 
					// allowed to do comparisons on answers from system functions but not from user macros
					if (ptr[1] != ENDUNIT && *(ptr-1) != ' ') 
					{
						char op[10];
						char* opptr = ptr-1;
						*op = *opptr;
						op[1] = 0;
						char* rhs = ++opptr; 
						if (*opptr == '=') // was == or >= or <= or &= 
						{
							op[1] = '=';
							op[2] = 0;
							++rhs;
						}
						char copy[MAX_WORD_SIZE];
						ptr = ReadCompiledWord(rhs,copy);
						rhs = copy;

						if (*rhs == '^') // local function argument or indirect ^$ var  is LHS. copy across real argument
						{
							char* at = "";
							if (rhs[1] == '$') at = GetUserVariable(rhs+1); 
							else if (IsDigit(rhs[1])) at = callArgumentList[rhs[1]-'0'+fnVarBase];
							at = SkipWhitespace(at);
							strcpy(rhs,at);
						}
				
						if (*op == '?' && opptr[0] != '~')
						{
							matched = MatchTest(reverse,FindWord(currentOutputBase),(positionEnd < basicStart && firstMatched < 0) ? basicStart : positionEnd,NULL,NULL,false); 
							if (!(statusBits & NOT_BIT) && matched && firstMatched < 0) firstMatched = positionStart; //   first SOLID match
						}
						else
						{
							unsigned int id;
							result = HandleRelation(currentOutputBase,op,rhs,false,id); 
							matched = (result & ENDCODES) ? 0 : 1;
						}
					}
					FreeBuffer();
					currentOutputBase = old;
					currentRuleOutputBase = oldrule;
                }
				else // user function - execute it in pattern context as continuation of current code
				{ 
					//   save old base data
					baseStack[functionNest] = callArgumentBase; 
					argStack[functionNest] = callArgumentIndex; 
					fnVarBaseStack[functionNest] = fnVarBase;

					if (trace & TRACE_PATTERN || D->internalBits & TRACE_MACRO) Log(STDUSERLOG,"("); 
					ptr += 2; // skip ( and space
					// read arguments
					while (*ptr && *ptr != ')' ) 
					{
						char* arg = callArgumentList[callArgumentIndex++];
						ptr = ReadArgument(ptr,arg);  // gets the unevealed arg
						if (*arg == '^' && IsDigit(arg[1])) strcpy(arg,callArgumentList[atoi(arg+1)+fnVarBase]); //  function variable - switch  to value 
						if (trace & TRACE_PATTERN || D->internalBits & TRACE_MACRO) Log(STDUSERLOG," %s, ",arg); 
					}
					if (trace & TRACE_PATTERN || D->internalBits & TRACE_MACRO) Log(STDUSERLOG,")\r\n"); 
					fnVarBase = callArgumentBase = argStack[functionNest];
					ptrStack[functionNest++] = ptr+2; // skip closing paren and space
					ptr = (char*) D->w.fndefinition + 1; // continue processing within the macro, skip argument count
					oldecho = echo;
					oldtrace = trace;
					if (D->internalBits & TRACE_MACRO) 
					{
						trace = (unsigned int)-1;
						echo = true;
					}
					continue;
				}
				break;
           case 0: // end of data (argument or function - never a real rule)
	           if (argumentText) // return to normal from argument substitution
                {
                    ptr = argumentText;
                    argumentText = NULL;
                    continue;
                }
                else if (functionNest > startNest) // function call end
                {
 					if (trace & TRACE_PATTERN) Log(STDUSERTABLOG,""); 
					--functionNest;
                    callArgumentIndex = argStack[functionNest]; //   end of argument list (for next argument set)
                    callArgumentBase = baseStack[functionNest]; //   base of callArgumentList
                    fnVarBase = fnVarBaseStack[functionNest];
					ptr = ptrStack[functionNest]; // continue using prior code
					trace = oldtrace;
                    echo = oldecho;
					continue;
                }
                else 
				{
					ChangeDepth(-1,"Match");
 					return false; // shouldn't happen
				}
                break;
            case '(': case '[':  case '{': // nested condition (required or optional) (= consecutive  [ = choice   { = optional
                hold = wildcardIndex;
				{
					int oldgap = gap;
					unsigned int returnStart = positionStart;
					unsigned int returnEnd = positionEnd;
					unsigned int oldselect = wildcardSelector;
					wildcardSelector = 0;
					// nest inherits gaps leading to it. memorization requests withheld til he returns
					matched = Match(ptr,depth+1,positionEnd,*word, positionStart == INFINITE_MATCH,gap,wildcardSelector,returnStart,returnEnd,reverse); //   subsection ok - it is allowed to set position vars, if ! get used, they dont matter because we fail
					wildcardIndex = hold; //   flushes all wildcards swallowed within
					wildcardSelector = oldselect;
					if (matched) 
					{
						positionStart = returnStart;
						positionEnd = returnEnd;
						if (positionEnd) olde = (reverse) ? (positionEnd + 1) : (positionEnd - 1); //   nested checked continuity, so we allow match whatever it found - but not if never set it (match didnt have words)
						if (wildcardSelector) gap = oldgap;	 // to size a gap
					}
					else if (*word == '{') 
					{
						gap = oldgap; // restore any pending gap we didnt plug  (eg *~2 {xx yy zz} a )
					}
				}
				ptr = BalanceParen(ptr); // skip over the material including closer
       			returned = true;
				if (!matched) // failed, revert wildcard index - if ! was used, we will need this
                {
  				    if (*word == '{') 
                    {
						if (wildcardSelector & WILDSPECIFIC) //   we need to memorize failure because optional cant fail
						{
							wildcardSelector ^= WILDSPECIFIC;
							SetWildCard(0, wordCount); 
						}

                        if (gap) continue;   //   if we are waiting to close a wildcard, ignore our failed existence entirely
                        statusBits |= NOT_BIT; //   we didnt match and pretend we didnt want to
                    }
   					else wildcardSelector = 0;
                }
                else if (*word == '{') //   was optional, revert the wildcard index (keep position data)
                {
                    wildcardIndex = hold;	// drop any wildcards bound (including reserve)
                    if (!matched) continue; // be transparent in case wildcard pending
                }
                else if (wildcardSelector > 0)  wildcardIndex = hold; //   drop back to this index so we can save on it 
                break;
            case ')': case ']': case '}' :  //   end sequence/choice/optional
				matched = (kind == '('); //   [] and {} must be failures if we are here
				if (gap) //   pending gap  -  [ foo fum * ] and { foo fot * } are pointless but [*3 *2] is not 
                {
					if (depth != 0) // for simplicity don't end with a gap 
					{
						gap = wildcardSelector = 0;
						matched = false; //   force match failure
					}
					else positionStart = wordCount + 1; //   at top level a close implies > )
				}
                break; 
            case '"':  //   double quoted string
				matched = FindPhrase(word,(positionEnd < basicStart && firstMatched < 0) ? basicStart : positionEnd, reverse);
				if (!(statusBits & NOT_BIT) && matched && firstMatched < 0) firstMatched = positionStart; //   first SOLID match
				break;
            case '%': //   system variable
				if (!word[1]) // simple % 
				{
					matched = MatchTest(reverse,FindWord(word),(positionEnd < basicStart && firstMatched < 0) ? basicStart: positionEnd,NULL,NULL,statusBits & QUOTE_BIT); //   possessive 's
					if (!(statusBits & NOT_BIT) && matched && firstMatched < 0) firstMatched = positionStart; //   first SOLID match
				}
                else matched = SysVarExists(word);
                break;
            case '?': //  question sentence? 
				if (!word[1]) matched = tokenFlags & QUESTIONMARK;
				else matched = false;
	            break;
            case '=': //   a comparison test - never quotes the left side. Right side could be quoted
				//   format is:  = 1-bytejumpcodeToComparator leftside comparator rightside
				if (!word[1]) //   the simple = being present
				{
					matched = MatchTest(reverse,FindWord(word),(positionEnd < basicStart && firstMatched < 0)  ? basicStart : positionEnd,NULL,NULL,statusBits & QUOTE_BIT); //   possessive 's
					if (!(statusBits & NOT_BIT) && matched && firstMatched < 0) firstMatched = positionStart; //   first SOLID match
				}
				//   if left side is anything but a variable $ or _ or @, it must be found in sentence and that is what we compare against
				else 
				{
					// get the operator
					compare = word + Decode(word+1,true); // use accelerator to point to op in the middle
					char op[10];
					char* opptr = compare;
					*op = *opptr;
					op[1] = 0;
					char* lhs = word + 2;
					char* rhs = ++opptr; 
					if (*opptr == '=') // was == or >= or <= or &= 
					{
						op[1] = '=';
						op[2] = 0;
						++rhs;
					}
					*compare = 0;		// separate left and right
					char copy[MAX_WORD_SIZE];
					strcpy(copy,rhs);		// we duplicate rhs because lhs owns the memory and might overwrite it
					rhs = copy; // right hand side of comparator operation
	
					if (*lhs == '^') // local function arg indirect ^$ var or _ as LHS
					{
						char* at = "";
						if (lhs[1] == '$') at = GetUserVariable(lhs+1); 
						else if (IsDigit(lhs[1])) at = callArgumentList[lhs[1]-'0'+fnVarBase];
						at = SkipWhitespace(at);
						strcpy(lhs,at);
					}

					if (*rhs == '^') // local function argument or indirect ^$ var  is LHS. copy across real argument
					{
						char* at = "";
						if (rhs[1] == '$') at = GetUserVariable(rhs+1); 
						else if (IsDigit(rhs[1])) at = callArgumentList[rhs[1]-'0'+fnVarBase];
						at = SkipWhitespace(at);
						strcpy(rhs,at);
					}
				
					bool quoted = false;
					if (*lhs == '\'') // left side is quoted
					{
						++lhs; 
						quoted = true;
					}
			
					if (*op == '?' && opptr[0] != '~')
					{
						char* val = "";
						if (*lhs == '$') val = GetUserVariable(lhs);
						else if (*lhs == '_') val = wildcardCanonicalText[GetWildcardID(lhs)];
						matched = MatchTest(reverse,FindWord(val),(positionEnd < basicStart && firstMatched < 0) ? basicStart : positionEnd,NULL,NULL,quoted); 
						if (!(statusBits & NOT_BIT) && matched && firstMatched < 0) firstMatched = positionStart; //   first SOLID match
						break;
					}
	
					result = *lhs;
					if (result == '%' || result == '$' || result == '_' || result == '@') // otherwise for words and concepts, look up in sentence and check relation there
					{
						result = HandleRelation(lhs,op,rhs,false,id); 
						matched = (result & ENDCODES) ? 0 : 1;
					}
					else // find and test
					{
						matched = MatchTest(reverse,FindWord(lhs),(positionEnd < basicStart && firstMatched < 0) ? basicStart : positionEnd,op,rhs,quoted); //   MUST match later 
						if (!matched) break;
					}
 				}
				break;
            case '\\': //   escape to allow [ ] () < > ' {  } ! as words and 's possessive And anything else for that matter
				if (word[1] == '!') matched =  (wordCount && tokenFlags & EXCLAMATIONMARK) != 0; //   exclamatory sentence
  				else if (word[1] == '?') matched =  tokenFlags & QUESTIONMARK; //   question sentence
				else 
				{
					matched =  MatchTest(reverse,FindWord(word+1),(positionEnd < basicStart && firstMatched < 0) ? basicStart : positionEnd,NULL,NULL,statusBits & QUOTE_BIT);
					if (!(statusBits & NOT_BIT) && matched && firstMatched < 0) firstMatched = positionStart; 
				}
                break;
			case '~': // current topic ~ and named topic
				if (word[1] == 0) // current topic
				{
					matched = IsCurrentTopic(currentTopicID); // clearly we are executing rules from it but is the current topic interesting
					break;
				}
			default: //   ordinary words, concept/topic, numbers, : and ~ and | and & accelerator
				matched = MatchTest(reverse,FindWord(word),(positionEnd < basicStart && firstMatched < 0) ? basicStart : positionEnd,NULL,NULL,statusBits & QUOTE_BIT);
				if (!(statusBits & NOT_BIT) && matched && firstMatched < 0) firstMatched = positionStart;
         } 
		statusBits &= -1 ^ QUOTE_BIT; // turn off any pending quote

        if (statusBits & NOT_BIT && matched) // flip success to failure
        {
            matched = false; 
            statusBits &= -1 ^ NOT_BIT;
            positionStart = oldp; //   restore any changed position values (if we succeed we would and if we fail it doesnt harm us)
            positionEnd = olde;
        }

		//   prove GAP was legal, accounting for ignored words if needed
 		unsigned int started;
		if (!reverse) started = (positionStart < MAX_SENTENCE_LENGTH) ? positionStart : 0; // position start may be the unlimited access value
		else started = (positionStart < MAX_SENTENCE_LENGTH) ? positionEnd : wordCount; // position start may be the unlimited access value
        if (gap && matched) 
        {
			unsigned int begin = started;
			started = (gap & 0x000000ff);
			unsigned int ignore = started;
			int x;
			if (reverse)
			{
				x = started - begin; // *~2 debug() something will generate a -1 started... this is safe here
				while (ignore > begin) // no charge for ignored words in gap
				{
					if (unmarked[ignore--]) --x; 
				}
			}
			else
			{
				x = begin - started; // *~2 debug() something will generate a -1 started... this is safe here
				while (ignore < begin) // no charge for ignored words in gap
				{
					if (unmarked[ignore++]) --x; 
				}
			}
			
			int testgap = gap >> 8;
			if (x <= testgap) olde = (reverse) ? positionStart : begin;   //   we know this was legal, so allow advancement test not to fail- matched gap is started...olde-1
			else  
			{
				matched = false;  // more words than limit
				wildcardSelector &= -1 ^ WILDGAP; //   turn off any save flag
			}
        }

		if (matched) // perform any memorization
		{
			if (olde == positionEnd && oldp == positionStart); // something like function call, didnt change position
			else if (wildcardSelector) //   memorize ONE or TWO things 
			{
				if (started == INFINITE_MATCH) started = 1;
				if (wildcardSelector & WILDGAP) //   would be first if both
				{
					if (reverse)
					{
						if ((started - positionEnd) == 0) SetWildCard("","",0,positionEnd+1); // empty gap
						else SetWildCard(positionEnd + 1,oldp-1);  //   wildcard legal swallow between elements
					}	
					else if ((positionStart - started) == 0) SetWildCard("","",0,olde+1); // empty gap
					else SetWildCard(started,positionStart-1);  //   wildcard legal swallow between elements
				}
				if (positionStart == INFINITE_MATCH) positionStart = 1;
				if (wildcardSelector & WILDSPECIFIC) SetWildCard(positionStart,positionEnd);  // specific swallow 
				gap = wildcardSelector = 0;
			}
			else gap = wildcardSelector = 0; /// should NOT clear this inside a [] or a {} on failure
		}
		else //   fix side effects of anything that failed by reverting
        {
            positionStart = oldp;
            positionEnd = olde;
  			if (kind == '(') gap = wildcardSelector = 0; /// should NOT clear this inside a [] or a {} on failure since they must try again
        }

        //   end sequence/choice/optional
        if (*word == ')' || *word ==  ']' || *word == '}') 
        {
			if (matched)
			{
				if (statusBits & GAPPASSBACK ) //   passing back a gap at end of nested (... * )
				{
					gap = statusBits & GAPPASSBACK;
					wildcardSelector =  statusBits & (WILDSPECIFIC|WILDGAP);
				}
			}
            if (matched && firstMatched > 0)  matched = firstMatched; //   tell spot we matched for top level retry
			success = matched != 0; 

			if (success && argumentText) //   we are ok, but we need to resume old data
			{
				ptr = argumentText;
				argumentText = NULL;
				continue;
			}

			break;
        }

		//   postprocess match of single word or paren expression
		if (statusBits & NOT_BIT) //   flip failure result to success now (after wildcardsetting doesnt happen because formally match failed first)
        {
            matched = true; 
			statusBits &= -1 ^ NOT_BIT;
         }

		//   word ptr may not advance more than 1 at a time (allowed to advance 0 - like a string match or test) unless global unmarks in progress
        //   But if initial start was INFINITE_MATCH, allowed to match anywhere to start with
		if (reverse)
		{
			if (matched && oldp != INFINITE_MATCH && olde < oldp && positionEnd >= (oldp - 1) && positionStart != INFINITE_MATCH ){;} // legal move ahead given matched WITHIN last time
			else if (matched && oldp != INFINITE_MATCH && positionEnd < (olde - 1 ) && positionStart != INFINITE_MATCH )  // failed to match position advance
			{
				unsigned int ignored = oldp-1;
				if (unmarked[ignored]) while (--ignored > positionEnd && unmarked[ignored]); // dont have to account for these
				if (ignored != positionStart) // position track failed
				{
					if ((unsigned int) firstMatched == positionStart) firstMatched = 0; // drop recog of it
					matched = false;
					positionStart = oldp;
					positionEnd = olde;
				}
			}
		}
		else if (matched && oldp != INFINITE_MATCH && olde < oldp && positionStart <= (oldp + 1) && positionStart != INFINITE_MATCH ){;} // legal move ahead given matched WITHIN last time
        else if (matched && oldp != INFINITE_MATCH && positionStart > (olde + 1) && positionStart != INFINITE_MATCH )  // failed to match position advance
        {
			unsigned int ignored = olde+1;
			if (unmarked[ignored]) while (++ignored < positionStart && unmarked[ignored]); // dont have to account for these
			if (ignored != positionStart) // position track failed
			{
				if ((unsigned int) firstMatched == positionStart) firstMatched = 0; // drop recog of it
				matched = false;
				positionStart = oldp;
				positionEnd = olde;
			}
        }

        //   now verify position of match, NEXT is default for (type, not matter for others
        if (kind == '(') //   ALL must match in sequence
        {
			//   we failed, retry shifting the start if we can
			if (!matched)
			{
				if (!retried  && wildstart && firstMatched > 0) //   we are top level and have a first matcher, we can try to shift it
				{
					if (trace & TRACE_PATTERN) Log(STDUSERTABLOG,"retry past %d ----------- ",firstMatched);
					//   reset to initial conditions, mostly 
					ptr = orig;
					wildcardIndex = 0; 
					basicStart = positionEnd = firstMatched;  //   THIS is different from inital conditions
					firstMatched = -1; 
					positionStart = INFINITE_MATCH; 
					gap = 0;
					wildcardSelector = 0;
					statusBits &= -1 ^ (NOT_BIT | FREEMODE_BIT);
					argumentText = NULL; 
					retried = true;	// do this retry ONLY once
					continue;
				}
				break; //   default fail
			}
			if (statusBits & FREEMODE_BIT) 
			{
				positionEnd = startposition;  //   allowed to pick up after here
				positionStart = INFINITE_MATCH; //   re-allow anywhere
			}
		}
        else if (matched /* && *word != '>' */ ) // was could not be END of sentence marker, why not???  
        {
			if (argumentText) //   we are ok, but we need to resume old data
			{
				ptr = argumentText;
				argumentText = NULL;
			}
			else
			{
				success = true; //   { and [ succeed when one succeeeds 
				break;
			}
		}
    } 

	//   begin the return sequence
	
	if (functionNest > startNest)//   since we are failing, we need to close out all function calls in progress at this level
    {
        callArgumentIndex = argStack[startNest];
        callArgumentBase = baseStack[startNest];
		fnVarBase = fnVarBaseStack[startNest];
		functionNest = startNest;
    }
	
	if (success)
	{
		returnstart = (firstMatched > 0) ? firstMatched : positionStart; // if never matched a real token, report 0 as start
		returnend = positionEnd;
	}

	//   if we leave this level w/o seeing the close, show it by elipsis 
	//   can only happen on [ and { via success and on ) by failure
	if (trace & TRACE_PATTERN && depth)
	{
		if (*word != ')' && *word != '}' && *word !=  ']')
		{
			if (success) Log(STDUSERTABLOG,"%c ... + %d:%d ",(kind == '{') ? '}' : ']',positionStart,positionEnd);
			else Log(STDUSERTABLOG,") ... - ");
		}
		else if (*word == ')') Log(STDUSERLOG,"+%d:%d ",positionStart,positionEnd);
	}
	
	ChangeDepth(-1,"Match");
    return success; 
}

// raw data parser for dictionary.... (not needed in a product)

#include "common.h"

#ifdef DISCARDDICTIONARYBUILD
void LoadRawDictionary(int mini)
{    
	printf("Raw dictionary code not installed\r\n");
}

void BuildShortDictionaryBase()
{
}

#else
#include "../extraSrc/readrawdata.cpp"
#endif
#include "common.h"
//------------------------
// ALWAYS AVAILABLE
//------------------------
char* newBuffer = 0;

static char* incomingPtrSys = 0;			// cache AFTER token find ptr when peeking.
static char lookaheadSys[MAX_WORD_SIZE];	// cache token found when peeking
static unsigned int hasWarnings;			// number of warnings generated
unsigned int hasErrors;

bool compiling = false;			// script compiler in progress
bool patternContext = false;	// current compiling a pattern

#define MAX_WARNINGS 150
static char warnings[MAX_WARNINGS][MAX_WORD_SIZE];
static unsigned int warnIndex = 0;

#define MAX_ERRORS 150
static char errors[MAX_ERRORS][MAX_WORD_SIZE];
static unsigned int errorIndex = 0;

static char functionArguments[MAX_ARGUMENT_COUNT+1][500];
static int functionArgumentCount = 0;
static char botheader[MAX_WORD_SIZE];

static bool endtopicSeen = false; // needed when ending a plan

uint64 buildID = 0;

static char* topicFiles[] = //   files created by a topic refresh from scratch 
{
	"TOPIC/factsx.txt",			//   hold facts	
	"TOPIC/keywordsx.txt",		//   holds topic and concepts keywords
	"TOPIC/macrosx.txt",		//   holds macro definitions
	"TOPIC/scriptx.txt",		//   hold topic definitions
	"TOPIC/plansx.txt",			//   hold plan definitions
	"TOPIC/patternWordsx.txt",	//   things we want to detect in patterns that may not be normal words
	"TOPIC/dictx.txt",			//   dictionary changes	

	"TOPIC/missingLabel.txt",	//   reuse/unerase needing delayed testing for label
	"TOPIC/missingSets.txt",	//   sets needing delayed testing
	0
};

void InitScriptSystem()
{
}

void AddWarning(char* buffer)
{
	sprintf(warnings[warnIndex++],"line %d of %s: %s",currentFileLine,currentFilename,buffer);
	if (warnIndex >= MAX_WARNINGS) --warnIndex;
}

void ScriptWarn()
{
	if (compiling)
	{
		++hasWarnings; 
		Log(STDUSERLOG,"*** Warning- line %d of %s: ",currentFileLine,currentFilename);
	}
}

void AddError(char* buffer)
{
	sprintf(errors[errorIndex++],"line %d of %s: %s",currentFileLine,currentFilename,buffer);
	if (errorIndex >= MAX_ERRORS) --errorIndex;
}

void ScriptError()
{
	++hasErrors; 
	if (compiling)
	{
		patternContext = false; 
		Log(STDUSERLOG,"*** Error- line %d of %s: ",currentFileLine,currentFilename);
	}
}

void EraseTopicFiles(uint64 build)
{
	int i = -1;
	while (topicFiles[++i])
	{
		strcpy(tmpWord,topicFiles[i]);
		char* ptr = strchr(tmpWord,'.') - 1;
		if (*ptr == 'x') *ptr = (build == BUILD0) ? '0' : '1'; // unique name per file build
		remove(tmpWord);
	}
}

static char* FindComparison(char* word)
{
	if (!*word || !word[1] || !word[2]) return NULL; //   if token is short, we cannot do the below word+1 scans 
	if (*word == '.') return NULL; //  .<_3 is not a comparison
	if (*word == '\\') return NULL; // escaped is not a comparison
	char* at = strchr(word+1,'!'); 
	if (!at) at = strchr(word+1,'<');
	if (!at) at = strchr(word+1,'>');
	if (!at) 
	{
		at = strchr(word+1,'&');
		if (at && at[1] == '_') at = 0;	// ignore & as part of a name
	}
	if (!at) at = strchr(word+1,'=');
	if (!at) at = strchr(word+1,'?');  //   member of set
	if (!at)
	{
		at = strchr(word+1,'!');  //   negation
		if (at && (at[1] == '=' || at[1] == '?'));
		else at = NULL;
	}
	return at;
}

char* ReadNextSystemToken(FILE* in,char* ptr, char* word, bool separateUnderscore, bool peek)
{ 

#ifdef INFORMATION
The outside can ask for the next real token or merely peek ahead one token. And sometimes the outside
after peeking, decides it wants to back up a real token (passing it to some other processor).

To support backing up a real token, the system must keep the current readBuffer filled with the data that
led to that token (to allow a ptr - strlen(word) backup).

To support peeking, the system may have to read a bunch of lines in to find a token. It is going to need to
track that buffer separately, so when it needs a real token which was the peek, it can both get the peek value
and be using contents of the new buffer thereafter. 

So peeks must never touch the real readBuffer. And real reads must know whether the last token was peeked 
and from which buffer it was peeked.

And, if someone wants to back up to allow the old token to be reread, they have to CANCEL any peek data, so the token
comes from the old buffer. Meanwhile the newbuffer continues to have content for when the old buffer runs out.
#endif
	
	//   get next token
	if (!in && !ptr) // clear cache request, next get will be from main buffer (though secondary buffer may still have peek read data)
	{
		if (word) *word = 0;
		incomingPtrSys = NULL; // no longer holding a PEEK value.
		return NULL;
	}

	char* result = 0;
	if (incomingPtrSys) //  had a prior PEEK, now in cache. use up cached value, unless duplicate peeking
	{
		result = incomingPtrSys; // caller who is peeking will likely ignore this
		if (!peek)
		{
			// he wants reality now...
			if (*newBuffer) // prior peek was from this buffer, make it real data in real buffer
			{
				strcpy(readBuffer,newBuffer);
				result = (result - newBuffer) + readBuffer; // adjust pointer to current buffer
				*newBuffer = 0;
			}
			strcpy(word,lookaheadSys);
			incomingPtrSys = 0;
		}
		else 
		{
			strcpy(word,lookaheadSys); // duplicate peek
			result = (char*)1;	// NO ONE SHOULD KEEP A PEEKed PTR
		}

		return result;
	}

	*word = 0;

	if (ptr) result = ReadSystemToken(ptr,word,separateUnderscore);
	bool newline = false;
	while (!*word) // found no token left in existing buffer
	{
		if (!newline && *newBuffer) // use pre-read buffer per normal, it will have a token
		{
			strcpy(readBuffer,newBuffer);
			*newBuffer = 0;
			result = ReadSystemToken(readBuffer,word,separateUnderscore);
			break;
		}
		else // read new line into hypothetical buffer, not destroying old actual buffer yet
		{
			if (!in || !ReadALine(newBuffer,in)) return NULL; //   end of file
			if (!strnicmp(newBuffer,"#ignore",7)) // hit an ignore zone
			{
				unsigned int ignoreCount = 1;
				while (ReadALine(newBuffer,in))
				{
					if (!strnicmp(newBuffer,"#ignore",7)) ++ignoreCount;
					else if (!strnicmp(newBuffer,"#endignore",10))
					{
						if (--ignoreCount == 0)
						{
							if (!ReadALine(newBuffer,in)) return NULL;	// EOF
							break;
						}
					}
				}
				if (ignoreCount) return NULL;	//EOF before finding closure
			}
		}
		result = ReadSystemToken(newBuffer,word,separateUnderscore); // result is ptr into NEWBUFFER
		newline = true;
	}

	if (peek) //   save request - newBuffer has implied newline if any
	{
		incomingPtrSys = result;  // next location in new buffer
		strcpy(lookaheadSys,word); // save next token peeked
		result = (char*)1;	// NO ONE SHOULD KEEP A PEEKed PTR
	}
	else if (newline) // live token from new buffer, adjust pointers and buffers to be fully up to date
	{
		strcpy(readBuffer,newBuffer);
		result = (result - newBuffer) + readBuffer; // ptr into current readBuffer now
		*newBuffer = 0;
	}

	return result; // ptr into READBUFFER or 1 if from peek zone
}

static void InsureAppropriateCase(char* word)
{
	char c;
	char* at = FindComparison(word);
	//   force to lower case various standard things
	//   topcs/sets/classes/user vars/ functions and function vars  are always lower case
 	if (at) //   a comparison has 2 sides
	{
		c = *at;
		*at = 0;
		InsureAppropriateCase(word);
		if (at[1] == '=' || at[1] == '?') InsureAppropriateCase(at+2); // == or >= or such
		else InsureAppropriateCase(at+1);
		*at = c;
	}
	else if (*word == '_' || *word == '\'') InsureAppropriateCase(word+1);
	else if ((*word == '^' && word[1] != '"') || *word == '~' || *word == '$' || *word == '%' || *word == '|' ) MakeLowerCase(word);	
	else if (*word == '@' && IsDigit(word[1])) MakeLowerCase(word);	//   potential factref like @2subject
}

static int GetFunctionArgument(char* arg) //   get index of argument (0-based) if it is value, else -1
{
	for (int i = 0; i < functionArgumentCount; ++i)
	{
		if (!stricmp(arg,functionArguments[i])) return i;
	}
	return -1; //   failed
}

char* ReadSystemToken(char* ptr, char* word, bool separateUnderscore) //   how we tokenize system stuff (rules and topic system) words -remaps & to AND
{
	*word = 0;
    if (!ptr)  return 0;
    char* start = word;
    ptr = SkipWhitespace(ptr);

#ifdef INFORMATION
	A token is nominally a contiguous collection of characters broken off by tab or space (since return and newline are stripped off).
	Tokens to include whitespace are encased in doublequotes.
	Strings preceeded by ^ are compiled as normal output.

	Characters with reserved status automatically also break into individual tokens and to include them you must put \ before them. These include:
	[ ]  ( )  { }  always and separate into individual tokens except for _(  _[   _{ 

	< > and << >> are reserved, but only when at start or end of token. Allowed comparisons embedded. As is <= and >=
	Tokens ending with ' or 's break off (possessive) in patterns.  
	
	Tokens starting with prefix characters ' or ! or _ keep together, except per reserved tokens.	'$junk  is one token.
	Variables ending with punctuation separate the punctuation.  $hello. is two tokens as is _0.

	Reserved characters in a composite token with _ before or after are kept. E.g. This_(_story_is_)_done
	You can include a reserved tokens by putting \ in front of them.

	Some tokens revise their start, like the pattern tokens representing comparison. They do this in the script compiler.
#endif

	// strings
	if (*ptr == '"' || ( *ptr  == '^' && ptr[1] == '"') || (*ptr == '\\' && ptr[1] == '"')) //   doublequote maybe with functional heading
	{
		// simple \"
		if (*ptr == '\\' && (!ptr[2] ||ptr[2] == ' ' || ptr[2] == '\t' || ptr[2] == ENDUNIT)) 
		{
			*word = '\\';
			word[1] = '"';
			word[2] = 0;
			return ptr+2;
		}
		bool backslash = false;
		bool noblank = true;
		if (*ptr == '^') 
		{
			*word++ = *ptr++;	// ^"script" 
			noblank = false; // allowed blanks at start or rear
		}
		else if (*ptr == '\\') //  \"string is this"
		{
			backslash = true;
			++ptr;
		}
		char* end = ReadQuote(ptr,word,backslash,noblank);	//   swallow ending marker and points past
		if (end)  
		{
		// when seeing ^, see if it remaps as a function argument
			// check for internal ^ also...
			char* hat = word-1;
			while ( (hat = strchr(hat+1,'^'))) // find a hat within
			{
				char* at = hat;
				while (*++at && (IsAlpha(*at) || *at == '_' || IsDigit(*at))){;}
				char c = *at;
				*at = 0;
				int index = GetFunctionArgument(hat);
				*at = c;
				if (index >= 0) 
				{
					char tmp[MAX_WORD_SIZE];
					strcpy(tmp,at); // protect chunk
					sprintf(hat,"^%d%s",index,tmp);
				}
			}
			return end;					//   if we did swallow a string
		}
		if (*ptr == '\\') // was this \"xxx with NO closing
		{
			memmove(word+1,word,strlen(word)+1);
			*word = '\\';
		}
		else
		{
			word = start;
			if (*start == '^') --ptr;
		}

	}

	// the normal composite token
	while (*ptr && *ptr != ' ' && *ptr != '\t' && *ptr != ENDUNIT) 
	{
		char c = *ptr++;
		*word++ = c;
		*word = 0;
		if (nestingData[c]) // break off nesting attached to a started token unless its an escaped token
		{
			size_t len = word - start;
			if (len == 1) break;		// automatically token by itself
			if (len == 2)
			{
				if ((*start == '_' || *start == '!') && (c == '[' || c == '(' || c == '{')) break; // one token as _( or !( 
				if (*start == '\\') break;	// one token escaped
			}
			// split off into two tokens
			--ptr;
			--word;
			break;  
		}
	}
	*word = 0;

    word = start;
	size_t len = strlen(word);
	if (len == 0) return ptr; 

	if (*word == '#') // is this a constant from dictionary.h?
	{
		uint64 n = FindValueByName(word+1);
		if (!n) n = FindValue2ByName(word+1);
		if (n) sprintf(word,"%lld",n);
		else if (!IsDigit(word[1]) && word[1] != '!') //treat rest as a comment line (except if has number after it, which is user text OR internal arg reference for function
		{
			if (IsAlpha(word[1])) BADSCRIPT("Bad numeric # constant %s",word)
			*ptr = 0;
			*word = 0;
		}
	}

	// some tokens require special splitting
		
	//   break off starting << from <<hello   
	if (*word == '<' && word[1] != '=')
	{
		if (len == 3 && *word == word[1] && word[2] == '=') {;}
		else if (word[1] == '<')
		{
			if (word[2]) // not assign operator
			{
				ptr -= strlen(word) - 2;
				word[2] = 0;
				len -= 2;
			}
		}
	}

	//   break off ending  >> from hello>> 
	if (len > 2 && word[len-1] == '>')
	{
		if (len == 3 && *word == word[1] && word[2] == '=') {;}
		else if (word[len-2] == '>')
		{
			ptr -= 2;
			word[len-2] = 0;
			len -= 2;
		}
	}

	// break off punctuation from variable end 
	if (len > 2 && ((*word == '$' && !IsDigit(word[1])) || (*word == '@' && IsDigit(word[1])) || *word == '%' || (*word == '_' && IsDigit(word[1])) || (*word == '\'' && word[1] == '_'))) // not currency
	{
		if (!patternContext || word[len-1] != '?') // BUT NOT $$xxx? in pattern context
		{
			while (realPunctuation[word[len-1]]) // one would be enough, but $hello... needs to be addressed
			{
				--len;
				--ptr;
			}
			word[len] = 0;
		}
	}

	// break off opening < in pattern
	if (patternContext && *word == '<' && word[1] != '<')
	{
		ptr -= len - 1;
		len = 1;
		word[1] = 0;
	}

	// break off closing > in pattern unless escaped or notted
	if (len == 2 && (*word == '!' || *word == '\\')){;}
	else if (patternContext && len > 1 && word[len-1] == '>' && word[len-2] != '>')
	{
		ptr -= len - 1;
		--len;
		word[len-1] = 0;
	}

	// find internal comparison op if any
	char* at = (patternContext) ? FindComparison(word) : 0;
	if (at && *word == '*' && !IsDigit(word[1])) 
	{
		if (compiling) BADSCRIPT("TOKENS-1 Cannot do comparison on variable gap %s . Memorize and compare against _# instead later. ",word)
	}
	
	if (at) // revise comparison operators
	{
		if (*at == '!') ++at;
		++at;
		
		if (*at == '^' && at[1]) // remap function arg on right side.
		{
			int index = GetFunctionArgument(at);
			if (index >= 0) sprintf(at,"^%d",index);
		}

		// check for remap on LHS
		if (*word == '^')
		{
			char c = *--at;
			*at = 0;
			int index = GetFunctionArgument(word);
			*at = c;
			char hold[MAX_WORD_SIZE];
			if (index >= 0) 
			{
				sprintf(hold,"^%d%s",index,at);
				strcpy(word,hold);
			}
		}

	}
	// when seeing ^, see if it remaps as a function argument
	// check for internal ^ also...
	char* hat = word-1;
	while ( (hat = strchr(hat+1,'^'))) // find a hat within
	{
		char* at = hat;
		while (*++at && (IsAlpha(*at) || *at == '_' || IsDigit(*at))){;}
		char c = *at;
		*at = 0;
		int index = GetFunctionArgument(hat);
		*at = c;
		if (index >= 0) 
		{
			char tmp[MAX_WORD_SIZE];
			strcpy(tmp,at); // protect chunk
			sprintf(hat,"^%d%s",index,tmp);
		}
	}

	// same for quoted function arg
	if (*word == '\'' && word[1] == '^' && word[2])
	{
		int index = GetFunctionArgument(word+1);
		if (index >= 0) sprintf(word,"'^%d",index);
	}

	// break apart math on variables eg $value+2 
	if (*word == '%' || *word == '%' || *word == '$')
	{
		char* at = word;
		while (IsAlpha(*++at));  // find end of word
		if (*at && punctuation[*at] & ARITHMETICS && *at != '=')
		{
			ptr -= strlen(at);
			*at = 0;
			len = at - start;
		}
	}
	char* tilde = (IsAlpha(*word)) ? strchr(word+1,'~') : 0;
	if (tilde) // has specific meaning like African-american~1n or African-american~1
	{
		if (IsDigit(*++tilde)) // we know the meaning, removing any POS marker since that is redundant
		{
			if (IsDigit(*++tilde)) ++tilde;
			if (*tilde && !tilde[1])  *tilde = 0; // trim off pos marker

			// now force meaning to master
			MEANING M = ReadMeaning(word,true,false);
			if (M) 
			{
				M = GetMaster(M);
				sprintf(word,"%s~%d",Meaning2Word(M)->word,Meaning2Index(M));
			}
		}
	}

	InsureAppropriateCase(word);
	return ptr; 
}

////////////////// CAN BE COMPILED AWAY

#ifndef DISCARDSCRIPTCOMPILER

#define MAX_TOPIC_SIZE  500000
#define MAX_TOPIC_RULES 32767
#define MAX_TABLE_ARGS 20

static unsigned int hasPlans;					// how many plans did we read

static int missingFiles;						// how many files of topics could not be found

static int spellCheck = 0;						// what do we spell check
static int topicCount = 0;						// how many topics did we compile
static char duplicateTopicName[MAX_WORD_SIZE];	// potential topic name repeated
static char assignKind[MAX_WORD_SIZE];	// what we are assigning from in an assignment call
static char currentTopicName[MAX_WORD_SIZE];	// current topic being read
static char lowercaseForm[MAX_WORD_SIZE];		// a place to put a lower case copy of a token
static char argset[50][MAX_WORD_SIZE];			// arguments for a function call being built
static WORDP currentFunctionDefinition;			// current macro defining or executing
static FILE* patternFile = NULL; // where to store pattern words
static char nextToken[MAX_WORD_SIZE];			// current lookahead token

static char verifyLines[100][MAX_WORD_SIZE];	// verification lines for a rule to dump after seeing a rule
static unsigned int verifyIndex = 0;			// index of how many verify lines seen

#ifdef INFORMATION
Script compilation validates raw topic data files amd converts them into efficient-to-execute forms.
This means creating a uniform spacing of tokens and adding annotations as appropriate.

Reading a topic file (on the pattern side) often has tokens jammed together. For example all grouping characters like
() [ ] { } should be independent tokens. Possessive forms like cat's and cats' should return as two tokens.

One does not refer to & as a character, because tokenization always translates that to "and". 
Just as all contractions will get expanded to the full word.

Some tokens can be prefixed with ! or single-quote or _ .
In order to be able to read special characters (including prefix characters) literally, one can prefix it with \  as in \[  . The token returned includes the \.
\! means the exclamation mark at end of sentence. 
You are not required to do \? because it is directly a legal token, but you can.  
You CANNOT test for . because it is the default and is subsumed automatically.
#endif

static void ClearBeenHere(WORDP D, uint64 junk)
{
	RemoveInternalFlag(D,BEEN_HERE);
}

bool TopLevelUnit(char* word) // major headers (not kinds of rules)
{
	return (!stricmp(word,"concept:") || !stricmp(word,"data:") || !stricmp(word,"plan:") 
		|| !stricmp(word,"outputMacro:") || !stricmp(word,"patternMacro:") || !stricmp(word,"dualMacro:")  || !stricmp(word,"table:") || !stricmp(word,"tableMacro:") || 
		!stricmp(word,"bot:") || !stricmp(word,"topic:") || (*word == ':' && IsAlpha(word[1])) );	// :xxx is a debug command
}

static char* FlushToTopLevel(FILE* in,char* ptr,unsigned int depth,char* data)
{
	globalDepth = depth;
	if (data) *data = 0; // remove data
	char word[MAX_WORD_SIZE];
	int oldindex = jumpIndex;
	jumpIndex = -1; // prevent ReadNextSystemToken from possibly crashing.
	*newBuffer = 0;
	while (ALWAYS)
	{
		char* quote = NULL;
		while ((quote = strchr(ptr,'"'))) ptr = quote + 1; //  flush quoted things
		ptr = ReadNextSystemToken(in,ptr,word,false);
		if (!*word) break;
		MakeLowerCopy(lowercaseForm,word);
		if (TopLevelUnit(lowercaseForm) || TopLevelRule(lowercaseForm)) 
		{
			ptr -= strlen(word);
			break;
		}
	}
	jumpIndex = oldindex;
	return ptr;
}

static bool IsSet(char* word)
{
	if (!word[1]) return true;
	WORDP D = FindWord(word,0,LOWERCASE_LOOKUP);
	return (D && D->systemFlags & CONCEPT) ? true : false;
}

static bool IsTopic(char* word)
{
	if (!word[1]) return true;
	WORDP D = FindWord(word,0,LOWERCASE_LOOKUP);
	return (D && D->systemFlags & TOPIC) ? true : false;
}

static void DoubleCheckSetOrTopic()
{
	FILE* in = fopen("TOPIC/missingsets.txt","rb");
	if (!in) return;
	while (ReadALine(readBuffer,in) != 0) 
    {
		char word[MAX_WORD_SIZE];
		char* ptr = ReadCompiledWord(readBuffer,word);
		if (!IsSet(word) && !IsTopic(word)) 
			WARNSCRIPT("Undefined set or topic %s\r\n",readBuffer)
	}
	fclose(in);
	remove("TOPIC/missingSets.txt");
}

static void CheckSetOrTopic(char* name) // we want to prove all references to set get defined
{
	char word[MAX_WORD_SIZE];
	MakeLowerCopy(word,name);
	char* label = strchr(word,'.'); // set reference might be ~set or  ~set.label
	if (label) *label = 0; 
	if (IsSet(word) || IsTopic(word)) return;

	WORDP D = StoreWord(word);
	if (D->internalBits & BEEN_HERE) return; // already added to check file
	AddInternalFlag(D,BEEN_HERE);
	FILE* out = fopen("TOPIC/missingsets.txt","ab");
	fprintf(out,"%s line %d in %s\r\n",word,currentFileLine,currentFilename);
	fclose(out);
}

static char* AddVerify(char* kind, char* sample)
{
	char* comment = strstr(sample,"# "); // locate any comment on the line and kill it
	if (comment) *comment = 0;
	sprintf(verifyLines[verifyIndex++],"%s %s",kind,SkipWhitespace(sample)); 
	return 0;	// kill rest of line
}

static void WriteVerify()
{
	if (!verifyIndex) return;
	char name[100];
	if (duplicateCount) sprintf(name,"VERIFY/%s.%d.txt",currentTopicName+1,duplicateCount);
	else sprintf(name,"VERIFY/%s.txt",currentTopicName+1); 
	FILE* valid  = FopenUTF8WriteAppend(name);
	if (valid)
	{
		char* space = "";
		if (REJOINDERID(currentRuleID)) space = "    ";
		for (unsigned int i = 0; i < verifyIndex; ++i) 
		{
			fprintf(valid,"%s %s.%d.%d %s\r\n",space,currentTopicName,TOPLEVELID(currentRuleID),REJOINDERID(currentRuleID),verifyLines[i]); 
		}
		fclose(valid);
	}
	verifyIndex = 0;
}

#ifdef INFORMATION
We mark words that are not normally in the dictionary as pattern words if they show up in patterns.
For example, the names of synset heads are not words, but we use them in patterns. They will
be marked during the scan phase of matching ONLY if some pattern "might want them". I.e., 
they have a pattern-word mark on them. same is true for multiword phrases we scan.

Having marked words also prevents us from spell-correcting something we were expecting but which is not a legal word.
#endif

static void WritePatternWord(char* word)
{
	if (!compiling || *word == '~' || *word == '$' || *word == '^') return; // not normal words

	if (IsDigit(*word)) // any non-number stuff
	{
		char* ptr = word;
		while (*++ptr)
		{
			if (!IsDigit(*ptr) && *ptr != '.' && *ptr != ',') break;
		}
		if (!*ptr) return;	// ordinary number
	}

	// case sensitivity?
	char tmp[MAX_WORD_SIZE];
	MakeLowerCopy(tmp,word);
	WORDP lower = FindWord(word,0,LOWERCASE_LOOKUP);
	WORDP upper = FindWord(word,0,UPPERCASE_LOOKUP);
	if (!strcmp(tmp,word))  {;} // came in as lower case
	else if (upper && GetMeaningCount(upper) > 0){;} // clearly known as upper case
	else if (lower && lower->properties & (QWORD | FINITE_SET_WORDS) && !(lower->properties & (DETERMINER|AUX_VERB))) WARNSCRIPT("Keyword %s should not be uppercase - did prior rule fail to close\r\n",word)
	else if (spellCheck && lower && lower->properties & VERB && !(lower->properties & NOUN)) WARNSCRIPT("Uppercase keyword %s is usually a verb.  Did prior rule fail to close\r\n",word)
	
	// do we want to note this word
	WORDP D = StoreWord(word);
	if (D->properties & NORMAL_WORD) return;	// already a known word
	if (D->internalBits & BEEN_HERE) return;	//   already written to pattern file or doublecheck topic ref file
	if (patternFile) 
	{
		AddSystemFlag(D,PATTERN_WORD);
		fprintf(patternFile,"%s\r\n",word);
		AddInternalFlag(D,BEEN_HERE);
	}
}

static void NoteUse(char* label,char* topic)
{
	MakeUpperCase(label);
	WORDP D = FindWord(label);
	if (!D || !(D->internalBits & LABEL))
	{
		FILE* out = fopen("TOPIC/missingLabel.txt","ab");
		if (out)
		{
			fprintf(out,"%s %s %s %d\r\n",label,topic,currentFilename,currentFileLine);
			fclose(out);
		}
	}
}

static void ValidateCallArgs(WORDP D,char* arg1, char* arg2)
{
	if (!stricmp(D->word,"^next"))
	{	
		if (stricmp(arg1,"RESPONDER") && stricmp(arg1,"REJOINDER") && stricmp(arg1,"RULE") && stricmp(arg1,"GAMBIT") && stricmp(arg1,"INPUT") && stricmp(arg1,"FACT")) 
			BADSCRIPT("CALL- 62 1st argument to ^next must be FACT OR INPUT or RULE or GAMBIT or RESPONDER or REJOINDER - %s",arg1)
	}	
	else if(!stricmp(D->word,"^keephistory"))
	{
		if (stricmp(arg1,"USER") && stricmp(arg1,"BOT") )
			BADSCRIPT("CALL- ? 1st argument to ^keephistory must be BOT OR USER - %s",arg1)
	}
	else if (!stricmp(D->word,"^field") && IsAlpha(*arg2))
	{	
		if (*arg2 != 's' && *arg2 != 'S' &&  *arg2 != 'v' && *arg2 != 'V' && *arg2 != 'O' && *arg2 != 'o' ) 
			BADSCRIPT("CALL- 9 2nd argument to ^field must be SUBJECT or VERB or OBJECT - %s",arg1)
	}
	else if (!stricmp(D->word,"^position") )
	{
		if (stricmp(arg1,"START") && stricmp(arg1,"END") && stricmp(arg1,"BOTH")) 
			BADSCRIPT("CALL- ? 1st argument to ^position must be START, END, BOTH, - %s",arg1)
	}
	else if (!stricmp(D->word,"^getparse") )
	{
		if (stricmp(arg2,"PHRASE") && stricmp(arg2,"VERBAL") && stricmp(arg2,"CLAUSE")&& stricmp(arg2,"NOUNPHRASE")) 
			BADSCRIPT("CALL- ? 2nd argument to ^getparse must be PHRASE, VERBAL, CLAUSE, NOUNPHRASE- %s",arg2)
	}
	else if (!stricmp(D->word,"^reset") && IsAlpha(*arg1))
	{
		if (stricmp(arg1,"user") && stricmp(arg1,"topic") && *arg1 != '@') 
			BADSCRIPT("CALL- 10 1st argument to ^reset must be USER or TOPIC or an @set- %s",arg1)
	}
	else if (!stricmp(D->word,"^substitute"))
	{
		if (stricmp(arg1,"word") && stricmp(arg1,"character")) 
			BADSCRIPT("CALL- 11 1st argument to ^substitute must be WORD or CHARACTER- %s",arg1)
	}
	else if (!stricmp(D->word,"^gambit"))
	{
		if (!*arg1) 
			BADSCRIPT("CALL- 63 call to ^gambit requires at least 1 argument (topic name, ~, or PENDING) ")
	}
	else if (!stricmp(D->word,"^pos") && IsAlpha(*arg1))
	{
		if (stricmp(arg1,"syllable") && stricmp(arg1,"VERB") && stricmp(arg1,"AUX") && stricmp(arg1,"PRONOUN") && stricmp(arg1,"TYPE") 
			 && stricmp(arg1,"NOUN") && stricmp(arg1,"DETERMINER") && stricmp(arg1,"PLACE")
 			 && stricmp(arg1,"capitalize") && stricmp(arg1,"uppercase") && stricmp(arg1,"lowercase") && stricmp(arg1,"canonical") && stricmp(arg1,"integer"))
 			BADSCRIPT("CALL- 12 1st argument to ^pos must be SYLLABLE or VERB or AUX or PRONOUN or NOUN or DETERMINER or PLACE or CAPITALIZE or UPPERCASE or LOWERCASE or CANONICAL or INTEGER- %s",arg1)
	}
	else if (!stricmp(D->word,"^getrule"))
	{
		if (stricmp(arg1,"TOPIC") &&  stricmp(arg1,"OUTPUT") && stricmp(arg1,"PATTERN") && stricmp(arg1,"LABEL") && stricmp(arg1,"TYPE")  && stricmp(arg1,"TAG") && stricmp(arg1,"USABLE")) 
 			BADSCRIPT("CALL- 13 1st argument to ^getrule must be TAG or TYPE or LABEL or PATTERN or OUTPUT or TOPIC or USABLE - %s",arg1)
	}
	else if (!stricmp(D->word,"^poptopic"))
	{
		if (*arg1 && *arg1 != '~' && *arg1 != '$' && *arg1 != '_' && *arg1 != '%' && *arg1 != '^')
 			BADSCRIPT("CALL- 61 1st argument to ^poptopic must be omitted or a topic name or variable which will return a topic name - %s",arg1)
	}
	else if (!stricmp(D->word,"^nextrule"))
	{
		if (stricmp(arg1,"GAMBIT") && stricmp(arg1,"RESPONDER") && stricmp(arg1,"REJOINDER")  && stricmp(arg1,"RULE")) 
 			BADSCRIPT("CALL- 14 1st argument to ^getrule must be TAG or TYPE or LABEL or PATTERN or OUTPUT - %s",arg1)
	}
	else if (!stricmp(D->word,"^end") && IsAlpha(*arg1))
	{
		if (stricmp(arg1,"RULE") && stricmp(arg1,"TOPIC") && stricmp(arg1,"SENTENCE") && stricmp(arg1,"INPUT")  && stricmp(arg1,"PLAN")) 
 			BADSCRIPT("CALL- 15 1st argument to ^end must be RULE or TOPIC or SENTENCE or INPUT or PLAN- %s",arg1)
	}
	else if (!stricmp(D->word,"^fail") && IsAlpha(*arg1))
	{
		if (stricmp(arg1,"RULE") && stricmp(arg1,"TOPIC") && stricmp(arg1,"SENTENCE") && stricmp(arg1,"INPUT")) 
 			BADSCRIPT("CALL- 16 1st argument to ^fail must be RULE or TOPIC or SENTENCE or INPUT - %s",arg1)
	}
	else if (!stricmp(D->word,"^compute") && IsAlpha(*arg2))
	{
		char* op = arg2;
		if (stricmp(op,"+") && stricmp(op,"plus") && stricmp(op,"add") && stricmp(op,"and") &&
			stricmp(op,"sub") && stricmp(op,"minus") && stricmp(op,"subtract") && stricmp(op,"deduct") && stricmp(op,"-") &&
			stricmp(op,"x") && strnicmp(op,"times",4) && stricmp(op,"multiply") && stricmp(op,"*") &&
			stricmp(op,"divide") && stricmp(op,"quotient") && stricmp(op,"/") &&
			stricmp(op,"remainder") && stricmp(op,"modulo") && stricmp(op,"mod") && stricmp(op,"%") && stricmp(op,"random") &&
			stricmp(op,"root") && stricmp(op,"square_root")  && stricmp(op,"^") && stricmp(op,"power") && stricmp(op,"exponent")) 
			BADSCRIPT("CALL- 17 2nd argument to ^compute must be numeric operation - %s",op)
	}
	else if (!stricmp(D->word,"^counttopic") && IsAlpha(*arg1))
	{
		if (strnicmp(arg1,"gambit",6) && stricmp(arg1,"used") && strnicmp(arg1,"rule",4) && stricmp(arg1,"available"))  
			BADSCRIPT("CALL-20 CountTopic 1st arg must be GAMBIT or RULE or AVAILABLE or USED - %s",arg1)
	}
	else if (!stricmp(D->word,"^hasgambit") && IsAlpha(*arg2))
	{
		if (stricmp(arg2,"last") && stricmp(arg2,"any") )  BADSCRIPT("CALL-21 HasGambit 2nd arg must be omitted or be LAST or ANY - %s",arg1)
	}
	else if (!stricmp(D->word,"^lastused" ) && IsAlpha(*arg1))
	{
		if (strnicmp(arg1,"gambit",6) && strnicmp(arg1,"rejoinder",9) && strnicmp(arg1,"responder",9) && stricmp(arg1,"any"))  BADSCRIPT("CALL-22 LastUsed 1st arg must be GAMBIT or REJOINDER or RESPONDER or ANY - %s",arg1)
	}
	else if ((!stricmp(nextToken,"^first") || !stricmp(nextToken,"^last") || !stricmp(nextToken,"^random")) && *arg2) BADSCRIPT("CALL-23 Too many arguments to first/last/random - %s",arg2)

	//   validate inference calls if we can
	else if (!strcmp(D->word,"^query"))
	{
		if (!stricmp(arg1,"direct_s"))
		{
			if (!*arg2 || *arg2 == '?') BADSCRIPT("CALL-24 Must name subject argument to query")
			if (*argset[3] && *argset[3] != '?') BADSCRIPT("CALL-25 Cannot name verb argument to query - %s",argset[3])
			if (*argset[4] && *argset[4] != '?') BADSCRIPT("CALL-26 Cannot name object argument to query - %s",argset[4])
			if (*argset[8] && *argset[8] != '?') BADSCRIPT("CALL-27 Cannot name propgation argument to query - %s",argset[8])
			if (*argset[9] && *argset[9] != '?') BADSCRIPT("CALL-28 Cannot name match argument to query - %s",argset[9])
		}
		if (!stricmp(arg1,"direct_v"))
		{
			if (*arg2 && *arg2 != '?') BADSCRIPT("CALL-29 Cannot name subject argument to query - %s",arg2)
				if (!*argset[3] || *argset[3] == '?') BADSCRIPT("CALL-30 Must name verb argument to query")
			if (*argset[4] && *argset[4] != '?') BADSCRIPT("CALL-31 Cannot name object argument to query - %s",argset[4])
			if (*argset[8] && *argset[8] != '?') BADSCRIPT("CALL-32 Cannot name propgation argument to query - %s",argset[8])
			if (*argset[9] && *argset[9] != '?') BADSCRIPT("CALL-33 Cannot name match argument to query - %s",argset[9])
		}
		if (!stricmp(arg1,"direct_o"))
		{
			if (*arg2 && *arg2 != '?') BADSCRIPT("CALL-34 Cannot name subject argument to query -%s",arg2)
			if (*argset[3] && *argset[3] != '?') BADSCRIPT("CALL-35 Cannot name verb argument to query -%s",argset[3])
				if (!*argset[4] || *argset[4] == '?') BADSCRIPT("CALL-36 Must name object argument to query")
			if (*argset[8] && *argset[8] != '?') BADSCRIPT("CALL-37 Cannot name propgation argument to query -%s",argset[8])
			if (*argset[9] && *argset[9] != '?') BADSCRIPT("CALL-38 Cannot name match argument to query -%s",argset[9])
		}
		if (!stricmp(arg1,"direct_sv") )
		{
				if (!*arg2 || *arg2 == '?') BADSCRIPT("CALL-39 Must name subject argument to query")
				if (!*argset[3] || *argset[3] == '?') BADSCRIPT("CALL-40 Must name verb argument to query")
			if (*argset[4] && *argset[4] != '?') BADSCRIPT("CALL-41 Cannot name object argument to query -%s",argset[4])
			if (*argset[8] && *argset[8] != '?') BADSCRIPT("CALL-42 Cannot name propgation argument to query -%s",argset[8])
			if (*argset[9] && *argset[9] != '?') BADSCRIPT("CALL-43 Cannot name match argument to query -%s",argset[9])
		}
		if (!stricmp(arg1,"direct_sv_member"))
		{
				if (!*arg2 || *arg2 == '?') BADSCRIPT("CALL-44 Must name subject argument to query")
				if (!*argset[3] || *argset[3] == '?') BADSCRIPT("CALL-45 Must name verb argument to query")
			if (*argset[4] && *argset[4] != '?') BADSCRIPT("CALL-46 Cannot name object argument to query -%s",argset[4])
			if (*argset[8] && *argset[8] != '?') BADSCRIPT("CALL-47 Cannot name propgation argument to query -%s",argset[8])
			if (*argset[9] && *argset[9] == '?') BADSCRIPT("CALL-48 Must name match argument to query -%s",argset[9])
		}
		if (!stricmp(arg1,"direct_vo"))
		{
			if (*arg2 && *arg2 != '?') BADSCRIPT("CALL-49 Cannot name subject argument to query -%s",arg2)
				if (!*argset[3] || *argset[3] == '?') BADSCRIPT("CALL-50 Must name verb argument to query")
				if (!*argset[4] || *argset[4] == '?') BADSCRIPT("CALL-51 Must name object argument to query")
			if (*argset[8] && *argset[8] != '?') BADSCRIPT("CALL-52 Cannot name propgation argument to query -%s",argset[8])
			if (*argset[9] && *argset[9] != '?') BADSCRIPT("CALL-53 Cannot name match argument to query -%s",argset[9])
		}
		if (!stricmp(arg1,"direct_svo"))
		{
			if (!*arg2 || *arg2 == '?') BADSCRIPT("CALL-54 Must name subject argument to query")
				if (!*argset[3] || *argset[3] == '?') BADSCRIPT("CALL-55 Must name verb argument to query")
				if (!*argset[4] || *argset[4] == '?') BADSCRIPT("CALL-56 Must name object argument to query")
			if (*argset[8] && *argset[8] != '?') BADSCRIPT("CALL-57 Cannot name propgation argument to query -%s",argset[8])
			if (*argset[9] && *argset[9] != '?') BADSCRIPT("CALL-58 Cannot name match argument to query -%s",argset[9])
		}
	}
}

static char* ReadCall(char* name, char* ptr, FILE* in, char* &data,bool call)
{	//   returns with no space after it
	//   ptr is just after the ^name -- user can make a call w/o ^ in name but its been patched. Or this is function argument
	char reuseTarget1[MAX_WORD_SIZE];
	char reuseTarget2[MAX_WORD_SIZE];
	*reuseTarget2 = *reuseTarget1  = 0;	//   in case this turns out to be a ^reuse call, we want to test for its target

	char hold[MAX_BUFFER_SIZE];
	char word[MAX_WORD_SIZE];
	char* arguments = ptr;
	char* mydata = hold;	//   read in all data, then treat callArgumentList as output data for processing
	// locate the function
	WORDP D = FindWord(name,0,LOWERCASE_LOOKUP);
	if (!call || !D || !(D->systemFlags & FUNCTION_NAME))  //   not a function, is it a function variable?
	{
		if (!IsDigit(name[1])) 
			BADSCRIPT("CALL-1 Call to function not yet defined %s",name)
		*data++ = '^';
		*data++ = name[1];
		if (IsDigit(name[2])) *data++ = name[2];
		*data = 0; 
		return ptr;
	}
	SystemFunctionInfo* info = NULL;
	bool isStream = false;		//   dont check contents of stream, just format it
	if (D->x.codeIndex)			//   system function
	{
		info = &systemFunctionSet[D->x.codeIndex];
		if (info->argumentCount == STREAM_ARG) isStream = true;
	}
	else if (patternContext && !(D->systemFlags & IS_PATTERN_MACRO)) BADSCRIPT("CALL-2 Can only call patternmacro or dual macro from pattern area - %s",name)
	else if (!patternContext && !(D->systemFlags &  (IS_OUTPUT_MACRO | IS_TABLE_MACRO))) BADSCRIPT("CALL-3 Cannot call pattern or table macro from output area - %s",name)
	
	for (unsigned int i = 0; i <= 9; ++i) *argset[i] = 0; //   default EVERYTHING before we test it later
	if (!stricmp(D->word,"^debug")) 
		DebugCode(NULL); // a place for a script compile breakpoint

	// write call header
	strcpy(data,D->word); 
	data += D->length;
	*data++ = ' ';	
	*data++ = '(';	
	*data++ = ' ';	

	bool oldContext = patternContext;
	patternContext = false;

	//   validate argument counts and stuff locally, then swallow data offically as output data
	int parenLevel = 1;
	int argumentCount = 0;
	ptr = ReadNextSystemToken(in,ptr,word,false); // skip (
	while (ALWAYS) //   read as many tokens as needed to complete the call, storing them locally
	{
		ptr = ReadNextSystemToken(in,ptr,word,false);
		if (!*word) break;
		MakeLowerCopy(lowercaseForm,word);
		if (TopLevelUnit(lowercaseForm) || TopLevelRule(lowercaseForm)) 
		{
			// we allow commands as callArgumentList
			if (*word != ':') BADSCRIPT("CALL-4 Function call not completed %s",name) //   definition ends when another major unit or top level responder starts
		}

		// closing paren stuck onto token like _) - break it off 
		if (word[1] == ')' && !word[2] && *word != '\\')
		{
			ptr -= strlen(word);
			if (*ptr == *word) ++ptr;
			word[1] = 0;
		}

		//   note that in making calls, [] () and {}  count as a single argument with whatver they have inside
		switch(*word)
		{
		case '(': case '[': case '{':
			++parenLevel;
			break;
		case ')': case ']': case '}':
			--parenLevel;
			if (parenLevel == 1) ++argumentCount;	//   completed a () argument
			break;
		case '"':
			if (word[1] != FUNCTIONSTRING && oldContext) // simple string is in pattern context, flip to underscore form
			{
				// convert string into its pattern form.
				unsigned int n = BurstWord(word,0);
				if (n > 1) strcpy(word,JoinWords(n));
			}
			// DROPPING THRU
		case '\'':  
			// DROPPING THRU
		default:
			if (*word == '~' ) CheckSetOrTopic(word); // set or topic

			if (!stricmp(word,"PLAN") && !stricmp(name,"^end")) endtopicSeen = true;

			if (parenLevel == 1)  
			{
				if (*word == FUNCTIONSTRING && word[1] == '"')  // always compile function arguments
				{
					strcpy(word,CompileString(word));
				}
				ReadNextSystemToken(in,ptr,nextToken,false,true);

				// argument is a function without its ^ ?
				if (*word != '^' && *nextToken == '(') //   looks like a call, reformat it if it is
				{
					char name[MAX_WORD_SIZE];
					*name = '^';
					MakeLowerCopy(name+1,word);	
					WORDP D = FindWord(name,0,PRIMARY_CASE_ALLOWED);
					if (D && D->systemFlags & FUNCTION_NAME) strcpy(word,name); 
				}

				if (*word == '^' )   //   function call or function var ref 
				{
					char* arg = mydata;
					ptr = ReadCall(word,ptr,in,mydata,*nextToken == '(');
					*mydata = 0;
					strcpy(argset[++argumentCount],arg);
					*mydata++ = ' ';
					continue;
				}

				strcpy(argset[++argumentCount],word);
			}
		}

		if (oldContext && IsAlpha(*word)) WritePatternWord(word);

		//   add simple item into data
		strcpy(mydata,word);
		mydata += strlen(mydata);
		if (parenLevel == 0) break;	//   we finished the call (no trailing space)
		*mydata++ = ' ';	
	}
	*--mydata = 0;  //   remove closing paren

	char* arg1 = argset[1];
	char* arg2 = argset[2];

	// validate assignment calls if we can - this will be a first,last,random call
	if (*assignKind)
	{
		char kind = arg1[2];
		if (!kind) BADSCRIPT("CALL-5 Assignment must designate how to use factset (s v or o)- %s  in %s %s ",assignKind,name,arguments)
		else if ((kind == 'a' || kind == '+' || kind == '-') && *assignKind != '_')  BADSCRIPT("CALL-6 Can only spread a fact onto a match var - %s",assignKind)
		else if (*assignKind == '%' && (kind == 'f' ||  !kind))  BADSCRIPT("CALL-7 cannot assign fact into system variable") // into system variable
		else if (*assignKind == '@' && kind != 'f') BADSCRIPT("CALL-8 Cannot assign fact field into fact set") // into set, but not a fact
	}
	
	if (!stricmp(D->word,"^reuse") && (IsAlpha(*arg1) || *arg1 == '~')) 
	{
		MakeUpperCopy(reuseTarget1,arg1); // topic names & labels must be upper case
	}
	else if (!stricmp(D->word,"^enable") && IsAlpha(*arg1)) 
	{
		if (stricmp(arg1,"topic") && stricmp(arg1,"rule")) BADSCRIPT("CALL-18 Enable 1st arg must be TOPIC or RULE - %s",arg1)
		if (*arg2 != '~' || strchr(arg2,'.')) // not a topic or uses ~topic.rulename notation
		{
			MakeUpperCopy(reuseTarget1,arg2); // topic names & labels must be upper case
		}
	}
	else if (!stricmp(D->word,"^disable") && IsAlpha(*arg1)) 
	{
		if (stricmp(arg1,"topic") && stricmp(arg1,"rule") && stricmp(arg1,"rejoinder")) BADSCRIPT("CALL-19 Disable 1st arg must be TOPIC or RULE or REJOINDER - %s",arg1)
		if (!stricmp(arg1,"rejoinder")){;}
		else if (*arg2 != '~' || strchr(arg2,'.'))  MakeUpperCopy(reuseTarget1,arg2); // topic names & labels must be upper case 
	}

	ValidateCallArgs(D,arg1,arg2);

	if (parenLevel != 0) BADSCRIPT("CALL-59 Failed to properly close (or [ in call to %s",D->word)

	if (isStream){;}  // no cares
	else if (info) // system function
	{
		if (argumentCount != info->argumentCount && info->argumentCount != VARIABLE_ARGS) BADSCRIPT("CALL-60 Incorrect argument count to system function %s- %d instead of %d",name,argumentCount,info->argumentCount & 255)
	}
	else if ((D->systemFlags & FUNCTION_BITS) == IS_PLAN_MACRO) 
	{
		if (argumentCount != (int)D->w.planArgCount) BADSCRIPT("CALL-60 Incorrect argument count to plan %s- %d instead of %d",name,argumentCount,D->w.planArgCount)
	}
	else // std macro (input, output table)
	{
		if (argumentCount != MACRO_ARGUMENT_COUNT(D)) BADSCRIPT("CALL-60 Incorrect argument count to macro %s- %d instead of %d",name,argumentCount,MACRO_ARGUMENT_COUNT(D))
	}

	// handle crosscheck of labels
	char* dot = strchr(reuseTarget1,'.');
	if (!*reuseTarget1);
	else if (dot) // used dotted notation, split them up
	{
		strcpy(reuseTarget2,dot+1);
		*dot = 0;
	}
	else if (*reuseTarget1 != '~') //  only had name, not topic.name, fill in
	{
		strcpy(reuseTarget2,reuseTarget1);
		if (currentFunctionDefinition) strcpy(reuseTarget1,currentFunctionDefinition->word);
		else strcpy(reuseTarget1,currentTopicName);
	}

	if (*reuseTarget1 && (*reuseTarget1 != '$' && *reuseTarget1 != '_' && *reuseTarget2 != '$' && *reuseTarget2 != '_')) //   we cant crosscheck variable choices
	{
		if (*reuseTarget1 != '~')
		{
			memmove(reuseTarget1+1,reuseTarget1,strlen(reuseTarget1)+1);
			*reuseTarget1 = '~';
		}
		strcat(reuseTarget1,".");
		strcat(reuseTarget1,reuseTarget2); // compose the name
		NoteUse(reuseTarget1,currentFunctionDefinition ? currentFunctionDefinition->word : currentTopicName);
	}

	//   now generate stuff as an output stream with its validation
	int oldspell = spellCheck;
	spellCheck = 0;
	ReadOutput(hold,NULL,data,NULL,D);
	spellCheck = oldspell;

	patternContext = oldContext;
	
	*data++ = ')'; //   outer layer generates trailing space
	
	return ptr;	
}

static void TestSubstitute(char* word,char* message)
{
	WORDP D = FindWord(word);
	if (D && GetSubstitute(D))
	{
		D = GetSubstitute(D);
		if (D->word[0] == '!') {;} // ignore conditional
		else if (D->word[1])	 
			WARNSCRIPT("substitutes.txt changes %s to %s %s\r\n",word,D->word,message)
		else  WARNSCRIPT("substitutes.txt erases %s %s\r\n",word,message)
	}
}

static void SpellCheckScriptWord(char* input,int startSeen) 
{
	// remove any trailing punctuation
	char word[MAX_WORD_SIZE];
	strcpy(word,input);
	size_t len = strlen(word);
	while (len > 1 && !IsAlpha(word[len-1]) && word[len-1] != '.') word[--len] = 0;

	WORDP D = FindWord(word);
	if (word[1] == 0 || IsUpperCase(*word) || !IsAlpha(*word) || strchr(word,'\'') || strchr(word,'.') || strchr(word,'_') || strchr(word,'-') || strchr(word,'~')) {;} // ignore proper names, sets, numbers, composite words, wordnet references, etc
	else if (!D || (!(D->properties & NORMAL_WORD) && !(D->systemFlags & PATTERN_WORD)))
	{
		WORDP entry,canonical;
		uint64 sysflags = 0;
		uint64 cansysflags = 0;
		uint64 flags = GetPosData(2,word,entry,canonical,sysflags,cansysflags,false,true,0);
		// do we know a possible base for it
		//char* canon = FindCanonical(word, 2,true);
		//if (!canon) canon = GetSingularNoun(word,true,true);
		//if (!canon) canon = GetInfinitive(word,true);
		//if (!canon) canon = GetAdjectiveBase(word,false);
		//if (!canon) canon = GetAdverbBase(word,false);
		if (!flags)
		{
			WORDP E = FindWord(word,0,SECONDARY_CASE_ALLOWED);
			if (E && E != D && E->word[2]) WARNSCRIPT("Word %s only known in opposite case\r\n",word)
			else WARNSCRIPT("%s is not a known word. Is it misspelled?\r\n",word)
		}
	}

	// see if substitition will ruin this word
	if (startSeen != -1) TestSubstitute(word,"anywhere in input");
	char test[MAX_WORD_SIZE];
	sprintf(test,"<%s",word);
	if (startSeen == 0) TestSubstitute(test,"at input start");
	sprintf(test,"%s>",word);
	if (startSeen != -1) TestSubstitute(test,"at input end");
	sprintf(test,"<%s>",word);
	if (startSeen == 0) TestSubstitute(test,"as entire input");
}

static char* GetRuleElipsis(char* rule)
{
	static char value[50];
	strncpy(value,rule,45);
	value[45] = 0;
	return value;
}

static bool PatternRelationToken(char* ptr)
{
	if (*ptr == '!' && (ptr[1] == '=' || ptr[1] == '?')) return true;
	if (*ptr == '>' || *ptr == '<' || *ptr == '?' || *ptr == '&') return true;
	if (*ptr == '=') return true;;
	return false;
}

static bool RelationToken(char* word)
{
	if (*word == '=') return (word[1] == '=' || !word[1]);
	return (*word == '<' ||  *word == '>' ||  *word == '?'  || (*word == '!'  && word[1] == '=') || *word == '&');
}

char* ReadPattern(char* ptr, FILE* in, char* &data,bool macro)
{ //   called from topic or patternmacro
#ifdef INFORMATION //   meaning of leading characters
< >	 << >>	sentence start & end boundaries, any 
!			NOT 
nul			end of data from macro definition or argument substitution
* *1 *~ *~2 *-1	 gap (infinite, exactly 1 word, 0-2 words, 0-2 words, 1 word before)
_  _2		memorize next match or refer to 3rd memorized match (0-based)
@			factset references @5subject  and _1 (positional set)  
$			user variable 
^	^1		function call or function argument (user)
()[]{}		nesting of some kind (sequence AND, OR, OPTIONAL)
dquote		string token
?			a question input
~dat  ~		topic/set reference or current topic 
%			system variable 
=xxx		comparison test (= > < )
apostrophe and apostrophe!		non-canonical meaning on next token or exclamation test
\			escape next character as literal (\$ \= \~ \(etc)
#xxx		a constant number symbol, but only allowed on right side of comparison
------default values
-1234567890	number token
12.14		number token
1435		number token
a-z,A-Z,|,_	normal token
,			normal token (internal sentence punctuation) - period will never exist since we strip tail and cant be internal

----- these are things which must all be insured lower case (some can be on left or right side of comparison op)
%			system variable 
~dat 		topic/set reference
a: thru u:	responder codes
if/loop/loopcount	constructs
^call  call	function/macro calls with or without ^
^fnvar		function variables
^$glblvar	global function variables
$			user variable 
@			debug ahd factset references
labels on responders
responder types s: u: t: r: 
name of topic  or concept

#endif
	char word[MAX_WORD_SIZE];
	char nestKind[100];
	int nestIndex = 0;
	patternContext = true;

	//   if macro call, there is no opening ( or closing )
	//   We claim an opening and termination comes from finding a toplevel token
	if (macro) nestKind[nestIndex++] = '(';

	bool unorderedSeen = false; // << >> zone
	bool variableGapSeen = false; // wildcard pending

	// prefix characters
	bool memorizeSeen = false; // memorization pending
	bool quoteSeen = false;	// saw '
	bool notSeen = false;	 // saw !

	bool startSeen = false; // starting token or not
	char* start = data;
	while (ALWAYS) //   read as many tokens as needed to complete the definition
	{
		ptr = ReadNextSystemToken(in,ptr,word);
		if (!*word) break; //   end of file
		MakeLowerCopy(lowercaseForm,word);
		if (TopLevelUnit(lowercaseForm) || TopLevelRule(lowercaseForm)) // end of pattern
		{
			ptr -= strlen(word);
			break;
		}
		char c = 0;
		char* comparison = FindComparison(word);
		if (comparison) // comparison, do normal analysis on 1st argument
		{
			c = *comparison;
			*comparison = 0;
		}
		switch(*word) // ordinary tokens, not the composite comparison blob
		{
			// token prefixes
			case '!': //   NOT
				if (quoteSeen) BADSCRIPT("PATTERN-1 Cannot have ' and ! in succession")
				if (memorizeSeen) BADSCRIPT("PATTERN-2 Cannot use _ before _")
				if (notSeen) BADSCRIPT("PATTERN-3 Cannot have two ! in succession")
				if (!word[1]) 
					BADSCRIPT("PATTERN-4 Must attach ! to next token. If you mean exclamation match, use escaped ! \r\n %s",ptr)
				notSeen = true;
				if (comparison) *comparison = c;
				ptr -= strlen(word);
				if (*ptr == '!') ++ptr;
				continue;
			case '_':	//   memorize OR var reference
				if (memorizeSeen) BADSCRIPT("PATTERN-6 Cannot have two _ in succession")
				if (!word[1]) BADSCRIPT("PATTERN-7 Must attach _ to next token. If you mean _ match, use escaped _. \r\n %s",ptr)
				if (IsDigit(word[1])) // match variable
				{
					if (GetWildcardID(word) < 0) BADSCRIPT("PATTERN-8 _%d is max match reference - %s",MAX_WILDCARDS-1,word)
					break;
				}

				memorizeSeen = true;
				quoteSeen = false;
				if (comparison) *comparison = c;
				ptr -= strlen(word);
				if (*ptr == '_') ++ptr;
				continue;
			case '.':  // set to wildcard position
				if (word[2] != '_') BADSCRIPT("PATTERN-71 Cannot use  . for anything except a wildcard name - %s",word)
				else if (word[1] != '<' && word[1] != '>' ) BADSCRIPT("PATTERN-9  requires < or > to designate start or end of wildcard location - %s",word)// .<_0  or .>_0
				break;
			case '\'': //   original (non-canonical) token - possessive must be \'s or \'
				if (quoteSeen) BADSCRIPT("PATTERN-10 Cannot have two ' in succession")
				if (!word[1]) BADSCRIPT("PATTERN-11 Must attach ' to next token. If you mean ' match, use \' \r\n %s",ptr)
				quoteSeen = true;
				variableGapSeen = false;
				if (comparison) *comparison = c;
				ptr -= strlen(word);
				if (*ptr == '\'') ++ptr;
				continue;
			case '<':	//   sentence start <  or  unordered start <<
				if (quoteSeen) BADSCRIPT("PATTERN-12 Cannot use ' before < or <<")
				if (notSeen) BADSCRIPT("PATTERN-13 Cannot use ! before < or <<")
				if (word[1] == '<')  //   <<  unordered start
				{
					if (memorizeSeen) BADSCRIPT("PATTERN-14 Cannot use _ before << ")
					if (unorderedSeen) BADSCRIPT("PATTERN-15 << already in progress")
					if (variableGapSeen) BADSCRIPT("PATTERN-16 Cannot use * before <<")
					unorderedSeen = true;
				}
				else if (word[1])  BADSCRIPT("PATTERN-17 %s cannot start with <",word)
				variableGapSeen = false;
				break; 
			case '@': 
				if (quoteSeen) BADSCRIPT("PATTERN-18 Quoting @ is meaningless.");
				if (memorizeSeen) BADSCRIPT("PATTERN-19 Cannot use _ before  @")
				if (word[1] == '_') // set match position  @_5
				{
					if (GetWildcardID(word+1) >= MAX_WILDCARDS)  BADSCRIPT("PATTERN-? %s is not a valid positional reference - must be < %d",word,MAX_WILDCARDS)  
					char* end = word+2; 
					if (IsDigit(*end)) ++end;
					if (*end)
					{
						if (*end == '+' && end[1] == '+' && !end[2]) {;}
						else if (*end == '-' && end[1] == '-' && !end[2]) {;}
						else BADSCRIPT("PATTERN-? %s is not a valid positional reference",word)  
					}
				}
				else if (GetSetID(word) < 0) BADSCRIPT("PATTERN-20 %s is not a valid factset reference",word)  // factset reference
				break;
			case '>':	//   sentence end > or unordered end >>
				if (quoteSeen) BADSCRIPT("PATTERN-21 Cannot use ' before > or >>")
				if (word[1] == '>') //   >>
				{
					if (memorizeSeen) BADSCRIPT("PATTERN-22 Cannot use _ before  >> ")
					if (!unorderedSeen) BADSCRIPT("PATTERN-23 Have no << in progress");
					if (variableGapSeen) BADSCRIPT("PATTERN-24 Cannot use wildcard inside >>")
					unorderedSeen = false;
				}
				variableGapSeen = false;
				break; //   sentence end align
			case '(':	//   sequential pattern unit begin
				if (quoteSeen) BADSCRIPT("PATTERN-25 Quoting ( is meaningless.");
				nestKind[nestIndex++] = '(';
				break;
			case ')':	//   sequential pattern unit end
				if (quoteSeen) BADSCRIPT("PATTERN-26 Quoting ) is meaningless.");
				if (memorizeSeen) BADSCRIPT("PATTERN-27 Cannot use _ before  )")
				if (variableGapSeen && nestIndex > 1) 
					BADSCRIPT("PATTERN-26 Cannot have wildcard followed by )")
				if (nestKind[--nestIndex] != '(') BADSCRIPT("PATTERN-9 ) is not closing corresponding (")
				break;
			case '[':	//   list of pattern choices begin
				if (quoteSeen) BADSCRIPT("PATTERN-30 Quoting [ is meaningless.");
				nestKind[nestIndex++] = '[';
				break;
			case ']':	//   list of pattern choices end
				if (quoteSeen) BADSCRIPT("PATTERN-31 Quoting ] is meaningless.");
				if (memorizeSeen) BADSCRIPT("PATTERN-32 Cannot use _ before  ]")
				if (variableGapSeen) BADSCRIPT("PATTERN-33 Cannot have wildcard followed by ]")
				if (nestKind[--nestIndex] != '[') BADSCRIPT("PATTERN-34 ] is not closing corresponding [")
				break;
			case '{':	//   list of optional choices begins
				if (variableGapSeen)
				{
					// if we can see end of } and it has a gap after it... thats a problem - two gaps in succession is the equivalent
					char* end = strchr(ptr,'}');
					if (end)
					{
						end = SkipWhitespace(end);
						if (*end == '*') WARNSCRIPT("Wildcard before and after optional will probably not work since wildcards wont know where to end if optional fails. Use some other formulation")
					}
				}
				if (quoteSeen) BADSCRIPT("PATTERN-35 Quoting { is meaningless.");
				if (notSeen)  BADSCRIPT("PATTERN-36 !{ is pointless since { can fail or not anyway")
				if (nestIndex && nestKind[nestIndex-1] == '{') BADSCRIPT("PATTERN-37 {{ is illegal")
				nestKind[nestIndex++] = '{';
				break;
			case '}':	//   list of optional choices ends
				if (quoteSeen) BADSCRIPT("PATTERN-38 Quoting } is meaningless.");
				if (memorizeSeen) BADSCRIPT("PATTERN-39 Cannot use _ before  }")
				if (variableGapSeen) BADSCRIPT("PATTERN-40 Cannot have wildcard followed by }")
				if (nestKind[--nestIndex] != '{') BADSCRIPT("PATTERN-41 } is not closing corresponding {")
				break;
			case '\\': //   literal next character
				if (quoteSeen) BADSCRIPT("PATTERN-42 Quoting an escape is meaningless.");
				if (!word[1]) BADSCRIPT("PATTERN-43 Backslash must be joined to something to escape")
				variableGapSeen = false;
				if (word[1] && IsAlpha(word[1])) memmove(word,word+1,strlen(word)); // escaping a real word, just use it
				break;
			case '*': //   gap: * *1 *~2 	(infinite, exactly 1 word, 0-2 words, 0-2 words, 1 word before) and *alpha*x* is form match
				if (quoteSeen) BADSCRIPT("PATTERN-44 Quoting a wildcard");
				if (unorderedSeen) BADSCRIPT("PATTERN-45 Cannot have wildcard %s inside << >>",word)
				if (variableGapSeen) BADSCRIPT("PATTERN-46 Cannot have wildcard followed by %s",word)
				if (IsAlpha(word[1])) break; // find this word as fragmented spelling like sch*ding* since it will have * as a prefix
				
				// gaps of various flavors
				if (notSeen)  BADSCRIPT("PATTERN-47 cannot have ! before gap - %s",word)
				if (IsDigit(word[1])) //   enumerated gap size
				{
					int n = word[1] - '0';
					if (n == 0) BADSCRIPT("PATTERN-48 *0 is meaningless")	 
					if (word[2]) BADSCRIPT("PATTERN-49 *9 is the largest gap allowed or bad stuff is stuck to your token- %s",word)
				}
				else if (word[1] == '-') // backwards
				{
					int n = word[2] - '0';
					if (n == 0) BADSCRIPT("PATTERN-50 *-1 is the smallest backward wildcard allowed - %s",word)
					if (word[3]) BADSCRIPT("PATTERN-51 *-9 is the largest backward wildcard or bad stuff is stuck to your token- %s",word)
				}
				else if (word[1] == '~') // close-range gap
				{
					variableGapSeen = true;
					int n = word[2] - '0';
					if (!word[2]) BADSCRIPT("PATTERN-52 *~ is not legal, you need a digit after it")
					else if (n == 0) BADSCRIPT("PATTERN-53 *~1 is the smallest close-range gap - %s",word)
					else if (word[3]) BADSCRIPT("PATTERN-54 *~9 is the largest close-range gap or bad stuff is stuck to your token- %s",word)
				}
				else if (word[1]) BADSCRIPT("PATTERN-55 * jammed against some other token- %s",word)
				else variableGapSeen = true; // std * unlimited wildcard
				startSeen = true;
				break;
			case '?': //   question input ?   
				if (quoteSeen) BADSCRIPT("PATTERN-56 Quoting a ? is meaningless.");
				if (memorizeSeen) BADSCRIPT("PATTERN-57 Cannot use _ before ?")
				if (variableGapSeen) BADSCRIPT("PATTERN-58 Cannot have wildcards before ?")
				break;
			case '$':	//   user var
				if (quoteSeen) BADSCRIPT("PATTERN-59 Quoting a $ variable is meaningless - %s",word);
				variableGapSeen = false;
				break;
			case '"': //   string
				{
					// you can quote a string, because you are quoting its members
					variableGapSeen = false;
					strcpy(word,JoinWords(BurstWord(word,CONTRACTIONS)));// change from string to std token
					WritePatternWord(word); 
					unsigned int n = 0;
					char* ptr = word;
					while ((ptr = strchr(ptr,'_')))
					{
						++n;
						++ptr;
					}
					if (n >= SEQUENCE_LIMIT) BADSCRIPT("PATTERN-? Too many  words in string %s, will never match",word)
				}
				break;
			case '%': //   system data
				// you can quote system variables because %topic returns a topic name which can be quoted to query
				if (memorizeSeen) BADSCRIPT("PATTERN-60 Cannot use _ before system variable - %s",word)
				if (!word[1]); //   simple %
				else if (!FindWord(word)) BADSCRIPT("PATTERN-61 %s is not a system variable",word)
				if (comparison) *comparison = c;
				variableGapSeen = false;
				break;
			case '~':
				if (quoteSeen) BADSCRIPT("PATTERN-62 Quoting a concept is meaningless - %s",word);
				variableGapSeen = false;
				startSeen = true;
				CheckSetOrTopic(word); // set or topic
				break;
			default: //   normal token ( and anon function call)
				//    MERGE user pattern words into one? , e.g. drinking age == drinking_age in dictionary
				//   only in () sequence mode. Dont merge [old age] or {old age} or << old age >>
				if (nestKind[nestIndex-1] == '(' && !unorderedSeen) //   BUG- do we need to see what triples etc wordnet has
				{
					ReadNextSystemToken(in,ptr,nextToken,true,true); 
					WORDP F = FindWord(word);
					WORDP E = FindWord(nextToken);
					if (E && F && E->properties & PART_OF_SPEECH  && F->properties & PART_OF_SPEECH)
					{
						char join[MAX_WORD_SIZE];
						sprintf(join,"%s_%s",word,nextToken);
						E = FindWord(join);
						if (E && E->properties & PART_OF_SPEECH) // change to composite
						{
							strcpy(word,join);		//   joined word replaces it
							ptr = ReadNextSystemToken(in,ptr,nextToken,true,false); // swallow the lookahead
							*nextToken = 0;
						}
					}
				}
				variableGapSeen = false;
				startSeen = true;
				break;
		}

		if (comparison) //   is a comparison of some kind
		{
			*comparison = c;
			if (c == '!') // move not operator out in front of token
			{
				*data++ = '!';
				size_t len = strlen(comparison+1);
				memmove(comparison,comparison+1,len);
				comparison[len] = 0;
			}

			char* rhs = comparison+1;
			if (*rhs == '=' || *rhs == '?') ++rhs;
			if (!*rhs && *word == '$'); // allowed member in sentence
			else if (!*rhs && *word == '_' && IsDigit(word[1])); // allowed member in sentence
			else if (*rhs == '#') // names a constant #define to replace with number value
			{
				uint64 n = FindValueByName(rhs+1);
				if (!n) n = FindValue2ByName(rhs+1);
				if (!n) BADSCRIPT("PATTERN-63 No #constant recognized - %s",rhs+1)
				sprintf(rhs,"%lld",n);
			}
			else if (IsAlphabeticDigitNumeric(*rhs))  WritePatternWord(rhs);		//   ordinary token
			else if (*rhs == '~') 
			{
				MakeLowerCase(rhs);
				CheckSetOrTopic(rhs);	
			}
			else if (*rhs == '_');	// match variable
			else if (*rhs == '$' || *rhs == '%') MakeLowerCase(rhs);	// user variable or system variable
			else if (*rhs == '^' && (rhs[1] == '_' || rhs[1] == '$' || IsDigit(rhs[1]))) MakeLowerCase(rhs); // indirect match variable or indirect user vaiable or function variable
			else if (!*rhs && *comparison == '?' && !comparison[1]);
			else if (*rhs == '\'' && (rhs[1] == '$' || rhs[1]== '_')); //   unevaled user variable or raw match variable
			else if (!comparison[2] && *word == '$'); // find in sentence
			else BADSCRIPT("PATTERN-64 Illegal comparison %s or failed to close prior rule starting at %s",word, GetRuleElipsis(start))
			int len = (comparison - word) + 2; //   include the = and jump code in length

			//   rebuild token
			char tmp[MAX_WORD_SIZE];
			*tmp = '=';		//   comparison header
			if (len > 70) BADSCRIPT("PATTERN-65 Left side of comparison must not exceed 70 characters - %s",word)
			char* x = tmp+1;
			Encode(len,x,true);
			strcpy(tmp+2,word); //   copy left side over
			strcpy(word,tmp);	//   replace original token
		}
		else if (*word == '~') CheckSetOrTopic(word); 
		
		ReadNextSystemToken(in,ptr,nextToken,true,true); 

		//   see if we have an implied call (he omitted the ^)
		if (*word != '^' && *nextToken == '(') //   looks like a call, reformat it if it is
		{
			char rename[MAX_WORD_SIZE];
			*rename = '^';
			strcpy(rename+1,word);	//   in case user omitted the ^
			WORDP D = FindWord(rename,0,LOWERCASE_LOOKUP);
			if (D && D->systemFlags & FUNCTION_NAME) strcpy(word,D->word); //   a recognized call
		}
		if (*word == '^')   //   function call or function var ref or indirect function variable assign ref like ^$$tmp = null
		{
			if (quoteSeen) BADSCRIPT("PATTERN-? Cannot use quote before ^ function call or variable")
			if (notSeen) 
			{
				*data++ = '!';
				notSeen = false;
			}
			if (memorizeSeen) 
			{
				if (!IsDigit(word[1])) BADSCRIPT("PATTERN-66 Cannot use _ before ^ function call")
				*data++ = '_';
				memorizeSeen = false;
			}
			if (word[1] == '$')
			{
				strcpy(data,word);
				data += strlen(data);
			}
			else 
			{
				ptr = ReadCall(word,ptr,in,data,*nextToken == '(');
				if (PatternRelationToken(ptr)) // immediate relation bound to call?
				{
					ptr = ReadNextSystemToken(in,ptr,word);
					strcpy(data,word);
					data += strlen(data);
				}
			}
			*data++ = ' ';
			continue;
		}

		if (IsAlpha(*word))
		{
			char* p;
			if ((p = strchr(word,'*'))) // wild word fragment?  reformat to have leading * and lower case the test
			{
				char hold[MAX_WORD_SIZE];
				if (IsAlphaOrDigit(p[1])) BADSCRIPT("PATTERN-72 Word fragment must be a prefix only")
				MakeLowerCopy(hold,word);
				*word = '*';
				strcpy(word+1,hold);
			}
			else // ordinary word - break off possessives as needed
			{
				size_t len = strlen(word);
				if (len > 1 && word[len-1] == '\'') // ending ' possessive plural
				{
					ptr -= 1;
					if (*ptr == '\'') ++ptr;
					word[--len] = 0;
				}
				else if (len > 2 && word[len-1] == 's' && word[len-2] == '\'') // ending 's possessive singular
				{
					ptr -= 2;
					if (*ptr == '\'') ++ptr;
					len -= 2;
					word[len] = 0;
				}
				strcpy(word,JoinWords(BurstWord(word,CONTRACTIONS))); // change to std token
				if (spellCheck) SpellCheckScriptWord(word,startSeen ? 1 : 0);
				WritePatternWord(word); //   memorize it to know its important
			}
		}

		//   put out the next token and space 
		if (notSeen) 
		{
			if (memorizeSeen) BADSCRIPT("PATTERN-67 Cannot have ! and _ together")
			*data++ = '!';
			notSeen = false;
		}
		if (quoteSeen) 
		{
			*data++ = '\'';
			quoteSeen = false;
		}
		if (memorizeSeen) 
		{
			*data++ = '_';
			memorizeSeen = false;
		}
		strcpy(data,word);
		data += strlen(data);
		*data++ = ' ';	

		if (nestIndex == 0) break; //   we completed this level
	}
	*data = 0;

	//   leftovers?
	if (macro && nestIndex != 1) BADSCRIPT("PATTERN-68 Failed to balance ( or [ or { properly in macro")
	else if (!macro && nestIndex != 0) BADSCRIPT("PATTERN-69 Failed to balance ( or [ or { properly");

	if (unorderedSeen) BADSCRIPT("PATTERN-70 Failed to close <<")
	patternContext = false;
	return ptr;
}

static char* GatherChunk(char* ptr, FILE* in, char* save, bool body) // get unformated data til closing marker
{
	char word[MAX_WORD_SIZE];
	char* start = save;
	bool bracket = false;
	int level = (body) ? 0 : 1;
	while (ALWAYS)
	{
		ptr = ReadNextSystemToken(in,ptr,word,false); 
		MakeLowerCopy(lowercaseForm,word);
		if (*word == '[') bracket = true; 
		else if (*word == ']') bracket = false;
		if (!*word || TopLevelUnit(word) || TopLevelRule(lowercaseForm) || (Rejoinder(lowercaseForm) && (!bracket || !body))) 
		{
			if (level >= 1)
			{
				*save = 0;
				start[50] = 0;
				if (!body) BADSCRIPT("CHOICE-2 Fail to close code started with %s ",start)
				else BADSCRIPT("BODY-1 Fail to close code started with %s ",start)
			}
		}
		char c = *word;
		int prior = level;
		level += nestingData[c];
		if (body && level == 1 && prior == 0) start = save; 
		if (level == 0) break; //   end of stream of if body
		strcpy(save,word);
		save += strlen(save);
		*save++ = ' ';
	}
	*save = 0;
	return ptr;
}

static char* ReadChoice(char* word, char* ptr, FILE* in, char* &data,char* rejoinders)
{	//   returns the stored data, not the ptr, starts with the {
	char* choice = AllocateBuffer();
	*data++ = '[';
	*data++ = ' ';
	ReadNextSystemToken(in,ptr,word,true); // get possible rejoinder label
	if (word[1] == ':' && !word[2]) // is rejoinder label
	{
		if (*word < 'a' || *word >= 'q') BADSCRIPT("CHOICE-1 Bad level label %s in [ ]",word)
		if (rejoinders) rejoinders[(int)(*word - 'a' + 1)] = 2; //   authorized level
		*data++ = *word;
		*data++ = word[1];
		*data++ = ' ';
		ptr = ReadNextSystemToken(in,ptr,word,false);
	}
	ptr = GatherChunk(ptr, in, choice,false); 
	ReadOutput(choice,NULL,data,rejoinders);
	*data++ = ']';
	*data++ = ' ';
	*data = 0;
	FreeBuffer();
	return ptr;
}

static char* ReadBody(char* word, char* ptr, FILE* in, char* &data,char* rejoinders)
{	//    stored data starts with the {
	char* body = AllocateBuffer();
	*data++ = '{';
	*data++ = ' ';
	bool oldContext = patternContext;
	patternContext = false;
	ptr = GatherChunk(ptr, in, body,true); 
	ReadOutput(body+2,NULL,data,rejoinders); 
	patternContext = oldContext;
	*data++ = '}'; //   body has no blank after it, done by higher level
	FreeBuffer();
	return ptr;
}

#ifdef INFORMATION

An IF consists of:
	if (test-condition code) xx
	{body code} yy
	else (test-condition code) xx
	{body code} yy
	else (1) xx
	{body code} yy
	
spot yy is offset to end of entire if and xx if offset to next branch of if before "else".

#endif

static char* ReadIf(char* word, char* ptr, FILE* in, char* &data,char* rejoinders)
{
	char* bodyends[1000];				//   places to patch for jumps
	unsigned int bodyendIndex = 0;
	char* original = data;
	strcpy(data,"^^if ");
	data += 5;
	int paren = 0;
	patternContext = false;
	while (ALWAYS)
	{
		//   read the (
		ptr = ReadNextSystemToken(in,ptr,word,false); //   the '('
		MakeLowerCopy(lowercaseForm,word);
		if (!*word || TopLevelUnit(word) || TopLevelRule(lowercaseForm) || Rejoinder(lowercaseForm)) BADSCRIPT("IF-1 Incomplete IF statement - %s",word)
		if (*word != '(') BADSCRIPT("IF-2 Missing (for IF test - %s",word)
		++paren;
		*data++ = '(';
		*data++ = ' ';
		//   test is either a function call OR an equality comparison OR an IN relation OR an existence test
		//   the followup will be either (or  < > ==  or  IN  or )
		//   The function call returns a status code, you cant do comparison on it
		//   but both function and existence can be notted- IF (!$var) or IF (!read(xx))
		//   You can have multiple tests, separated by AND and OR.
pattern: 
		ptr = ReadNextSystemToken(in,ptr,word,false,false); 
		if (*word == '~') CheckSetOrTopic(word); 

		// separate ! from things if not  != and !?
		if (*word == '!' && word[1] && word[1] != '=' && word[1] != '?') 
		{
			ptr -= strlen(word);
			if (*ptr == '!') ++ptr;
			word[1] = 0;
		}

		char* equal = strchr(word+1,'='); // actually a test joined on?
		if (equal)
		{
			if (equal[1] == '=' && equal[2]) // break it off
			{
				ptr -= strlen(equal);
				memmove(ptr+3,ptr+2,strlen(ptr+2));
				ptr[2] = ' ';
				*equal = 0;
			}
			else if ((*(equal-1) == '!' || *(equal-1) == '>' || *(equal-1) == '<') && equal[1]) // break it off
			{
				ptr -= strlen(equal-1);
				memmove(ptr+3,ptr+2,strlen(ptr+2));
				ptr[2] = ' ';
				*(equal-1) = 0;
			}
		}
		char* question = strchr(word+1,'?');
		if (question && word[1])
		{
			ptr -= strlen(question);
			memmove(ptr+2,ptr+1,strlen(ptr+1));
			ptr[1] = ' ';
			*question = 0;
		}

		bool notted = false;
		if (*word == '!' && !word[1]) 
		{
			notted = true;
			*data++ = '!';
			*data++ = ' ';
			ptr = ReadNextSystemToken(in,ptr,word,false,false); 
		}
		if (*word == '\'' && !word[1]) 
		{
			*data++ = '\'';
			ptr = ReadNextSystemToken(in,ptr,word,false,false); 
			if (*word != '_') BADSCRIPT("IF-3 Can only quote _matchvar in IF test")
		}
		if (*word == '!') BADSCRIPT("IF-4 Cannot do two ! in a row")
		ReadNextSystemToken(in,ptr,nextToken,false,true); 
		MakeLowerCase(nextToken);
		if (*nextToken == '(')  // function call?
		{
			if (*word != '^') //     a call w/o its ^
			{
				char rename[MAX_WORD_SIZE];
				*rename = '^';
				strcpy(rename+1,word);	//   in case user omitted the ^
				strcpy(word,rename);
			}
			ptr = ReadCall(word,ptr,in,data,true);  //   read call
			ReadNextSystemToken(in,ptr,nextToken,false,true); 

			if (RelationToken(nextToken))
			{
				if (notted) BADSCRIPT("IF-5 cannot do ! in front of comparison %s",nextToken)
				*data++ = ' ';
				ptr =  ReadNextSystemToken(in,ptr,word,false,false); //   swallow operator
				strcpy(data,word);
				data += strlen(word);
				*data++ = ' ';
				ptr =  ReadNextSystemToken(in,ptr,word,false,false); //   swallow value
				strcpy(data,word);
				data += strlen(word);
			}
		}
		else if (*nextToken == '!' && nextToken[1] == '?')
		{
			if (notted) BADSCRIPT("IF-6 cannot do ! in front of query %s",nextToken)
			if (*word == '\'' && word[1] == '_') {;}
			else if (*word != '@' &&*word != '$' && *word != '_' && *word != '^' && *word != '%') 
				BADSCRIPT("IF test query must be with $var, _# or '_#, %sysvar, @1subject or ^fnarg -%s",word)
			strcpy(data,word);
			data += strlen(word);
			*data++ = ' ';
			ptr =  ReadNextSystemToken(in,ptr,word,false,false); //   swallow operator
			strcpy(data,word);
			data += strlen(word);
			*data++ = ' ';
			ptr =  ReadNextSystemToken(in,ptr,word,false,false); //   swallow value
			if (*word == '^' && !IsDigit(word[1]))  BADSCRIPT("IF-7 not allowed 2nd function call in relation - %s",word)
			if (*word == '~') CheckSetOrTopic(word); 
			strcpy(data,word);
			data += strlen(word);
		}
		else if (RelationToken(nextToken))
		{
			if (notted && *nextToken != '?') BADSCRIPT("IF-8 cannot do ! in front of comparison %s",nextToken)
			if (*word == '\'' && (word[1] == '$' || word[1] == '_')) {;} // quoted variable
			else if (*word != '@' &&*word != '$' && *word != '_' && *word != '^' && *word != '%' && !IsDigit(*word) && *word != '+' && *word != '-') BADSCRIPT("IF test comparison must be with number, $var, _#, sysvar, @1subject or ^fnarg -%s",word)
			strcpy(data,word);
			data += strlen(word);
			*data++ = ' ';
			ptr =  ReadNextSystemToken(in,ptr,word,false,false); //   swallow operator
			strcpy(data,word);
			data += strlen(word);
			*data++ = ' ';
			ptr =  ReadNextSystemToken(in,ptr,word,false,false); //   swallow value
			if (*word == '~') CheckSetOrTopic(word);
			if (*word == '^' && !IsDigit(word[1])) BADSCRIPT("IF-9 not allowed function call in relation as 2nd arg - %s",word)
			strcpy(data,word);
			data += strlen(word);
		}
		else if (*nextToken == ')' || !stricmp(nextToken,"and") || !stricmp(nextToken,"or")) //   existence test
		{
			if (*word != '$' && *word != '_' && *word != '@' && *word != '^'  && *word != '%' ) BADSCRIPT("IF-10 existence test - %s. Must be ($var) or (%var) or (_#) or (@#) or (~concept) ",word)
			strcpy(data,word);
			data += strlen(word);
		}
		else BADSCRIPT("IF-11 illegal test %s %s . Use (X > Y) or (Foo()) or (X IN Y) or ($var) or (_3)",word,nextToken) 
		*data++ = ' ';
		
		//   check for close or more conditions
		ptr =  ReadNextSystemToken(in,ptr,word,false,false); //   )
		if (*word == '~') CheckSetOrTopic(word); 
		if (*word == ')')
		{
			*data++ = ')';
			*data++ = ' ';
		}
		else if (!stricmp(word,"or") || !stricmp(word,"and"))
		{
			MakeLowerCopy(data,word);
			data += strlen(word);
			*data++ = ' ';
			goto pattern;	//   handle next element
		}
		else BADSCRIPT("IF-12 comparison must close with ) -%s .. Did you make a function call as 1st argument? that's illegal",word)

		char* ifbase = data;
		*data++ = 'a'; //   reserve space for offset after the closing ), which is how far to go past body
		*data++ = 'a';
		*data++ = ' ';

		//   swallow body of IF after test --  must have { surrounding now
		ReadNextSystemToken(in,ptr,word,false,true); //   {
		if (*word != '{') 
		{
			*data = 0;
			BADSCRIPT("IF-13 body must start with { instead of %s  -- saw pattern %s",word,readBuffer,original)
		}
		ptr = ReadBody(word,ptr,in,data,rejoinders);
		*data++ = ' ';
		bodyends[bodyendIndex++] = data; //   jump offset to end of if (backpatched)
		DummyEncode(data); //   reserve space for offset after the closing ), which is how far to go past body
		*data++ = ' ';
		Encode((unsigned int)(data-ifbase),ifbase);	// offset to ELSE or ELSE IF from body start 
		
		//   now see if ELSE branch exists
		ReadNextSystemToken(in,ptr,word,false,true); //   else?
		if (stricmp(word,"else"))  break; //   caller will add space after our jump index

		//   there is either else if or else
		ptr = ReadNextSystemToken(in,ptr,word,false,false); //   swallow the else
		strcpy(data,"else ");
		data += 5;
		ReadNextSystemToken(in,ptr,word,false,true); //   see if or {
		if (*word == '{') //   swallow the ELSE body now since no IF - add fake successful test
		{
			//   successful test condition for else
			*data++ = '(';
			*data++ = ' ';
			*data++ = '1';
			*data++ = ' ';
			*data++ = ')';
			*data++ = ' ';

			ifbase = data; 
			DummyEncode(data);//   reserve skip data
			*data++ = ' ';
			ptr = ReadBody(word,ptr,in,data,rejoinders);
			*data++ = ' ';
			bodyends[bodyendIndex++] = data; //   jump offset to end of if (backpatched)
			DummyEncode(data);//   reserve space for offset after the closing ), which is how far to go past body
			Encode((unsigned int)(data-ifbase),ifbase);	// offset to ELSE or ELSE IF from body start (accelerator)
			break;
		}
		ptr = ReadNextSystemToken(in,ptr,word,false,false); //   eat the IF
	}
	if (*(data-1) == ' ') --data;	//   remove excess blank
	patternContext = false;

	//   store offsets from successful bodies to the end
	while (bodyendIndex != 0)
	{
		char* at = bodyends[--bodyendIndex];
		Encode((unsigned int)(data-at+1),at); // accerators on completion of if to end of whole if
	}

	*data = 0;
	return ptr; //   we return with no extra space after us, caller adds it
}

static char* ReadLoop(char* word, char* ptr, FILE* in, char* &data,char* rejoinders)
{
	strcpy(data,"^^loop ");
	data += 7;
	ptr = ReadNextSystemToken(in,ptr,word,false,false); //   (
	*data++ = '(';
	*data++ = ' ';
	if (*word != '(') BADSCRIPT("LOOP-1 count must be ()  or (count) -%s",word)
	ptr = ReadNextSystemToken(in,ptr,word,false,false); //   counter - 
	if (*word == ')') strcpy(data,"-1"); //   omitted, use -1
	else if (!IsDigit(*word) && *word != '$' && *word != '_' && *word != '%'  && *word != '^') BADSCRIPT("LOOP-2 counter must be $var, _#, %var, or ^fnarg  -%s",word)
	else 
	{
		strcpy(data,word);
		ptr = ReadNextSystemToken(in,ptr,word,false,false);
	}
	data += strlen(data);
	*data++ = ' ';
	if (*word != ')') BADSCRIPT("LOOP-3 counter must end with )  -%s",word)
	*data++ = ')';
	*data++ = ' ';
	char* loopstart = data;
	DummyEncode(data);  // reserve loop jump to end accelerator
	*data++ = ' ';

	//   now do body
	ReadNextSystemToken(in,ptr,word,false,true); 
	if (*word != '{') BADSCRIPT("LOOP-4 body must start with { -%s",word)
	ptr = ReadBody(word,ptr,in,data,rejoinders);
	Encode((unsigned int)(data - loopstart + 1),loopstart);	// offset to body end from body start (accelerator)
	*data = 0;
	return ptr; // caller adds extra space after
}

char* ReadOutput(char* ptr, FILE* in,char* &data,char* rejoinders,WORDP call)
{
	char* original = data;
	*data = 0;
	char word[MAX_WORD_SIZE];
	*assignKind = 0;
	int paren = 0;
	int insert = 0;
	bool oldContext = patternContext;
	patternContext = false;
	char hold[MAX_WORD_SIZE];
	*hold = 0;
	while (ALWAYS) //   read as many tokens as needed to complete the responder definition
	{
		if ((data-original) >= MAX_JUMP_OFFSET) BADSCRIPT("OUTPUT-1 code exceeds size limit of %d bytes",MAX_JUMP_OFFSET)

		if (*hold) // pending assignment code
		{
			if (*hold == '=')
			{
				strcpy(word,"=");
				memmove(hold,hold+1,strlen(hold));
			}
			else
			{
				strcpy(word,hold);
				*hold = 0;
			}
		}
		else ptr = ReadNextSystemToken(in,ptr,word,false); 
		if (!*word)  break; //   end of file
		if (*word == '$') // jammed together asignment?
		{
			char* assign = strchr(word,'=');
			if (assign)
			{
				strcpy(hold,assign);
				*assign = 0;
			}
		}
		if (insert) --insert;
		MakeLowerCopy(lowercaseForm,word);
		if (*word == '#' && word[1] == '!')  //   special comment
		{
			ptr -= strlen(word); //   let someone else see this  also
			break; 
		}
		if (*word == 'a' && word[2] == 0 && (word[1] == ';' || word[1] == '"' || word[1] == '\'' ) ) 
			WARNSCRIPT("Is %s supposed to be a rejoinder marker?\r\n",word,currentFilename);

		if (TopLevelUnit(word) || TopLevelRule(lowercaseForm) || Rejoinder(lowercaseForm)) //   responder definition ends when another major unit or top level responder starts
		{
			if (*word != ':') // allow commands here 
			{
				ptr -= strlen(word); //   let someone else see this starter also
				break; 
			}
		}

		ReadNextSystemToken(in,ptr,nextToken,false,true); //   caching request

		if (insert == 1) // set assignment like  @1 += xxx
		{
			// if (*nextToken == '^') BADSCRIPT("OUTPUT-2 Cannot merge function call output to set directly. Assign to intermediate set then do @x += @y.")
		}

		switch(*word)
		{
			case '(':  case '{':
				++paren;
				break;
			case '[':
				ptr = ReadChoice(word,ptr,in,data,rejoinders);
				continue;
			case ')': case ']': case '}':
				--paren;
				if (paren < 0) 
					BADSCRIPT("OUTPUT-3 Unbalanced %s",word)
				break;
			case '\'': 
				strcpy(data,word);
				data += strlen(data);
				if (*word == '\'' && word[1] == 's' && !word[2] && IsAlphaOrDigit(*nextToken)) *data++ = ' ';
 				else if (word[1] == 0 && (*nextToken == '_' || IsAlpha(*nextToken) ))  {;}
				else *data++ = ' ';  
				continue;
			case '@': //   factset ref
				if (!IsDigit(word[1])) BADSCRIPT("OUTPUT-4 bad factset reference - %s",word)
				if (!stricmp(nextToken,"+=") || !stricmp(nextToken,"-=") ) insert = 2;
				break;
		}

		char* nakedNext = nextToken;
		if (*nakedNext == '^') ++nakedNext;	// word w/o ^ 
		char* nakedWord = word;
		if (*nakedWord == '^') ++nakedWord;	// word w/o ^ 
	
		if (*nextToken == '=' && !nextToken[1]) // assignment
		{
			strcpy(data,word);	//   add simple item into data
			data += strlen(data);
			*data++ = ' ';
			ptr = ReadNextSystemToken(in,ptr,nextToken,false,false); //   use up lookahead of =
			strcpy(data,"=");	
			++data;
			*data++ = ' ';
			ReadNextSystemToken(in,ptr,nextToken,false,true); //   aim lookahead at followup
			if (!stricmp(nakedNext,"first") || !stricmp(nakedNext,"last") || !stricmp(nakedNext,"random") )  strcpy(assignKind,word); // verify usage fact retrieved from set
			continue;
		}
		else if (*nextToken == '{' && !stricmp(nakedWord,"loop"))  // loop missing () 
		{
			ptr = ReadLoop(word,ptr,in,data,rejoinders);
			*data++ = ' ';
			continue;
		}
		else if (*nextToken != '(')
		{
		}
		else if (!stricmp(nakedWord,"if"))  // strip IF of ^
		{
			ptr = ReadIf(word,ptr,in,data,rejoinders);
			*data++ = ' ';
			continue;
		}
		else if (!stricmp(nakedWord,"loop"))  // strip LOOP of ^
		{
			ptr = ReadLoop(word,ptr,in,data,rejoinders);
			*data++ = ' ';
			continue;
		}
		else if (*word != '^') //   looks like a call ... if its ALSO a normal word, presume it is not a call, like: I like (American) football
		{
			// be wary.. respond(foo) might have been text...  
			// How does he TELL us its text? interpret normal word SPACE ( as not a function call?
			char rename[MAX_WORD_SIZE];
			*rename = '^';
			strcpy(rename+1,word);	//   in case user omitted the ^
			MakeLowerCase(rename);
			WORDP D = FindWord(rename,0,PRIMARY_CASE_ALLOWED);
			if (D && D->systemFlags & FUNCTION_NAME) // it is a function
			{
				// is it also english. If builtin function, do that for sure
				// if user function AND english, more problematic.  maybe he forgot
				WORDP E = FindWord(word);
				if (!E || !(E->properties & PART_OF_SPEECH) || D->x.codeIndex) strcpy(word,rename); //   a recognized call
				else if (*ptr == '(') strcpy(word,rename); // use his spacing to decide
			}
		}
		// a function call, not a functional string or functional variable.
		if (*word == '^' && word[1] != '"' && word[1] != '\'' && word[1] != '$' && word[1] != '_' && word[1])
		{
			ptr = ReadCall(word,ptr,in,data,*nextToken == '('); //   add function call or function var ref
			*assignKind = 0;
		}
		else 
		{
			if (*word == '~' ) CheckSetOrTopic(word);
			if (IsAlpha(*word) && spellCheck == OUTPUT_SPELL) SpellCheckScriptWord(word,-1);
			strcpy(data,word);	//   add simple item into data
			data += strlen(data);
		}
		*data++ = ' ';
	}
	while (*(data-1) == ' ') *--data = 0;
	*data++ = ' ';
	*data = 0;

	//   now verify no choice block exceeds CHOICE_LIMIT and that each [ is closed with ]
	while (*original)
	{
		original = ReadCompiledWord(original,word);
		if (*original != '[') continue;

		unsigned int count = 0;
		char* at = original;
		while (*at == '[')
		{
			//   find the closing ]
			while (ALWAYS) 
			{
				at = strchr(at+1,']'); //   find closing ] - we MUST find it (check in initsql)
				if (!at) BADSCRIPT("OUTPUT-5 Failure to close [ choice")
				if (*(at-2) != '\\') break; //   found if not a literal \[
			}
            ++count;
			at += 2;	//   at next token
		}
		if (count >= (CHOICE_LIMIT - 1)) BADSCRIPT("OUTPUT-6 Max %d choices in a row",CHOICE_LIMIT)
		original = at;
	}
	patternContext = oldContext;
	return ptr;
}

static char* ReadTopLevelRule(char* typeval,char* ptr, FILE* in,char* data,char* basedata)
{//   handles 1 responder/gambit + all rejoinders attached to it
	char type[10];
	strcpy(type,typeval);
	char kind[MAX_WORD_SIZE];
	strcpy(kind,type);
	char word[MAX_WORD_SIZE];
	char rejoinders[256];	//   legal levels a: thru q:
	memset(rejoinders,0,sizeof(rejoinders));
	WriteVerify();	// dump any accumulated verification data before the rule
	//   rejoinders == 1 is normal, 2 means authorized in []  3 means authorized and used
	*rejoinders = 1;	//   we know we have a responder. we will see about rejoinders later
	while (ALWAYS) //   read responser + all rejoinders
	{
		MakeLowerCase(kind);
		
		//   validate rejoinder is acceptable
		if (Rejoinder(kind))
		{
			int level = *kind - 'a' + 1;	//   1 ...
			if (rejoinders[level] >= 2) rejoinders[level] = 3; //   authorized by [b:] and now used
			else if (!rejoinders[level-1]) BADSCRIPT("RULE-1 Illegal rejoinder level %s",kind)
			else rejoinders[level] = 1; //   we are now at this level, enables next level
			//   levels not authorized by [b:][g:] etc are disabled
			while (++level < 20)
			{
				if (rejoinders[level] == 1) rejoinders[level] = 0;
			}
			
			currentRuleID += ONE_REJOINDER;
			WriteVerify();
		}
		strcpy(data,kind); 
		data += 2;
		*data++ = ' ';	
		bool patternDone = false;

#ifdef INFORMATION

A responder of any kind consists of a prefix of `xx  spot xx is an encoded jump offset to go the the
end of the responder. Then it has the kind item (t:   s:  etc). Then a space.
Then one of 3 kinds of character:
	a. a (- indicates start of a pattern
	b. a space - indicates no pattern exists
	c. a 1-byte letter jump code - indicates immediately followed by a label and the jump code takes you to the (

#endif
		char label[MAX_WORD_SIZE];
		*label = 0;
		while (ALWAYS) //   read as many tokens as needed to complete the responder definition
		{
			ptr = ReadNextSystemToken(in,ptr,word,false); 
			if (!*word)  break;
			MakeLowerCopy(lowercaseForm,word);

			size_t len = strlen(word);
			if (TopLevelUnit(word) || TopLevelRule(lowercaseForm)) break;//   responder definition ends when another major unit or top level responder starts

			if (*word == '(') //   found pattern, no label
			{
				ptr = ReadPattern(ptr-1,in,data,false); //   back up and pass in the paren for pattern
				patternDone = true;
				break;
			}
			else //   label or start of output
			{
				ReadNextSystemToken(in,ptr,nextToken,false,true);	//   peek what comes after

				if (*nextToken == '(' && (IsAlpha(*word) || IsDigit(*word))) //  label exists
				{
					char name[MAX_WORD_SIZE];
					*name = '^';
					strcpy(name+1,word);
					WORDP D = FindWord(name,0,LOWERCASE_LOOKUP);
					if (D && D->systemFlags & FUNCTION_NAME) WARNSCRIPT("label: %s is a potential macro in %s. Add ^ if you want it treated as such.\r\n",word,currentFilename)
					else if (!stricmp(word,"if") || !stricmp(word,"loop")) WARNSCRIPT("label: %s is a potential flow control (if/loop) in %s. Add ^ if you want it treated as a control word.\r\n",word,currentFilename)

					//  potential ^reuse label
					strcpy(label,currentTopicName); 
					strcat(label,".");
					strcat(label,word); 
					MakeUpperCase(label); // full label to test if exists.
					WORDP E = StoreWord(label,0);
					AddInternalFlag(E,LABEL);

					if (len > 40) BADSCRIPT("RULE-2 Label %s must be less than 40 characters",word)
					*data++ = (char)('0' + len + 2); //   prefix attached to label
					strcpy(data,word);
					data += len;
					*data++ = ' ';
					ReadNextSystemToken(NULL,NULL,NULL); // drop lookahead token
					ptr = ReadPattern(ptr,in,data,false); //   read ( for real in the paren for pattern
					patternDone = true;
				}
				else //   we were seeing start of output (no label and no pattern), proceed to output
				{
					if (*type != GAMBIT && *type != RANDOM_GAMBIT) BADSCRIPT("RULE-3 Missing pattern for rule")
					*data++ = ' ';
					patternDone = true;
					ReadNextSystemToken(NULL,NULL,NULL); // drop token cache (ptr still in main buffer so we can reread main buffer)
					ptr -= strlen(word); // back up to resee the word
				}
				break;
			}
		} //   END OF WHILE
		if (patternDone) 
		{
			ptr = ReadOutput(ptr,in,data,rejoinders);
	
			//   data points AFTER last char added. Back up to last char, if blank, leave it to be removed. else restore it.
			while (*--data == ' '); 
			*++data = ' ';
			strcpy(data+1,ENDUNITTEXT); //   close out last topic item+
			data += strlen(data);

			while (ALWAYS) // read all verification comments for next rule if any, getting the next real word token
			{
				ptr = ReadNextSystemToken(in,ptr,word,false); 
				if (*word != '#' || word[1] != '!') break;
				ptr = AddVerify(word,ptr);
			}

			MakeLowerCopy(lowercaseForm,word);
			if (!*word || TopLevelUnit(word) || TopLevelRule(lowercaseForm))  
			{
				ptr -= strlen(word);
				break;//   responder definition ends when another major unit or top level responder starts
			}

			//  word is a rejoinder type
			strcpy(kind,lowercaseForm);
		}
		else ReportBug("unexpected word in ReadTopLevelRule - %s",word)
	}

	//   did he forget to fill in any [] jumps
	for (unsigned int i = ('a'-'a'); i <= ('q'-'a'); ++i)
	{
		if (rejoinders[i] == 2) BADSCRIPT("RULE-4 Failed to define rejoinder %c: for responder just ended", i + 'a' - 1)
	}

	*data = 0;
	return ptr;
}

static char* ReadMacro(char* ptr,FILE* in,char* kind,uint64 build)
{
	bool table = !stricmp(kind,"table:"); // create as a transient notwrittentofile 
	uint64 typeFlags = 0;
	if (!stricmp(kind,"tableMacro:") || table) typeFlags = IS_TABLE_MACRO;
	else if (!stricmp(kind,"outputMacro:")) typeFlags = IS_OUTPUT_MACRO;
	else if (!stricmp(kind,"patternMacro:")) typeFlags = IS_PATTERN_MACRO;
	else if (!stricmp(kind,"dualMacro:")) typeFlags = IS_PATTERN_MACRO | IS_OUTPUT_MACRO;

	char macroName[MAX_WORD_SIZE];
	*macroName = 0;
	functionArgumentCount = 0;
	char data[MAX_BUFFER_SIZE];
	*data = 0;
	char* pack = data;
	int parenLevel = 0;
	WORDP D = NULL;
	bool gettingArguments = true;
	patternContext = false;
	while (gettingArguments) //   read as many tokens as needed to get the name and argumentList
	{
		char word[MAX_WORD_SIZE];
		ptr = ReadNextSystemToken(in,ptr,word,false);
		if (!*word) break; //   end of file

		if (!*macroName) //   get the macro name
		{
			if (*word == '^') memmove(word,word+1,strlen(word)); //   remove his ^
			MakeLowerCase(word);
			if (!table && !IsAlpha(*word)) BADSCRIPT("MACRO-1 Macro name must start alpha %s",word)
		if (table)
		{
			strcpy(macroName,"tbl:");
			strcpy(macroName+4,word);
			Log(STDUSERLOG,"Reading table %s\r\n",macroName);
		}
		else
		{
			if (!IsLegalName(word)) BADSCRIPT("MACRO-2 Illegal characters in function name %s",word)
			*macroName = '^';
			strcpy(macroName+1,word);
			Log(STDUSERLOG,"Reading %s %s\r\n",kind,macroName);
		}
		D = StoreWord(macroName);
		if (D->systemFlags & FUNCTION_NAME && !table) BADSCRIPT("MACRO-3 macro %s already defined",macroName)
		continue;
	}

		size_t len = strlen(word);
		if (TopLevelUnit(word)) //   definition ends when another major unit starts
		{
			ptr -= len; //   let someone else see this starter also
			break; 
		}
		char* restrict = NULL;
		switch(*word)
		{
			case '(': 
				if (parenLevel++ != 0) BADSCRIPT("MACRO-4 bad paren level in macro definition %s",macroName)
				continue; //   callArgumentList open
			case ')':
				if (--parenLevel != 0) BADSCRIPT("MACRO-5 bad closing paren in macro definition %s",macroName)
				gettingArguments = false;
				break;
			case '^':  //   declaring a new argument
				if (IsDigit(word[1])) BADSCRIPT("MACRO-6 Function arguments must be alpha names, not digits like %s ",word)
				restrict = strchr(word,'.');
				if (restrict)
				{
					if (!stricmp(restrict+1,"KEEP_QUOTES"))	D->x.macroFlags |= 1 << functionArgumentCount; // a normal string where spaces are kept instead of _ (format string)
					else if (!stricmp(restrict+1,"COMPILE")) D->x.macroFlags |= (1 << 16) << functionArgumentCount; // a compile string " " becomes "^:"
					else  BADSCRIPT("MACRO-? Table/Tablemacro argument restriction must be KEEP_QUOTES OR COMPILE- %s ",word)
					*restrict = 0;
				}
				strcpy(functionArguments[functionArgumentCount++],word);
				if (functionArgumentCount > MAX_ARG_LIMIT)  BADSCRIPT("MACRO-7 Too many callArgumentList to %s - max is %d",macroName,MAX_ARG_LIMIT)
				continue;
			default:
				BADSCRIPT("MACRO-7 Bad argument to macro definition %s",macroName)
		}
	}
	if (!D) return ptr; //   nothing defined

	AddSystemFlag(D,FUNCTION_NAME|typeFlags); 
	AddInternalFlag(D,build);
	*pack++ = (unsigned char)(functionArgumentCount + 'A'); // some 30 can be had
	
	currentFunctionDefinition = D;
	ptr = ((typeFlags & FUNCTION_BITS) == IS_PATTERN_MACRO) ? ReadPattern(ptr,in,pack,true) : ReadOutput(ptr,in,pack,NULL); 
	*pack = 0;

	//   record that it is a macro, with appropriate validation information
	D->w.fndefinition = (unsigned char*) AllocateString(data);

	if (!table) // tables are not real macros, they are temporary
	{
		//   write out definition -- this is the real save of the data
		FILE* out = FopenUTF8WriteAppend(build == BUILD0 ? (char*)"TOPIC/macros0.txt" : (char*)"TOPIC/macros1.txt");
		if ((D->systemFlags & FUNCTION_BITS) ==  IS_TABLE_MACRO) fprintf(out,"%s T %d %d %s\r\n",macroName,D->x.macroFlags,functionArgumentCount,data);
		else if ((D->systemFlags & FUNCTION_BITS) == (IS_OUTPUT_MACRO|IS_PATTERN_MACRO))  fprintf(out,"%s %c %d %s\r\n",macroName,'D',functionArgumentCount,data);
		else fprintf(out,"%s %c %d %s\r\n",macroName,((D->systemFlags & FUNCTION_BITS) == IS_OUTPUT_MACRO) ? 'O' : 'P',functionArgumentCount,data);
		fclose(out);
	}
	return ptr;
}

static char* ReadTable(char* ptr, FILE* in,uint64 build)
{
	char word[MAX_WORD_SIZE];
	char post[MAX_WORD_SIZE]; 
	char args[MAX_TABLE_ARGS+1][MAX_WORD_SIZE];
	unsigned short quoteProcessing = 0;
	unsigned int indexArg = 0;
	char* pre = NULL;
	ptr = SkipWhitespace(ptr);
	ReadNextSystemToken(in,ptr,word,false,true); 
	if (*word != '^')  // add function marker if it lacks one
	{
		memmove(word+1,word,strlen(word)+1);
		*word = '^';
	}
	currentFunctionDefinition = FindWord(word);
	unsigned int sharedArgs;
	bool tableMacro = false;
	if (!currentFunctionDefinition) // go define a temporary tablemacro function since this is a spontaneous table  Table:
	{
		memmove(word,word+1,strlen(word));
		ptr = ReadMacro(ptr,in,"table:",build); //   defines the name,argumentList, and script
		ptr = ReadNextSystemToken(in,ptr,word,false,false); //   the DATA: separator
		if (stricmp(word,"DATA:")) 	BADSCRIPT("TABLE-1 missing DATA: separator for table - %s",word);
		sharedArgs = 0;
	}
	else // this is an existing table macro being executed
	{
		tableMacro = true;
		ptr = ReadNextSystemToken(in,ptr,word,false,false);  // swallow function name
		ptr = ReadNextSystemToken(in,ptr,word,false,false);  // swallow (
		if (*word != '(') BADSCRIPT("TABLE-2 Must have ( before arguments")
		while (ALWAYS) // read argument values we supply to the existing tablemacro
		{
			ptr = ReadNextSystemToken(in,ptr,args[indexArg],false,false);  
			if (*args[indexArg] == ')') break;
			if (*args[indexArg] == '^') 
				BADSCRIPT("TABLE-3 TableMacro %s requires real args, not redefinition args",currentFunctionDefinition->word)
			if (++indexArg >= MAX_TABLE_ARGS) BADSCRIPT("TABLE-4 too many table args")
		}
		sharedArgs = indexArg;
	}
	quoteProcessing = currentFunctionDefinition->x.macroFlags; // values of KEEP_QUOTES for each argument

	// now we have the function definition and any shared arguments. We need to read the real arguments per table line now and execute.

	char* argumentList = AllocateBuffer();
	++jumpIndex;
	int holdDepth = globalDepth;
	char* xxbase = ptr;  // debug hook
	while (ALWAYS) 
	{
		if (setjmp(scriptJump[jumpIndex])) // flush on error
		{
			ptr = FlushToTopLevel(in,ptr,holdDepth,0);
			break;
		}
		ptr = ReadNextSystemToken(in,ptr,word,false,false); 
		if (*word == '\\' && word[1] == 'n') continue; // newline means pretend new table entry

		if (*word == ':' && word[1]) // debug command
		{
			ptr -= strlen(word);
			char output[MAX_WORD_SIZE];
			DoCommand(ptr,output);
			*ptr = 0;
			continue;
		}
		if (!*word || TopLevelUnit(word) ) // end
		{
			ptr -= strlen(word);
			break;
		}
	
		char* original = ptr - strlen(word);
		
		//   process a data set from the line
		char* systemArgumentList = argumentList;
		*systemArgumentList++ = '(';
		*systemArgumentList++ = ' ';
		unsigned int argCount = 0;

		// common arguments processing
		for (unsigned int i = 0; i < sharedArgs; ++i)
		{
			strcpy(systemArgumentList,args[i]);
			systemArgumentList += strlen(systemArgumentList);
			*systemArgumentList++ = ' ';
			++argCount;
		}

		// now fill in args of table data from a single line
		char* choiceArg = NULL; //   the multiple interior
		bool startup = true;
		while (ALWAYS) 
		{
			if (!startup) ptr = ReadSystemToken(ptr,word);	//   next item to associate
			startup = false;
			if (!*word) break;					//   end of LINE of items stuff

			if (!stricmp(word,"...")) break;	// pad to end of arg count

			if (!stricmp(word,"\\n"))			// fake end of line
			{
				memmove(readBuffer,ptr,strlen(ptr)+1);	//   erase earlier stuff we've read
				ptr = readBuffer;
				break; 
			}

			if (*word == '[' ) // choice set (one per line allowed)
			{
				if (choiceArg) BADSCRIPT("TABLE-5 Only allowed 1 multiple choice [] arg")
				pre = systemArgumentList;  //   these are the fixed arguments before the multiple choice one
				choiceArg = ptr; //   multiple choices arg 
				char* at = strchr(ptr,']'); //  find end of multiple choice
				if (!at) BADSCRIPT("TABLE-6 bad [ ] ending %s in table %s",readBuffer,currentFunctionDefinition->word)
				ptr = at + 1; //   continue fixed argumentList AFTER the multiple choices set (but leave blank if there)
				++argCount;
				continue; //   skipping over this arg, move on to next arg now.
			}
			uint64 flag = 0;
			bool saveQuotes = (quoteProcessing & ( 1 << argCount)) ? 1 : 0; // want to use quotes and spaces, instead of none and convert to _ which is the default
			if (*word == FUNCTIONSTRING && word[1] == '"') strcpy(word,CompileString(word)); // no underscores in string, compiled as executable
			else if (*word == '"' && saveQuotes) {;}// no underscores in string, preserve string. Quotes needed to detect as single argument for fact creation
			else strcpy(word,JoinWords(BurstWord(word,(*word == '"') ? POSSESSIVES : 0))); // by default strings are stored with _, pretending they are words.
			if ( *word == '\\') memmove(word,word+1,strlen(word)); // remove escape
			if (*word == '"' && !word[1]) BADSCRIPT("TABLE-? isolated doublequote argument- start of string not recognized?");
			if (flag != AS_IS && *word != '"' && strstr(word," ")) BADSCRIPT("TABLE-7 unexpected space in string %s - need to use doublequotes around string",word);
			WORDP baseWord = StoreWord(word,flag);
			strcpy(word,baseWord->word); 
	
			//   store next argument
			if (*word == '\'') //   quoted value
			{
				ptr = ReadSystemToken(ptr,word);	//   next item to associate
				if (!ptr || !*word ) break;			//   end of LINE of items stuff
				baseWord = StoreWord(word,0);
				strcpy(word,baseWord->word); 
			}
			strcpy(systemArgumentList,word);
			systemArgumentList += strlen(systemArgumentList);
			*systemArgumentList++ = ' ';
			++argCount;

			//   handle synonyms as needed
			ptr = SkipWhitespace(ptr); //   to align to see if (given 
			MEANING base = MakeMeaning(baseWord);
			if (*ptr == '(' && ++ptr) while (ALWAYS) // synonym listed, create a fact for it
			{
				ptr = ReadSystemToken(ptr,word);
				if (!*word || *word == '[' || *word == ']')  BADSCRIPT("TABLE-8 Synomym in table %s lacks token",currentFunctionDefinition->word)
				if (*word == ')') break;	//   end of synonms
				strcpy(word,JoinWords(BurstWord(word,CONTRACTIONS)));
				if (IsUpperCase(*word)) CreateFact(MakeMeaning(StoreWord(word,NOUN|NOUN_PROPER_SINGULAR)),Mmember,base); 
				else CreateFact(MakeMeaning(StoreWord(word,NOUN|NOUN_SINGULAR)),Mmember,base);
			}
			if ((MACRO_ARGUMENT_COUNT(currentFunctionDefinition) - sharedArgs) == 1)
			{
				memmove(readBuffer,ptr,strlen(ptr)+1);	
				ptr = readBuffer;
				break;
			}
		}

		while (!stricmp(word,"...") && argCount < MACRO_ARGUMENT_COUNT(currentFunctionDefinition))
		{
			strcpy(systemArgumentList,"*");
			systemArgumentList += strlen(systemArgumentList);
			*systemArgumentList++ = ' ';
			++argCount;
		}

		*systemArgumentList = 0;
		if (choiceArg) strcpy(post,pre); // save argumentList after the multiple choices

		//   now we have one map of the argumentList row
		if (argCount && argCount != MACRO_ARGUMENT_COUNT(currentFunctionDefinition)) 
			BADSCRIPT("TABLE-9 Bad table %s in table %s, want %d arguments and have %d",original,currentFunctionDefinition->word,MACRO_ARGUMENT_COUNT(currentFunctionDefinition),argCount)

		//   table line is read, now execute rules on it, perhaps multiple times, after stuffing in the choice if one
		if (argCount) //   we swallowed a dataset. Process it
		{
			while (ALWAYS)
			{
				//   prepare variable argumentList
				if (choiceArg) //   do it with next multi
				{
					choiceArg = ReadSystemToken(choiceArg,word); //   get choice
					unsigned int control = 0;
					if (*word == FUNCTIONSTRING && word[1] == '"') strcpy(word,CompileString(word)); // readtable
					else strcpy(word,JoinWords(BurstWord(word,CONTRACTIONS|control)));
					strcpy(word,StoreWord(word,(control) ? AS_IS : 0)->word); 

					if (!*word || *word == ']') break;			//   end of multiple choice
					if (*word == '\'') //   quoted value
					{
						choiceArg = ReadSystemToken(choiceArg,word); //   get 1st of choice
						if (!*word || *word == ']') break;			//   end of LINE of items stuff
						ForceUnderscores(word);
						strcpy(pre,StoreWord(word)->word); //   record the local w/o any set expansion
					}
					else 
					{
						WORDP D = StoreWord(word);
						strcpy(pre,D->word); //   record the multiple choice
						choiceArg = SkipWhitespace(choiceArg);
						if (*choiceArg == '(' && ++choiceArg) while(choiceArg) //   synonym 
						{
							choiceArg = ReadSystemToken(choiceArg,word);
							if (!*word) BADSCRIPT("TABLE-10 Failure to close synonym list in table %s",currentFunctionDefinition->word)
							if (*word == ')') break;	//   end of synonms
							ForceUnderscores(word);
							CreateFact(MakeMeaning(StoreWord(word)),Mmember,MakeMeaning(D)); 
						}
					}		

					char* at = pre + strlen(pre);
					*at++ = ' ';
					strcpy(at,post); //   add rest of argumentList
					systemArgumentList = at + strlen(post);
				}
				*systemArgumentList++ = ')';	//   end of call setup
				*systemArgumentList = 0;
				
				ChangeDepth(2,"readTable");
				currentRule = NULL;
				unsigned int result;
				DoFunction(currentFunctionDefinition->word,argumentList,currentOutputBase,result);
				ChangeDepth(-2,"readTable");
				if (!choiceArg) break;
			}
		}
	}
	FreeBuffer();

	if (!tableMacro)  // delete dynamic function
	{
		currentFunctionDefinition->systemFlags &= -1LL ^ FUNCTION_NAME;
		currentFunctionDefinition->w.fndefinition = NULL;
		AddInternalFlag(currentFunctionDefinition,DELETED_MARK);
	}
	currentFunctionDefinition = NULL; 
	--jumpIndex;
	return ptr;
}

static void SetJumpOffsets(char* data) // store jump offset for each rule
{
    char* at = data;
    char* end = data;
    while (*at && *++at) // find each responder end
    {
        if (*at == ENDUNIT) 
        {
            int diff = (int)(at - end  + 1);
			if (diff > MAX_JUMP_OFFSET) BADSCRIPT("TOPIC-9 Jump offset too far - %d but limit %d near %s",diff,MAX_JUMP_OFFSET,readBuffer) //   limit 2 char (12 bit) 
			Encode(diff,end);
            end = at + 1;
        }
    }
 }

static char* ReadKeyword(char* word,char* ptr,bool &notted, bool &quoted, MEANING concept,uint64 type,bool ignoreSpell)
{
	// read the keywords zone of the concept
	char* at;
	MEANING M;
	WORDP D;
	size_t len = strlen(word);
	switch(*word) 
	{
		case '!':	// excuded keyword
			if (len == 1) BADSCRIPT("CONCEPT-5 Must attach ! to keyword in %s",Meaning2Word(concept)->word);
			if (notted) BADSCRIPT("CONCEPT-5 Cannot use ! after ! in %s",Meaning2Word(concept)->word);
			notted = true;
			ptr -= len;
			if (*ptr == '!') ++ptr;
			break;
		case '\'': 
			if (len == 1) BADSCRIPT("CONCEPT-6 Must attach ' to keyword in %s",Meaning2Word(concept)->word);
			if (quoted) BADSCRIPT("CONCEPT-5 Cannot use ' after ' in %s",Meaning2Word(concept)->word);
			quoted = true;	//   since we emitted the ', we MUST emit the next token
			ptr -= len;
			if (*ptr == '\'') ++ptr;
			break;
		default:
			if (*word == '$' || *word == '_' || *word == '%') BADSCRIPT("CONCEPT-? Cannot use $var or _var or %var as a keyword in %s",Meaning2Word(concept)->word);
			if (*word == '~') MakeLowerCase(word); //   sets are always lower case
			if ((at = strchr(word+1,'~'))) //   wordnet meaning request, confirm definition exists
			{
				char level[10];
				strcpy(level,at);
				M = ReadMeaning(word);
				if (!M) BADSCRIPT("CONCEPT-7 WordNet word doesn't exist %s",word)
				WORDP D = Meaning2Word(M);
				unsigned int index = Meaning2Index(M);
				if ((GetMeaningCount(D) == 0 && !(M & BASIC_POS)) || (index && !strcmp(word,D->word) && index > GetMeaningCount(D)))
				{
#ifndef FULLDICTONARY
					if (index) WARNSCRIPT("WordNet word does not have such meaning %s\r\n",word)
#endif
					M &= -1 ^ INDEX_BITS;
				}
			}
			else // ordinary word or concept-- see if it makes sense
			{
				M = ReadMeaning(word);
				D = Meaning2Word(M);
					
				if (type) AddProperty(D,type); // augment its type

				if (*D->word == '~') // concept
				{
					if (M == concept) 
						BADSCRIPT("CONCEPT-8 Cannot include topic into self - %s",D->word);
					CheckSetOrTopic(D->word);
				}
				else if ( ignoreSpell || !spellCheck || strchr(D->word,'_') || !D->word[1] || IsUpperCase(*D->word)) {;}	// ignore spelling issues, phrases, short words &&  proper names
				else if (!(D->properties & PART_OF_SPEECH && !(D->systemFlags & (PATTERN_WORD))))
				{
					SpellCheckScriptWord(D->word,-1);
					WritePatternWord(D->word);
				}
			} // end ordinary word

			CreateFact(M,(notted) ? Mexclude : Mmember,concept, quoted ? ORIGINAL_ONLY : 0); 
			quoted = false;
			notted = false;
	} 
	return ptr;
}

static char* ReadBot(char* ptr, FILE* in, uint64 build)
{
	*botheader = ' ';
	char word[MAX_WORD_SIZE];
	ptr = ReadCompiledWord(ptr,word);
	MakeLowerCopy(botheader,word);
	char* x;
	while ((x = strchr(botheader,','))) *x = ' ';	// change comma to space. all bot names have spaces on both sides
	Log(STDUSERLOG,"Reading bot restriction: %s\r\n",botheader);
	return ptr;
}

static char* ReadTopic(char* ptr, FILE* in,uint64 build)
{
	patternContext = false;

	char* data = (char*) malloc(MAX_TOPIC_SIZE); // use a big chunk of memory for the data
	*data = 0;
	char* pack = data;

	++topicCount;
	*currentTopicName = 0;
	unsigned int flags = 0;
	bool topicFlagsDone = false;
	bool keywordsDone = false;
	int parenLevel = 0;
	bool quoted = false;
	bool notted = false;
	MEANING topic = 0;
	int holdDepth = globalDepth;
	WORDP topicName = NULL;
	unsigned int gambits = 0;
	unsigned int toplevelrules = 0; // does not include rejoinders
	currentRuleID = 0;	// reset rule notation
	verifyIndex = 0;	

	if (setjmp(scriptJump[++jumpIndex])) 
	{
		ptr = FlushToTopLevel(in,ptr,holdDepth,data); //   if error occurs lower down, flush to here
	}
	while (ALWAYS) //   read as many tokens as needed to complete the definition
	{
		char word[MAX_WORD_SIZE];
		ptr = ReadNextSystemToken(in,ptr,word,false);
		if (!*word) break;

		if (!*currentTopicName) //   get the topic name
		{
			if (*word != '~') BADSCRIPT("Topic name - %s must start with ~",word)
			strcpy(currentTopicName,word);
			Log(STDUSERLOG,"Reading topic %s\r\n",currentTopicName);
			topicName = FindWord(currentTopicName);
			if (topicName && topicName->systemFlags & CONCEPT && !(topicName->systemFlags & TOPIC) && topicName->internalBits & (BUILD0|BUILD1)) BADSCRIPT("TOPIC-1 Concept already defined with this topic name %s",currentTopicName)
			topicName = StoreWord(currentTopicName);
			if (!IsLegalName(currentTopicName)) BADSCRIPT("TOPIC-2 Illegal characters in topic name %s",currentTopicName)
			topic = MakeMeaning(topicName);

			// handle potential multiple topics of same name
			duplicateCount = 0;
			while (topicName->systemFlags & TOPIC)
			{
				++duplicateCount;
				char name[MAX_WORD_SIZE];
				sprintf(name,"%s.%d",currentTopicName,duplicateCount);
				topicName = StoreWord(name);
				if (!*duplicateTopicName) 
					strcpy(duplicateTopicName,currentTopicName);
			}
			strcpy(currentTopicName,topicName->word);
			AddSystemFlag(topicName,TOPIC|CONCEPT);  
			AddInternalFlag(topicName,build);
			topicName->w.botNames = NULL;
			//   empty the verify file
			sprintf(word,"VERIFY/%s.txt",currentTopicName+1); 
			FILE* in = fopen(word,"wb");
			if (in) fclose(in);

			continue;
		}

		if (TopLevelUnit(word)) //   definition ends when another major unit starts
		{
			ptr -= strlen(word); //   let someone else see this starter also
			break; 
		}

		switch(*word)
		{
		case '(': case '[':
			if (!keywordsDone && topicFlagsDone) BADSCRIPT("TOPIC-3 Illegal bracking in topic keywords %s",word)
			topicFlagsDone = true; //   topic flags must occur before list of keywords
			++parenLevel;
			break;
		case ')': case ']':
			--parenLevel;
			if (parenLevel == 0) keywordsDone = true;
			break;
		case '#':
			if (*word == '#' && word[1] == '!')  ptr = AddVerify(word,ptr);
			continue;
		default:
			MakeLowerCopy(lowercaseForm,word);
			if (!topicFlagsDone) //   do topic flags
			{
				if (!strnicmp(word,"bot=",4)) // bot restriction on the topic
				{
					char botlist[MAX_WORD_SIZE];
					MakeLowerCopy(botlist,word+4);
					char* x;
					while ((x = strchr(botlist,','))) *x = ' ';	// change comma to space. all bot names have spaces on both sides
					topicName->w.botNames = AllocateString(botlist,strlen(botlist)); // bot=harry,georgia,roger
				}
                else if (!stricmp(word,"deprioritize")) flags |= TOPIC_LOWPRIORITY; 
				else if (!stricmp(word,"noblocking")) flags |= TOPIC_NOBLOCKING; 
 				else if (!stricmp(word,"nopatterns")) flags |= TOPIC_NOPATTERNS; 
 				else if (!stricmp(word,"nogambits")) flags |= TOPIC_NOGAMBITS; 
 				else if (!stricmp(word,"nosamples")) flags |= TOPIC_NOSAMPLES; 
 				else if (!stricmp(word,"nokeys"))  flags |= TOPIC_NOKEYS; 
                else if (!stricmp(word,"keep")) flags |= TOPIC_KEEP; 
 				else if (!stricmp(word,"norandom")) flags &= -1 ^TOPIC_RANDOM;
				else if (!stricmp(word,"normal")) flags &= -1 ^TOPIC_PRIORITY;
				else if (!stricmp(word,"norepeat")) flags &= -1 ^TOPIC_REPEAT;
				else if (!stricmp(word,"nostay")) flags |= TOPIC_NOSTAY;
				else if (!stricmp(word,"priority"))  flags |= TOPIC_PRIORITY; 
				else if (!stricmp(word,"random")) flags |= TOPIC_RANDOM;
				else if (!stricmp(word,"repeat")) flags |= TOPIC_REPEAT; 
				else if (!stricmp(word,"safe")) flags |= -1 ^TOPIC_SAFE;
				else if (!stricmp(word,"stay")) flags &= -1 ^TOPIC_NOSTAY;
				else if (!stricmp(word,"erase")) flags &= -1 ^TOPIC_KEEP;
				else if (!stricmp(word,"system")) flags |= TOPIC_SYSTEM | TOPIC_KEEP | TOPIC_NOSTAY;
				else if (!stricmp(word,"user"));
                else BADSCRIPT("Bad topic flag %s for topic %s",word,currentTopicName)
			}
			else if (!keywordsDone) ptr = ReadKeyword(word,ptr,notted,quoted,topic,0,false);//   absorb keyword list
			else if (TopLevelRule(lowercaseForm))//   absorb a responder/gambit and its rejoinders
			{
				++toplevelrules;
				if (TopLevelGambit(word)) ++gambits;
				if (pack == data)
				{
					strcpy(pack,ENDUNITTEXT+1);	//   init 1st rule
					pack += strlen(pack);
				}
				ptr = ReadTopLevelRule(lowercaseForm,ptr,in,pack,data);
				currentRuleID = TOPLEVELID(currentRuleID) + 1;
				pack += strlen(pack);
				if ((pack - data) > (MAX_TOPIC_SIZE - 2000)) BADSCRIPT("TOPIC-4 Topic %s data too big. Split it by calling another topic using u: () respond(~subtopic) and putting the rest of the rules in that subtopic",currentTopicName)
			}
			else BADSCRIPT("Expecting responder for topic %s, got %s",currentTopicName,word)
		}
	}

	--jumpIndex;

	if (parenLevel) BADSCRIPT("TOPIC-5 Failure to balance ( in %s",currentTopicName)
	if (!topicName) BADSCRIPT("TOPIC-6 No topic name?")
	if (toplevelrules > MAX_TOPIC_RULES) BADSCRIPT("TOPIC-8 %s has too many rules- %d must be limited to %d. Call a subtopic.",currentTopicName,toplevelrules,MAX_TOPIC_RULES)
	if (!topicName->w.botNames && *botheader) topicName->w.botNames = AllocateString(botheader,strlen(botheader)); //  harry,georgia,roger

	size_t len = pack-data;
	unsigned int checksum = (unsigned int) (Hashit((unsigned char*) data, len) & 0x0ffffffff);
	
	//   trailing blank after jump code
    SetJumpOffsets(data); 
	if (len >= (MAX_TOPIC_SIZE-100)) BADSCRIPT("TOPIC-7 Too much data in one topic")
	FILE* out = FopenUTF8WriteAppend(build == BUILD0 ? "TOPIC/script0.txt" : "TOPIC/script1.txt");
	
	// write out topic data
	char* restriction = (topicName->w.botNames) ? topicName->w.botNames : (char*)"all";
	unsigned int len1 = (unsigned int)strlen(restriction);
	fprintf(out,"TOPIC: %s %d %d %d %d %d %s\r\n",currentTopicName,(unsigned int) flags,(unsigned int) checksum,(unsigned int) toplevelrules,(unsigned int) gambits,(unsigned int)(len + len1 + 7),currentFilename); 
	fprintf(out,"\" %s \" %s\r\n",restriction,data);
	fclose(out);
	
	free(data);
	
	return ptr;
}

static char* ReadPlan(char* ptr, FILE* in,uint64 build)
{
	char planName[MAX_WORD_SIZE];
	char baseName[MAX_WORD_SIZE];
	*planName = 0;
	functionArgumentCount = 0;
	int parenLevel = 0;
	WORDP D = NULL;
	bool gettingArguments = true;
	endtopicSeen = false;
	patternContext = false;
	int baseArgumentCount = 0;
	unsigned int duplicateCount = 0;
	while (gettingArguments) //   read as many tokens as needed to get the name and argumentList
	{
		char word[MAX_WORD_SIZE];
		ptr = ReadNextSystemToken(in,ptr,word,false);
		if (!*word) break; //   end of file

		if (!*planName) //   get the plan name
		{
			if (*word == '^') memmove(word,word+1,strlen(word)); //   remove his ^
			MakeLowerCase(word);
			if (!IsAlpha(*word)) BADSCRIPT("PLAN-1 Plan name must start alpha %s",word)
			if (!IsLegalName(word)) BADSCRIPT("PLAN-2 Illegal characters in plan name %s",word)
			*planName = '^';
			strcpy(planName+1,word);
			strcpy(baseName,planName);
			Log(STDUSERLOG,"Reading plan %s\r\n",planName);

			// handle potential multiple plans of same name
			WORDP plan = FindWord(planName);
			char name[MAX_WORD_SIZE];
			strcpy(name,planName);
			if (plan) baseArgumentCount = plan->w.planArgCount;
			while (plan && plan->systemFlags & FUNCTION_NAME)
			{
				++duplicateCount;
				sprintf(name,"%s.%d",baseName,duplicateCount);
				plan = FindWord(name);
				strcpy(planName,name);
			}

			D = StoreWord(planName);
			continue;
		}

		size_t len = strlen(word);
		if (TopLevelUnit(word)) //   definition ends when another major unit starts
		{
			ptr -= len; //   let someone else see this starter also
			break; 
		}
		switch(*word)
		{
			case '(': 
				if (parenLevel++ != 0) BADSCRIPT("PLAN-4 bad paren level in plan definition %s",planName)
				continue; //   callArgumentList open
			case ')':
				if (--parenLevel != 0) BADSCRIPT("PLAN-5 bad closing paren in plan definition %s",planName)
				gettingArguments = false;
				break;
			case '^':  //   declaring a new argument
				if (IsDigit(word[1])) BADSCRIPT("PLAN-6 Plan arguments must be alpha names, not digits like %s ",word)
				strcpy(functionArguments[functionArgumentCount++],word);
				if (functionArgumentCount > MAX_ARG_LIMIT)  BADSCRIPT("PLAN-7 Too many callArgumentList to %s - max is %d",planName,MAX_ARG_LIMIT)
				continue;
			default:
				BADSCRIPT("PLAN-7 Bad argument to plan definition %s",planName)
		}
	}
	if (!D) return ptr; //   nothing defined
	if (parenLevel) BADSCRIPT("PLAN-5 Failure to balance ( in %s",planName)
	if (duplicateCount && functionArgumentCount != baseArgumentCount) 
		BADSCRIPT("PLAN->? Additional copies of %s must have %d arguments",planName,baseArgumentCount)
	AddSystemFlag(D,FUNCTION_NAME|IS_PLAN_MACRO); 
	AddInternalFlag(D,build);
	D->w.planArgCount = functionArgumentCount;
	currentFunctionDefinition = D;
	
	char* data = (char*) malloc(MAX_TOPIC_SIZE); // use a big chunk of memory for the data
	*data = 0;
	char* pack = data;

	int holdDepth = globalDepth;
	unsigned int toplevelrules = 0; // does not include rejoinders

	if (setjmp(scriptJump[++jumpIndex])) 
	{
		ptr = FlushToTopLevel(in,ptr,holdDepth,data); //   if error occurs lower down, flush to here
	}
	while (ALWAYS) //   read as many tokens as needed to complete the definition
	{
		char word[MAX_WORD_SIZE];
		ptr = ReadNextSystemToken(in,ptr,word,false);
		if (!*word) break;

		if (TopLevelUnit(word)) //   definition ends when another major unit starts
		{
			ptr -= strlen(word); //   let someone else see this starter also
			break; 
		}

		switch(*word)
		{
		case '#':
			if (*word == '#' && word[1] == '!')  BADSCRIPT("PLAN-? Verification not meaningful in a plan")
			continue;
		default:
			MakeLowerCopy(lowercaseForm,word);
			if (TopLevelRule(lowercaseForm))//   absorb a responder/gambit and its rejoinders
			{
				++toplevelrules;
				if (pack == data)
				{
					strcpy(pack,ENDUNITTEXT+1);	//   init 1st rule
					pack += strlen(pack);
				}
				ptr = ReadTopLevelRule(lowercaseForm,ptr,in,pack,data);
				pack += strlen(pack);
				if ((pack - data) > (MAX_TOPIC_SIZE - 2000)) BADSCRIPT("PLAN-4 Plan %s data too big. Split it by calling another topic using u: () respond(~subtopic) and putting the rest of the rules in that subtopic",planName)
			}
			else BADSCRIPT("Expecting responder for plan %s, got %s",planName,word)
		}
	}

	--jumpIndex;

	if (toplevelrules > MAX_TOPIC_RULES) BADSCRIPT("PLAN-8 %s has too many rules- %d must be limited to %d. Call a plantopic.",planName,toplevelrules,MAX_TOPIC_RULES)

	size_t len = pack-data;
	if (!len)  WARNSCRIPT("No data in plan %s\r\n",currentTopicName)

	if (!endtopicSeen) BADSCRIPT("PLAN-8 Plan %s cannot succeed since no ^end(plan) exists\n",planName)

	//   trailing blank after jump code
    SetJumpOffsets(data); 
	if (len >= (MAX_TOPIC_SIZE-100)) BADSCRIPT("PLAN-7 Too much data in one plan")
	*pack = 0;

		
	//   write how many plans were found (for when we preload during normal startups)
	if (hasPlans == 0)
	{
		
		// init the plan output file
		FILE* out = FopenUTF8Write(build == BUILD0 ? (char*)"TOPIC/plans0.txt" : (char*)"TOPIC/plans1.txt");
		fprintf(out,"0     \r\n"); //   reserve 5-digit count for number of plans
		fclose(out);
	}
	++hasPlans;

	// write out plan data
	FILE* out = FopenUTF8WriteAppend(build == BUILD0 ? (char*)"TOPIC/plans0.txt" : (char*)"TOPIC/plans1.txt");
	char* restriction =  (char*)"all";
	unsigned int len1 = (unsigned int)strlen(restriction);
	fprintf(out,"PLAN: %s %d %d %d %s\r\n",planName,(unsigned int) functionArgumentCount,(unsigned int) toplevelrules,(unsigned int)(len + len1 + 7),currentFilename); 
	fprintf(out,"\" %s \" %s\r\n",restriction,data);
	fclose(out);

	free(data);
	return ptr;
}

static char* ReadConcept(char* ptr, FILE* in,uint64 build)
{
	char conceptName[MAX_WORD_SIZE];
	*conceptName = 0;
	MEANING concept = 0;
	WORDP D;
	bool ignoreSpell = false;
	
	patternContext = false;
	bool quoted = false;
	bool notted = false;
	int parenLevel = 0;
	uint64 type = 0;
	uint64 sys;
	while (ALWAYS) //   read as many tokens as needed to complete the definition (must be within same file)
	{
		char word[MAX_WORD_SIZE];
		ptr = ReadNextSystemToken(in,ptr,word,false);
		if (!*word) break;	//   file ran dry
		size_t len = strlen(word);
		if (TopLevelUnit(word)) //   definition ends when another major unit starts
		{
			ptr -= len; //   let someone else see this starter 
			break; 
		}

		// establish name and characteristics of the concept
		if (!*conceptName) //   get the concept name, will be ~xxx or :xxx 
		{
			if (*word != '~' ) BADSCRIPT("CONCEPT-1 Concept name must begin with ~ or : - %s",word)

			// Users may not create repeated user topic names. Ones already saved in dictionary are fine to overwrite
			MakeLowerCopy(conceptName,word);
			if (!IsLegalName(conceptName)) BADSCRIPT("CONCEPT-2 Illegal characters in concept name %s",conceptName)

			D = FindWord(conceptName);
			if (D && D->systemFlags & CONCEPT && D->internalBits & (BUILD0|BUILD1)) BADSCRIPT("CONCEPT-3 Concept/topic already defined %s",conceptName)
			// create concept header
			D = StoreWord(conceptName,0,CONCEPT);
			AddInternalFlag(D,build);
			concept = MakeMeaning(D);
			sys = type = 0;
			parenLevel = 0;

			Log(STDUSERLOG,"Reading concept %s\r\n",conceptName);

			// read the control flags of the concept
			ptr = SkipWhitespace(ptr);
			while (*ptr && *ptr != '(' && *ptr != '[' && *ptr != '"') // not started and no concept comment given (concept comments come after all control flags
			{
				ptr = ReadCompiledWord(ptr,word);
				char* paren = strchr(word,'(');
				if (paren) // handle attachment of paren + stuff
				{
					while (*--ptr != '(');
					*paren = 0;
				}
				ptr = SkipWhitespace(ptr);
				uint64 bits = FindValueByName(word);
				type |= bits;
				uint64 bits1 = FindValue2ByName(word);
				sys |= bits1;
				if (bits) AddProperty(D, bits);
				else if (bits1) AddSystemFlag(D, bits1);
				else if (!stricmp(word,"IGNORESPELLING")) ignoreSpell = true;
				else BADSCRIPT("CONCEPT-4 Unknown concept property %s",word) 
			}

			// read in comment label about concept
			if (*ptr == '"')
			{
				ptr = ReadNextSystemToken(in,ptr,word,false);
				Convert2Underscores(word,false,false,true);
				CreateFact(MakeMeaning(StoreWord(word)),MconceptComment,concept);
			}
			continue;  // read more tokens now that concept has been established
		}

		// read the keywords zone of the concept
		switch(*word) //   THE MEAT OF CONCEPT DEFINITIONS
		{
			case '(':  case '[':	// start keyword list
				if (parenLevel) BADSCRIPT("CONCEPT-5 Cannot use [ or ( within a keyword list for %s",conceptName);
				parenLevel++;
				break;
			case ')': case ']':		// end keyword list
				--parenLevel;
				if (parenLevel < 0) BADSCRIPT("CONCEPT-6 Missing ( for concept definition %s",conceptName)
					if (parenLevel == 0) break;
				break;
			default: 
				 ptr = ReadKeyword(word,ptr,notted,quoted,concept,type,ignoreSpell);
		}
	}
	if (parenLevel) BADSCRIPT("CONCEPT-7 Failure to give closing ( in concept %s",conceptName)
	return ptr;
}

static void ReadTopicFile(char* name,uint64 build) //   read contents of a topic file (.top or .tbl)
{
	*botheader = 0;

	FILE* in = FopenReadNormal(name);
	if (!in) 
	{
		if (strchr(name,'.')) // names a file, not a directory
		{
			WARNSCRIPT("Missing file %s\r\n",name) 
			++missingFiles;
		}
		return;
	}

	Log(STDUSERLOG,"\r\n----Reading file %s\r\n",currentFilename);

	//   if error occurs lower down, flush to here
	int holdDepth = globalDepth;
	patternContext = false;
	char* ptr = "";
	if (setjmp(scriptJump[++jumpIndex])) 
	{
		ptr = FlushToTopLevel(in,ptr,holdDepth,0);
	}
	char word[MAX_WORD_SIZE];
	while (ALWAYS) 
	{
		ptr = ReadNextSystemToken(in,ptr,word,false); //   eat tokens (should all be top level)
		if (!*word) break;						//   no more tokens found

		currentFunctionDefinition = NULL; //   can be set by ReadTable or ReadMacro

		if (*word == ':' && word[1])		// testing command
		{
			char output[MAX_WORD_SIZE];
			DoCommand(readBuffer,output);
			*readBuffer = 0;
			*ptr = 0;
		}
		else if (!stricmp(word,"concept:")) ptr = ReadConcept(ptr,in,build);
		else if (!stricmp(word,"topic:"))  ptr = ReadTopic(ptr,in,build);
		else if (!stricmp(word,"plan:"))  ptr = ReadPlan(ptr,in,build);
		else if (!stricmp(word,"bot:"))  ptr = ReadBot(ptr,in,build);
		else if (!stricmp(word,"table:")) ptr = ReadTable(ptr,in,build);
		else if (!stricmp(word,"patternMacro:") || !stricmp(word,"outputMacro:") || !stricmp(word,"dualMacro:") || !stricmp(word,"tableMacro:")) ptr = ReadMacro(ptr,in,word,build);
		else BADSCRIPT("FILE-1 Unknown top-level declaration %s in %s",word,name)
	}
	fclose(in);
	--jumpIndex;
}

void DoubleCheckReuse()
{
	FILE* in = fopen("TOPIC/missingLabel.txt","rb");
	if (!in) return;

	char word[MAX_WORD_SIZE];
	char topic[MAX_WORD_SIZE];
	while (ReadALine(readBuffer,in))
	{
		char *ptr = ReadCompiledWord(readBuffer,word);		// topic + label
		ptr = ReadCompiledWord(ptr,topic);					// from topic
		ptr = ReadCompiledWord(ptr,tmpWord);				// from file
		unsigned int line;
		ReadInt(ptr,line);									// from line
		WORDP D = FindWord(word);
		if (!D) // cannot find full label
		{
			if (!strcmp(topic,word))  WARNSCRIPT("Missing local label %s for reuse/unerase in topic %s in File: %s Line: %d\r\n",word,topic,tmpWord,line)
			else  WARNSCRIPT("Missing cross-topic label %s for reuse in File: %s Line: %d\r\n",word,tmpWord,line)
		}
	}
	fclose(in);
	remove("TOPIC/missingLabel.txt");
}

static void WriteConcepts(WORDP D, uint64 build)
{
	char* name = D->word;
	if (*name != '~' || !(D->internalBits & build)) return; // not a topic or concept or not defined this build
	RemoveInternalFlag(D,(BUILD0|BUILD1));
		
	// write out keywords 
	FILE* out = FopenUTF8WriteAppend(build == BUILD0 ? "TOPIC/keywords0.txt" : "TOPIC/keywords1.txt");
	fprintf(out,(D->systemFlags & TOPIC) ? "T%s " : "%s ", D->word);

	uint64 properties = D->properties;	
	uint64 bit = START_BIT;
	while (properties && bit)
	{
		if (properties & bit && bit)
		{
			properties ^= bit;
			fprintf(out,"%s ",FindNameByValue(bit));
		}
		bit >>= 1;
	}
	
	properties = D->systemFlags;	
	bit = START_BIT;
	while (properties && bit)
	{
		if (properties & bit && bit && !(bit & ( CONCEPT | TOPIC | PATTERN_WORD )	))
		{
			char* name = FindName2ByValue(bit);
			properties ^= bit;
			fprintf(out,"%s ",name);
		}
		bit >>= 1;
	}

	fprintf(out,"( ");

	size_t lineSize = 0;
	NextinferMark();
	FACT* F = GetObjectHead(D);
	if (F)
	{
		while (F) 
		{
			if (F->verb == Mmember|| F->verb == Mexclude) // the only relevant facts
			{
				char word[MAX_WORD_SIZE];
				WORDP E = Meaning2Word(F->subject);
				AddInternalFlag(E,BEEN_HERE);
				if (*E->word == '"') // change string to std token
				{
					strcpy(word,E->word+1);
					size_t len = strlen(word);
					word[len-1] = ' ';			// remove trailing quote
					ForceUnderscores(word); 
				}
				else if (F->flags & ORIGINAL_ONLY) sprintf(word,"'%s ",WriteMeaning(F->subject));
				else sprintf(word,"%s ",WriteMeaning(F->subject,true));

				char* dict = strchr(word+1,'~'); // has a wordnet attribute on it
				if (*word == '~' || dict  ) // concept or full wordnet word reference
				{
					if (E->inferMark != inferMark) SetTried(D,0);
					E->inferMark = inferMark; 
					if (dict)
					{
						unsigned int which = atoi(dict+1);
						if (which) // given a meaning index, mark it
						{
							uint64 offset = 1 << which;
							SetTried(E,GetTried(E) | offset);	
						}
					}
				}

				// write it out- this INVERTS the order now and when read back in, will be reestablished correctly 
				// but dictionary storage locations will be inverted
				if (F->verb == Mexclude) fwrite("!",1,1,out);
				size_t wlen = strlen(word);
				lineSize += wlen;
				fwrite(word,1,wlen,out);
				if (lineSize > 500) // avoid long lines
				{
					fprintf(out,"\r\n    ");
					lineSize = 0;
				}
				KillFact(F);
			}
			F = GetObjectNext(F);
		}
	}

	fprintf(out,")\r\n");
	fclose(out);
}

static 
void WriteDictionaryChange(FILE* dictout, uint64 build)
{
	// Note that topic labels (topic.name) and pattern words  will not get written
	FILE* in;
	if ( build == BUILD0) in = fopen("TMP/prebuild0","rb");
	else in = fopen("TMP/prebuild1","rb");
	if (!in) ReportBug("Missing zone base file")
	for (WORDP D = dictionaryBase+1; D < dictionaryFree; ++D) 
	{
		uint64 oldproperties = 0;
		uint64 oldflags = 0;
		bool notPrior = false;
		if ( (build == BUILD0 && D < dictionaryPreBuild0 ) || (build == BUILD1 && D < dictionaryPreBuild1))
		{
			oldproperties = Read64(in);
			oldflags = Read64(in);
			char junk[1];
			if (fread(junk,1,1,in)   != 1) // multiword header 
			{
				printf("out of dictionary change data2?\r\n");
			}
		}
		else notPrior = true;
		if (!D->word) continue;	// an empty bucket
		uint64 prop = D->properties;
		uint64 flags = D->systemFlags;
		if (D->properties & AS_IS) 
		{
			RemoveProperty(D,AS_IS); // fact field value
			uint64 prop1 = D->properties;
			prop1 &= -1LL ^ oldproperties;
			uint64 sys1 = flags;
			sys1 &= -1LL ^ oldflags;
			sys1 &= -1LL ^ (NO_EXTENDED_WRITE_FLAGS | CONCEPT); // we dont need these- concepts will come from keywords file
			if ( (build == BUILD0 && D < dictionaryPreBuild0 ) || (build == BUILD1 && D < dictionaryPreBuild1))
			{
				if (!prop1 && !sys1) continue;	// no need to write out, its in the prior world (though flags might be wrong)
			}
		}
		else if (*D->word == '$') continue; // no variables
		else if (D->systemFlags & NO_EXTENDED_WRITE_FLAGS) continue; // ignore pattern words, etc EXCEPT when field of a fact
		else if (D->properties & (NOUN_NUMBER|ADJECTIVE_NUMBER)  && IsDigit(*D->word)) continue; // no numbers
		else if (!D->properties && D->internalBits & UPPERCASE_HASH && !D->systemFlags) continue; // boring uppercase pattern word, just not marked as pattern word because its uppercase

		char* at = D->word - 1;
		while (IsDigit(*++at)){;}
		if (*at == 0) continue;  // purely a number - not allowed to write it out. not allowed to have unusual flags

		// only write out changes in flags and properties
		RemoveProperty(D,oldproperties); // remove the old properties
		D->systemFlags &= -1 ^  oldflags; // remove the old flags

		// if the ONLY change is an existing word got made into a concept, dont write it out anymore
		if (!D->properties && D->systemFlags == CONCEPT && D <= dictionaryPreBuild0) {;} 
		else if (D->properties || D->systemFlags || notPrior)  // there were changes
		{
			fprintf(dictout,"+ %s ",D->word);
			WriteDictionaryFlags(D,dictout); // write the new
			fprintf(dictout,"\r\n");
		}
		D->properties = prop;
		D->systemFlags = flags;
	}
	fclose(in);
    fclose(dictout);
}

static void WriteExtendedFacts(FILE* factout,FILE* dictout,uint64 build)
{
	if (!factout || !dictout) return;

	char* buffer = AllocateBuffer();
	char* ptr = WriteVariables(buffer);
	fwrite(buffer,ptr-buffer,1,factout);
	FreeBuffer();

	WriteDictionaryChange(dictout,build);

	WriteFacts(factout,(build == BUILD0) ? wordnetFacts : build0Facts);
}

static void ClearTopicConcept(WORDP D, uint64 build)
{
	unsigned int k = (ulong_t) build;
	if (D->systemFlags & (CONCEPT|TOPIC) && D->internalBits & k)  
	{
		RemoveSystemFlag(D,CONCEPT|TOPIC);
		RemoveInternalFlag(D,BUILD0|BUILD1);
	}
}

static void DumpErrors()
{
	if (errorIndex) Log(STDUSERLOG,"\r\n ERROR SUMMARY: \r\n");
	for (unsigned int i = 0; i < errorIndex; ++i) Log(STDUSERLOG,"  %s\r\n",errors[i]);
}

static unsigned int DumpWarnings()
{
	if (warnIndex) Log(STDUSERLOG,"\r\nWARNING SUMMARY: \r\n");
	unsigned int count = 0;
	for (unsigned int i = 0; i < warnIndex; ++i) 
	{
		if (strstr(warnings[i],"is not a known word")) {++count;}
		else if (strstr(warnings[i],"is unknown as a word")) {++count;}
		else Log(STDUSERLOG,"  %s\r\n",warnings[i]);
	}
	return count;
}

bool ReadTopicFiles(char* name,uint64 build,int spell)
{
	FILE* in = FopenReadNormal(name);
	if (!in)
	{
		printf("%s not found\r\n",name);
		return false;
	}
	hasPlans = 0;
	trace = 0;
	char word[MAX_WORD_SIZE];
	buildID = build;				// build 0 or build 1
	*duplicateTopicName = 0;	// an example of a repeated topic name found
	*newBuffer = 0;
	missingFiles = 0;
	spellCheck = spell;			// what spell checking to perform

	//   erase facts and dictionary to appropriate level
	if (build == BUILD1) ReturnDictionaryToBuild0(); // rip dictionary back to start of build (but props and systemflags can be wrong)
	else  ReturnDictionaryToWordNet();
	WalkDictionary(ClearTopicConcept,build);				// remove concept/topic flags from prior defined by this build
	EraseTopicFiles(build);
	ClearUserVariables();
	compiling = true;
	errorIndex = warnIndex = hasWarnings = hasErrors = 0;
	echo = true;
	
	//   store known pattern words in pattern file that we want to recognize (not spellcorrect on input)
	patternFile = FopenUTF8Write(build == BUILD0 ? "TOPIC/patternWords0.txt" : "TOPIC/patternWords1.txt");
	if (!patternFile)
	{
		printf("Unable to create patternfile  in the TOPIC subdirectory? Make sure this directory exists and is writable.\r\n");
		return false;
	}

	AllocateOutputBuffer();

	// init the script output file
	FILE* out = FopenUTF8Write(build == BUILD0 ? (char*)"TOPIC/script0.txt" : (char*)"TOPIC/script1.txt");
	if (strlen(name) > 100) name[99] = 0;
	if (!strnicmp(name,"files",5)) name += 5; // dont need the prefix
	fprintf(out,"0     %s %s\r\n",GetMyTime(time(0)),name); //   reserve 5-digit count for number of topics + timestamp
	fclose(out);
	
	uint64 oldtokenControl = tokenControl;
	tokenControl = 0;
	topicCount = 0;
	
	//   read file list to service
	while (ReadALine(readBuffer,in))
	{
		ReadCompiledWord(readBuffer,word);
		if (*word == '#' || !*word) continue;
		if (!stricmp(word,"stop") || !stricmp(word,"exit")) break; //   fast abort
		size_t len = strlen(word);
		char output[MAX_WORD_SIZE];
		if (word[len-1] == '/') WalkDirectory(word,ReadTopicFile,build); // read all files in folder (top level)
		else if (*word == ':' && word[1]) DoCommand(readBuffer,output); // testing command
		else // single file
		{
			ReadTopicFile(word,build);
		}
	}
	if (in) fclose(in);
	fclose(patternFile);

	StartFile("Post compilation Verification");

	// verify errors across all files
	DoubleCheckSetOrTopic();	//   prove all sets/topics he used were defined
	DoubleCheckReuse();		// see if jump labels are defined
	if (*duplicateTopicName)  WARNSCRIPT("At least one duplicate topic name, i.e., %s, which may intended if bot restrictions differ.\r\n",duplicateTopicName)
	WalkDictionary(ClearBeenHere,0);

	// write out compiled data

	
	//   write how many topics were found (for when we preload during normal startups)
	out = fopen(build == BUILD0 ? "TOPIC/script0.txt" : "TOPIC/script1.txt","rb+");
	if (out)
	{
		fseek(out,0,SEEK_SET);
		sprintf(word,"%05d",topicCount);
		fwrite(word,1,5 * sizeof(char),out);
		fclose(out);
	}

	if (hasPlans)
	{
		out = fopen(build == BUILD0 ? "TOPIC/plans0.txt" : "TOPIC/plans1.txt","rb+");
		if (out)
		{
			char word[MAX_WORD_SIZE];
			fseek(out,0,SEEK_SET);
			sprintf(word,"%05d",hasPlans);
			fwrite(word,1,5 * sizeof(char),out);
			fclose(out);
		}
	}

	// we delay writing out keywords til now, allowing multiple accumulation across tables and concepts
	WalkDictionary(WriteConcepts,build);
	WalkDictionary(ClearBeenHere,0);

	// dump variables, dictionary changes, topic facts
	WriteExtendedFacts(FopenUTF8Write(build == BUILD0 ? "TOPIC/facts0.txt" : "TOPIC/facts1.txt"), FopenUTF8Write(build == BUILD0 ? "TOPIC/dict0.txt" : "TOPIC/dict1.txt"),  build); 
	
	// cleanup
	buildID = 0;
	numberOfTopics = 0;
	lastTopic = 0;
	tokenControl  = oldtokenControl;
	currentRuleOutputBase = currentOutputBase = NULL;
	FreeOutputBuffer();
	compiling = false;
	jumpIndex = 0;
	if (missingFiles) Log(STDUSERLOG,"%d topic files were missing.\r\n",missingFiles);
	
	if (hasErrors) 
	{
		EraseTopicFiles(build);
		DumpErrors();
		Log(STDUSERLOG,"r\n%d errors - press Enter to quit. Then fix and try again.\r\n",hasErrors);
		ReadALine(readBuffer,stdin);
		ReturnDictionaryToWordNet();
		return false;
	}
	else if (hasWarnings) 
	{
		unsigned int count = DumpWarnings();
		Log(STDUSERLOG,"%d spelling warnings and %d more serious warnings\r\n    ",count,hasWarnings-count);
	}
	else Log(STDUSERLOG,"No errors or warnings\r\n\r\n");
	ReturnDictionaryToWordNet();

	Log(STDUSERLOG,"\r\n\r\nFinished compile\r\n\r\n");

	return true;
}

char* CompileString(char* ptr) // incoming is:  ^"xxx"
{
	char tmp[MAX_WORD_SIZE * 2];
	strcpy(tmp,ptr); // protect copy from multiple readcalls
	size_t len = strlen(tmp);
	if (tmp[len-1] != '"') BADSCRIPT("STRING-1 String not terminated with doublequote %s",tmp)
	tmp[len-1] = 0;	// remove trailing quote

	// flip the FUNCTION marker inside the string
	static char data[MAX_WORD_SIZE * 2];	
	char* pack = data;
	*pack++ = '"';
	*pack++ = FUNCTIONSTRING;
	*pack++ = ':'; // a internal marker that is has in fact been compiled - otherwise it is a format string whose spaces count but cant fully execute

	if (tmp[2] == '(') ReadPattern(tmp+2,NULL,pack,false); // incoming is:  ^"(xxx"
	else ReadOutput(tmp+2,NULL,pack,NULL);

	TrimSpaces(data,false);
	len = strlen(data);
	data[len]  = '"';	// put back closing quote
	data[len+1] = 0;
	return data;
}
#endif
#include "common.h"

#define LETTERMAX 40

static unsigned char legalWordCharacter[256] =		// legal characters in English words
{
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,'\'',
	0,0,0,0,0,'-','.',0,'0','1',	'2','3','4','5','6','7','8','9',0,0,
	0,0,0,0,0,'A','B','C','D','E', 	'F','G','H','I','J','K','L','M','N','O',
	'P','Q','R','S','T','U','V','W','X','Y', 	'Z',0,0,0,0,'_',0,'A','B','C',			
	'D','E','F','G','H','I','J','K','L','M',
	'N','O','P','Q','R','S','T','U','V','W',	'X','Y','Z',0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,
};

static unsigned char letterIndexData[256] = 
{
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,37,38,0,27,28,	29,30,31,32,33,34,35,36,0,0,  //37=- 38 = .  
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0, 	0,0,0,0,0,39,0,1,2,3, // 39 is _
	4,5,6,7,8,9,10,11,12,13, 	14,15,16,17,18,19,20,21,22,23,
	24,25,26,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0
};

static MEANING lengthLists[100];		// lists of valid words by length

typedef struct SUFFIX
{
    char* word;
	uint64 flags;
} SUFFIX;

static SUFFIX stems[] = 
{
	{"less",NOUN},
	{"ness",ADJECTIVE|NOUN},
	{"est",ADJECTIVE},
	{"en",ADJECTIVE},
	{"er",ADJECTIVE},
	{"ly",ADJECTIVE},
	{0},
};

void InitSpellCheck()
{
	memset(lengthLists,0,sizeof(MEANING) * 100);
	WORDP D = dictionaryBase - 1;
	while (++D <= dictionaryFree)
	{
		if (!D->word || !IsAlpha(*D->word) || D->length >= 100 || D->internalBits & UTF8 || strchr(D->word,'_')) continue;
		if (D->properties & PART_OF_SPEECH || D->systemFlags & PATTERN_WORD)
		{
			D->spellNode = lengthLists[D->length];
			lengthLists[D->length] = MakeMeaning(D);
		}
	}
}

static int SplitWord(char* word)
{
	WORDP D2;
	bool good;
	int breakAt = 0;
	if (IsDigit(*word))
    {
		while (IsDigit(word[++breakAt]) || word[breakAt] == '.'){;} //   find end of number
        if (word[breakAt]) // found end of number
		{
			D2 = FindWord(word+breakAt,0,PRIMARY_CASE_ALLOWED);
			if (D2)
			{
				good = (D2->properties & (PART_OF_SPEECH|FOREIGN_WORD)) != 0 || (D2->internalBits & HAS_SUBSTITUTE) != 0; 
				if (good && (D2->systemFlags & AGE_LEARNED))// must be common words we find
				{
					char number[MAX_WORD_SIZE];
					strncpy(number,word,breakAt);
					number[breakAt] = 0;
					StoreWord(number,ADJECTIVE|NOUN|ADJECTIVE_NUMBER|NOUN_NUMBER); 
					return breakAt; // split here
				}
			}
		}
    }

	//  try all combinations of breaking the word into two known words
	breakAt = 0;
	size_t len = strlen(word);
    for (unsigned int k = 1; k < len-1; ++k)
    {
        if (k == 1 &&*word != 'a' &&*word != 'A' &&*word != 'i' &&*word != 'I') continue; //   only a and i are allowed single-letter words
		WORDP D1 = FindWord(word,k,PRIMARY_CASE_ALLOWED);
        if (!D1) continue;
		good = (D1->properties & (PART_OF_SPEECH|FOREIGN_WORD)) != 0 || (D1->internalBits & HAS_SUBSTITUTE) != 0; 
		if (!good || !(D1->systemFlags & AGE_LEARNED)) continue; // must be normal common words we find

        D2 = FindWord(word+k,len-k,PRIMARY_CASE_ALLOWED);
        if (!D2) continue;
        good = (D2->properties & (PART_OF_SPEECH|FOREIGN_WORD)) != 0 || (D2->internalBits & HAS_SUBSTITUTE) != 0;
		if (!good || !(D2->systemFlags & AGE_LEARNED) ) continue; // must be normal common words we find

        if (!breakAt) breakAt = k; // found a split
		else // found multiple places to split... dont know what to do
        {
           breakAt = -1; 
           break;
		}
    }
	return breakAt;
}

static char* SpellCheck(unsigned int i)
{
    //   on entry we will have passed over words which are KnownWord (including bases) or isInitialWord (all initials)
    //   wordstarts from 1 ... wordCount is the incoming sentence words (original). We are processing the ith word here.
    char* word = wordStarts[i];
	if (!*word) return NULL;
	if (!stricmp(word,loginID) || !stricmp(word,computerID)) return word; //   dont change his/our name ever

	size_t len = strlen(word);
	if (len > 2 && word[len-2] == '\'') return word;	// dont do anything with ' words

    //   test for run togetherness like "talkabout fingers"
    int breakAt = SplitWord(word);
    if (breakAt > 0)//   we found a split, insert 2nd word into word stream
    {
        ++wordCount;
		memmove(wordStarts+i+1,wordStarts+i,sizeof(char*) * (wordCount-i)); // open up a slot for a new word
        wordStarts[i+1] = wordStarts[i]+breakAt; // set this to the second word (shared from within 1st word)
        return FindWord(wordStarts[i],breakAt,PRIMARY_CASE_ALLOWED)->word; //   1st word gets replaced, we added valid word after
    }

	// now imagine partial runtogetherness, like "talkab out fingers"
	if (i < wordCount)
	{
		char tmp[MAX_WORD_SIZE];
		strcpy(tmp,word);
		strcat(tmp,wordStarts[i+1]);
		breakAt = SplitWord(tmp);
		if (breakAt > 0) // replace words with the dual pair
		{
			wordStarts[i+1] = StoreWord(tmp+breakAt)->word; // set this to the second word (shared from within 1st word)
			return FindWord(tmp,breakAt,PRIMARY_CASE_ALLOWED)->word; // 1st word gets replaced, we added valid word after
		}
	}

    //   remove any nondigit characters repeated more than once. Dont do this earlier, we want substitutions to have a chance at it first.  ammmmmmazing
	char word1[MAX_WORD_SIZE];
    char* ptr = word-1; 
	char* ptr1 = word1;
    while (*++ptr)
    {
	   *ptr1 = *ptr;
	   while (ptr[1] == *ptr1 && ptr[2] == *ptr1 && (*ptr1 < '0' || *ptr1 > '9')) ++ptr; // skip double repeats
	   ++ptr1;
    }
	*ptr1 = 0;
	if (FindCanonical(word1,0,true)) return AllocateString(word1); // this is a different form of a canonical word so its ok

	//   now use word spell checker 
    char* d = SpellFix(word,i,PART_OF_SPEECH); 
    return (d) ? AllocateString(d) : NULL;
}

bool SpellCheckSentence()
{
	bool fixedSpell = false;
	unsigned int start = 1;
	// dont spell check  out of band data
	if (*wordStarts[start] == '[')
	{
		while (++start <= wordCount && *wordStarts[start] != ']'); // find a close
		start =  (*wordStarts[start] != ']') ? 1 : (start + 1);
	}

	for (unsigned int i = start; i <= wordCount; ++i)
	{
		char* word = wordStarts[i];
		if (!word || !word[1] || *word == '"' ) continue; // illegal or single char or quoted thingy 

		// compute length
		size_t len = 0;
		// do we know the word as is?
		WORDP D = FindWord(word,0,PRIMARY_CASE_ALLOWED);
		if (D && D->systemFlags & PATTERN_WORD ) continue;
		if (D && (D->properties & (PART_OF_SPEECH|FOREIGN_WORD) || *D->word == '~')) continue;	// we know this word clearly or its a concept set ref emotion

		char* p = word -1;
		unsigned char c;
		char* hyphen = 0;
		char* under = 0;
		while ((c = *++p) != 0)
		{ 
			++len;
			if (!legalWordCharacter[c]) break; // not a character of an english word
			if (c == '-') hyphen = p; // note is hyphenated
			else if (c == '_') under = p; // note is underscored
		}
		if (len == 0 || under ||  GetTemperatureLetter(word)) continue;	// bad ignore utf word or llegal length - also no composite words
		if (c) // illegal word character
		{
			if (IsDigit(word[0]) || len == 1){;} // probable numeric?
			// accidental junk on end of word we do know immedately?
			else if (i > 1 && !IsAlphaOrDigit(wordStarts[i][len-1]))
			{
				WORDP entry,canonical;
				char word[MAX_WORD_SIZE];
				strcpy(word,wordStarts[i]);
				word[len-1] = 0;
				uint64 sysflags = 0;
				uint64 cansysflags = 0;
				GetPosData(0,word,entry,canonical,sysflags,cansysflags,true,true); // dont create a non-existent word
				if (entry && entry->properties & PART_OF_SPEECH)
				{
					wordStarts[i] = entry->word;
					fixedSpell = true;
				}
			}
			continue;	// not a legal word character, leave it alone
		}

		// see if we know the other case
		if (!(tokenControl & (ONLY_LOWERCASE|STRICT_CASING)) || i == startSentence)
		{
			WORDP E = FindWord(word,0,SECONDARY_CASE_ALLOWED);
			bool useAlternateCase = false;
			if (E && E->systemFlags & PATTERN_WORD) useAlternateCase = true;
			if (E && E->properties & (PART_OF_SPEECH|FOREIGN_WORD))
			{
				// if the word we find is UPPER case, and this might be a lower case noun plural, don't change case.
				size_t len = strlen(word);
				if (word[len-1] == 's' ) 
				{
					WORDP F = FindWord(word,len-1);
					if (!F || !(F->properties & (PART_OF_SPEECH|FOREIGN_WORD))) useAlternateCase = true;
					else continue;
				}
				else useAlternateCase = true;
			}
			if (useAlternateCase)
			{
				wordStarts[i] = E->word;
				fixedSpell = true;
				continue;	
			}
		}
		
		// merge with next token?
		char join[MAX_WORD_SIZE];
		if (i != wordCount && *wordStarts[i+1] != '"' )
		{
			strcpy(join,word);
			strcat(join,"_");
			strcat(join,wordStarts[i+1]);
			D = FindWord(join);
			if (D && D->properties & PART_OF_SPEECH && !(D->properties & AUX_VERB_BITS)) // merge these two, except "going to" or wordnet composites of normal words
			{
				WORDP P1 = FindWord(word,0,LOWERCASE_LOOKUP);
				WORDP P2 = FindWord(wordStarts[i+1],0,LOWERCASE_LOOKUP);
				if (!P1 || !P2 || !(P1->properties & PART_OF_SPEECH) || !(P2->properties & PART_OF_SPEECH)) 
				{
					memmove(wordStarts+i+1,wordStarts+i+2,sizeof(char*) * (wordCount - i - 1));
					wordStarts[i] = D->word;
					--wordCount;
					continue;
				}
			}
		}   

		// see if hypenated word should be separate or joined
		if (hyphen)
		{
			char test[MAX_WORD_SIZE];
			*hyphen = 0;

			// test for split
			strcpy(test,hyphen+1);
			WORDP E = FindWord(test,0,LOWERCASE_LOOKUP);
			WORDP D = FindWord(word,0,LOWERCASE_LOOKUP);
			if (*word == 0) wordStarts[i] = wordStarts[i] + 1; // -pieces  want to lose the leading hypen  (2-pieces)
			else if (D && E) //   1st word gets replaced, we added another word after
			{
				if ((wordCount +1 ) >= MAX_SENTENCE_LENGTH) continue;	// no room
				++wordCount;
				for (unsigned int k = wordCount; k > i; --k) wordStarts[k] = wordStarts[k-1]; // make room for new word
				wordStarts[i] = D->word;
				wordStarts[i+1] = E->word;
				++i;
			}
			else // remove hyphen entirely?
			{
				strcpy(test,word);
				strcat(test,hyphen+1);
				D = FindWord(test);
				if (D) wordStarts[i] = D->word;
				*hyphen = '-';
			}
			fixedSpell = true;
			continue; // ignore hypenated errors that we couldnt solve, because no one mistypes a hypen
		}

		if (*word != '\'' && !FindCanonical(word, i,true)) // dont check quoted or findable words
		{
			word = SpellCheck(i);

			// dont spell check proper names to improper, if word before or after is lower case
			if (word && i != 1 && IsUpperCase(*wordStarts[i]) && !IsUpperCase(*word))
			{
				if (!IsUpperCase(*wordStarts[i-1])) return false;
				else if (i != wordCount && !IsUpperCase(*wordStarts[i+1])) return false;
			}

			if (word && !*word) // performed substitution on prior word, restart this one
			{
				fixedSpell = true;
				--i;
				continue;
			}
			if (word) 
			{
				wordStarts[i] = word;
				fixedSpell = true;
				continue;
			}
		}
    }
	return fixedSpell;
}

unsigned int EditDistance(char* dictword, unsigned int size, unsigned int inputLen, char* inputSet, unsigned int min,unsigned char realWordLetterCounts[LETTERMAX])
{//   dictword has no underscores, inputSet is already lower case
    char dictw[MAX_WORD_SIZE];
    MakeLowerCopy(dictw,dictword);
    char* dictinfo = dictw;
    char* dictstart = dictinfo;
    unsigned int val = 0; //   a difference in length will manifest as a difference in letter count
    //   how many changes  (change a letter, transpose adj letters, insert letter, drop letter)
    if (size != inputLen) 
	{
		val += (size < inputLen) ? 5 : 2;	// real word is shorter than what they typed, not so likely as longer
		if (size < 7) val += 3;	
	}
    //   first and last letter errors are rare, more likely to get them right
    if (*dictinfo != *inputSet) val += 6; // costs a lot  to change first letter, odds are he types that right 
    if (dictinfo[size-1] != inputSet[inputLen-1]) val += 6; // costs more to change last letter, odds are he types that right or sees its wrong
    if (val > min) return 60;	// fast abort
	
	// match off how many letter counts are correct between the two, need to be close enough to bother with
	unsigned char dictWordLetterSet[LETTERMAX];
	memset(dictWordLetterSet,0,LETTERMAX); 
	for (unsigned int  i = 0; i < size; ++i) ++dictWordLetterSet[letterIndexData[(unsigned char)dictinfo[i]]]; // computer number of each kind of letter
	unsigned int count = 0;
	for (unsigned int  i = 0; i < LETTERMAX; ++i) 
	{
		if (dictWordLetterSet[i] && dictWordLetterSet[i] == realWordLetterCounts[i]) ++count; 
	}
	unsigned int countVariation = size - ((size > 7) ? 3 : 2); // since size >= 2, this is always >= 0
	if (count < countVariation)  return 60;	// need most letters be in common
	if (count == size)  // same letters (though he may have excess) --  how many transposes
	{
		unsigned int bad = 0;
		for (unsigned int i = 0; i < size; ++i) if (dictinfo[i] != inputSet[i]) ++bad;
		if (bad <= 2) return val + 3; // 1 transpose
		else if (bad <= 4) return val + 9; // 2 transpose
		else return val + 38; // many transpose
    }
	
	// now look at specific letter errors
    char* dictend = dictinfo+size;
    char* inputend = inputSet+inputLen;
	count = 0;
    while (ALWAYS)
    {
		++count;
        if (*dictinfo == *inputSet) // match
        {
            if (inputSet == inputend && dictinfo == dictend) break;    // ended
            ++inputSet;
            ++dictinfo;
            continue;
        }
        if (inputSet == inputend || dictinfo == dictend) // one ending, other has to catch up by adding a letter
        {
            if (inputSet == inputend) ++dictinfo;
            else ++inputSet;
            val += 6;
            continue;
        }

        //   letter match failed

        //   try to resynch series and reduce cost of a transposition of adj letters  
        if (*dictinfo == inputSet[1] && dictinfo[1] == *inputSet) // transpose 
        {
			if (dictinfo[2] == inputSet[2]) // they match after, so transpose is pretty likely
			{
				val += 4;  
				if (dictinfo[2]) // not at end, skip the letter in synch for speed
				{
					++dictinfo;
					++inputSet;
				}
			}
			else val += 8;  // transposed maybe good, assume it is
   			dictinfo += 2;
			inputSet += 2;
		}
        else if (*dictinfo == inputSet[1]) // current dict letter matches matches his next input letter, so maybe his input inserted a char here and need to delete it 
        {
            char* prior = inputSet-1; // potential extraneous letter
            if (*prior == *inputSet) val += 5; // low cost for dropping an excess repeated letter - start of word is prepadded with 0 for prior char
            else if (*inputSet == '-') val += 3; //   very low cost for removing a hypen 
            else if (inputSet+1 == inputend && *inputSet == 's') val += 30;    // losing a trailing s is almost not acceptable
            else val += 9; //  high cost removing an extra letter, but not as much as having to change it
            ++inputSet;
		}
        else if (dictinfo[1] == *inputSet) // next dict leter matches current input letter, so maybe his input deleted a char here and needs to insert  it
        {
            char* prior = (dictinfo == dictstart) ? (char*)" " : (dictinfo-1);
            if (*dictinfo == *prior  && !IsVowel(*dictinfo )) val += 5; 
            else if (IsVowel(*dictinfo ))  val += 1; //  low cost for missing a vowel ( already charged for short input), might be a texting abbreviation
            else val += 9; // high cost for deleting a character, but not as much as changing it
            ++dictinfo;
       }
       else //   this has no valid neighbors.  alter it to be the correct, but charge for multiple occurences
       {
			if (count == 1 && *dictinfo != *inputSet) val += 30; //costs a lot to change the first letter, odds are he types that right or sees its wrong
			//  2 in a row are bad, check for a substituted vowel sound
			bool swap = false;
			unsigned int oldval = val;
			if (dictinfo[1] != inputSet[1])
			{
				if (*inputSet == 't' && !strncmp(dictinfo,"ght",3)) 
				{
                    dictinfo += 3;
                    inputSet += 1;
                    val += 5;  
				}
				else if (!strncmp(inputSet,"ci",2) && !strncmp(dictinfo,"cki",3)) 
				{
                    dictinfo += 3;
                    inputSet += 2;
                    val += 5;
				}
				else if (*(dictinfo-1) == 'a' && !strcmp(dictinfo,"ir") && !strcmp(inputSet,"re")) // prepair prepare as terminal sound
				{
                    dictinfo += 2;
                    inputSet += 2;
                    val += 3;
				}
				else if (!strncmp(inputSet,"ous",3) && !strncmp(dictinfo,"eous",4)) 
				{
                    dictinfo += 4;
                    inputSet += 3;
                    val += 5; 
               }
              else if (!strncmp(inputSet,"of",2) && !strncmp(dictinfo,"oph",3)) 
               {
                    dictinfo += 3;
                    inputSet += 2;
                    val += 5; 
               }
             else if (*dictinfo == 'x' && !strncmp(inputSet,"cks",3)) 
               {
                    dictinfo += 1;
                    inputSet += 3;
                    val += 5; 
               }
               else if (*inputSet == 'k' && !strncmp(dictinfo,"qu",2)) 
               {
                    dictinfo += 2;
                    inputSet += 1;
                    val += 5;  
               }
			   if (oldval != val){;} // swallowed a multiple letter sound change
               else if (!strncmp(dictinfo,"able",4) && !strncmp(inputSet,"ible",4)) swap = true;
               else if (!strncmp(dictinfo,"ible",4) && !strncmp(inputSet,"able",4)) swap = true;
               else if (*dictinfo == 'a' && dictinfo[1] == 'y'     && *inputSet == 'e' && inputSet[1] == 'i') swap = true;
               else if (*dictinfo == 'e' && dictinfo[1] == 'a'     && *inputSet == 'e' && inputSet[1] == 'e') swap = true;
               else if (*dictinfo == 'e' && dictinfo[1] == 'e'     && *inputSet == 'e' && inputSet[1] == 'a') swap = true;
               else if (*dictinfo == 'e' && dictinfo[1] == 'e'     && *inputSet == 'i' && inputSet[1] == 'e') swap = true;
               else if (*dictinfo == 'e' && dictinfo[1] == 'i'     && *inputSet == 'a' && inputSet[1] == 'y') swap = true;
               else if (*dictinfo == 'e' && dictinfo[1] == 'u'     && *inputSet == 'o' && inputSet[1] == 'o') swap = true;
               else if (*dictinfo == 'e' && dictinfo[1] == 'u'     && *inputSet == 'o' && inputSet[1] == 'u') swap = true;
               else if (*dictinfo == 'i' && dictinfo[1] == 'e'     && *inputSet == 'e' && inputSet[1] == 'e') swap = true;
               else if (*dictinfo == 'o' && dictinfo[1] == 'o'     && *inputSet == 'e' && inputSet[1] == 'u') swap = true;
               else if (*dictinfo == 'o' && dictinfo[1] == 'o'     && *inputSet == 'o' && inputSet[1] == 'u') swap = true;
               else if (*dictinfo == 'o' && dictinfo[1] == 'o'     && *inputSet == 'u' && inputSet[1] == 'i') swap = true;
               else if (*dictinfo == 'o' && dictinfo[1] == 'u'     && *inputSet == 'e' && inputSet[1] == 'u') swap = true;
               else if (*dictinfo == 'o' && dictinfo[1] == 'u'     && *inputSet == 'o' && inputSet[1] == 'o') swap = true;
               else if (*dictinfo == 'u' && dictinfo[1] == 'i'     && *inputSet == 'o' && inputSet[1] == 'o') swap = true;
               if (swap)
               {
                    dictinfo += 2;
                    inputSet += 2;
                    val += 5; 
               }
            } 

            // can we change a letter to another similar letter
            if (oldval == val) 
            {
				bool convert = false;
                if (*dictinfo == 'i' && *inputSet== 'y' && count > 1) convert = true;//   but not as first letter
                else if ((*dictinfo == 's' && *inputSet == 'z') || (*dictinfo == 'z' && *inputSet == 's')) convert = true;
                else if (*dictinfo == 'y' && *inputSet == 'i' && count > 1) convert = true; //   but not as first letter
                else if (*dictinfo == '/' && *inputSet == '-') convert = true;
                else if (inputSet+1 == inputend && *inputSet == 's') val += 30;    //   changing a trailing s is almost not acceptable
                if (convert) val += 5;	// low cost for exchange of similar letter, but dont do it often
                else val += 12;			// changing a letter is expensive, since it destroys the visual image
                ++dictinfo;
                ++inputSet;
            }
       } 
       if (val > min) return val; // too costly, ignore it
    }
    return val;
}

static char* StemSpell(char* word,unsigned int i)
{
    static char word1[MAX_WORD_SIZE];
    strcpy(word1,word);
    size_t len = strlen(word);

	char* ending = NULL;
    char* best = NULL;
    
	//   suffixes
	if (len < 5){;} // too small to have a suffix we care about (suffix == 2 at min)
    else if (!strnicmp(word+len-3,"ing",3))
    {
        word1[len-3] = 0;
        best = SpellFix(word1,0,VERB); 
        if (best && FindWord(best)) return GetPresentParticiple(best);
	}
    else if (!strnicmp(word+len-2,"ed",2))
    {
        word1[len-2] = 0;
        best = SpellFix(word1,0,VERB); 
        if (best)
        {
			char* past = GetPastTense(best);
			if (!past) return NULL;
			size_t len = strlen(past);
			if (past[len-1] == 'd') return past;
			ending = "ed";
        }
    }
	else
	{
		unsigned int i = 0;
		char* suffix;
		while ((suffix = stems[i].word))
		{
			uint64 kind = stems[i++].flags;
			size_t len = strlen(suffix);
			if (!strnicmp(word+len-len,suffix,len))
			{
				word1[len-len] = 0;
				best = SpellFix(word1,0,kind); 
				if (best) 
				{
					ending = suffix;
					break;
				}
			}
		}
	}
	if (!ending && word[len-1] == 's')
    {
        word1[len-1] = 0;
        best = SpellFix(word1,0,VERB|NOUN); 
        if (best)
        {
			WORDP F = FindWord(best);
			if (F && F->properties & NOUN) return GetPluralNoun(F);
			ending = "s";
        }
   }
   if (ending)
   {
		strcpy(word1,best);
		strcat(word1,ending);
		return word1;
   }
   return NULL;
}

char* SpellFix(char* originalWord,unsigned int start,uint64 posflags)
{
    size_t len = strlen(originalWord);
	if (len >= 100 || len == 0) return NULL;
	if (IsDigit(*originalWord)) return NULL; // number-based words and numbers must be treated elsewhere
	bool isUpper = IsUpperCase(*originalWord) && start > 1;

	char word[MAX_WORD_SIZE];
	MakeLowerCopy(word,originalWord);

	// mark positions of the letters and make lower case
    char base[257];
    memset(base,0,257);
    char* ptr = word - 1;
    char c;
    int position = 0;
    while ((c = *++ptr) && position < 255)
    {
        if (c == '_') return NULL;    // its a phrase, not a word
        base[position++ + 1] = toLowercaseData[(unsigned char) c];
   }

	//   Priority is to a word that looks like what the user typed, because the user probably would have noticed if it didnt and changed it. So add/delete  has priority over tranform
    WORDP choices[4000];
    WORDP bestGuess[4000];
    unsigned int index = 0;
    unsigned int bestGuessindex = 0;
    unsigned int min = 30;
	unsigned char realWordLetterCounts[LETTERMAX];
	memset(realWordLetterCounts,0,LETTERMAX); 
	for (unsigned int  i = 0; i < len; ++i)  ++realWordLetterCounts[(unsigned char)letterIndexData[(unsigned char)word[i]]]; // compute number of each kind of character
	
	uint64  pos = PART_OF_SPEECH;  // all pos allowed
    WORDP D;
    if (posflags == PART_OF_SPEECH && start < wordCount) // see if we can restrict word based on next word
    {
        D = FindWord(wordStarts[start+1],0,PRIMARY_CASE_ALLOWED);
        uint64 flags = (D) ? D->properties : (-1); //   if we dont know the word, it could be anything
        if (flags & PREPOSITION) pos &= -1 ^ (PREPOSITION|NOUN);   //   prep cannot be preceeded by noun or prep
        if (!(flags & (PREPOSITION|VERB|CONJUNCTION_BITS|ADVERB)) && flags & DETERMINER) pos &= -1 ^ (DETERMINER|ADJECTIVE|NOUN|ADJECTIVE_NUMBER|NOUN_NUMBER); //   determiner cannot be preceeded by noun determiner adjective
        if (!(flags & (PREPOSITION|VERB|CONJUNCTION_BITS|DETERMINER|ADVERB)) && flags & ADJECTIVE) pos &= -1 ^ (NOUN); 
        if (!(flags & (PREPOSITION|NOUN|CONJUNCTION_BITS|DETERMINER|ADVERB|ADJECTIVE)) && flags & VERB) pos &= -1 ^ (VERB); //   we know all helper verbs we might be
        if (D && *D->word == '\'' && D->word[1] == 's' ) pos &= NOUN;    //   we can only be a noun if possessive - contracted 's should already be removed by now
    }
    if (posflags == PART_OF_SPEECH && start > 1)
    {
        D = FindWord(wordStarts[start-1],0,PRIMARY_CASE_ALLOWED);
        uint64 flags = (D) ? D->properties : (-1); // if we dont know the word, it could be anything
        if (flags & DETERMINER) pos &= -1 ^ (VERB|CONJUNCTION_BITS|PREPOSITION|DETERMINER);  
    }
    posflags &= pos; //   if pos types are known and restricted and dont match

	static int range[] = {0,-1,1};
	for (unsigned int i = 0; i < 3; ++i)
	{
		MEANING offset = lengthLists[len + range[i]];
		while (offset)
		{
			D = Meaning2Word(offset);
			offset = D->spellNode;
			if (!(D->properties & posflags)) continue; // wrong kind of word
			if (isUpper && !(D->systemFlags & UPPERCASE_HASH)) continue;	// dont spell check to lower a word in upper
			unsigned int val = EditDistance(D->word, D->length, len, base+1,min,realWordLetterCounts);
			if (val <= min) // as good or better
			{
				if (val < min)
				{
					index = 0;
					min = val;
				}
				if (D->internalBits & BEEN_HERE) 
				{
					choices[index++] = D;
					if (index > 3998) break; 
					AddInternalFlag(D,BEEN_HERE);
				}
			}
		}
	}
	// try endings ing, s, etc
	if (start) // no stem spell if COMING from a stem spell attempt (start == 0)
	{
		char* stem = StemSpell(word,start);
		if (stem) 
		{
			WORDP D = FindWord(stem);
			if (D) 
			{
				for (unsigned int j = 0; j < index; ++j) 
				{
					if (choices[j] == D) // already in our list
					{
						D = NULL; 
						break;
					}
				}
			}
			if (D) choices[index++] = D;
		}
	}

    if (!index) return NULL; // no whole found

	// take our guesses, and pick the most common (earliest learned) word
    uint64 agemin = 0;
    bestGuess[0] = NULL;
	for (unsigned int j = 0; j < index; ++j) RemoveInternalFlag(choices[j],BEEN_HERE);
    if (index == 1) return choices[0]->word;	// pick the one
    for (unsigned int j = 0; j < index; ++j) 
    {
        uint64 val = choices[j]->systemFlags & AGE_LEARNED;
        if (val < agemin) continue;
		if (choices[j]->internalBits & UPPERCASE_HASH && index > 1) continue;	// ignore proper names for spell better when some other choice exists
        if (val > agemin)
        {
            agemin = val;
            bestGuessindex = 0;
        }
        bestGuess[bestGuessindex++] = choices[j];
    }
   if (bestGuessindex == 0 && index == 2) return choices[0]->word;	// pick one, what do we have to lose
   return (bestGuessindex == 1) ? bestGuess[0]->word : NULL; //   dont accept multiple choices at same grade level
}

#include "common.h"

typedef char* (*SYSTEMVARPTR)(char* value); //   value is strictly overrride for testing

typedef struct SYSTEMVARIABLE
{
    const char* name;			// script name
    SYSTEMVARPTR address;		// function used to access it
	const char* comment;		// description
} SYSTEMVARIABLE;

extern SYSTEMVARIABLE sysvars[];

static char systemValue[MAX_WORD_SIZE]; // common answer place

////////////////////////////////////////////////////
/// OVERVIEW CODE 
////////////////////////////////////////////////////

void DefineSystemVariables()
{
	unsigned int i = 0;
	while (sysvars[++i].name)
	{
		if (sysvars[i].name[0] == '%') // not a header
		{
			StoreWord((char*) sysvars[i].name)->x.topicIndex = (unsigned short) i;
			(*sysvars[i].address)("."); // clear saved value
		}
	}
}

char* SystemVariable(char* word,char* value)
{
	WORDP D = FindWord(word);
	unsigned int index = (D) ? D->x.topicIndex : 0;
	if (!index) 
	{
		ReportBug("No system variable %s",word)
		return "";
	}
	return (*sysvars[index].address)(value);
}

void DumpSystemVariables()
{
	unsigned int i = 0;
	while (sysvars[++i].name)
	{
		char* result = (sysvars[i].address) ? (*sysvars[i].address)(NULL) : (char*)""; // actual variable or header
		if (!*result) 
		{
			if (strstr(sysvars[i].comment,"Boolean")) result = "null";
			else if (strstr(sysvars[i].comment,"Numeric")) result = "0";
			else result = "null";
		}
		if (sysvars[i].address) Log(STDUSERLOG,"%s = %s - %s\r\n",sysvars[i].name, result,sysvars[i].comment);  // actual variable
		else Log(STDUSERLOG,"%s\r\n",sysvars[i].name);  // header
	}
}

static char* AssignValue(char* hold, char* value)
{
	if (value[0] == value[1] && value[1] == '"') *value = 0;	// null string
	else if (!stricmp(value,"NULL") || !stricmp(value,"NIL")) *value = 0; 
	strcpy(hold,value);
	return hold;
}

////////////////////////////////////////////////////
/// TIME AND DATE 
////////////////////////////////////////////////////

static char* Sdate(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
 	char* x = GetTimeInfo() + 8;
    ReadCompiledWord(x,systemValue);
    if (regression) return "1";
    return (systemValue[0] != '0') ? systemValue : (systemValue+1); //   1 or 2 digit date
}

static char* SdayOfWeek(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    if (regression) return "Monday";
    ReadCompiledWord(GetTimeInfo(),systemValue);
    switch(systemValue[1])
    {
        case 'o': return "Monday";
        case 'u': return (char*)((systemValue[0] == 'T') ? "Tuesday" : "Sunday");
        case 'e': return "Wednesday";
        case 'h': return "Thursday";
        case 'r': return "Friday";
        case 'a': return "Saturday";
    }
	return "";
}

static char* SdayNumberOfWeek(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	ReadCompiledWord(GetTimeInfo(),systemValue);
	int n;
    switch(systemValue[1])
    {
		case 'u': n = (systemValue[0] != 'T') ? 1 : 3; break;
		case 'o': n = 2; break;
		case 'e': n = 4; break;
		case 'h': n = 5; break;
		case 'r': n = 6; break;
		case 'a': n = 7; break;
		default: n = 0; break;
	}
	systemValue[0] = (char)(n + '0');
	systemValue[1] = 0;
	return systemValue;
}

static char* SFullTime(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	uint64 curr = (uint64) time(0);
    if (regression) curr = 44444444; 
#ifdef WIN32
   sprintf(systemValue,"%I64d",curr); 
#else
   sprintf(systemValue,"%lld",curr); 
#endif
    return systemValue;
}

static char* Shour(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	strncpy(systemValue,GetTimeInfo()+11,2);
	systemValue[2] = 0;
    return  systemValue;
}

static char* SleapYear(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	time_t rawtime;
	time (&rawtime );
	struct tm* timeinfo = localtime (&rawtime );
    int year = timeinfo->tm_year;
    bool leapYear = !(year % 400) || (!(year % 4) && (year % 100));
    return leapYear ? (char*)"1" : (char*)"";
}  

static char* Sminute(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	ReadCompiledWord(GetTimeInfo()+14,systemValue);
	systemValue[2] = 0;
	return systemValue;
}

static char* Smonth(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	if (regression) return "6";
    ReadCompiledWord(GetTimeInfo()+SKIPWEEKDAY,systemValue);
	switch(systemValue[0])
	{
		case 'J':  //   january june july 
			if (systemValue[1] == 'a') return "1";
			else if (systemValue[2] == 'n') return "6";
			else if (systemValue[2] == 'l') return "7";
		case 'F': return "2";
		case 'M': return (systemValue[2] != 'y') ? (char*)"3" : (char*)"5"; 
  		case 'A': return (systemValue[1] == 'p') ? (char*)"4" : (char*)"8";
		case 'S': return "9";
		case 'O': return "10";
        case 'N': return "11";
        case 'D': return "12";
	}
	return "";
}

static char* SmonthName(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	if (regression) return "June";
    ReadCompiledWord(GetTimeInfo()+SKIPWEEKDAY,systemValue);
	switch(systemValue[0])
	{
		case 'J':  //   january june july 
			if (systemValue[1] == 'a') return "January";
			else if (systemValue[2] == 'n') return "June";
			else if (systemValue[2] == 'l') return "July";
		case 'F': return "February";
		case 'M': return (systemValue[2] != 'y') ? (char*)"March" : (char*)"May"; 
  		case 'A': return (systemValue[1] == 'p') ? (char*)"April" : (char*)"August";
		case 'S': return "September";
		case 'O': return "October";
        case 'N': return "November";
        case 'D': return "December";
	}
	return "";
}

static char* Ssecond(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    ReadCompiledWord(GetTimeInfo()+17,systemValue);
    systemValue[2] = 0;
    return systemValue;
}

static char* Svolleytime(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	clock_t diff = ElapsedMilliseconds() - startTimeInfo;
    sprintf(systemValue,"%u",(unsigned int)diff);
    return systemValue;
}

static char* Stime(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    strncpy(systemValue,GetTimeInfo()+11,5);
    systemValue[5] = 0;
    return systemValue;
}

static char* SweekOfMonth(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    if (regression) return "1";
	unsigned int n;
	char* x = GetTimeInfo() + 8;
	if (*x == ' ') ++x; // Mac uses space, pc uses 0 for 1 digit numbers 
    ReadInt(x,n);
	systemValue[0] = (char)('0' + (n/7) + 1);
	systemValue[1] = 0;
    return systemValue;
}

static char* Syear(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    ReadCompiledWord(GetTimeInfo()+20,systemValue);
    return (regression) ? (char*)"1951" : systemValue;
}

static char* Srand(char* value) // 1 .. 100
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	sprintf(systemValue,"%d",random(100)+1);
	return systemValue;
}

////////////////////////////////////////////////////
/// SYSTEM 
////////////////////////////////////////////////////

static char* Sall(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	return (all != 0) ? (char*)"1" : (char*)"";
}

static char* Sfact(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	sprintf(systemValue,"%d",Fact2Index(factFree));
    return systemValue;
}

static char* Sregression(char* value)
{
	static char hold[50];
	if (value) 
	{
		if (*value != '.') regression = *value != '0';
		return strcpy(hold,value);
	}
	if (*hold != '.') return hold;
	return (regression != 0) ? (char*)"1" : (char*)"";
}

static char* Sdocument(char* value)
{
	static char hold[50];
	if (value) return strcpy(hold,value); // may not legall set on one's own
	if (*hold != '.') return hold;
	return (documentMode != 0) ? (char*)"1" : (char*)"";
}
static char* Srule(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	if (currentTopicID == 0 || currentRuleID == -1) return "";
	sprintf(systemValue,"%s.%d.%d",GetTopicName(currentTopicID),TOPLEVELID(currentRuleID),REJOINDERID(currentRuleID));
    return systemValue;
}

static char* Sserver(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	if (!server) return "";

	sprintf(systemValue,"%d",port);
	return systemValue;
}

static char* Stopic(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	GetActiveTopicName(systemValue);
    return systemValue;
}

static char* STrace(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	if (!trace) return "0";
	sprintf(systemValue,"%d",trace);
	return systemValue;
}

////////////////////////////////////////////////////
/// USER INPUT
////////////////////////////////////////////////////

static char* Sforeign(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	return tokenFlags & FOREIGN_TOKENS ?  (char*)"1" : (char*)"";
}

static char* Sinput(char* value)
{
	static char hold[50];
	if (value)
	{  
		if (value[0] != '.') inputCount = atoi(value); // actually changes it
		else strcpy(hold,value);
	}
	if (*hold != '.') return hold;
	sprintf(systemValue,"%d",inputCount); 
	return systemValue;
}

static char* Slength(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
 	sprintf(systemValue,"%d",wordCount); 
	return systemValue;
}

static char* Smore(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    return moreToCome ? (char*)"1" : (char*)"";
}  

static char* SmoreQuestion(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    return moreToComeQuestion ? (char*)"1" : (char*)"";
}   

static char* Sparsed(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    return tokenFlags & FAULTY_PARSE ? (char*)"" : (char*)"1";
}  

static char* Ssentence(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    return tokenFlags & NOT_SENTENCE ? (char*)"" : (char*)"1";
}  

static char* Squestion(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    return tokenFlags & QUESTIONMARK ? (char*)"1" : (char*)"";
}  

static char* Scommand(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    return tokenFlags & COMMANDMARK ? (char*)"1" : (char*)"";
}  

static char* Squotation(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    return tokenFlags & QUOTATION ? (char*)"1" : (char*)"";
}  

static char* Simpliedyou(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
    return tokenFlags & IMPLIED_YOU ? (char*)"1" : (char*)"";
}  

static char* Stense(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	if (tokenFlags & PAST) return "past";
	else if (tokenFlags & FUTURE) return "future";
	else return "present";
}

static char* StokenFlags(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	sprintf(systemValue,"%lld",tokenFlags); 
	return systemValue;
}

static char* SuserFirstLine(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	sprintf(systemValue,"%d",userFirstLine); 
	return systemValue;
}

static char* SuserInput(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	return tokenFlags & USERINPUT ? (char*)"1" : (char*)"";
}   

static char* Svoice(char* value) 
{
	static char hold[50];
	if (value)  return AssignValue(hold,value);
	if (*hold != '.') return hold;
	return (tokenFlags & PASSIVE) ? (char*)"passive" : (char*)"active";
}

////////////////////////////////////////////////////
/// OUTPUT VARIABLES
////////////////////////////////////////////////////

static char* SinputRejoinder(char* value)
{ 
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	if (inputRejoinderTopic == NO_REJOINDER) return (char*)"";
	sprintf(systemValue,"%s.%d.%d",GetTopicName(inputRejoinderTopic),TOPLEVELID(inputRejoinderRuleID),REJOINDERID(inputRejoinderRuleID)); 
	return systemValue;
}

static char* SlastOutput(char* value) 
{
	static char hold[500];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	return (responseIndex) ? responseData[responseOrder[responseIndex-1]].response : (char*)"";
}

static char* SlastQuestion(char* value) 
{
	static char hold[50];
 	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	if (!responseIndex) return "";
	char* sentence = responseData[responseOrder[responseIndex-1]].response;
	size_t len = strlen(sentence);
	return (sentence[len-1] == '?') ? (char*)"1" : (char*)"";
}

static char* SoutputRejoinder(char* value)
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	if (outputRejoinderTopic == NO_REJOINDER) return (char*)"";
	sprintf(systemValue,"%s.%d.%d",GetTopicName(outputRejoinderTopic),TOPLEVELID(outputRejoinderRuleID),REJOINDERID(outputRejoinderRuleID)); 
	return systemValue;
}

static char* Sresponse(char* value) 
{
	static char hold[50];
	if (value) return AssignValue(hold,value);
	if (*hold != '.') return hold;
	sprintf(systemValue,"%d",responseIndex);
	return systemValue;
}   

SYSTEMVARIABLE sysvars[] =
{ 
	{"",0,""},

	{"\r\n---- Time, Date, Number variables",0,""},
	{"%date",Sdate,"Numeric day of the month"}, 
	{"%day",SdayOfWeek,"Named day of the week"}, 
	{"%daynumber",SdayNumberOfWeek,"Numeric day of week (0=sunday)"},  
	{"%fulltime",SFullTime,"Numeric full time/date in seconds"}, 
	{"%hour",Shour,"Numeric 2-digit current hour of day (00..23)"}, 
	{"%leapyear",SleapYear,"Boolean - is it a leap year"}, 
	{"%minute",Sminute,"Numeric 2-digit current minute"}, 
	{"%month",Smonth,"Numeric month number (1..12)"},
	{"%monthname",SmonthName,"Name of month"}, 
	{"%rand",Srand,"Numeric random number (1..100)"}, 
	{"%second",Ssecond,"Numeric 2-digit current second"}, 
	{"%time",Stime,"Current military time (e.g., 21:07)"}, 
	{"%week",SweekOfMonth,"Numeric week of month (1..5)"}, 
	{"%volleytime",Svolleytime,"Numeric milliseconds since volley start"}, 
	{"%year",Syear,"Numeric current 4-digit year"},
	
	{"\r\n---- System variables",0,""},
	{"%all",Sall,"Boolean - is all flag on"}, 
	{"%document",Sdocument,"Boolean - is :document flag on"}, 
	{"%fact",Sfact,"Most recent fact id"}, 
	{"%regression",Sregression,"Boolean - is regression flag on"}, 
	{"%rule",Srule,"Get a tag to current executing rule or null"}, 
	{"%server",Sserver,"Port id of server or null if not server"}, 
	{"%topic",Stopic,"Current interesting topic executing (not system or nostay)"}, 
	{"%trace",STrace,"Numeric value of trace flag"}, 

	{"\r\n---- Input variables",0,""},
	{"%command",Scommand,"Boolean - is the current input a command"},
	{"%foreign",Sforeign,"Boolean - is the bulk of current input foreign words"},
	{"%impliedyou",Simpliedyou,"Boolean - is the current input have you as an implied subject"},
	{"%input",Sinput,"Numeric volley id of the current input"}, 
	{"%length",Slength,"Numeric count of words of current input"}, 
	{"%more",Smore,"Boolean - is there more input pending"}, 
	{"%morequestion",SmoreQuestion,"Boolean - is there a ? in pending input"}, 
	{"%parsed",Sparsed,"Boolean - was current input successfully parsed"}, 
	{"%question",Squestion,"Boolean - is the current input a question"},
	{"%quotation",Squotation,"Boolean - is the current input a quotation"},
	{"%sentence",Ssentence,"Boolean - does it seem like a sentence - has subject and verb or is command"}, 
	{"%tense",Stense,"Tense of current input (present, past, future)"}, 
	{"%tokenflags",StokenFlags,"Numeric value of all tokenflags"}, 
	{"%userfirstline",SuserFirstLine,"Numeric volley count at start of session"}, 
	{"%userinput",SuserInput,"Boolean - is input coming from user"}, 
	{"%voice",Svoice,"Voice of current input (active,passive)"}, 

	{"\r\n---- Output variables",0,""},
	{"%inputrejoinder",SinputRejoinder,"if pending input rejoinder, this is the tag of it else null"},
	{"%lastoutput",SlastOutput,"Last line of currently generated output or null"},
	{"%lastquestion",SlastQuestion,"Boolean - did last output end in a ?"}, 
	{"%outputrejoinder",SoutputRejoinder,"tag of current output rejoinder or null"}, 
	{"%response",Sresponse,"Numeric count of responses generated for current volley"}, 
	
	{NULL,NULL,""},
};
 // tagger.cpp - used for pos tagging

#include "common.h"

unsigned int lowercaseWords;
unsigned int knownWords;
unsigned int tagRuleCount = 0;
uint64* tags = NULL;
char** comments = NULL;
static char* Describe(unsigned int i,char* buffer);

char* wordCanonical[MAX_SENTENCE_LENGTH]; //   current sentence tokenization
WORDP originalLower[MAX_SENTENCE_LENGTH];
WORDP originalUpper[MAX_SENTENCE_LENGTH];
WORDP canonicalLower[MAX_SENTENCE_LENGTH];
WORDP canonicalUpper[MAX_SENTENCE_LENGTH];
uint64 finalPosValues[MAX_SENTENCE_LENGTH];
uint64 allOriginalWordBits[MAX_SENTENCE_LENGTH];	// starting pos tags in this word position
uint64 lcSysFlags[MAX_SENTENCE_LENGTH];      // current system tags lowercase in this word position (there are no interesting uppercase flags)
uint64 posValues[MAX_SENTENCE_LENGTH];			// current pos tags in this word position
uint64 canSysFlags[MAX_SENTENCE_LENGTH];		// canonical sys flags lowercase in this word position 

static unsigned char describeVerbal[100];
static unsigned char describePhrase[100];
static unsigned char describeClause[100];
static unsigned  int describedVerbals;
static unsigned  int describedPhrases;
static unsigned  int describedClauses;
unsigned int parseFlags[MAX_SENTENCE_LENGTH];

// dynamic cumulative data across assignroles calls
unsigned int phrases[MAX_SENTENCE_LENGTH];
unsigned int clauses[MAX_SENTENCE_LENGTH];
unsigned int verbals[MAX_SENTENCE_LENGTH];
unsigned char ignoreWord[MAX_SENTENCE_LENGTH];
unsigned char coordinates[MAX_SENTENCE_LENGTH]; // for conjunctions
unsigned char crossReference[MAX_SENTENCE_LENGTH]; // object back to spawner,  particle back to verb
uint64 roles[MAX_SENTENCE_LENGTH];
unsigned char tried[MAX_SENTENCE_LENGTH];

unsigned char objectRef[MAX_SENTENCE_LENGTH + 1];  // link from verb to any main object ( allow use of 0 and end for holding)
unsigned char indirectObjectRef[MAX_SENTENCE_LENGTH];  // link from verb to any indirect object
unsigned char complementRef[MAX_SENTENCE_LENGTH + 1];  // link from verb to any 2ndary complement
// also posValues

int itAssigned = 0;
int theyAssigned = 0;

void SetParserMarks(WORDP D,bool enable)// used for setting up parseFlags
{
	// set up special marks on the sets named in speical english attributes. Their direct members inherit their flag bit
	unsigned int bit = 1;
	FACT* F = GetObjectHead(D);
	while (F)
	{
		WORDP A = Meaning2Word(F->subject); // most recent first
		if (enable)
		{
			A->inferMark = bit;
			A->properties |= AS_IS;
		}
		else
		{
			A->inferMark = 0;
			A->properties &= -1 ^ AS_IS;
		}
		F = GetObjectNext(F);
		bit <<= 1;
	}
}

char* GetNounPhrase(int i,const char* avoid)
{
	static char buffer[MAX_WORD_SIZE];
	*buffer = 0;
#ifndef DISCARDPARSER
	if (clauses[i-1] != clauses[i]) // noun is a clause
	{
		unsigned int clause = clauses[i];
		unsigned int at = i-1;
		while (clauses[++at] & clause)
		{
			char* word = wordStarts[at];							
			if (tokenFlags & USERINPUT) strcat(buffer,word);		
			else if (!stricmp(word,"my")) strcat(buffer,"your");	
			else if (!stricmp(word,"your")) strcat(buffer,"my");	
			else strcat(buffer,word);
			strcat(buffer," ");
		}
		size_t len = strlen(buffer);
		buffer[len-1] = 0;
		return buffer;
	}

	if (posValues[i+1] & (NOUN_INFINITIVE|NOUN_GERUND)) // noun is a verbal 
	{
		unsigned int verbal = verbals[i];
		unsigned int at = i-1;
		while (verbals[++at] & verbal)
		{
			char* word = wordStarts[at];							
			if (tokenFlags & USERINPUT) strcat(buffer,word);		
			else if (!stricmp(word,"my")) strcat(buffer,"your");	
			else if (!stricmp(word,"your")) strcat(buffer,"my");	
			else strcat(buffer,word);
			strcat(buffer," ");
		}
		size_t len = strlen(buffer);
		buffer[len-1] = 0;
		return buffer;
	}

	if (clauses[i-1] != clauses[i]) return wordStarts[i]; // cannot cross clause boundary
	if (verbals[i-1] != verbals[i]) return wordStarts[i]; // cannot cross verbal boundary
	if (phrases[i-1] != phrases[i]) return wordStarts[i]; // cannot cross phrase boundary

	int start = (int) i; // on the noun
	// NOTE posvalues still has adjectivenoun as adjective.  Finalposvalues has it as a noun.
	while (--start > 0 && posValues[start] & (NOUN_BITS | COMMA | CONJUNCTION_COORDINATE | ADJECTIVE_BITS | DETERMINER | PREDETERMINER | ADVERB_BITS | POSSESSIVE | PRONOUN_POSSESSIVE)) 
	{
		if (roles[start] & (MAININDIRECTOBJECT|INDIRECTOBJECT2)) break; // cannot switch to this
		if (posValues[start] & TO_INFINITIVE) break;
		if (posValues[start] & COMMA && !(posValues[start-1] & ADJECTIVE_BITS)) break; // NOT like:  the big, red, tall human
		if (posValues[start] & CONJUNCTION_COORDINATE)
		{
			if ( canonicalLower[start] && strcmp(canonicalLower[start]->word,"and")) break;	// not "and"
			if (!(posValues[start-1] & (ADJECTIVE_BITS|COMMA))) break;	// NOT like:  the big, red, and very tall human
			if (posValues[start-1] & COMMA && !(posValues[start-2] & ADJECTIVE_BITS)) break;	// NOT like:  the big, red, and very tall human
		}
		if (posValues[start] & NOUN_GERUND) break; 
		if (posValues[start] & ADVERB_BITS && !(posValues[start+1] & ADJECTIVE_BITS)) break;

		WORDP canon = canonicalLower[start];
		WORDP orig = originalLower[start];
		if (orig && (!strcmp("here",orig->word) || !strcmp("there",orig->word))) break;
		//if (orig && (!strcmp("this",orig->word) || !strcmp("that",orig->word) || !strcmp("these",orig->word) || !strcmp("those",orig->word))) break;
		if (canon && canon->properties & PRONOUN_BITS && !strcmp(canon->word,avoid)) break; // avoid recursive pronoun expansions... like "their teeth"
		if (posValues[start] & NOUN_PROPER_SINGULAR) break; // proper singular blocks appostive 
	}
	
	// start is NOT a member
	while (++start <= i)
	{
		char* word = wordStarts[start];							
		if (tokenFlags & USERINPUT) strcat(buffer,word);		
		else if (!stricmp(word,"my")) strcat(buffer,"your");	
		else if (!stricmp(word,"your")) strcat(buffer,"my");	
		else strcat(buffer,word);
		if (start != i) strcat(buffer," ");
	}
#endif
	return buffer;
}

static char* DescribeComponent(unsigned int i,char* buffer,char* open, char* close) // verbal or phrase or clause
{
	strcat(buffer,open);
	Describe(i,buffer);
	strcat(buffer,close);
	return buffer;
}

static char* Describe(unsigned int i,char* buffer)
{
	// before
	unsigned int currentPhrase = phrases[i] & (-1 ^ phrases[i-1]); // only the new bit
	if (!currentPhrase) currentPhrase = phrases[i];
	unsigned int currentVerbal = verbals[i] & (-1 ^ verbals[i-1]); // only the new bit
	if (!currentVerbal) currentVerbal = verbals[i];
	unsigned int currentClause = clauses[i] & (-1 ^ clauses[i-1]); // only the new bit
	if (!currentClause) currentClause = clauses[i];
	bool found = false;
	char word[MAX_WORD_SIZE];
	for (unsigned int j = 1; j < i; ++j) // find things before
	{
		if (ignoreWord[j]) continue;
		if (crossReference[j] == i && posValues[j] & IDIOM)
		{
			strcat(buffer,wordStarts[j]);
			strcat(buffer,"_");
		}
		else if (crossReference[j] == i && phrases[j] ^ currentPhrase)
		{
			if (!found) strcat(buffer," [");
			else  strcat(buffer," ");
			found = true;
			++describedPhrases;
			describePhrase[describedPhrases] = (unsigned char)j;
			sprintf(word,"p%d",describedPhrases);
			strcat(buffer,word);
			strcat(buffer," ");
		}
		else if (crossReference[j] == i && verbals[j] ^ currentVerbal)
		{
			if (!found) strcat(buffer," [");
			else  strcat(buffer," ");
			found = true;
			++describedVerbals;
			describeVerbal[describedVerbals] =  (unsigned char)j;
			sprintf(word,"v%d",describedVerbals);
			strcat(buffer,word);
			strcat(buffer," ");
		}
		else if (crossReference[j] == i && clauses[j] ^ currentClause)
		{
			if (!found) strcat(buffer," [");
			else  strcat(buffer," ");
			found = true;
			++describedClauses;
			describeClause[describedClauses] =  (unsigned char)j;
			sprintf(word,"c%d",describedClauses);
			strcat(buffer,word);
			strcat(buffer," ");
		}
		else if (crossReference[j] == i && !(roles[j] & (MAINSUBJECT|MAINOBJECT|MAININDIRECTOBJECT)))
		{
			if (roles[j] & OBJECT_COMPLEMENT && posValues[j] & NOUN_BITS && !phrases[j] && !clauses[j] && !verbals[j]) continue;
			if (!found) strcat(buffer," [");
			else  strcat(buffer," ");
			found = true;
			if (posValues[j] != TO_INFINITIVE) Describe(j,buffer);
			else strcat(buffer,"to");
		}
	}
	if (found) 
	{
		char* end = buffer + strlen(buffer) - 1;
		if (*end == ' ') *end = 0;
		strcat(buffer,"]");
	}
	found = false;
	if (!(posValues[i-1] & IDIOM)) strcat(buffer," ");

	// the word
	strcat(buffer,wordStarts[i]);
	if (*wordStarts[i] == '"') strcat(buffer,"...\""); // show omitted quotation

	// after
	for (unsigned int j = i+1; j <= wordCount; ++j) // find things after
	{
		if (ignoreWord[j]) continue;
		if (crossReference[j] == i && posValues[j] & PARTICLE)
		{
			strcat(buffer,"_");
			strcat(buffer,wordStarts[j]);
		}
		else if (crossReference[j] == i && phrases[j] ^ currentPhrase)
		{
			if (!found) strcat(buffer," [");
			else  strcat(buffer," ");
			found = true;
			++describedPhrases;
			describePhrase[describedPhrases] =  (unsigned char)j;
			sprintf(word,"p%d",describedPhrases);
			strcat(buffer,word);
			strcat(buffer," ");
		}
		else if (crossReference[j] == i && verbals[j] ^ currentVerbal)
		{
			if (!found) strcat(buffer," [");
			else  strcat(buffer," ");
			found = true;
			++describedVerbals;
			describeVerbal[describedVerbals] =  (unsigned char)j;
			sprintf(word,"v%d",describedVerbals);
			strcat(buffer,word);
			strcat(buffer," ");
		}
		else if (crossReference[j] == i && clauses[j] ^ currentClause)
		{
			if (!found) strcat(buffer," [");
			else  strcat(buffer," ");
			found = true;
			++describedClauses;
			describeClause[describedClauses] =  (unsigned char)j;
			sprintf(word,"c%d",describedClauses);
			strcat(buffer,word);
			strcat(buffer," ");
		}
		else if (currentPhrase && phrases[j] == currentPhrase && roles[j] & OBJECT2 && crossReference[j] == i)
		{
			strcat(buffer," ");
			Describe(j,buffer);
		}
		else if (posValues[i] & TO_INFINITIVE && posValues[j] & (NOUN_INFINITIVE|VERB_INFINITIVE))
		{
			strcat(buffer," ");
			Describe(j,buffer);
		}
		else if (crossReference[j] == i && !(roles[j] & (MAINSUBJECT|MAINOBJECT|MAININDIRECTOBJECT)))
		{
			if (roles[j] & OBJECT_COMPLEMENT && posValues[j] & NOUN_BITS && !phrases[j] && !clauses[j] && !verbals[j]) continue;
			if (!found && !(posValues[i] & PREPOSITION)) strcat(buffer," [");
			found = true;
			Describe(j,buffer);
			strcat(buffer," ");
		}
	}
	if (found) 
	{
		char* end = buffer + strlen(buffer) - 1;
		if (*end == ' ') *end = 0;
		strcat(buffer,"] ");
	}

	if (coordinates[i] > i) // conjoined
	{
		strcat(buffer," + " );
		Describe(coordinates[i],buffer);
	}

	return buffer;
}

void DescribeUnit(unsigned int i, char* buffer, char* msg,unsigned int verbal, unsigned int clause)
{
	char word[MAX_WORD_SIZE];
	if (i) // adjective object or causal infinitive
	{
		strcat(buffer,msg);
		if (verbals[i] != verbal)  
		{
			++describedVerbals;
			describeVerbal[describedVerbals] =  (unsigned char)i;
			sprintf(word,"v%d",describedVerbals);
			strcat(buffer,word);
		}
		else if (clauses[i] != clause)
		{
			++describedClauses;
			describeClause[describedClauses] =  (unsigned char)i;
			sprintf(word,"c%d",describedClauses);
			strcat(buffer,word);
		}
		else Describe(i,buffer);
		strcat(buffer," ");
	}
}

void DumpSentence(unsigned int start,unsigned int end)
{
#ifndef DISCARDPARSER
	unsigned int to = end;
	unsigned int subject = 0, verb = 0, indirectobject = 0, object = 0,complement = 0;
	unsigned int i;
	bool notFound = false;
	char word[MAX_WORD_SIZE];
	describedVerbals = 0;
	describedPhrases = 0;
	describedClauses = 0;

	for ( i = start; i <= to; ++i) // main sentence
	{
		if (ignoreWord[i] && *wordStarts[i] != '"') continue;
		if (roles[i] & MAINSUBJECT && !subject) subject = i;
		if (roles[i] & MAINVERB && !verb) verb = i;
		if (roles[i] & OBJECT_COMPLEMENT && posValues[i] & NOUN_BITS && !complement) complement = i;
		if (roles[i] & OBJECT_COMPLEMENT && posValues[i] & (ADJECTIVE_BITS|VERB_INFINITIVE|NOUN_INFINITIVE) && !complement) complement = i;
		if (roles[i] & SUBJECT_COMPLEMENT && !complement) complement = i;
		if (!stricmp(wordStarts[i],"not")) notFound = true;
		if (roles[i] & SENTENCE_END) 
		{
			to = i;
			break;
		}
		if ((roles[i] & CONJUNCT_KINDS) == CONJUNCT_SENTENCE)
		{
			to = i;
			break;
		}
	}
	char* buffer = AllocateBuffer();
	strcat(buffer,"  MainSentence: ");

	for (i = start; i <= to; ++i)
	{
		if (roles[i] & ADDRESS)
		{
			Describe(i,buffer);
			strcat(buffer," :  ");
		}
	}
	
	if (subject) DescribeUnit(subject,buffer, "Subj:",0,0);
	else if (tokenFlags& IMPLIED_YOU) 	strcat(buffer,"YOU   ");
	
	if (verb) 
	{
		object = objectRef[verb];
		indirectobject = indirectObjectRef[verb];
		strcat(buffer,"  Verb:");
		if (notFound) strcat(buffer,"(NOT!) ");
		Describe(verb,buffer);
		strcat(buffer,"   ");
	}

	if (indirectobject) 
	{
		strcat(buffer,"  IndObj:");
		Describe(indirectobject,buffer);
		strcat(buffer,"   ");
	}

	DescribeUnit(object,buffer, "  Obj:",0,0);
	DescribeUnit(complement,buffer, "Compl:",0,0);

	if (clauses[start]){;}
	else if (!stricmp(wordStarts[start],"when")) strcat(buffer,"(:when) ");
	else if (!stricmp(wordStarts[start],"where")) strcat(buffer,"(:where) ");
	else if (!stricmp(wordStarts[start],"why")) strcat(buffer,"(:why) ");
	else if (!stricmp(wordStarts[start],"who") && subject != 1 && object != 1) strcat(buffer,"(:who) ");
	else if (!stricmp(wordStarts[start],"what") && subject != 1 && object != 1) strcat(buffer,"(:what) ");
	else if (!stricmp(wordStarts[start],"how")) strcat(buffer,"(:how) ");

	if (tokenFlags & QUESTIONMARK)  strcat(buffer,"? ");

	if (tokenFlags & PAST) strcat(buffer," PAST ");
	else if (tokenFlags & FUTURE) strcat(buffer," FUTURE ");
	else if (tokenFlags & PRESENT) strcat(buffer," PRESENT ");

	if (tokenFlags & PERFECT) strcat(buffer,"PERFECT ");
	if (tokenFlags & CONTINUOUS) strcat(buffer,"CONTINUOUS ");

	if (tokenFlags & PASSIVE) strcat(buffer," PASSIVE ");
	strcat(buffer,"\n");
	for (unsigned int i = 1; i <= describedPhrases; ++i)
	{
		sprintf(word,"Phrase %d :",i);
		strcat(buffer,word);
		Describe(describePhrase[i],buffer);
		strcat(buffer,"\n");
	}
	for (unsigned int i = 1; i <= describedVerbals; ++i)
	{
		sprintf(word,"Verbal %d: ",i);
		strcat(buffer,word);
		unsigned int verbal = describeVerbal[i]; 
		unsigned int verbalid = verbals[verbal] & (-1 ^ verbals[verbal-1]);
		if (!verbalid) verbalid = verbals[verbal];
		for (unsigned int j = i; j <= endSentence; ++j)
		{
			if (!(verbals[j] & verbalid)) continue;
			if (roles[j] & VERB2) 
			{
				strcat(buffer,"  Verb:");
				Describe(j,buffer); // the verb
				if (indirectObjectRef[j]) 
				{
					strcat(buffer,"  Indirect: ");
					Describe(indirectObjectRef[j],buffer);
				}
				DescribeUnit(objectRef[j],buffer, "  Direct:",verbalid,0);
				DescribeUnit(complementRef[j],buffer, " Complement:",verbalid,0);
				break;
			}
		}
		strcat(buffer,"\n");
	}
	for (unsigned int i = 1; i <= describedClauses; ++i)
	{
		sprintf(word,"Clause %d %s : ",i,wordStarts[describeClause[i]]);
		strcat(buffer,word);
		unsigned int clause = describeClause[i];
		unsigned int clauseid = clauses[clause] & (-1 ^ clauses[clause-1]);
		if (!clauseid) clauseid = clauses[clause];
		for (unsigned int j = i; j <= endSentence; ++j)
		{
			if (!(clauses[j] & clauseid)) continue;
			if (roles[j] & SUBJECT2)  
			{
				strcat(buffer,"  Subj:");
				Describe(j,buffer); // the subject
				strcat(buffer,"  ");
			}
			if (roles[j] & VERB2)  
			{
				strcat(buffer,"  Verb:");
				Describe(j,buffer); // the verb
				if (indirectObjectRef[j]) 
				{
					strcat(buffer,"  Indirect: ");
					Describe(indirectObjectRef[j],buffer);
				}
				DescribeUnit(objectRef[j],buffer, "  Direct:",0,clauseid);
				DescribeUnit(complementRef[j],buffer, "  Complement:",0,clauseid);
			}
		}
		strcat(buffer,"\n");
	}

	for (unsigned int i = start; i <= to; ++i) // show phrases
	{
		if (ignoreWord[i]) continue;
		if (i >= to) continue; // ignore
		if (coordinates[i] && posValues[i] & CONJUNCTION_COORDINATE)
		{
			strcat(buffer,"\r\n Coordinate ");
			uint64 crole = roles[i] & CONJUNCT_KINDS;
			if (crole == CONJUNCT_NOUN) strcat(buffer,"Noun: ");
			else if (crole == CONJUNCT_VERB) strcat(buffer,"Verb: ");
			else if (crole == CONJUNCT_ADJECTIVE) strcat(buffer,"Adjective: ");
			else if (crole == CONJUNCT_ADVERB) strcat(buffer,"Adverb: ");
			else if (crole == CONJUNCT_PHRASE) strcat(buffer,"Phrase: ");
			else strcat(buffer,"Sentence: ");
			strcat(buffer,wordStarts[i]);
			strcat(buffer," (");
			if (coordinates[i] && coordinates[coordinates[i]])
			{
				strcat(buffer,wordStarts[coordinates[coordinates[i]]]); // the before
				strcat(buffer,"/");
				strcat(buffer,wordStarts[coordinates[i]]); // the after
			}
			strcat(buffer,") ");
		}
	}

	for (unsigned int i = start; i <= to; ++i) // show phrases
	{
		if (ignoreWord[i]) continue;
		if ( phrases[i] && phrases[i] != phrases[i-1] && (i != wordCount || phrases[wordCount] != phrases[1])) 
		{
			if (posValues[i] & (NOUN_BITS|PRONOUN_BITS)) strcat(buffer,"\r\n  Absolute Phrase: ");
			//else if (posValues[i] & (ADJECTIVE_BITS|ADVERB_BITS)) strcat(buffer,"\r\n  Time Phrase: ");
			else continue;
			if (i == 1 && phrases[wordCount] == phrases[1]) 
			{
				DescribeComponent(wordCount,buffer,"{","}"); // wrapped?
				strcat(buffer," ");
			}
			DescribeComponent(i,buffer,"{","}"); // wrapped?
			strcat(buffer," ");
		}

		if (roles[i] & TAGQUESTION) strcat(buffer," TAGQUESTION ");
	}

	Log(STDUSERLOG,"%s\r\n",buffer);

	FreeBuffer();
	if (to < end) DumpSentence(to+1,end); // show next piece
#endif
 }

char* GetRole(unsigned int i)
{
	static char answer[MAX_WORD_SIZE];
	*answer = 0;
#ifndef DISCARDPARSER
	uint64 role = roles[i];
	if (role & APPOSITIVE) strcat(answer, "APPOSITIVE ");
	if (role & ADVERBIAL) strcat(answer, "ADVERBIAL ");
	if (role & ADJECTIVAL) strcat(answer, "ADJECTIVAL ");  // if it is not specified as adverbial or adjectival, it is used as a noun  -- prep after a noun will be adjectival, otherwize adverbial
	// THey claim a preposition phrase to act as a noun  "During a church service is not a good time to discuss picnic plans" or "In the South Pacific is where I long to be" 
	// but inverted it's - a good time to discuss picnic plans is not during a church service. 

	if ((role & ADVERBIALTYPE) == WHENUNIT) strcat(answer, "WHENUNIT ");	
	if ((role & ADVERBIALTYPE)  == WHEREUNIT) strcat(answer, "WHEREUNIT ");
	if ((role & ADVERBIALTYPE)   == HOWUNIT) strcat(answer, "HOWUNIT "); // how and in what manner
	if ((role & ADVERBIALTYPE)   == WHYUNIT) strcat(answer, "WHYUNIT ");

	if (role & MAINSUBJECT) strcat(answer,"MAINSUBJECT ");
	if (role & NOUN_OMITTED_ADJECTIVE) strcat(answer,"ADJECTIVE_OMITTED_NOUN ");
	if (role & MAINVERB) strcat(answer, "MAINVERB ");
	if (role & MAINOBJECT) strcat(answer, "MAINOBJECT ");
	if (role & MAININDIRECTOBJECT) strcat(answer,  "MAININDIRECTOBJECT ");
	
	if (role & OBJECT2) strcat(answer,  "OBJECT2 ");
	if (role & SUBJECT2) strcat(answer,  "SUBJECT2 ");
	if (role & VERB2) strcat(answer,  "VERB2 ");
	if (role & INDIRECTOBJECT2) strcat(answer, "INDIRECTOBJECT2 ");
	if (role & OBJECT_COMPLEMENT) strcat(answer,   "OBJECT_COMPLEMENT ");
	if (role & SUBJECT_COMPLEMENT) strcat(answer,   "SUBJECT_COMPLEMENT ");
	
	unsigned int crole = role & CONJUNCT_KINDS;

	if (crole == CONJUNCT_NOUN) strcat(answer, "CONJUNCT_NOUN ");
	else if (crole == CONJUNCT_VERB) strcat(answer, "CONJUNCT_VERB ");
	else if (crole == CONJUNCT_ADJECTIVE) strcat(answer, "CONJUNCT_ADJECTIVE ");
	else if (crole == CONJUNCT_ADVERB) strcat(answer, "CONJUNCT_ADVERB ");
	else if (crole == CONJUNCT_PHRASE) strcat(answer, "CONJUNCT_PHRASE ");
	else if (crole== CONJUNCT_CLAUSE) strcat(answer, "CONJUNCT_CLAUSE ");
	else if (crole == CONJUNCT_SENTENCE) strcat(answer, "CONJUNCT_SENTENCE ");
	
	if (role & POSTNOMINAL_ADJECTIVE) strcat(answer, "POSTNOMINAL_ADJECTIVE ");
	if (role & ADJECTIVE_COMPLEMENT) strcat(answer, "ADJECTIVE_COMPLEMENT ");
	if (role & OMITTED_TIME_PREP) strcat(answer, "OMITTED_TIME_PREP ");
	if (role & ADDRESS) strcat(answer, "ADDRESS ");
	if (role & COMMA_PHRASE) strcat(answer, "COMMA_PHRASE ");
	if (role & TAGQUESTION) strcat(answer, "TAGQUESTION ");
	if (role & ABSOLUTE_PHRASE) strcat(answer, "ABSOLUTE_PHRASE ");
	
#endif
	return answer;
}
#include "common.h"

#ifndef DISCARDTESTING

static unsigned int lineLimit = 0; // in abstract report lines that are longer than this...
static WORDP topLevel = 0;
static unsigned int err = 0;
static unsigned int filesSeen; 
static 	char directory[MAX_WORD_SIZE];
static int itemcount = 0;
static char* abstractBuffer;

#define ABSTRACT_SPELL 1
#define ABSTRACT_SET_MEMBER 2
#define ABSTRACT_CANONICAL 4
#define ABSTRACT_PRETTY 8
#define ABSTRACT_VP 16
#define ABSTRACT_NOCODE 32
#define ABSTRACT_RESTRICTIONS (ABSTRACT_SPELL|ABSTRACT_SET_MEMBER|ABSTRACT_CANONICAL|ABSTRACT_PRETTY|ABSTRACT_VP )

#define RECORD_SIZE 4000

// prototypes
static bool DumpOne(WORDP S,int all,int depth,bool shown);
static int CountDown(MEANING T,int all,int depth,unsigned int baseStamp);
static void C_Retry(char* input);

static MEANING* meaningList; // list of meanings from :concepts
static MEANING* meaningLimit; // end of meaninglistp

////////////////////////////////////////////////////////
/// UTILITY ROUTINES
////////////////////////////////////////////////////////

int CountSet(WORDP D,unsigned int baseStamp) //   full recursive referencing
{
	if (!D) return 0;

	int count = 0;
	FACT* F = GetObjectHead(D);
	FACT* G;
	while (F) //   do all atomic members of it
	{
		G = F;
		F = GetObjectNext(F);
		WORDP S = Meaning2Word(G->subject);
		if (!(G->verb == Mmember)  || G->flags & FACTDEAD) continue;
		if (*S->word == '~' ) continue;
		else if (Meaning2Index(G->subject)) count += CountDown(GetMaster(G->subject),-1,0,baseStamp); //   word~2 reference is a synset header -- follow IS_A submembers
		else //   simple atomic member -- or POS specificiation
		{
			if (S->inferMark <= baseStamp) //   count once
			{
				S->inferMark = inferMark;
				++count;
			}
		}
	}
	F = GetObjectHead(D);
	while (F) //   do all set members of it
	{
		G = F;
		F = GetObjectNext(F);
		WORDP S = Meaning2Word(G->subject);
		if (!(G->verb == Mmember)  || G->flags & FACTDEAD) continue;
		if (*S->word == '~')  count += CountSet(S,baseStamp);
	}
	return count;
}

static int CountDown(MEANING T,int all,int depth,unsigned int baseStamp)
{ //  T is a synset header
	T &= -1 ^ SYNSET_MARKER;

	if (all == 5) return 0;
	int count = 0;

	//   show each word in synset
    WORDP D = Meaning2Word(T);
	WORDP baseWord = D;
	unsigned int index = Meaning2Index(T);
	unsigned int baseIndex = index;

	// walk the master list of synonyms at this level
	bool shown = false;
	while (ALWAYS) 
    {
		MEANING next = GetMeaning(D,index);
		if (D->inferMark != inferMark) 
		{
			if (D->inferMark <= baseStamp) ++count;
			D->inferMark = inferMark;	
			if (depth != -1) shown |= DumpOne(D,all,depth,shown); //   display it
		}
		D = Meaning2Word(next);
		index = Meaning2Index(next);
		if (D == baseWord && index == baseIndex) break; // back at start of loop
    }

	//   down go down to next level synset from this one
	FACT* F = GetObjectHead(T); 
	while (F)
	{
		if (F->verb ==  Mis && F->object == T) count += CountDown(F->subject,all,depth+1,baseStamp);
		F = GetObjectNext(F);
	}
	return count;
}

static void Indent(int count,bool nonumber)
{
	if (!nonumber) Log(STDUSERLOG,"%d.",count);
	while (count--) Log(STDUSERLOG,"    ");
}

static bool DumpOne(WORDP S,int all,int depth,bool shown)
{
	bool did = false;
	if (all) 
	{
			if ( all == 3) return false;
			if (itemcount == 0 && all != 2) Indent(depth,shown);
			unsigned char* data = GetWhereInSentence(S);
			if (all == 1) 
			{
				if (!data)
				{
					data = AllocateWhereInSentence(S);
					if (!data) return false;
					*data = 0;
					data[1] = 0;
				}
				if (++data[1] == 0) ++data[0];
			}
			if (all == 1 && *data && (data[0] || data[1] > 1)) Log(STDUSERLOG,"+%s  ",S->word); //   multiple occurences
			else  //   first occurence of word
			{
				if (all == 1 && !(S->systemFlags & VERB_DIRECTOBJECT)) //   generate a list of intransitive verbs
				{
					FILE* out = fopen("intransitive.txt","ab");
					fprintf(out,"%s 1\r\n",S->word);
					fclose(out);
				}
				if (all == 1 && (S->systemFlags & VERB_INDIRECTOBJECT)) //   generate a list of dual transitive verbs
				{
					FILE* out = fopen("intransitive.txt","ab");
					fprintf(out,"%s 2\r\n",S->word);
					fclose(out);
				}
				Log(STDUSERLOG,"%s  ",S->word);
			}
			++itemcount;
			if (itemcount == 10 && all != 2)
			{
				Log(STDUSERLOG,"\r\n");
				itemcount = 0;
			}
			did = true;
	}
	return did;
}

static void MarkExclude(WORDP D)
{
	FACT* F = GetObjectHead(D);
	while (F)
	{
		if (F->verb == Mexclude) Meaning2Word(F->subject)->inferMark = inferMark;
		F = GetObjectNext(F);
	}
}

/////////////////////////////////////////////
/// TESTING
/////////////////////////////////////////////

static void C_AutoReply(char* input)
{
	regression = 1;
	if  (*input == '1' || *input == 'O' || *input == 'o') oktest = OKTEST;
	else if  (*input == '2' || *input == 'W' || *input == 'w') oktest = WHYTEST;
	else 
	{
		regression =  false;
		oktest = 0;
	}
	if (oktest) Log(STDUSERLOG,"Auto input set to %s\r\n",(oktest == OKTEST) ? "ok" : "why");
}  

static void C_NoReact(char* input)
{
	noReact = !noReact;
	Log(STDUSERLOG,"Noreact = %d\r\n",noReact);
} 

static void C_POS(char* input)
{
	if (!*input) prepareMode = (prepareMode == POS_MODE) ? NO_MODE : POS_MODE;
	else 
	{
		unsigned int oldtrace = trace;
		uint64 oldTokenControl = tokenControl;

		char word[MAX_WORD_SIZE];
		char* at = ReadCompiledWord(input,word);
		if (!stricmp(word,"PENN"))
		{
			input = at;
			tokenControl = STRICT_CASING | DO_ESSENTIALS| DO_PARSE | DO_CONTRACTIONS| NO_HYPHEN_END | NO_COLON_END | NO_SEMICOLON_END | TOKEN_AS_IS;
		}
		else 
		{
			char* token = GetUserVariable("$token");
			int64 f;
			ReadInt64(token,f);
			tokenControl = f;
		}
		trace = (unsigned int) -1;
		prepareMode = POS_MODE;
		quotationInProgress = 0;	
		PrepareSentence(input,true,true);	
		prepareMode = NO_MODE;
		tokenControl = oldTokenControl;
		trace = oldtrace;
	}
}

static void C_Prepare(char* input)
{
	uint64 oldToken = tokenControl;
	if (!*input) prepareMode = (prepareMode == PREPARE_MODE) ? NO_MODE : PREPARE_MODE;
	else 
	{
		char prepassTopic[MAX_WORD_SIZE];
		strcpy(prepassTopic, GetUserVariable("$prepass"));
		unsigned int oldtrace = trace;
		nextInput = input;
		while (ALWAYS)
		{
			prepareMode = PREPARE_MODE;
			PrepareSentence(nextInput,true,true);	
			prepareMode = NO_MODE;
			if (!trace) trace = TRACE_BASIC | TRACE_MATCH;
			if (PrepassSentence(prepassTopic)) PrepareSentence(nextInput,true,true); // user input revise and resubmit?  -- COULD generate output and set rejoinders
			else if (!*nextInput) break;
		}
		trace = oldtrace;
	}
	tokenControl = oldToken;
}

static void C_Source(char* input)
{
	char word[MAX_WORD_SIZE];
	char* ptr = ReadCompiledWord(input,word);
	FILE* in = FopenReadNormal(word); // source
	if (in) sourceFile = in;
	else Log(STDUSERLOG,"No such source file: %s\r\n",word);
	SetUserVariable("$$document",word);
	ReadCompiledWord(ptr,word);
	echoSource = 0;
	if (!stricmp(word,"echo")) echoSource = SOURCE_ECHO_USER;
	else if (!stricmp(word,"internal"))  echoSource = SOURCE_ECHO_LOG;
} 

static void ReadNextDocument(char* name,uint64 value)
{
	FILE* in = FopenReadNormal(name); // source
	if (in) sourceFile = in;
	else 
	{
		Log(STDUSERLOG,"No such source file: %s\r\n",name);
		return;
	}
	documentLineCount = 0;
	docTime = ElapsedMilliseconds();
	tokenCount = 0;
	documentMode = true;
	SetUserVariable("$$document",name);
	echo = false;
	*outBuffer = 0;
	OnceCode("$control_pre"); // just once per document
	ProcessInputFile();
	postProcessing = AllocateBuffer();
	++outputNest; // this is not generating new output
	OnceCode("$control_post");
	--outputNest;
	postProcessing = 0;
	FreeBuffer();

	if (value & 1) // show doc stats
	{
		bool oldecho = echo;
		echo = true;
		unsigned int diff = (unsigned int) (ElapsedMilliseconds() - docTime);
		unsigned int mspl = diff/documentLineCount;
		unsigned int difftoken = (diff >= 1000) ? (tokenCount/(diff/1000)) : 0;
		Log(STDUSERLOG,"\r\n    Read %d lines (%d tokens) in %d ms = %d ms/l or %d token/second\r\n",documentLineCount,tokenCount, diff,mspl,difftoken);
		echo = oldecho;
	}
}

static void C_Document(char* input)
{
	FILE* pub = FopenUTF8Write("LOGS/pub.txt");
	fclose(pub);
	while (ALWAYS)
	{
		if (!strnicmp(input,"single",6))
		{
			input += 7;
			singleSource = true;
		}
		else if (!strnicmp(input,"echo",4))
		{
			input += 5;
			echoDocument = true;
		}
		else break;
	}
	char name[MAX_WORD_SIZE];
	char* ptr = ReadCompiledWord(input,name);

	// set echo characteristic and stats
	char word[MAX_WORD_SIZE];
	char summary[MAX_WORD_SIZE];
	*summary = 0;
	echoSource = 0;
	unsigned int stats = 0;
	while (ptr && *ptr)
	{
		ptr = ReadCompiledWord(ptr,word);
		if (!stricmp(word,"echo")) echoSource = SOURCE_ECHO_USER;
		else if (!stricmp(word,"internal"))  echoSource = SOURCE_ECHO_LOG;
		else if (!stricmp(word,"stats")) stats = 1;
		else if (*word == '~') strcpy(summary,word); // final postprocess
	}

	documentBuffer = AllocateBuffer() + 1; // hide a char before edge for backward testing
	*documentBuffer = 0;
	++baseBufferIndex; // system will reset  buffers each sentence to include ours

	size_t len = strlen(name);
	if (name[len-1] == '/') WalkDirectory(name,ReadNextDocument, stats);
	else ReadNextDocument(name,stats);

	echo = false;
	documentMode = false; // postprocessing on entire doc will now happen
	FinishVolley(" ",outBuffer,summary);
	documentBuffer = 0;
	FreeBuffer();
	--baseBufferIndex;
} 

static void DoAssigns(char* ptr)  // find variable assignments
{
	char var[MAX_WORD_SIZE];
	char* dollar;
	char* percent;
	char* underscore;
	char* at;
	char* first = 0;
	while (ptr) // do all user variables
	{
		at = NULL;
		char* spot = ptr;
		dollar = strchr(ptr,'$');  // find a potential variable
		percent = strchr(ptr,'%');
		underscore = strchr(ptr,'_');
		if (dollar) at = dollar;
		else if (percent) at = percent;
		else while ((underscore = strchr(spot,'_')))  // may not be real yet, might be like New_year's_eve 
		{
			if (IsDigit(underscore[1])) 
			{
				at = underscore;
				break;
			}
			else spot = underscore + 1;
		}
		if (!at) break;
		if (percent && percent < at) at = percent;
		if (underscore && underscore < at) at = underscore;
		
		// at is the soonest assignment
		char* eq = strchr(at,'='); // has an assignment
		if (!eq) break; // no assignment
		char c = *eq;
		*eq-- = 0; // break off lhs
		ReadCompiledWord(at,var);
		*eq = c;  // change  $current=1  into $curren= 1 moving operator and giving space after
		if (eq[2] == '=') 
		{
			eq[1] = eq[2];
			eq[2] = ' '; // 2 char operator
		}
		else eq[1] = ' '; // single char operator

		if (!first) first = at; // start of all
		unsigned int result;
		ptr = PerformAssignment(var,eq,result);
		if (ptr) memset(at,' ',ptr-at);
	}
	if (first) 
		*first = 0; // remove all assignments
}

static void C_TestPattern(char* input)
{ // pattern, input, optional var assigns  -  (drink)  Do you like drink? %date = 1
#ifndef DISCARDSCRIPTCOMPILER
	if (*input != '(') 
	{
		Log(STDUSERLOG,"Bad test pattern");
		return;
	}

	char data[MAX_WORD_SIZE];
	char* pack = data;
	strcpy(readBuffer,input);
	if (setjmp(scriptJump[++jumpIndex])) // return on script compiler error
	{
		--jumpIndex;
		return;
	}
	ReadNextSystemToken(NULL,NULL,data,false,false); // flush cache
	char* ptr = ReadPattern(readBuffer, NULL, pack,false); // swallows the pattern

	//   var assign?
	DoAssigns(ptr);
	if (!*ptr) return; //   forget example sentence
	char prepassTopic[MAX_WORD_SIZE];
	strcpy(prepassTopic,GetUserVariable("$prepass"));
	PrepareSentence(ptr,true,true);	
	// if (PrepassSentence(prepassTopic)) PrepareSentence(nextInput,true,true); // user input revise and resubmit?  -- COULD generate output and set rejoinders  dont fix the sentence
	
	unsigned int gap = 0;
	unsigned int wildcardSelector = 0;
	wildcardIndex = 0;
	unsigned int junk1;
	blocked = true;
	bool result =  Match(data+2,0,0,'(',true,gap,wildcardSelector,junk1,junk1);
	blocked = false;
	if (result) Log(STDUSERLOG," Matched\r\n");
	else Log(STDUSERLOG," Failed\r\n");
	--jumpIndex;
#endif
}

static void GambitTestTopic(char* topic)
{
	int topicID = FindTopicIDByName(topic);
	if (!topicID) 
	{
		Log(STDUSERLOG,"topic not found %s\r\n",topic);
		return;
	}
	if (GetTopicFlags(topicID) & TOPIC_NOGAMBITS) return;
	bool  oldRegression = regression;
	regression = true;

	char* data = GetTopicData(topicID);
	char* output = AllocateBuffer();
	int ruleID = -1;
	while (data)
	{
		char* rule = data;
		++ruleID;
		int id = 0;
		data = FindNextRule(NEXTTOPLEVEL,data,id);
		if (*rule != GAMBIT && *rule != RANDOM_GAMBIT) continue; // not a gambit

		// get the output
		rule  = GetPattern(rule,NULL,NULL);
		char* end = strchr(rule,ENDUNIT);  // will not be a useful output as blanks will become underscores, but can do ^reuse() to execute it
		*end = 0;
		strcpy(output,rule);
		*end = ENDUNIT;
		char* q = strchr(output,'?');
		if (!q) continue;	 // not a question
		q[1] = 0; // ignore any following.
		char* at = q;
		while (--at > output) // is there a question before this
		{
			if ((*at == '.' || *at == '!') && at[1] == ' ') break;// end of a sentence?
		}
		if (at != output) output = at+1;

		globalDepth = 0;

		//  perform varible setup, do assigns, and prepare matching context
		ResetToPreUser();
		ReadNewUser();   
		char prepassTopic[MAX_WORD_SIZE];
		strcpy(prepassTopic,GetUserVariable("$prepass"));
		inputCount = 1;
		strcpy(currentInput,output);	//   this is what we respond to, literally.
		nextInput = output;
		OnceCode("$control_pre");
		PrepareSentence(output,true,true);
		if (PrepassSentence(prepassTopic)) PrepareSentence(nextInput,true,true); // user input revise and resubmit?  -- COULD generate output and set rejoinders
		AddPendingTopic(topicID); // ResetToPreUser clears pendingTopicIndex
		responseIndex = 0;
		Reply();
		if (pendingTopicIndex && pendingTopicList[pendingTopicIndex-1] == (unsigned int) topicID){;}
		else if (!responseIndex || responseData[0].topic != (unsigned int)topicID )
		{
			Log(STDUSERTABLOG,"Not answering own question in topic %d %s.%d.%d: %s => %s %s \r\n\r\n",++err,topic,TOPLEVELID(ruleID),REJOINDERID(ruleID),output,GetTopicName(responseData[0].topic),responseData[0].response);
		}
	}
	FreeBuffer();
	regression = oldRegression;
}

static void C_TestTopic(char* input)
{
	char word[MAX_WORD_SIZE];
	input = ReadCompiledWord(input,word);
	char prepassTopic[MAX_WORD_SIZE];
	strcpy(prepassTopic,GetUserVariable("$prepass"));
	PrepareSentence(input,true,true);	
	if (PrepassSentence(prepassTopic)) PrepareSentence(nextInput,true,true); // user input revise and resubmit?  -- COULD generate output and set rejoinders
	unsigned int topic = FindTopicIDByName(word);
	if (!topic)  return;
	int pushed =  PushTopic(topic); 
	if (pushed < 0) return;
	char* buffer = AllocateBuffer();
	ClearUserVariableSetFlags();
	AllocateOutputBuffer();
	PerformTopic(0,buffer); //   ACTIVE handle - 0 is good result
	FreeOutputBuffer();
	FreeBuffer();
	for (unsigned int i = 0; i < responseIndex; ++i) Log(STDUSERLOG,"%s\r\n", responseData[responseOrder[i]].response);
	ShowChangedVariables();
}

static void VerifyAccess(char* topic,char kind,char* prepassTopic) // prove patterns match comment example, kind is o for outside, r for rule, t for topic, s for samples
{
	bool testKeyword = kind == 'k';
	bool testPattern = kind == 'p' ;
	bool testBlocking = kind == 'b';
	bool testSample = kind == 's' || kind == 'S' ;
	if (kind == 'a' || !kind) testKeyword = testPattern = testBlocking =  true;
 	unsigned int topicIndex = FindTopicIDByName(topic);
	if (!topicIndex) 
	{
		printf("%s not found\r\n",topic);
		return;
	}
	WORDP topicWord = FindWord(GetTopicName(topicIndex)); // must find it
	topic = topicWord->word;
	
	int flags = GetTopicFlags(topicIndex);
	if (flags & TOPIC_BLOCKED) return;

	if (testKeyword) 	// has no keyword into here so dont test keyword access
	{
		FACT* F = GetObjectHead(topicWord);
		while (F)
		{
			if (F->verb == Mmember) break; 
			F = GetObjectNext(F);
		}
		if (!F)  testKeyword = false;
	}

	if (GetTopicFlags(topicIndex) & (TOPIC_RANDOM|TOPIC_NOBLOCKING)) testBlocking = false;	
	if (GetTopicFlags(topicIndex) & (TOPIC_RANDOM|TOPIC_NOKEYS)) testKeyword = false;	
	if (GetTopicFlags(topicIndex) & TOPIC_NOPATTERNS) testPattern = false;	
	if (GetTopicFlags(topicIndex) & TOPIC_NOSAMPLES) testSample = false;	
	
	char name[100];
	char* tname = (*topic == '~') ? (topic + 1) : topic;
	if (duplicateCount) sprintf(name,"VERIFY/%s.%d.txt",tname,duplicateCount);
	else sprintf(name,"VERIFY/%s.txt",tname);
	FILE* in = fopen(name,"rb");
	if (!in) 
	{
		printf("%s verification data not found\r\n",name);
		return;
	}

	unsigned int oldtrace = trace;
	trace = 0;
	Log(STDUSERLOG,"VERIFYING %s ......\r\n",topic);
	char* copyBuffer = AllocateBuffer();
	char junk[MAX_WORD_SIZE];
	// process verification data
	while (ReadALine(readBuffer,in))
	{
		if (bufferIndex > 6) return;

		if (!strnicmp(readBuffer,":trace",10))
		{
			trace = atoi(readBuffer+11);
			continue;
		}
		if (!strnicmp(readBuffer,":exit",5)) myexit(":exit requested");
		bool failTest = false;
	
		// read tag of rule to apply input to
		char* dot = strchr(readBuffer,'.');
		if (!dot) continue;
		int ruleID = atoi(dot+1);
		dot = strchr(dot+1,'.');
		if (dot) ruleID |= atoi(dot+1) * ONE_REJOINDER;
		char* rule = GetRule(topicIndex,ruleID);						// the rule we want to test
		char* topLevelRule = GetRule(topicIndex,TOPLEVELID(ruleID));	// the top level rule (if a rejoinder)
		char* rejoinderTop = NULL;
		int rejoinderTopID = 0;
		if (rule != topLevelRule) // its a rejoinder, find the start of the rejoinder area
		{
			rejoinderTop = topLevelRule;  // the limit of backward checking
			char* at = rule; // start at the given rejoinder
			rejoinderTopID = ruleID;
			while (*at >= *rule && REJOINDERID(rejoinderTopID)) // stop if drop below our level or go to top level rule
			{
				at = RuleBefore(topicIndex,at);
				rejoinderTopID -= ONE_REJOINDER;
			}
			rejoinderTopID += ONE_REJOINDER; // now move back down to 1st of our level
			rejoinderTop = FindNextRule(NEXTRULE,at,rejoinderTopID);
		}

		// the comment headers are:
		// #!x  - description header for :abstract
		// #!!R  - expect to fail RULE
		// #!!T - expect to fail TOPIC (be masked by earlier rule)
		// #!!K - expect to fail keywords
		// #!!S - dont run sample
		*junk = junk[1] = junk[2] = 0;
		char* test = strchr(readBuffer,'!')+1;	// the input sentence (skipping offset and #! marker)
		if (*test != ' ') test = ReadCompiledWord(test,junk); // things to not test
		MakeLowerCase(junk);
		if (*junk == 'x') continue;  // only used for :abstract

		bool wantFailBlocking = false;
		bool wantFailKeyword = false;
		bool wantFailPattern = false;
		bool wantNoSample = false;
		if (strchr(junk,'b') || strchr(junk,'B')) wantNoSample = wantFailBlocking = true;
		if (strchr(junk,'k') || strchr(junk,'K')) wantNoSample = wantFailKeyword = true;
		if (strchr(junk,'p') || strchr(junk,'P')) wantFailPattern = true;
		if (strchr(junk,'s') || strchr(junk,'S')) wantNoSample = true;

		//   test pattern on THIS rule

		globalDepth = 0;

		//  perform varible setup, do assigns, and prepare matching context
		ResetToPreUser();
		ReadNewUser();   
		inputCount = 1;
		if (testSample) OnceCode("$control_pre");

		DefineSystemVariables(); // clear system variables to default
		DoAssigns(test); // kills test start where any defines are
		strcpy(copyBuffer,test);
		strcpy(currentInput,test);	//   this is what we respond to, literally.
		nextInput = test;
		PrepareSentence(test,true,true);
		if (PrepassSentence(prepassTopic)) PrepareSentence(nextInput,true,true); // user input revise and resubmit?  -- COULD generate output and set rejoinders
		currentTopicID = topicIndex;
		strcpy(test,copyBuffer); // sentence prep may have altered test data and we might want to redo it
		AddPendingTopic(topicIndex); // ResetToPreUser clears pendingTopicIndex

		char label[MAX_WORD_SIZE];
		char pattern[MAX_WORD_SIZE];
		char* topLevelOutput = GetOutputCopy(topLevelRule); 
		GetPattern(rule,label,pattern);
		if (!*pattern) 
		{
			ReportBug("No pattern here? %s %s\r\n",topic,rule)
			continue;
		}

		bool result;
		if (testKeyword && !wantFailKeyword &&  !TopLevelGambit(rule) &&  TopLevelRule(rule) )  // perform keyword test on sample input sentence
		{
			unsigned int pStart = 0;
			unsigned int pEnd = 0;
			if (!GetNextSpot(topicWord,0,pStart,pEnd)) // not findable topic
			{
				Query("direct_v","?","idiom",topic,(unsigned int)-1,"?","?","?","?");  // get all idioms that can trigger this topic
				unsigned int i = FACTSET_COUNT(0);
				while (i > 0)
				{
					FACT* F = factSet[0][i];
					WORDP pattern = Meaning2Word(F->subject);
					strcpy(callArgumentList[callArgumentBase+1],pattern->word);
					*callArgumentList[callArgumentBase+2] = 0; // dumy argument 1
					if (MatchCode(junk) == 0) break;
					--i;
				}

				if ( i == 0) 
				{
					Log(STDUSERTABLOG,"%d Missing keyword %s.%d.%d <= %s\r\n",++err,topic,TOPLEVELID(ruleID),REJOINDERID(ruleID),test);
					failTest = true;
				}
			}
		}

		//   inside the pattern, test this rule
		if (testPattern && !wantFailPattern)
		{
			result = RuleTest(rule);
			if ((!result && !wantFailPattern) || (result && wantFailPattern) ) //   didnt do what we expected
			{
				Log(STDUSERTABLOG,"Bad Pattern %d %s.%d.%d: %s => %s\r\n\r\n",++err,topic,TOPLEVELID(ruleID),REJOINDERID(ruleID),test,pattern);
				failTest = true;

				// redo with tracing on if selected so we can watch it fail
				if (oldtrace)
				{
					trace = oldtrace;
					PrepareSentence(test,true,true);	
					if (PrepassSentence(prepassTopic)) PrepareSentence(nextInput,true,true); // user input revise and resubmit?  -- COULD generate output and set rejoinders
					strcpy(test,copyBuffer); // sentence prep may have altered test data and we might want to redo it
					RuleTest(rule);
					trace = 0;
				}
				continue;
			}
		}
		
		if (testBlocking && !wantFailBlocking  && !TopLevelGambit(rule)) // check for blocking
		{
			char* data;
			char* output = NULL;
			int id = 0;
			if (TopLevelRule(rule)) // test all top level rules in topic BEFORE this one
			{
				data = GetTopicData(topicIndex);
				char label[MAX_WORD_SIZE];
				char pattern[MAX_WORD_SIZE];
				while (data && data < rule)
				{
					if (*data == GAMBIT || *data == RANDOM_GAMBIT); // no data gambits
					else if (*rule == STATEMENT && *data == QUESTION); // no mismatch type
					else if (*rule == QUESTION && *data == STATEMENT); // no mismatch type
					else 
					{
						output = GetPattern(data,label,pattern);
						if (!*pattern) break; 
						unsigned int result;
						if (pattern[2] == ')' || pattern[2] == '*') result =  0; // universal match patterns are PRESUMED not to be blocking. they obviously obscure anything
						else result = RuleTest(data);// past the paren
						if (result)	break; // he matched, blocking us
					}
					data = FindNextRule(NEXTTOPLEVEL,data,id);
				}
			}
			else  // rejoinder matching 
			{
				data = rejoinderTop;
				id = rejoinderTopID;
				while (data < rule)
				{
					if (*data == *rule)// all rules of this same level and before us
					{
						unsigned int result = RuleTest(data); // past the paren
						if (result)	break; // he matched, blocking us
					}
					data = FindNextRule(NEXTRULE,data,id);
				}
			}

			if (data && data < rule) // earlier rule matches same pattern
			{
				// prove not a simple () (*) (!?)  (?) etc
				char* t = pattern+2; // start AFTER the ( 
				while (ALWAYS)
				{
					t = ReadCompiledWord(t,junk);
					if (!stricmp(junk,"!") || !stricmp(junk,"*") || !stricmp(junk,"?")) continue;
					break;
				}
				if (*junk == 0 || *junk == ')') continue;	// presumed end of pattern

				// prove it may output something - all matching rejoinders automatically mask if occur sooner
				if (!Rejoinder(data)) // top level units that dont generate output dont actually mask.
				{
					char word[MAX_WORD_SIZE];
					while (*output && *output != ENDUNIT)
					{
						output = ReadCompiledWord(output,word);
						if (IsAlpha(*word) && FindWord(word)) 
							break; // possible problem
					}
				}
				if (!output || *output == ENDUNIT) continue;	// no text output found

				if (REJOINDERID(id)) Log(STDUSERTABLOG,"Blocking %d Rejoinder %d.%d %s\r\n",++err,TOPLEVELID(id),REJOINDERID(id),ShowRule(data));
				else Log(STDUSERTABLOG,"Blocking %d TopLevel %d.%d %s\r\n",++err,TOPLEVELID(id),REJOINDERID(id),ShowRule(data));
				Log(STDUSERTABLOG,"    blocks %d.%d %s\r\n    given: %s\r\n\r\n",TOPLEVELID(ruleID),REJOINDERID(ruleID),ShowRule(rule),test);
				failTest = true;
			}
		}
		if (testSample && !wantNoSample && !failTest  && TopLevelRule(rule)) // check for sample
		{
			ClearPendingTopics();
			responseIndex = 0;
			currentTopicID = 0;
			if (oldtrace) trace = oldtrace;
			Reply();
			trace = 0;			
			if (!responseIndex || responseData[0].topic != topicIndex)
			{
				Log(STDUSERTABLOG,"Bad sample topic %d %s.%d.%d: %s => %s %s \r\n\r\n",++err,topic,TOPLEVELID(ruleID),REJOINDERID(ruleID),test,GetTopicName(responseData[0].topic),responseData[0].response);
			}
			else if (kind != 'S') // also check rule bad
			{
				int id = atoi(responseData[0].id+1);
				char* dot = strchr(responseData[0].id+2,'.');
				id |= MAKE_REJOINDERID(atoi(dot+1));

				int reuseid = -1;
				dot = strchr(dot+1,'.');
				if (dot)
				{
					reuseid = atoi(dot+1);
					dot = strchr(dot+2,'.');
					reuseid |= MAKE_REJOINDERID(atoi(dot+1));
				}
				if (id == ruleID || (reuseid >= 0 && TOPLEVELID(reuseid) == (unsigned int) ruleID)) {;} // we match
				else if (TOPLEVELID(id) == (unsigned int) ruleID && !strstr(topLevelOutput,"refine")) {;} // we matched top level and are not looking for refinement
				else
					Log(STDUSERTABLOG,"Bad sample rule %d %s  For: %s \r\n   want- %d.%d\n   got - %s => %s\r\n\r\n",++err,topic,test,
						TOPLEVELID(ruleID),REJOINDERID(ruleID),
						responseData[0].id+1,ShowRule(GetRule(topicIndex,id)));
			}
		}
	}
	fclose(in);
	RemovePendingTopic(topicIndex);
	FreeBuffer(); // copyBuffer
	trace = oldtrace;
}

static void VerifyAllTopics(char kind,char* prepassTopic,char* topic)
{
	size_t len = 0;
	char* x = strchr(topic,'*');
	if (x) len = x - topic ;
	for (unsigned int i = 1; i <= lastTopic; ++i) 
	{
		if (len && strnicmp(GetTopicName(i),topic,len)) continue;
		VerifyAccess(GetTopicName(i),kind,prepassTopic);
	}
}

static void AllGambitTests(char* topic)
{
	size_t len = 0;
	char* x = strchr(topic,'*');
	if (x) len = x - topic;
	for (unsigned int i = 1; i <= lastTopic; ++i) 
	{
		if (len && strnicmp(GetTopicName(i),topic,len)) continue;
		GambitTestTopic(GetTopicName(i));
	}
}

static void C_Verify(char* input)
{
	char word[MAX_WORD_SIZE];
	char topic[MAX_WORD_SIZE];
	*topic = 0;
	err = 0;
	char* ptr = ReadCompiledWord(input,word); // :verify    or    :verify blocking   or  :verify blocking ~family   or  :verify ~family or :verify sample
	char type = 0;
	if (*word == '~') 
	{
		strcpy(topic,word);
		ReadCompiledWord(ptr,word); // user may flip order and put topic first
	}
	
	if (!strnicmp(word,"pattern",7))	
	{
		type = 'p';
		if (!*topic) ReadCompiledWord(ptr,topic);
	}
	else if (!stricmp(word,"all"))	
	{
		type = 'a';
		if (!*topic) ReadCompiledWord(ptr,topic);
	}
	else if (!strnicmp(word,"gambit",6))
	{
		type = 'g';
		if (!*topic) ReadCompiledWord(ptr,topic);
	}
	else if (!strnicmp(word,"block",5)) 
	{
		type = 'b';
		if (!*topic) ReadCompiledWord(ptr,topic);
	}
	else if (!strnicmp(word,"keyword",7))
	{
		type = 'k';
		if (!*topic) ReadCompiledWord(ptr,topic);
	}
	else if (!strnicmp(word,"sample",6))
	{
		if (!strnicmp(word,"sampletopic",11)) type = 'S'; // bad topic only
		else type = 's'; // bad topics and rules
		if (!*topic) ReadCompiledWord(ptr,topic);
	}
	else if (*word && *word != '~') // topic name given without ~
	{
		topic[0] = '~';
		strcpy(topic+1,word);
	}

	if (type != 'g')
	{
		char prepassTopic[MAX_WORD_SIZE];
		strcpy(prepassTopic,GetUserVariable("$prepass"));
		if (*topic == '~' && !strchr(topic,'*')) VerifyAccess(topic,type,prepassTopic);
		else VerifyAllTopics(type,prepassTopic,topic);
	}

	// now do gambit tests
	if (type == 'g' || type == 'a')
	{
		if (*topic == '~'  && !strchr(topic,'*')) GambitTestTopic(topic);
		else AllGambitTests(topic);
	}
	Log(STDUSERLOG,"%d verify findings.\r\n",err);
}

bool stanfordParser = false;

static void PennWrite(char* name,uint64 flags)
{
	FILE* out = (FILE*)flags;
	FILE* in = fopen(name,"rb");
	if (!in) 
	{
		printf("missing %s\r\n",name);
		return;
	}
	bool content = false;
	char* buffer = AllocateBuffer();
	*buffer = 0;
	char* ptr = buffer;
	bool pendingDone = false;
	bool openQuote = false;
	while (ReadALine(readBuffer,in,maxBufferSize,true)) // read lines, returning empties as well
	{
		char word[MAX_WORD_SIZE];
		ReadCompiledWord(readBuffer,word);
		if (!*word && !stanfordParser) // empty line always separates sentences from Pennbank
		{
			if (content)
			{
				*ptr = 0;
				fprintf(out,"%s\r\n",buffer);
				ptr = buffer;
				*ptr = 0;
				content = false;
			}
			continue;
		}
		char* at = readBuffer;
		while (at && *at)
		{
			at = ReadCompiledWord(at,word);
			if (pendingDone) // saw a closing, aim to close it if not quote close
			{
				if (*word == '\'' && word[1] == '\'' && word[2] == '/' && openQuote) // close quote 
				{
					strcpy(word,"\"/\"");
					openQuote = false;
					strcat(ptr,word);
					ptr += strlen(ptr);
					strcat(ptr," ");
					++ptr;
					*word = 0;
				}	

				*ptr = 0;
				fprintf(out,"%s\r\n",buffer);
				ptr = buffer;
				*ptr = 0;
				content = false;
				pendingDone = false;
				if (!*word) continue; // closed quote around this
			}

			if (*word == '`' && word[1] == '`' && word[2] == '/') // open quote 
			{
				strcpy(word,"\"/\"");
				openQuote = true;
			}
			if (*word == '\'' && word[1] == '\'' && word[2] == '/') // close quote 
			{
				strcpy(word,"\"/\"");
				openQuote = false;
			}			
			if (*word == '[' || *word == ']') continue;	// ignore this
			if (*word == '=' && word[1] == '=') // ignore ======================================
			{
				if (content)
				{
					*ptr = 0;
					fprintf(out,"%s\r\n",buffer);
					ptr = buffer;
					*ptr = 0;
					content = false;
				}
				continue; 
			}
			strcat(ptr,word);
			ptr += strlen(ptr);
			strcat(ptr," ");
			++ptr;

			if (!content && !stanfordParser)
			{
				if (IsLowerCase(*word)) Log(STDUSERLOG,"LOWER START? %s in %s \r\n",readBuffer,name);
			}
			content = true;

			if (stanfordParser && (*word == '.' || *word == '?' || *word == '!')) // sentences using stanford parser will end with punctuation UNLESS have quote after that
			{
				pendingDone = true;
			}
		}
	}
	if (content)
	{
		*ptr = 0;
		fprintf(out,"%s\r\n",buffer);
	}
	fclose(in);
	FreeBuffer();
}

static void C_PennFormat(char* file)
{
	char indir[MAX_WORD_SIZE];
	file = ReadCompiledWord(file,indir); // where source is
	char word[MAX_WORD_SIZE];
	file = ReadCompiledWord(file,word); // where source is
	char outfile[MAX_WORD_SIZE];
	sprintf(outfile,"REGRESS/PENNTAGS/%s.txt",word); // where output is

	if (!strnicmp(file,"stanford",4)) stanfordParser = true; // sentences end with . or ! or ?
	FILE* out = fopen(outfile,"wb");
	if (!out) return;
	WalkDirectory(indir,PennWrite,(uint64)out);
	fclose(out);
}

static void C_PennMatch(char* file)
{
	char word[MAX_WORD_SIZE];
	file = ReadCompiledWord(file,word);
	bool raw = false;
	bool basic = false;
	if (!stricmp(word,"raw"))
	{
		raw = true;
		file = ReadCompiledWord(file,word);
	}
	if (!stricmp(word,"basic"))
	{
		basic = true;
		file = ReadCompiledWord(file,word);
	}
	char filename[MAX_WORD_SIZE];
	if (*word) sprintf(filename,"REGRESS/PENNTAGS/%s.txt",word);
	else strcpy(filename,"REGRESS/PENNTAGS/penn.txt");
	FILE* in = FopenReadOnly(filename);
	if (!in) return;
	char* buffer = AllocateBuffer();
	char tags[MAX_SENTENCE_LENGTH][20];
	char tokens[MAX_SENTENCE_LENGTH][100];
	char mytags[MAX_SENTENCE_LENGTH][200];
	char prior[MAX_WORD_SIZE];
	unsigned int len;
	unsigned int right = 0;
	unsigned int total = 0;
	unsigned int sentences = 0;
	quotationInProgress = 0;	
	prepareMode = PENN_MODE;
	unsigned int totalAmbigs = 0;
	unsigned int ambigItems = 0;
	while (ReadALine(readBuffer,in))
	{
		char* at = buffer;
		*at = 0;
		char word[MAX_WORD_SIZE];
		char* ptr = SkipWhitespace(readBuffer);
		if (!*ptr || *ptr == '#') continue;
		if (!strnicmp(ptr,":exit",5)) break;
		len = 0;
		while (ptr && *ptr)
		{
			ptr = ReadCompiledWord(ptr,word);
			if (!*word) break;
			char* sep = strrchr(word,'/'); // find last one (there might be \/  when they actually want token
			if (!sep)
			{
				printf("Failed %s\r\n",readBuffer);
				break;
			}
			*sep = 0;
			++len;

			// recode \/ and its ilk
			char word1[MAX_WORD_SIZE];
			strcpy(word1,word);
			char* sep1;
			while ((sep1 = strchr(word1,'\\'))) memmove(sep1,sep1+1,strlen(sep1)+1);

			strcpy(tokens[len],word1);

			if (!stricmp(word1,"-LRB-")) strcat(at,"(");
			else if (!stricmp(word1,"-RRB-")) strcat(at,")");
			else if (!stricmp(word1,"-LSB-")) strcat(at,"[");
			else if (!stricmp(word1,"-RSB-")) strcat(at,"]");
			else if (!stricmp(word1,"-LCB-")) strcat(at,"{");
			else if (!stricmp(word1,"-RCB-")) strcat(at,"}");
			else if (*word1 == '`' && word1[1] == '`') strcat(at,"\"");  // open quote
			else if (*word1 == '\'' && word1[1] == '\'') strcat(at,"\""); // close quote
			else strcat(at,word1);

			at += strlen(at);
			strcat(at++," ");
			strcpy(tags[len],sep+1); // what we expect
		}
		if (len == 0) continue; // on to next

		*at = 0;
		total += len;
		if (*tags[len] == '.' || *tags[len] == '?' || *tags[len] == '!') 
		{
			++right;	 // end punctuation is always right
			--len;
		}
		// test this sentence
		char* answer1;
		tokenControl = STRICT_CASING | DO_ESSENTIALS | DO_POSTAG | DO_CONTRACTIONS | NO_HYPHEN_END | NO_COLON_END | NO_SEMICOLON_END | TOKEN_AS_IS | NO_MARK;
		if (!raw && !basic) tokenControl |= DO_PARSE;
		ReturnToFreeze();
		PrepareSentence(buffer,true,true);	
		++sentences;
		answer1 = DumpAnalysis(1,wordCount,posValues,"Tagged POS",false,true); // to debug at
		if (basic) 
		{
			bool bad = false;
			for (unsigned int i = 1; i <= wordCount; ++i) if (bitCounts[i] != 1) bad = true;
			if (bad) Log(STDUSERLOG,"%s\r\n",answer1);
			continue;
		}
		char* xxhold = answer1; // for debugging
		answer1 = strchr(answer1,':') + 1;
		unsigned int a = 0;
		while (answer1 && *answer1)
		{
			char* close = strstr(answer1,")  ");
			if (!close) break;
			close[1] = 0;
			strcpy(mytags[++a],answer1);
			close[1] =  ' ';
			answer1 = close+3;
		}
		if (answer1) strcpy(mytags[++a],answer1); // any remnant
		unsigned int oldRight = right;
		if ((a-1) != wordCount)
		{
			Log(STDUSERLOG,"Tag MisCount: %d instead of %d %s \r\n",a,wordCount,buffer);
			while (++a <= wordCount) *mytags[a] = 0;
		}

		if (len != wordCount) 
		{
			Log(STDUSERLOG,"MisCount: %d %s \r\n",currentFileLine,buffer);
		}
		strcpy(prior,buffer);
		for (unsigned int i = 1; i <= wordCount; ++i) // match off the pos values we understand. all others are wrong by definition
		{
			unsigned int ok = right;
retry:
			char* sep = strchr(tags[i],'|');
			if (sep) *sep = 0;

			if (bitCounts[i] != 1)
			{
				totalAmbigs += bitCounts[i];
				++ambigItems;
			}

			if (bitCounts[i] != 1 && (tokenControl & DO_PARSE) == DO_PARSE  ) // did not solve - we normally do all
			{
				Log(STDUSERLOG,"Ambiguous at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			} 
			else if (!stricmp(tags[i],"-LRB-"))
			{
				if (*wordStarts[i] == '(') ++right;
				else Log(STDUSERLOG,"** Bad left paren at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"-RRB-"))
			{
				if (*wordStarts[i] == ')') ++right;
				else Log(STDUSERLOG,"** Bad right paren at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"-LSB-"))
			{
				if (*wordStarts[i] == '[') ++right;
				else Log(STDUSERLOG,"** Bad left square bracket at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"-RSB-"))
			{
				if (*wordStarts[i] == ']') ++right;
				else Log(STDUSERLOG,"** Bad right square bracket at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"-LCB-"))
			{
				if (*wordStarts[i] == '{') ++right;
				else Log(STDUSERLOG,"** Bad left curly bracket at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"-RCB-"))
			{
				if (*wordStarts[i] == '}') ++right;
				else Log(STDUSERLOG,"** Bad right curly bracket at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (posValues[i] & IDIOM) ++right;
			else if (!stricmp(tags[i],"TO")) ++right;	// always correct
			else if (!stricmp(tags[i],"NN")) 
			{
				if (posValues[i] & (NOUN_SINGULAR | ADJECTIVE_NOUN | NOUN_NUMBER)  && allOriginalWordBits[i] & (NOUN_SINGULAR|NOUN_NUMBER)) ++right;
				else if (posValues[i] & ADJECTIVE_PARTICIPLE && allOriginalWordBits[i] & NOUN_GERUND) ++right; // *drinking straws
				else if (posValues[i] & NOUN_SINGULAR) ++right; // they doubtless dont know it should be lower case
				else if (posValues[i] & ADJECTIVE_NORMAL && allOriginalWordBits[i] & NOUN_SINGULAR) ++right;  //"*expert aim"
				else if (posValues[i] & NOUN_PROPER_SINGULAR) ++right; // "*Pill bugs are good"
				else if (posValues[i] & NOUN_GERUND && allOriginalWordBits[i] & NOUN_SINGULAR) ++right; // "*spitting is good"
				else if (posValues[i] & (PRONOUN_BITS) && (!stricmp(wordStarts[i],"something") || !stricmp(wordStarts[i],"everything"))) ++right;
				else Log(STDUSERLOG,"** Bad NN at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"NNS")) 
			{
				if (posValues[i] & (NOUN_PLURAL| ADJECTIVE_NOUN)  && allOriginalWordBits[i] & NOUN_PLURAL) ++right;
				else if (posValues[i] & NOUN_NUMBER && canSysFlags[i] & MODEL_NUMBER) ++right; // model numbers
				else if (posValues[i] & NOUN_PROPER_PLURAL) ++right; // they get it wrong
				else if (posValues[i] & NOUN_SINGULAR && allOriginalWordBits[i] & (NOUN_MASS | NOUN_PLURAL)) ++right;
				else Log(STDUSERLOG,"** Bad NNS at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"NNP")) // proper singular
			{
				uint64 val;
				if (posValues[i] & (NOUN_PROPER_SINGULAR | ADJECTIVE_NOUN) && allOriginalWordBits[i] & (NOUN_PROPER_SINGULAR | NOUN_SINGULAR)) ++right;
				else if (posValues[i] & NOUN_NUMBER && canSysFlags[i] & MODEL_NUMBER) ++right; // model numbers
				else if (posValues[i] & NOUN_NUMBER && IsRomanNumeral(wordStarts[i],val)) ++right; //  roman numerals
				else if (posValues[i] & ADJECTIVE_NORMAL && IsUpperCase(*wordStarts[i])) ++right; // things like French can be adjective or noun, we often call them adjectives instead of adjective_noun
				else if (posValues[i] & ADJECTIVE_NORMAL && allOriginalWordBits[i] & NOUN_PROPER_SINGULAR) ++right; // things like French can be adjective or noun, we often call them adjectives instead of adjective_noun
				else if (posValues[i] & NOUN_PROPER_PLURAL) ++right; // if it ended in s like Atomos.
				else if (posValues[i] & NOUN_SINGULAR) ++right; // "Bear had to eat a lot in raw mode
				else Log(STDUSERLOG,"** Bad NNP at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"NNPS"))  // proper plural
			{
				if (posValues[i] & (NOUN_PROPER_PLURAL| ADJECTIVE_NOUN) && allOriginalWordBits[i] & NOUN_PROPER_PLURAL) ++right;
				else Log(STDUSERLOG,"** Bad NNPS at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"IN")) 
			{
				if (posValues[i] & (CONJUNCTION_SUBORDINATE|PREPOSITION)) ++right;
				else if (posValues[i] & PARTICLE && allOriginalWordBits[i] & PREPOSITION) ++right; 
				else Log(STDUSERLOG,"** Bad IN at %d: %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"PDT")) 
			{
				if (posValues[i] & PREDETERMINER) ++right;
				else Log(STDUSERLOG,"** Bad PDT at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"POS")) 
			{
				if (posValues[i] & POSSESSIVE) ++right;
				else Log(STDUSERLOG,"** Bad POS at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"LS")) // bullet point
			{
				Log(STDUSERLOG,"** Bad LS at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"CC")) 
			{
				if (posValues[i] & CONJUNCTION_COORDINATE) ++right;
				else Log(STDUSERLOG,"** Bad CC at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"JJ")) 
			{
				if (posValues[i] & (ADJECTIVE_NORMAL|NOUN_NUMBER)) ++right;
				else if (posValues[i] & ADJECTIVE_NUMBER && !(lcSysFlags[i] & (MORE_FORM|MOST_FORM))) ++right;
				else if (posValues[i] & NOUN_SINGULAR && allOriginalWordBits[i] & NOUN_GERUND  && allOriginalWordBits[i] & ADJECTIVE_NORMAL) ++right; // " *melting point" 
				else if (posValues[i] & NOUN_PROPER_SINGULAR) ++right; // " *Western boots" 
				else if (posValues[i] & (ADJECTIVE_PARTICIPLE | ADJECTIVE_NOUN)) ++right; // "I am *tired"  "*pill bugs eat"
				else if (posValues[i] & NOUN_GERUND ) ++right; // "he got me *moving"
				else if (posValues[i] & NOUN_SINGULAR && posValues[i+1] & (ADJECTIVE_BITS|NOUN_BITS) && (tokenControl & DO_PARSE) != DO_PARSE ) ++right; // "the *bank teller" when using RAW mode or "*money_market mutual funds"
				else if (posValues[i] & DETERMINER) ++right; // "*Other people"
				else if (posValues[i] & PARTICLE) ++right; // "take it for *granted"
				else if (posValues[i] & VERB_PRESENT_PARTICIPLE && allOriginalWordBits[i] & ADJECTIVE_BITS) ++right;	// she is *willing to go"
				else Log(STDUSERLOG,"** Bad JJ at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"JJR")) 
			{
				if (originalLower[i]  && posValues[i] & ADJECTIVE_NORMAL && lcSysFlags[i] & MORE_FORM) ++right;
				else if ( posValues[i] & DETERMINER && lcSysFlags[i] & MORE_FORM) ++right;
				else Log(STDUSERLOG,"** Bad JJR at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"JJS")) 
			{
				if (originalLower[i] && posValues[i] & ADJECTIVE_NORMAL && lcSysFlags[i] & MOST_FORM) ++right;
				else if ( posValues[i] & DETERMINER && lcSysFlags[i] & MOST_FORM) ++right;
				else Log(STDUSERLOG,"** Bad JJS at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"RB")) 
			{
				if (posValues[i] & ADVERB_NORMAL) ++right;
				else  if (posValues[i] & PARTICLE && allOriginalWordBits[i] & ADVERB_BITS)  ++right;
				else Log(STDUSERLOG,"** Bad RB at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"RBR")) 
			{
				if (originalLower[i]  && posValues[i] & ADVERB_NORMAL && lcSysFlags[i] & MORE_FORM) ++right;
				else Log(STDUSERLOG,"** Bad RBR at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"RBS")) 
			{
				if (originalLower[i]  && posValues[i] & ADVERB_NORMAL && lcSysFlags[i] & MOST_FORM) ++right;
				else Log(STDUSERLOG,"** Bad RBS at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
		    }
			else if (!stricmp(tags[i],"UH")) 
			{
				if (posValues[i] & INTERJECTION) ++right;
				else if (wordCount == 1) ++right;	// anything COULD be...
				else Log(STDUSERLOG,"** Bad UH at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
		    }
			else if (!stricmp(tags[i],"MD")) 
			{
				if (posValues[i] & AUX_VERB_BITS) ++right;
				else Log(STDUSERLOG,"** Bad MD at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"RP")) 
			{
				if (posValues[i] & PARTICLE) ++right;
				else if (posValues[i] & ADVERB_NORMAL) ++right; // who can say if ideomatic particle verb or adverb.... 
				else Log(STDUSERLOG,"** Bad RP at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"DT")) 
			{
				if (posValues[i] & DETERMINER_BITS) ++right; // a an the // my her their our your
				else if (posValues[i] & ADJECTIVE_NUMBER) ++right;	// all numbers to us as adjectives might be considered determiners ?????
				else if (!stricmp(wordStarts[i],"this") && posValues[i] & PRONOUN_BITS) ++right; 
				else if (!stricmp(wordStarts[i],"that") && posValues[i] & PRONOUN_BITS) ++right;
				else if (!stricmp(wordStarts[i],"those") && posValues[i] & PRONOUN_BITS) ++right;
				else if (posValues[i] & ADVERB_BITS && posValues[i+1] & PREPOSITION) ++right; // "he walked *all by himself"
				//else if (!stricmp(wordStarts[i],"every") || !stricmp(wordStarts[i],"no") || !stricmp(wordStarts[i],"another")
				//	 || !stricmp(wordStarts[i],"any") || !stricmp(wordStarts[i],"some")
				else  Log(STDUSERLOG,"** Bad DT at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"PRP$")) 
			{
				if (posValues[i] & PRONOUN_POSSESSIVE) ++right;
				else Log(STDUSERLOG,"** Bad PRP$ at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"PRP")) 
			{
				if (posValues[i] & (PRONOUN_BITS)) ++right;
				else Log(STDUSERLOG,"** Bad PRP at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"VB")) // infinitive
			{
				if (posValues[i] & (NOUN_INFINITIVE|VERB_INFINITIVE)) ++right;  
				else if (posValues[i] & AUX_VERB_BITS && allOriginalWordBits[i] &  VERB_INFINITIVE) ++right;  // includes our modals 
				else Log(STDUSERLOG,"** Bad VB (infinitive) at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"VBD")) // past
			{
				if (posValues[i] & VERB_PAST || (posValues[i] & AUX_VERB_BITS &&  allOriginalWordBits[i] &  VERB_PAST) ) ++right;  // includes our modals that can have this tense as verbs
				else Log(STDUSERLOG,"** Bad VBD (past) at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"VBG"))  // gerund present participle
			{
				if (allOriginalWordBits[i] & (VERB_PRESENT_PARTICIPLE|NOUN_GERUND)) ++right;  // includes our modals that can have this tense as verbs
				else  Log(STDUSERLOG,"** Bad VBG (present participle) at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
		    }
			else if (!stricmp(tags[i],"VBN")) // past particple
			{
				if (posValues[i] & VERB_PAST_PARTICIPLE || ( posValues[i] & AUX_VERB_BITS && allOriginalWordBits[i] & VERB_PAST_PARTICIPLE)) ++right;  // includes our modals that can have this tense as verbs
				else if (posValues[i] & ADJECTIVE_PARTICIPLE && allOriginalWordBits[i] & VERB_PAST_PARTICIPLE) ++right;
				else  Log(STDUSERLOG,"** Bad VBN (past participle) at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"VBP")) // present
			{
				if (posValues[i] & VERB_PRESENT || (posValues[i] & AUX_VERB_BITS && allOriginalWordBits[i]  &  VERB_PRESENT)) ++right;  // includes our modals that can have this tense as verbs
				else Log(STDUSERLOG,"** Bad VBP (present) at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"VBZ")) // 3ps
			{
				if (posValues[i] & VERB_PRESENT_3PS || (posValues[i] & AUX_VERB_BITS && allOriginalWordBits[i]  &  VERB_PRESENT_3PS)) ++right; // includes our modals that can have this tense as verbs
				else Log(STDUSERLOG,"** Bad VBZ (present 3ps) at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"WDT")) 
			{
				if (!stricmp(wordStarts[i],"that") || !stricmp(wordStarts[i],"what") ||!stricmp(wordStarts[i],"whatever") ||!stricmp(wordStarts[i],"which") ||!stricmp(wordStarts[i],"whichever"))
				{ 
					if (posValues[i] & (DETERMINER|PRONOUN_BITS|CONJUNCTION_SUBORDINATE)) ++right; // what dog is that
					else Log(STDUSERLOG,"** Bad WDT at %d: %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
				}
				else Log(STDUSERLOG,"** Bad WDT at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"WP")) 
			{
				// that may be WDT
				if ( !stricmp(wordStarts[i],"what") || !stricmp(wordStarts[i],"who") || !stricmp(wordStarts[i],"whom"))
				{ // that whatever which WDT - whatsoever RB -  whosoever NN
					if (posValues[i] & (PRONOUN_BITS|CONJUNCTION_SUBORDINATE | DETERMINER | PREDETERMINER)) ++right; // what is that
					else Log(STDUSERLOG,"** Bad WP at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
				}
				else Log(STDUSERLOG,"** Bad WP at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"WP$")) 
			{
				if (!stricmp(wordStarts[i],"whose"))
				{
					if (posValues[i] & (PRONOUN_POSSESSIVE | DETERMINER)) ++right; // whose dog is that -- do we do both? or only one?
					else Log(STDUSERLOG,"** Bad WP$ at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
				}
				else Log(STDUSERLOG,"** Bad WP$ at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"WRB")) 
			{
				if (!stricmp(wordStarts[i],"how")  ||!stricmp(wordStarts[i],"whenever") ||!stricmp(wordStarts[i],"when") ||!stricmp(wordStarts[i],"where")
					||!stricmp(wordStarts[i],"whereby")||!stricmp(wordStarts[i],"wherein")||!stricmp(wordStarts[i],"why"))
				{
					// the ONLY exception is  "when" meaning "if" should be IN.  
					++right; 
					// however, whence, wherever, whereof are NOT wrb?
				}
				else Log(STDUSERLOG,"** Bad WRB at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!IsAlpha(*tags[i])) 
			{
				++right;	// all punctuation must be right
			}
			else if (!stricmp(tags[i],"CD")) 
			{
				if (posValues[i] & (NOUN_NUMBER | ADJECTIVE_NUMBER)) ++right;
				else Log(STDUSERLOG,"** Bad CD at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"EX")) 
			{
				if (posValues[i]  &  THERE_EXISTENTIAL) ++right;
				else Log(STDUSERLOG,"** Bad EX at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!stricmp(tags[i],"FW")) 
			{
				if (strstr(mytags[i],"unknown-word") || allOriginalWordBits[i] & FOREIGN_WORD) ++right;
				else Log(STDUSERLOG,"** Bad FW at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);
			}
			else if (!sep) Log(STDUSERLOG,"** Bad Unknown tag at %d: line %d %s %s %s\r\n",i,currentFileLine,mytags[i],tags[i],buffer);

			// composite choices
			if (sep && right == ok) // didn't match it yet
			{
				memmove(tags[i],sep+1,strlen(sep+1) + 1);
				goto retry;
			}
		}
		if ((tokenControl & DO_PARSE) == DO_PARSE ) 
		{
			if ((right-oldRight) != wordCount){;} // pos is bad so parse is by definition bad
			else if (tokenFlags & FAULTY_PARSE && !(tokenFlags & NOT_SENTENCE)) Log(STDUSERLOG,"     ** bad parse at %d: %s\r\n",currentFileLine,buffer);

			// verify plurality and determined
			unsigned int subject = 0;
			for (unsigned int i = startSentence; i <= endSentence; ++i)
			{
				if (roles[i] & (SUBJECT2|MAINSUBJECT)) subject = i;
				if (roles[i] & (VERB2|MAINVERB))
				{
					if (subject && posValues[subject] == NOUN_SINGULAR && posValues[i] == VERB_PRESENT && !(originalLower[i]->properties & NOUN_MASS)) Log(STDUSERLOG,"*** Warning singular noun %s to plural verb %s in %s\r\n",wordStarts[subject],wordStarts[i],buffer);
					if (subject && posValues[subject] == NOUN_PLURAL && posValues[i] == VERB_PRESENT_3PS) Log(STDUSERLOG,"*** Warning plural noun %s to singular verb %s in %s\r\n",wordStarts[subject],wordStarts[i],buffer);
					if (subject && posValues[subject] == PRONOUN_BITS && posValues[i] == VERB_PRESENT && !(lcSysFlags[i] & PRONOUN_SINGULAR)) Log(STDUSERLOG,"*** Warning singular pronoun %s to plural verb %s in %s\r\n",wordStarts[subject],wordStarts[i],buffer);
					if (subject && posValues[subject] == PRONOUN_BITS && posValues[i] == VERB_PRESENT_3PS && lcSysFlags[i] & PRONOUN_SINGULAR) Log(STDUSERLOG,"*** Warning plural pronoun %s to singular verb %s in %s\r\n",wordStarts[subject],wordStarts[i],buffer);
					subject = 0;
				}
				if (roles[i] & (SUBJECT2|MAINSUBJECT|OBJECT2|MAINOBJECT|INDIRECTOBJECT2|MAININDIRECTOBJECT) && posValues[i] & NOUN_SINGULAR && originalLower[i] && !(originalLower[i]->properties & (NOUN_MASS|PRONOUN_BITS)) )
				{
					unsigned int det;
					if (!IsDeterminedNoun(i,det)) Log(STDUSERLOG,"*** Warning undetermined noun %s in %s\r\n",wordStarts[i],buffer);
				}
			}
		}
	}
	fclose(in);
	FreeBuffer();
	float percent = ((float)right * 100) /total;
	int val = (int)percent;
	float percent1 = ((float)ambigItems * 100) /total;
	int val1 = (int)percent1;
	Log(STDUSERLOG,"right:%d wrong:%d total:%d percent:%d sentences:%d  ambig:%d percent:%d counts:%d\r\n",right,total-right,total,val,sentences,ambigItems, val1, totalAmbigs);
}

static void C_PennNoun(char* file)
{
	char word[MAX_WORD_SIZE];
	file = ReadCompiledWord(file,word);
	char filename[MAX_WORD_SIZE];
	if (*word) sprintf(filename,"REGRESS/PENNTAGS/%s.txt",word);
	else strcpy(filename,"REGRESS/PENNTAGS/penn.txt");
	FILE* in = FopenReadOnly(filename);
	if (!in) return;
	char* buffer = AllocateBuffer();
	char tags[MAX_SENTENCE_LENGTH][20];
	char tokens[MAX_SENTENCE_LENGTH][100];
	unsigned int len;
	while (ReadALine(readBuffer,in))
	{
		char* at = buffer;
		*at = 0;
		char word[MAX_WORD_SIZE];
		char* ptr = SkipWhitespace(readBuffer);
		if (!*ptr || *ptr == '#') continue;
		len = 0;
		while (ptr && *ptr)
		{
			ptr = ReadCompiledWord(ptr,word);
			if (!*word) break;
			char* sep = strrchr(word,'/'); // find last one (there might be \/  when they actually want token
			if (!sep)
			{
				printf("Failed %s\r\n",readBuffer);
				break;
			}
			*sep = 0;
			++len;

			// recode quotes (opening and closing)
			if (*word == '`' && word[1] == '`') strcpy(word,"\"");
			if (*word == '\'' && word[1] == '\'') strcpy(word,"\"");
			// recode \/ and its ilk
			char word1[MAX_WORD_SIZE];
			strcpy(word1,word);
			char* sep1;
			while ((sep1 = strchr(word1,'\\'))) memmove(sep1,sep1+1,strlen(sep1)+1);

			strcpy(tokens[len],word1);
			strcat(at,word1);
			at += strlen(at);
			strcat(at++," ");
			strcpy(tags[len],sep+1); // what we expect
		}
		if (len == 0) continue; // on to next

		*at = 0;
		for (unsigned int i = 1; i <= len; ++i) // match off the pos values we understand. all others are wrong by definition
		{
			char* sep = strchr(tags[i],'|');
			if (sep) *sep = 0;

			if (!stricmp(tags[i],"NN")) // found a noun, look backwards...
			{
				if (!strnicmp(tags[i+1],"NN",2)) continue;	 // noun follows us. he must be determined instead
				for (unsigned int x = i-1; x >= 1; --x)
				{
					if (!stricmp(tokens[x],",")) break;	 // immediately after comma may be appositive "Bob, dog of my dreams
					if (!stricmp(tokens[x],"of")) break;	 // can say of xxx always as in type of dog
					if (!stricmp(tags[x],"CC")) break;	// assume guy before is determeined
					if (!stricmp(tags[x],"DT")) break;	// it is determined
					if (!stricmp(tags[x],"POS")) break;	// is owned
					if (tags[x][0] == 'N') continue;	// it is joined noun.
					if (*tags[x] == 'J') continue; // adj
					if (!stricmp(tags[x],"PRP$")) break; // word after conjunct
					WORDP D = FindWord(tokens[i]);
					if (D && D->properties & NOUN_MASS)
						break;
					if (IsUpperCase(*tokens[i])) break; // actually not NN
					if (D && !IsAlpha(*D->word)) break;	 // not a normal word

					if (D && D->properties & NOUN_NODETERMINER)
						break;
					Log(STDUSERLOG,"%s: %s %s  %s\r\n",tokens[i],tags[x],tokens[x], buffer); // unxpected
					break;
	
				}
			}
		}
	}
	fclose(in);
	FreeBuffer();
}

static void C_VerifyPos(char* file)
{
	if (!*file) file = "REGRESS/postest.txt";
	FILE* in = FopenReadOnly(file);
	if (!in) return;

#ifdef WIN32
	unsigned int start = GetTickCount();
#endif
	
	prepareMode = POSVERIFY_MODE;
	uint64 oldtokencontrol = tokenControl;
	tokenControl =  DO_PARSE | DO_ESSENTIALS| DO_CONTRACTIONS | DO_BRITISH  | STRICT_CASING | DO_NUMBER_MERGE | DO_PROPERNAME_MERGE; 
	unsigned int tokens = 0;
	unsigned int count = 0;
	unsigned int fail = 0;
	char sentence[MAX_WORD_SIZE];
	while (ReadALine(readBuffer,in))
	{
		char* ptr =  SkipWhitespace(readBuffer);
		if (!strnicmp(ptr,"#END",3)) break;
		if (!*ptr || *ptr == '#') continue;
		// debug command
		if (*ptr == ':' && IsAlpha(ptr[1]))
		{
			char output[MAX_WORD_SIZE];
			DoCommand(ptr,output);
			continue;
		}
		ReturnToFreeze(); // dont let dictionary tamper affect this. A problem with ANY multiple sentence input...
	
		++count;
		strcpy(sentence,ptr);
		PrepareSentence(sentence,true,true);
		tokens += wordCount;
		char parseForm[MAX_WORD_SIZE * 5];
		*parseForm = 0;
		char liveParse[MAX_WORD_SIZE * 5];
		*liveParse = 0;
		strcpy(liveParse,DumpAnalysis(1,wordCount,posValues,"Parsed POS",false,true));
		TrimSpaces(liveParse,false);
		while (ReadALine(readBuffer,in))
		{
			char* start = SkipWhitespace(readBuffer);
			if (!*start || *start == '#') continue;
			if (!strnicmp(start,"Parsed",6)) 
			{
				strcpy(parseForm,TrimSpaces(start,false)); 
				break;
			}
		}


		if (strcmp(parseForm,liveParse))
		{
			size_t i;
			for (i = 0; i < strlen(parseForm); ++i)
			{
				if (parseForm[i] != liveParse[i]) break;
				if (!parseForm[i] || !liveParse[i]) break;
			}
			while (i && parseForm[--i] != '(');	// find start backwards
			if (i) --i;
			while (i && parseForm[--i] != ' ');	
			char hold[BIG_WORD_SIZE];
			strcpy(hold,parseForm+i);
			parseForm[i] = 0;
			strcat(parseForm,"\r\n--> ");
			strcat(parseForm,hold);
			char hold1[BIG_WORD_SIZE];
			*hold1 = 0;
			size_t len = strlen(liveParse);
			if ( len > i) strcpy(hold1,liveParse+i);
			liveParse[i] = 0;
			strcat(liveParse,"\r\n--> ");
			strcat(liveParse,hold1);
			Log(STDUSERLOG,"\r\nMismatch at %d: %s\r\n",count,sentence);
			Log(STDUSERLOG,"          got: %s\r\n",liveParse);
			Log(STDUSERLOG,"         want: %s\r\n",parseForm);
			int old = trace;
			trace |= TRACE_POS;
			PrepareSentence(sentence,true,true);
			trace = old;
			++fail;
		}
	}

	fclose(in);

#ifdef WIN32
	Log(STDUSERLOG,"%d sentences tested, %d failed doing %d tokens in %d ms\r\n",count,fail,tokens, GetTickCount() - start);
#else
	Log(STDUSERLOG,"%d sentences tested, %d failed.\r\n",count,fail);
#endif
	tokenControl = oldtokencontrol;
	prepareMode = 0; 
}

static void C_TimePos(char* file) // how many wps for pos tagging
{
	if (!*file) file = "RAWDICT/postiming.txt";
	FILE* in = fopen(file,"rb");
	if (!in) return;
	prepareMode = POSTIME_MODE;
	uint64 oldtokencontrol = tokenControl;
	tokenControl = DO_PARSE | DO_SUBSTITUTE_SYSTEM  | DO_NUMBER_MERGE | DO_PROPERNAME_MERGE ;
	posTiming = 0;
	unsigned int words = 0;
	while (ReadALine(readBuffer,in))
	{
		char* ptr =  SkipWhitespace(readBuffer);
		if (!*ptr || *ptr == '#') continue;
		if (!strnicmp(ptr,"Tagged",6)) continue; 
		PrepareSentence(ptr,true,true);
		words += wordCount;
	}

	fclose(in);
	float wps = (float)words / ((float)posTiming/(float)1000.0);
	Log(STDUSERLOG,"%d words tagged in %d ms wps: %d.\r\n",words,posTiming, (unsigned int) wps);
	tokenControl = oldtokencontrol;
	prepareMode = 0; 
}

static void C_VerifySpell(char* file) // test spell checker against a file of entries  wrong-spell rightspell like livedata/spellfix.txt
{ 
	FILE* in = fopen(file,"rb");
	if (!in) return;
	unsigned int right = 0;
	unsigned int wrong = 0;
	while (ReadALine(readBuffer,in))
	{
		// pull out the wrong and right words
		char wrongWord[MAX_WORD_SIZE];
		char rightWord[MAX_WORD_SIZE];
		char* ptr = SkipWhitespace(readBuffer);
		if (*ptr == 0 || *ptr == '#' || *ptr == '<' || *ptr == '\'' || IsDigit(*ptr)) continue; // unusual stuff
		ptr = ReadCompiledWord(ptr,wrongWord);
		if (strchr(wrongWord,'>') || strchr(wrongWord,'.') || strchr(wrongWord,',')) continue;  // unusual stuff
		ReadCompiledWord(ptr,rightWord);
		if (!*rightWord || strchr(rightWord,'+') || *rightWord == '~'  || *rightWord == '%') continue;  // unusual stuff
		
		WORDP D = FindWord(wrongWord);
		if (D && D->properties & (PART_OF_SPEECH|FOREIGN_WORD)) // already has a meaning
		{
			Log(STDUSERLOG,"%s already in dictionary\r\n",wrongWord);
			continue;
		}

		char* fix = SpellFix(wrongWord,1,PART_OF_SPEECH); 
		if (fix && !strcmp(fix,rightWord)) ++right;
		else
		{
			Log(STDUSERLOG,"%s wanted %s but got %s\r\n",wrongWord,rightWord,fix);
			++wrong;
		}
	}

	fclose(in);
	Log(STDUSERLOG,"Right:%d  Wrong:%d\r\n",right,wrong);
}

static void VerifySubstitutes1(WORDP D, uint64 unused)
{
	if (!(D->internalBits & HAS_SUBSTITUTE)) return;

	char expectedText[MAX_WORD_SIZE];
	char resultText[MAX_WORD_SIZE];
	*readBuffer = 0;
	unsigned int n;

	//   see if word has start or end markers. Remove them.
	bool start = false;
	if (*D->word == '<')
	{
		start = true;
		n = BurstWord(D->word+1);
	}
	else n = BurstWord(D->word);
	bool end = false;
	char* last = GetBurstWord(n-1);
	size_t len = strlen(last);
	if (last[len-1] == '>')
	{
		end = true;
		last[len-1] = 0;
	}

	//   now composite an example, taking into account start and end markers
	unsigned int i;
	if (!start) strcat(readBuffer,"x ");	//   so match is not at start
	for (i = 0; i < n; ++i)
	{
		strcat(readBuffer,GetBurstWord(i));
		strcat(readBuffer," ");
	}
	if (!end) strcat(readBuffer,"x "); //   so match is not at end

	//   generate what it results in
	PrepareSentence(readBuffer,true,true);

	*resultText = 0;
	if (!end) --wordCount;	//   remove the trailing x
	for (i = 1; i <= wordCount; ++i) //   recompose what tokenize got
	{
		if (!start && i == 1) continue;	//   remove the leading x
		strcat(resultText,wordStarts[i]);
		strcat(resultText," ");
	}

	WORDP S = GetSubstitute(D);
	if (!S && wordCount == 0) return;	//   erased just fine
	if (!S) Log(STDUSERLOG,"Substitute failed: %s didn't erase itself, got %s\r\n",D->word,resultText);
	else
	{
		strcpy(expectedText,S->word);
		strcat(expectedText," ");	//   add the trailing blank we get from concats above
		char* at;
		while ((at = strchr(expectedText,'+'))) *at = ' '; //   break up answer
		if (!stricmp(resultText,expectedText)) return;	//   got what was expected
		Log(STDUSERLOG,"Substitute failed: %s got %s not %s\r\n",D->word,resultText,expectedText);
	}
}

static void C_VerifySubstitutes(char* ptr) //   see if substitutes work...
{
	WalkDictionary(VerifySubstitutes1);
}

/////////////////////////////////////////////////////
/// SYSTEM CONTROL COMMANDS
/////////////////////////////////////////////////////

static void C_Bot(char* name)
{
	MakeLowerCopy(computerID,name);
	computerIDwSpace[0] = ' ';
	MakeLowerCopy(computerIDwSpace+1,computerID);
	strcat(computerIDwSpace," "); // trailing space
	int BOMvalue = -1; // get prior value
	char oldc;
	int oldCurrentLine;	
	BOMAccess(BOMvalue, oldc,oldCurrentLine); // copy out prior file access and reinit user file access
	ReadUserData(GetFileRead(loginID,computerID));
	BOMAccess(BOMvalue, oldc,oldCurrentLine); // restore old BOM values
	wasCommand = BEGINANEW;	// make system save revised user file
}


static void C_Build(char* input)
{
#ifndef DISCARDSCRIPTCOMPILER
	char oldlogin[MAX_WORD_SIZE];
	char oldbot[MAX_WORD_SIZE];
	char oldbotspace[MAX_WORD_SIZE];
	char oldloginname[MAX_WORD_SIZE];
	strcpy(oldlogin,loginID);
	strcpy(oldbot,computerID);
	strcpy(oldbotspace,computerIDwSpace);
	strcpy(oldloginname,loginName);
	char file[MAX_WORD_SIZE];
	char control[MAX_WORD_SIZE];
	input = ReadCompiledWord(input,file);
	input = SkipWhitespace(input);
	int spell = PATTERN_SPELL;
	bool reset = false;
	while (*input) 
	{
		input = ReadCompiledWord(input,control);
		input = SkipWhitespace(input);
		if (!stricmp(control,"nospell")) spell = NO_SPELL;
		else if (!stricmp(control,"outputspell")) spell = OUTPUT_SPELL;
		else if (!stricmp(control,"reset")) reset = true;
	}
	size_t len = strlen(file);
	if (!*file) Log(STDUSERLOG,"missing build label");
	else
	{
		sprintf(logFilename,"USERS/build%s_log.txt",file); //   all data logged here by default
		FILE* in = FopenUTF8Write(logFilename);
		if (in) fclose(in);
		char word[MAX_WORD_SIZE];
		sprintf(word,"files%s.txt",file);
		if (ReadTopicFiles(word,(file[len-1] == '0') ? BUILD0 : BUILD1,spell)) 
		{
			if (!stricmp(computerID,"anonymous")) *computerID = 0;	// use default
			CreateSystem();
			if (reset) systemReset = true;
		}
	}
	// refresh current user data lost when we rebooted the system
	strcpy(loginID,oldlogin);
	strcpy(computerID,oldbot);
	strcpy(computerIDwSpace,oldbotspace);
	strcpy(loginName,oldloginname);
	
#endif
}  

static void C_Quit(char* input)
{
	Log(STDUSERLOG,"Exiting ChatScript via Quit\r\n");
	quitting = true;
}

static void C_Restart(char* input)
{
	trace = 0;
	if (*input) 
	{
		MakeUpperCopy(language,input);
		NoteLanguage(); // set default is most recent persona dictionary
	}
	ClearUserVariables();
	CloseSystem();
	ReadParams();	// default params associated with language form
	CreateSystem();
	InitStandalone();
	if (!server)
	{
		printf("\r\nEnter user name: ");
		ReadALine(inBuffer,stdin);
		printf("\r\n");
		echo = false;
		PerformChat(inBuffer,computerID,"",callerIP,outBuffer);
	}
	else Log(STDUSERLOG,"System restarted\r\n");
}

static void C_User(char* username)
{
	printf("\r\nEnter input: ");
	ReadALine(inBuffer,stdin);
	PerformChat(SkipWhitespace(username),computerID,inBuffer,callerIP,outBuffer);
}

///////////////////////////////////////////////
/// SERVER COMMANDS
///////////////////////////////////////////////

static void C_Flush(char* x)
{
	FlushCache();
}


///////////////////////////////////////////////////
/// WORD INFORMATION
///////////////////////////////////////////////////

static MEANING FindChild(MEANING who,int n)
{ // GIVEN SYNSET
    FACT* F = GetObjectHead(who);
	unsigned int index = Meaning2Index(who);
    while (F)
    {
        FACT* at = F;
        F = GetObjectNext(F);
        if (at->verb != Mis) continue;
		if (index && at->object  != who) continue;	// not us
        if (--n == 0)   return at->subject;
    }
    return 0;
} 

static void DrawDownHierarchy(MEANING T,unsigned int depth,unsigned int limit,bool sets)
{
	if (sets) limit = 1000;
    if (depth >= limit || !T) return;
    WORDP D = Meaning2Word(T);
	if (D->inferMark == inferMark) return;	

	D->inferMark = inferMark;
    unsigned int index = Meaning2Index(T);
    unsigned int size = GetMeaningCount(D);
    if (!size) size = 1; 

	if (*D->word == '~') // show set members
	{
		if (D->internalBits & HAS_EXCLUDE) MarkExclude(D);

		FACT* F = GetObjectHead(D);
		unsigned int i = 0;
		while (F)
		{
			if (F->verb == Mmember)
			{
				MEANING M = F->subject;
				WORDP S = Meaning2Word(M);
				if (S->inferMark != inferMark)
				{
					if (*S->word == '~' && (depth + 1) < limit) // expand to lower level
					{
						Log(STDUSERLOG,"\r\n");
						for (unsigned int j = 0; j < (depth*2); ++j) Log(STDUSERLOG," "); // depth inclusive because tabbing for next level
						Log(STDUSERLOG,"%s ",WriteMeaning(M)); // simple member
						DrawDownHierarchy(M,depth+1,limit,sets);
						Log(STDUSERLOG,"\r\n");
						for (unsigned int j = 0; j < (depth*2); ++j) Log(STDUSERLOG," ");
					}
					else Log(STDUSERLOG,"%s ",WriteMeaning(M)); // simple member
					if ( ++i >= 10)
					{
						Log(STDUSERLOG,"\r\n");
						for (unsigned int j = 0; j < (depth*2); ++j) Log(STDUSERLOG," ");
						i = 0;
					}
				}
			}
			F = GetObjectNext(F);
		}
		return;
	}

    for (unsigned int k = 1; k <= size; ++k) //   for each meaning of this dictionary word
    {
        if (index)
		{
			if (k != index) continue; //   not all, just one specific meaning
			T = GetMaster(GetMeaning(D,k)); 
		}
		else 
		{
			if (GetMeaningCount(D)) T = GetMaster(GetMeaning(D,k));
			else T = MakeMeaning(D); //   did not request a specific meaning, look at each in turn
		}

        //   for the current T meaning
		char* gloss = GetGloss(Meaning2Word(T),Meaning2Index(T));
		if (!gloss) gloss = "";
        if (depth++ == 0 && size)  Log(STDUSERLOG,"\r\n<%s.%d => %s %s\r\n",D->word,k,WriteMeaning(T),gloss); //   header for this top level meaning is OUR entry and MASTER
        int l = 0;
        while (++l) //   find the children of the meaning of T
        {
			MEANING child = (limit >= 1) ? FindChild(T,l) : 0; //   only headers sought
            if (!child) break;
			if (sets) //   no normal words, just a set hierarchy
			{
				WORDP D = Meaning2Word(child);
				if (*D->word != '~') continue;
			}

			 //   child and all syn names of child
            for (unsigned int j = 0; j <= (depth*2); ++j) Log(STDUSERLOG," "); 
   			gloss = GetGloss(Meaning2Word(child),Meaning2Index(child));
			if (!gloss) gloss = "";
			Log(STDUSERLOG,"%d. %sz %s\r\n",depth,WriteMeaning(child),gloss);
			DrawDownHierarchy(child,depth,limit,sets);
        } //   end of children for this value
        --depth;
    }
}

static void DumpConceptPath(MEANING T) // once you are IN a set, the path can be this
{
	int k = 0;
	while (++k)
	{
		MEANING parent = FindSetParent(T,k); //   next set we are member of
		if (!parent)  break;

		WORDP D = Meaning2Word(parent);	// topic or concept
		if (D->internalBits & HAS_EXCLUDE) // prove no violation
		{
			FACT* F = GetObjectHead(D);
			while (F)
			{
				if (F->verb == Mexclude)
				{
					WORDP E = Meaning2Word(F->subject);
					if (E->inferMark == inferMark) break;
				}
				F = GetObjectNext(F);
			}
			if (F) continue;	// exclusion in effect
		}
		WORDP E = Meaning2Word(parent);
		if (E->inferMark != inferMark) 
		{
			E->inferMark = inferMark;
			*meaningLimit++ = parent;
		}
	}
}

static void ShowConcepts(MEANING T)
{
 	MEANING parent;
	unsigned int count;
	WORDP E = Meaning2Word(T);
	unsigned int index = Meaning2Index(T);
    if (*E->word != '~' && index == 0)  // at a base word
	{
		DumpConceptPath(T); // what is it a member of direclty

		//   then do concepts based on this word...
		unsigned int size = GetMeaningCount(E);
		if (!size) size = 1;	//   always at least 1, itself
		//   immediate sets of this base
		for  (unsigned int k = 1; k <= size; ++k)
		{
			if (index && k != index) continue; //   not all, just correct meaning

			//   get meaningptr spot facts are stored (synset head)
			if (!GetMeaningCount(E) ) T = MakeMeaning(E);	//   a generic since we have no meanings
			else 
			{
				if (GetMeaning(E,k) & SYNSET_MARKER) T = MakeMeaning(E,k); // we are master
				else T = GetMaster(GetMeaning(E,k)) | (GetMeaning(E,k) & TYPE_RESTRICTION); 
			}
			DumpConceptPath(T); 
		}

		//   up one wordnet hierarchy based on each meaning
		for  (unsigned int k = 1; k <= size; ++k)
		{
			if (index && k != index) continue; //   not all, just correct meaning

			//   get meaningptr spot facts are stored (synset head)
			if (!GetMeaningCount(E) ) T = MakeMeaning(E);	//   a generic since we have no meanings
			else 
			{
				if (GetMeaning(E,k) & SYNSET_MARKER) T = MakeMeaning(E,k); // we are master
				else T = GetMaster(GetMeaning(E,k)) | (GetMeaning(E,k) & TYPE_RESTRICTION); 
			}
			count = 0;
			while ((parent =  FindSynsetParent(T,count++))) ShowConcepts(parent); // immediate wordnet hierarchy
		}
	}
	else if (index != 0) //    always synset nodes above the base
	{
		count = 0;
		while ((parent =  FindSynsetParent(T,count++))) DumpConceptPath(parent); // sets of next parent level up
		count = 0;
		while ((parent =  FindSynsetParent(T,count++))) ShowConcepts(parent); // and follow next parent level up
	}
	else  DumpConceptPath(T); // track this synset to the next level
}

static void C_Concepts(char* input)
{
	char word[MAX_WORD_SIZE];
	ReadCompiledWord(input,word);
	MEANING M = ReadMeaning(word,false);
	if (!M) return;
	M = GetMaster(M);
	Log(STDUSERLOG,"%s: ",word);
	NextinferMark();

	meaningList = (MEANING*) AllocateBuffer();
	meaningLimit = meaningList;

	// check substitutes
	WORDP D = Meaning2Word(M);
	if (D->internalBits & HAS_SUBSTITUTE)
	{
		D = GetSubstitute(D);
		if (*D->word == '~')  *meaningLimit++ = MakeMeaning(D); 
	}

	char alter[MAX_WORD_SIZE];
	sprintf(alter,"<%s",word);
	D = FindWord(alter);
	if (D && D->internalBits & HAS_SUBSTITUTE)
	{
		D = GetSubstitute(D);
		if (*D->word == '~')   *meaningLimit++ = MakeMeaning(D); 
	}
	
	sprintf(alter,"<%s>",word);
	D = FindWord(alter);
	if (D && D->internalBits & HAS_SUBSTITUTE)
	{
		D = GetSubstitute(D);
		if (*D->word == '~')   *meaningLimit++ = MakeMeaning(D); 
	}

	 *meaningLimit++ = M;

	// check concepts and topics
	while (meaningList < meaningLimit) 
	{
		WORDP E = Meaning2Word(*meaningList);
		if (*E->word == '~') Log(STDUSERLOG,(E->systemFlags & TOPIC) ? (char*) "T%s " : (char*) "%s ",E->word);
		ShowConcepts(*meaningList++);
	}
	Log(STDUSERLOG,"\n");

	FreeBuffer();
}

static void C_Down(char* input)
{
	char word[MAX_WORD_SIZE];
	input = ReadCompiledWord(input,word);
	input = SkipWhitespace(input);
    int limit = atoi(input);
    if (!limit) limit = 1; //   top 2 level only (so we can see if it has a hierarchy)
	input = SkipWhitespace(input);
	NextinferMark();
	MEANING M = ReadMeaning(word,false);
	M = GetMaster(M);
    DrawDownHierarchy(M,1,limit+1,!stricmp(input,"sets"));
	Log(STDUSERLOG,"\r\n");
}

static void FindXWord(WORDP D, uint64 pattern)
{
	if (D->word && MatchesPattern(D->word,(char*) pattern)) Log(STDUSERLOG,"%s\r\n",D->word);
}

static void C_FindWords(char* input)
{
	WalkDictionary(FindXWord,(uint64) input);
}
static bool TestSetPath(MEANING T,unsigned int depth) // once you are IN a set, the path can be this
{
	WORDP D = Meaning2Word(T);
	if (D->inferMark == inferMark || depth > 100) return false;
	D->inferMark = inferMark;
	int k = 0;
	while (++k)
	{
		MEANING parent = FindSetParent(T,k); //   next set we are member of
		if (!parent)  break;
		WORDP D = Meaning2Word(parent);	// topic or concept
		if (D == topLevel) return true;
		if (TestSetPath(parent,depth+1)) return true; // follow up depth first
	}
	return false;
}

static bool TestUpHierarchy(MEANING T,int depth)
{
    if (!T) return false;

    WORDP E = Meaning2Word(T);
	if (E == topLevel) return true;
	unsigned int index = Meaning2Index(T);
    if (depth == 0)  
	{
		if (TestSetPath(T,depth)) return true;	
		if (*E->word == '~') return false;	// not a word

		//   then do concepts based on this word...
		unsigned int size = GetMeaningCount(E);
		if (!size) size = 1;	//   always at least 1, itself

		//   draw wordnet hierarchy based on each meaning
		for  (unsigned int k = 1; k <= size; ++k)
		{
			if (index && k != index) continue; //   not all, just correct meaning

			//   get meaningptr spot facts are stored (synset head)
			if (!GetMeaningCount(E) ) T = MakeMeaning(E);	//   a generic since we have no meanings
			else 
			{
				if (GetMeaning(E,k) & SYNSET_MARKER) T = MakeMeaning(E,k); // we are master
				else T = GetMaster(GetMeaning(E,k)); 
			}
			if (TestSetPath(T,depth)) return true;
			unsigned int count = 0;
			MEANING parent;
			while ((parent = FindSynsetParent(T,count++)))
			{
				//   walk wordnet hierarchy
				if (TestSetPath(parent,depth)) return true;
				TestUpHierarchy(parent,depth+1); //   we find out what sets PARENT is in (will be none- bug)
			}
		}
	}
	else //    always synset nodes
	{
		E->inferMark = inferMark; // came this way
		unsigned int count = 0;
		MEANING parent;
		while ((parent = FindSynsetParent(T,count++)))
		{
			//   walk wordnet hierarchy
			if (TestSetPath(parent,depth)) return true;
			TestUpHierarchy(parent,depth+1); //   we find out what sets PARENT is in (will be none- bug)
		}
	}
	return false;
}

static void TestSet(WORDP D,uint64 flags)
{
	if (!(D->properties & flags) || !(D->systemFlags & AGE_LEARNED)) return; // only want simple words to be tested
	MEANING M = MakeMeaning(D);
	NextinferMark();
	if (TestUpHierarchy(M,0)) return;
	Log(STDUSERLOG,"%s\r\n",D->word);
}

static void C_Nonset(char* buffer)
{
	char type[MAX_WORD_SIZE];
	buffer = ReadCompiledWord(buffer,type);
	uint64 kind  = FindValueByName(type);
	if (!kind) return;
	WORDP D = FindWord(buffer);
	topLevel = D;
	WalkDictionary(TestSet,kind);
}

static void C_HasFlag(char* buffer)
{
	bool notflag = false;
	char type[MAX_WORD_SIZE];
	buffer = ReadCompiledWord(buffer,type);
	WORDP D = FindWord(type); // name of set
	buffer = SkipWhitespace(buffer);
	if (*buffer == '!')
	{
		notflag = true;
		++buffer;
	}
	buffer = ReadCompiledWord(buffer,type);
	uint64 flag  = FindValue2ByName(type); // flag to find or !find
	FACT* F = GetObjectHead(D);
	while (F)
	{
		if (F->verb == Mmember)
		{
			WORDP S = Meaning2Word(F->subject);
			if (S->systemFlags & flag)
			{
				if (!notflag) Log(STDUSERLOG,"%s has %s\r\n",S->word,type);
			}
			else
			{
				if (notflag) Log(STDUSERLOG,"%s lacks %s\r\n",S->word,type);
			}
		}
		F = GetObjectNext(F);
	}
}

static bool HitTest(WORDP D, WORDP set) // can we hit this
{
	if (D->inferMark == inferMark) return false;	// been here already
	D->inferMark = inferMark;
	FACT* F = GetSubjectHead(D);
	while (F)
	{
		if (F->verb == Mmember)
		{
			WORDP E = Meaning2Word(F->object);
			if (E == set) return true;
			if (*E->word == '~') 
			{
				if (HitTest(E,set)) return true;
			}
		}
		F = GetSubjectNext(F);
	}

	return false;
}

static void C_Overlap(char* buffer)
{
	char set1[MAX_WORD_SIZE];
	char set2[MAX_WORD_SIZE];
	buffer = ReadCompiledWord(buffer,set1);
	WORDP E = FindWord(set1);
	if (!E || E->word[0] != '~')
	{
		printf("no such set %s\r\n",set1);
		return;
	}
	buffer = ReadCompiledWord(buffer,set2);
	WORDP D = FindWord(set2);
	if (!E || E->word[0] != '~')
	{
		printf("no such set %s\r\n",set2);
		return;
	}
	Log(STDUSERLOG,"These members of %s are also in %s:\r\n",set1,set2);

	// walk members of set1, seeing if they intersect set2
	FACT* F = GetObjectHead(E);
	while (F)
	{
		E = Meaning2Word(F->subject);
		if (F->verb == Mmember && *E->word != '~') // see if word is member of set2
		{
			NextinferMark();
			if (HitTest(E,D)) Log(STDUSERLOG,"%s\r\n",E->word);
		}
		F = GetObjectNext(F);
	}

}

static bool DumpSetPath(MEANING T,unsigned int depth) // once you are IN a set, the path can be this
{
	int k = 0;
	if (depth > 20)
	{
		printf("Hierarchy too deep-- recursive?");
		return false;
	}	
	while (++k)
	{
		MEANING parent = FindSetParent(T,k); //   next set we are member of
		if (!parent)  break;

		WORDP D = Meaning2Word(parent);	// topic or concept
		if (D->internalBits & HAS_EXCLUDE) // prove no violation
		{
			FACT* F = GetObjectHead(D);
			while (F)
			{
				if (F->verb == Mexclude)
				{
					WORDP E = Meaning2Word(F->subject);
					if (E->inferMark == inferMark) break;
				}
				F = GetObjectNext(F);
			}
			if (F) continue;	// exclusion in effect
		}

        Log(STDUSERLOG,"    ");
		for (unsigned int j = 0; j < depth; ++j) Log(STDUSERLOG,"   "); 
		WORDP E = Meaning2Word(parent);
		if (E->systemFlags & TOPIC) Log(STDUSERLOG,"T%s \r\n",WriteMeaning(parent)); 
		else Log(STDUSERLOG,"%s \r\n",WriteMeaning(parent)); 
		if (!DumpSetPath(parent,depth+1)) return false; // follow up depth first
	}
	return true;
}

static bool DumpUpHierarchy(MEANING T,int depth)
{
    if (!T) return true;
	if (depth > 20)
	{
		printf("Hierarchy too deep-- recursive?");
		return false;
	}

    WORDP E = Meaning2Word(T);
	E->inferMark = inferMark; // came this way
	unsigned int index = Meaning2Index(T);
    if (depth == 0)  
	{
		Log(STDUSERLOG,"\r\nFor %s:\r\n",E->word); 
		Log(STDUSERLOG," Set hierarchy:\r\n"); 

		if (!DumpSetPath(T,depth)) return false;	
		if (*E->word == '~') return true;	// we are done, it is not a word

		//   then do concepts based on this word...
		unsigned int size = GetMeaningCount(E);
		if (!size) size = 1;	//   always at least 1, itself
		Log(STDUSERLOG," Wordnet hierarchy:\r\n"); 

		//   draw wordnet hierarchy based on each meaning
		for  (unsigned int k = 1; k <= size; ++k)
		{
			if (index && k != index) continue; //   not all, just correct meaning

			//   get meaningptr spot facts are stored (synset head)
			if (!GetMeaningCount(E) ) T = MakeMeaning(E);	//   a generic since we have no meanings
			else 
			{
				if (GetMeaning(E,k) & SYNSET_MARKER) T = MakeMeaning(E,k) | (GetMeaning(E,k) & TYPE_RESTRICTION); // we are master
				else T = GetMaster(GetMeaning(E,k)) | (GetMeaning(E,k) & TYPE_RESTRICTION); 
			}
			WORDP D1 = Meaning2Word(T);
			Log(STDUSERLOG,"  ");
			Log(STDUSERLOG,"%s~%d:",E->word,k);
			if (T & NOUN) Log(STDUSERLOG,"N   ");
			else if (T & VERB) Log(STDUSERLOG,"V   ");
			else if (T & ADJECTIVE) Log(STDUSERLOG,"Adj ");
			else if (T & ADVERB) Log(STDUSERLOG,"Adv ");
			else if (T & PREPOSITION) Log(STDUSERLOG,"Prep ");
			char* gloss = GetGloss(D1,Meaning2Index(T));
			if (gloss) Log(STDUSERLOG," %s ",gloss);
			Log(STDUSERLOG,"\r\n"); 
		
			if (!DumpSetPath(T,depth)) return false;
			unsigned int count = 0;
			MEANING parent;
			while ((parent =  FindSynsetParent(T,count++)))
			{
				//   walk wordnet hierarchy
				WORDP P = Meaning2Word(parent);
				Log(STDUSERLOG,"   ");
				for (int j = 0; j < depth; ++j) Log(STDUSERLOG,"   "); 
				Log(STDUSERLOG," is %s ",WriteMeaning(parent)); //   we show the immediate parent
				char* gloss = GetGloss(P,Meaning2Index(parent));
				if (gloss) Log(STDUSERLOG," %s ",gloss);
				Log(STDUSERLOG,"\r\n"); 
				if (!DumpSetPath(parent,depth)) return false;
				if (!DumpUpHierarchy(parent,depth+1)) return false; //   we find out what sets PARENT is in (will be none- bug)
			}
		}
	}
	else //    always synset nodes
	{
		unsigned int count = 0;
		MEANING parent;
		while ((parent =  FindSynsetParent(T,count++)))
		{
			//   walk wordnet hierarchy
			WORDP P = Meaning2Word(parent);
			unsigned int index = Meaning2Index(parent);
			Log(STDUSERLOG,"   ");
			for (int j = 0; j < depth; ++j) Log(STDUSERLOG,"   "); 
			Log(STDUSERLOG," is %s",WriteMeaning(parent)); //   we show the immediate parent
			char* gloss = GetGloss(P,index);
			if (gloss) Log(STDUSERLOG," %s ",gloss);
			Log(STDUSERLOG,"\r\n");
			if (!DumpSetPath(parent,depth)) return false;
			if (!DumpUpHierarchy(parent,depth+1)) return false; //   we find out what sets PARENT is in (will be none- bug)
		}
	}
	return true;
}

static void C_Up(char* input)
{
 	char word[MAX_WORD_SIZE];
	NextinferMark();
	ReadCompiledWord(input,word);
	MEANING M = ReadMeaning(word,false);
	M = GetMaster(M);
	DumpUpHierarchy(M,0);
}

static void C_Word(char* input)
{
	char word[MAX_WORD_SIZE];
	char junk[MAX_WORD_SIZE];
	while(ALWAYS)
	{
		input = ReadCompiledWord(input,word);
		if (!*word) break;
		input = SkipWhitespace(input);
		int limit= 0;
		if (IsDigit(*input))
		{
			input = ReadCompiledWord(input,word);
			limit = atoi(junk);
		}
		DumpDictionaryEntry(word,limit);  
	}
} 	


static void WordDump(WORDP D,uint64 flags)
{
}

static void C_WordDump(char* input)
{
	WalkDictionary(WordDump,0);
#ifdef JUNK
	WORDP D = FindWord(input);
	if (!D) 
	{
		Log(STDUSERLOG,"No such set %s\r\n",input);
		return;
	}
	FACT* F = GetObjectHead(D);
	while (F)
	{
		if (F->verb == Mmember)
		{
			if (D->systemFlags & VERB_TAKES_VERBINFINITIVE)
				Log(STDUSERLOG,"redundant %s\r\n",D->word);
		}
		F = GetObjectNext(F);
	}
#endif
} 	

//////////////////////////////////////////////////
/// SYSTEM INFO
/////////////////////////////////////////////////

static void C_Commands(char* x)
{
	int i = 0;
	CommandInfo *routine;
	while ((routine = &commandSet[++i]) && routine->word) Log(STDUSERLOG,"%s - %s\r\n",routine->word,routine->comment); // linear search
}

static void C_Definition(char* x)
{
	char name[MAX_WORD_SIZE];
	ReadCompiledWord(x,name);
	WORDP D = FindWord(name);
	if (!D || !(D->systemFlags & FUNCTION_NAME)) Log(STDUSERLOG,"No such name\r\n");
	else if ((D->systemFlags & FUNCTION_BITS) == IS_PLAN_MACRO) Log(STDUSERLOG,"Plan macro\r\n");
	else if (D->x.codeIndex && (D->systemFlags & FUNCTION_BITS) != IS_TABLE_MACRO) Log(STDUSERLOG,"Engine API function\r\n");
	else if ((D->systemFlags & FUNCTION_BITS) == IS_OUTPUT_MACRO) Log(STDUSERLOG,"output macro: %s\r\n",D->w.fndefinition+1); // skip arg count
	else Log(STDUSERLOG,"pattern macro: %s\r\n",D->w.fndefinition+1); // skip arg count
}

static void C_Variables(char* input)
{
	if (!stricmp(input,"system")) DumpSystemVariables();
	else if (!stricmp(input,"user")) DumpVariables(); 
	else // all
	{
		DumpVariables();
		DumpSystemVariables();
		Log(STDUSERLOG,"Max Buffers used %d\r\n",maxBufferUsed);
		Log(STDUSERLOG,"%s\r\n",ShowPendingTopics());
	}
} 	

static void C_Functions(char* input)
{
	DumpFunctions();
}

static void ShowMacro(WORDP D,uint64 junk)
{
	if (!(D->systemFlags & FUNCTION_NAME)) {;} // not a function or plan
	else if ((D->systemFlags & FUNCTION_BITS) == IS_PLAN_MACRO) Log(STDUSERLOG,"plan: %s (%d)\r\n",D->word,D->w.planArgCount);
	else if (D->x.codeIndex) {;} //is system function (when not plan)
	else if (D->systemFlags & IS_PATTERN_MACRO && D->systemFlags & IS_OUTPUT_MACRO) Log(STDUSERLOG,"dualmacro: %s (%d)\r\n",D->word,MACRO_ARGUMENT_COUNT(D));
	else if (D->systemFlags & IS_PATTERN_MACRO) Log(STDUSERLOG,"patternmacro: %s (%d)\r\n",D->word,MACRO_ARGUMENT_COUNT(D));
	else if (D->systemFlags & IS_OUTPUT_MACRO) 	Log(STDUSERLOG,"outputmacro: %s (%d)\r\n",D->word,MACRO_ARGUMENT_COUNT(D));
	else if (D->systemFlags & IS_PLAN_MACRO) Log(STDUSERLOG,"tablemacro: %s (%d)\r\n",D->word,MACRO_ARGUMENT_COUNT(D));
}

static void C_Macros(char* input)
{
	WalkDictionary(ShowMacro,0);
}

static void C_MemStats(char* input)
{
	unsigned int factUsedMemKB = ( factFree-factBase) * sizeof(FACT) / 1000;
	unsigned int dictUsedMemKB = ( dictionaryFree-dictionaryBase) * sizeof(WORDENTRY) / 1000;
	// dictfree shares text space
	unsigned int textUsedMemKB = ( stringBase-stringFree)  / 1000;
	char* endDict = (char*)(dictionaryBase + maxDictEntries);
	unsigned int textFreeMemKB = ( stringFree- endDict) / 1000;
	unsigned int bufferMemKB = (maxBufferLimit * maxBufferSize) / 1000;
	
	unsigned int used =  factUsedMemKB + dictUsedMemKB + textUsedMemKB + bufferMemKB;
	used +=  (userTopicStoreSize + userTableSize) /1000;

	char buf2[MAX_WORD_SIZE];
	char buf[MAX_WORD_SIZE];
	strcpy(buf,StdIntOutput(factFree-factBase));
	strcpy(buf2,StdIntOutput(textFreeMemKB));
	Log(STDUSERLOG,"Used: words %s (%dkb) facts %s (%dkb) text %dkb buffers %d overflowBuffers %d\r\n",
		StdIntOutput(dictionaryFree-dictionaryBase), 
		dictUsedMemKB,
		buf,
		factUsedMemKB,
		textUsedMemKB,
		bufferIndex,overflowIndex);
}

static void C_Who(char*input)
{
	Log(STDUSERLOG,"%s talking to %s\r\n",loginID,computerID);
}

//////////////////////////////////////////////////////////
//// COMMAND SYSTEM
//////////////////////////////////////////////////////////

void InitCommandSystem() // set dictionary to match builtin functions
{
	unsigned int k = 0;
	CommandInfo *routine;
	while ((routine = &commandSet[++k]) && routine->word )
	{
		if (*routine->word == ':') StoreWord((char*) routine->word)->x.debugIndex  = (unsigned short)k; // a command, not a display label
	}
}

int Command(char* input,char* output)
{
	char word[MAX_WORD_SIZE];
	input = ReadCompiledWord(input,word);
	WORDP D = FindWord(word);
	bool oldecho = echo;
	echo = true;	// see outputs sent to log file on console also
	if (D) 
	{
		CommandInfo* info;
		if (D->x.debugIndex) 
		{
			info = &commandSet[D->x.debugIndex];
			if (debugger && !info->debugger) // not usable from inside debugger
			{
				Log(STDUSERLOG,"Cannot use %s from inside debugger\r\n",word);
				echo = oldecho;
				return 0;
			}
			input = SkipWhitespace(input);
			char data[MAX_WORD_SIZE];
			strcpy(data,input);
			TrimSpaces(data,false);
			wasCommand = COMMANDED;
			testOutput = output;
			if (output) *output = 0;
			(*info->fn)(data);
			testOutput = NULL;
			if (strcmp(info->word,":trace") && strcmp(info->word,":echo")) echo = oldecho;
			return wasCommand;
		}
	}
	Log(STDUSERLOG,"Unknown command %s\r\n",word);
	echo = oldecho;
	return COMMANDED; 
}

//////////////////////////////////////////////////////////
//// TOPIC INFO
//////////////////////////////////////////////////////////

void C_Gambits(char* buffer)
{
	buffer = SkipWhitespace(buffer);
	unsigned int topic = FindTopicIDByName(buffer);
	if (!topic) 
	{
		Log(STDUSERLOG,"No such topic %s\r\n",buffer);
		return;
	}
	
	char* base = GetTopicData(topic);  
	int ruleID = 0;
	unsigned int* map = gambitTagMap[topic];
	ruleID = *map;
	unsigned int* indices =  ruleOffsetMap[topic];
	unsigned int n = 0;
	while (ruleID != NOMORERULES)
	{
		char* ptr = base + indices[ruleID]; // the gambit 
		char* end = strchr(ptr,ENDUNIT);
		*end = 0;
		++n;
		char label[MAX_WORD_SIZE];
		char pattern[MAX_WORD_SIZE];
		char* output = GetPattern( ptr,label,pattern);
		if (strlen(pattern) == 4) *pattern = 0;
		if (*label) strcat(label,":");
		if (!UsableRule(topic,ruleID)) Log(STDUSERLOG,"- %d %s %s    %s\r\n",n,label,output,pattern);
		else Log(STDUSERLOG,"%d  %s %s    %s\r\n",n,label,output,pattern);
		*end = ENDUNIT;
		ruleID = *++map;
	}
}

void C_Pending(char* buffer)
{
	Log(STDUSERLOG,"Pending topics: %s\r\n", ShowPendingTopics());
}

static void CountConcept(WORDP D, uint64 count)
{
	if (D->systemFlags & CONCEPT && !(D->systemFlags & TOPIC))
	{
		unsigned int* ctr = (unsigned int*) count;
		++*ctr;
	}
}

static void C_TopicStats(char* input)
{
	unsigned int totalgambits = 0;
	unsigned int totalresponders = 0;
	unsigned int totalrejoinders = 0;
	unsigned int totalquestions = 0;
	unsigned int totalstatements = 0;
	unsigned int totaldual = 0;
	unsigned int conceptCount = 0;
	bool normal = false;
	if (!stricmp(input,"normal")) // show only normal topics
	{
		normal = true;
		*input = 0;
	}
	WalkDictionary(CountConcept,(uint64) &conceptCount);
	unsigned int topicCount = 0;

	size_t len = 0;
	char* x = strchr(input,'*');
	if (x) len = x - input;
	else if (*input == '~') len = strlen(input);

	for (unsigned int i = 1; i <= lastTopic; ++i) 
	{
		if (len && strnicmp(GetTopicName(i),input,len)) continue;
		char* name = GetTopicName(i);
		char* data = GetTopicData(i);
		unsigned int flags = GetTopicFlags(i);
		if (flags & TOPIC_SYSTEM && normal) continue;
		++topicCount;
		unsigned int gambits = 0;
		unsigned int responders = 0;
		unsigned int rejoinders = 0;
		int id = 0;
		while (data && *data)
		{
			if (TopLevelGambit(data)) ++gambits;
			else if (TopLevelRule(data)) ++responders;
			else ++rejoinders;

			if (*data == QUESTION) ++totalquestions;
			else if (*data == STATEMENT) ++totalstatements;
			else if (*data == STATEMENT_QUESTION) ++totaldual;

			data = FindNextRule(NEXTRULE,data,id);
		}
		totalgambits += gambits;
		totalresponders += responders;
		totalrejoinders += rejoinders;
		Log(STDUSERLOG,"    %s     gambits %d responders %d rejoinders %d\r\n", name,gambits,responders,rejoinders);
	}
	unsigned int totalrules = totalgambits + totalresponders + totalrejoinders;
	Log(STDUSERLOG,"Concepts %d Topics %d rules %d \r\n  gambits %d  responders %d (?: %d s: %d  u: %d) rejoinders %d\r\n",conceptCount,topicCount,totalrules,totalgambits,totalresponders,totalquestions,totalstatements,totaldual,totalrejoinders);
}

static void TrackFactsUp(MEANING T,FACT* G) //   show what matches up in unmarked topics
{ 
    if (!T) return;
	WORDP D = Meaning2Word(T);
	unsigned int index = Meaning2Index(T);
	unsigned int flags = (T & TYPE_RESTRICTION);
	if (!flags) flags = ESSENTIAL_FLAGS;
	if (D->systemFlags & TOPIC) 
	{
		if (D->inferMark == inferMark) return;
		D->inferMark = inferMark;
		unsigned int flags = GetTopicFlags(FindTopicIDByName(D->word));
		if (flags & TOPIC_SYSTEM) return;	// dont report system intersects
		
		char word[MAX_WORD_SIZE];
		WORDP E = Meaning2Word(G->subject);
		sprintf(word,"%s(%s)",D->word,E->word);
		Log(STDUSERLOG,"%s ",word);
		return;	
	}
	FACT* F = GetSubjectHead(D); 
	while (F) 
	{
		WORDP object = Meaning2Word(F->object);
		if ((F->verb == Mmember || F->verb == Mis) && object->inferMark != inferMark) 
		{
			object->inferMark = inferMark;
			unsigned int restrict = F->subject & TYPE_RESTRICTION;
			if (restrict) // type restricted member
			{
				if (!( restrict & flags ))
				{
					F = GetSubjectNext(F);
					continue;
				}
			}

			//  meaning restriction 
			if (index == Meaning2Index(F->subject)) // match generic or specific 
			{
				WORDP E = Meaning2Word(F->subject);
				if (*E->word == '~') TrackFactsUp(F->object,G);
				else TrackFactsUp(F->object,F);
			}
		}
		F = GetSubjectNext(F);
	}
}

static void TabInset(unsigned int depth,bool eol)
{
	if (eol) Log(STDUSERLOG,"\r\n");
	for (unsigned int i = 0; i < depth; ++i) Log(STDUSERLOG,"  ");
}

static void TrackFactsDown(MEANING M,FACT* F,unsigned int depth,size_t& length,bool display)
{
	WORDP D = Meaning2Word(M);
	if (D->inferMark == inferMark) return;	// already marked
	D->inferMark = inferMark;
	if (*D->word == '~')  // its a set-- nest and do the set
	{
		if (display)
		{
			if ( length != depth)  TabInset(depth,true);
			// header
			Log(STDUSERLOG,"%s\r\n",D->word);
			// indent 
			TabInset(depth+2,true);
			length = depth + 2;
		}
		else TrackFactsUp(M,F);
	    // concept keywords
		FACT* F = GetObjectHead(D);
		while (F)
		{
			TrackFactsDown(F->subject,F,depth+2,length,display);
			F = GetObjectNext(F);
		}
		if (display)
		{
			TabInset(depth,true); // end of concept keywords // restore indent 
			length = depth * 2;
		}
	}
	else // displaying a word of a set
	{
		unsigned int index = Meaning2Index(M);
		if (display)
		{
			char word[MAX_WORD_SIZE];
			if (!index)	sprintf(word,"%s ",D->word);
			else sprintf(word,"%s~%d ",D->word,index);
			Log(STDUSERLOG,"%s",word);
			size_t wlen = strlen(word)  + 1;
			length += wlen;
			while (wlen < 20) // force each word to be 20 wide
			{
				Log(STDUSERLOG," ");
				++wlen;
				++length;
			}
			if (length > 120) // avoid long lines
			{
				TabInset(depth,true);
				length = depth * 2;
			}
		}
		else if (index) // need to propogate down - but might be huge-- dont display
		{
			int l = 0;
			M = GetMaster(M); // master meaning
			while (++l) //   find the children of the meaning of T
			{
				MEANING child = FindChild(M,l);
				if (!child) break;
				TrackFactsDown(child,F,depth+2,length,false);
			} //   end of children for this value
		}
		else
		{
			unsigned int size = GetMeaningCount(D); // all meanings up
			for  (unsigned int k = 1; k <= size; ++k)
			{
				MEANING M = GetMeaning(D,k);
				TrackFactsUp(M,F); // anyone else refers to this meaning?
				MEANING parent = FindSetParent(M,0); //   next set we are member of
				TrackFactsUp(parent,F);
			}
		}
	}
}

static void C_Topics(char* input)
{
	PrepareSentence(input,true,true);	
	impliedSet = 0;
	KeywordTopicsCode(NULL);
	for (unsigned int i = 1; i <=  FACTSET_COUNT(0); ++i)
	{
		FACT* F = factSet[0][i];
		WORDP D = Meaning2Word(F->subject);
		WORDP N = Meaning2Word(F->object);
		unsigned int topic = FindTopicIDByName(D->word);
        char* name = GetTopicName(topic);
		Log(STDUSERLOG,"%s (%s) : ",name,N->word);
        //   look at references for this topic
        int start = -1;
        while (GetIthSpot(D,++start)) // find matches in sentence
        {
            // value of match of this topic in this sentence
            for (unsigned int k = positionStart; k <= positionEnd; ++k) 
			{
				if (k != positionStart) Log(STDUSERLOG,"_");
				Log(STDUSERLOG,"%s",wordStarts[k]);
			}
			Log(STDUSERLOG," ");
		}
		Log(STDUSERLOG,"\r\n");
	}
	impliedSet = ALREADY_HANDLED;
	
}

static void C_TopicInfo(char* input)
{
	char word[MAX_WORD_SIZE];
	char* ptr = ReadCompiledWord(input,word);
	if (*word == '~' && word[1] == 0) 
	{
		if (inputRejoinderTopic == NO_REJOINDER) return;
		strcpy(word,GetTopicName(inputRejoinderTopic));
		input = ptr;
	}
	else if (*word == '~')  input = ptr;
	
	size_t len = 0;
	char* x = strchr(word,'*');
	if (x) len = x - word;
	else if (*word == '~') len = strlen(word);

	for (unsigned int topicid = 1; topicid <= lastTopic; ++topicid) 
	{
		if (len && strnicmp(GetTopicName(topicid),word,len)) continue;

		WORDP D = FindWord(GetTopicName(topicid));
		int rejoinderOffset = -1;
		if ((int)topicid == inputRejoinderTopic) rejoinderOffset = inputRejoinderRuleID;
		bool used = true;
		bool available = true;
		bool rejoinder = false;
		bool gambit = false;
		bool responder = false;
		bool keys = false;
		bool overlap = false;
		bool all = false;
		if (!*input) all = keys = overlap = gambit = responder = rejoinder = true; // show it all
		char* ptr = input;
		while (*ptr)
		{
			ptr = ReadCompiledWord(ptr,word); // restriction
			if (!*word) break;
			if (!stricmp(word,"used")) available = false;
			else if (!stricmp(word,"available")) used = false;

			else if (!stricmp(word,"rejoinder")) rejoinder = true;
			else if (!stricmp(word,"gambit")) gambit = true;
			else if (!stricmp(word,"responder")) responder = true;
			else if (!stricmp(word,"all")) rejoinder = gambit = responder = true;

			else if (!stricmp(word,"keys")) keys = true;
			else if (!stricmp(word,"overlap")) overlap = true;
		}
		if (!gambit && !responder && !rejoinder) used = available = false;
		if (all) DisplayTopicFlags(topicid);

		if (keys) // display all keys (execpt recursive wordnet)
		{
			Log(STDUSERLOG,"\r\nTopic Keys: %s\r\n",D->word);
			NextinferMark();
			if (D->internalBits & HAS_EXCLUDE) MarkExclude(D);
			FACT* F = GetObjectHead(D);
			size_t length = 2;
			Log(STDUSERLOG,"  ");
			while (F)
			{
				TrackFactsDown(F->subject,F,1,length,true); 
				F = GetObjectNext(F);
			}
			Log(STDUSERLOG,"\r\n");
		}

		if (overlap)
		{
			Log(STDUSERLOG,"\r\nTopic Key Overlap: %s\r\n",D->word);
			NextinferMark();
			if (D->internalBits & HAS_EXCLUDE) MarkExclude(D);
			FACT* F = GetObjectHead(D);
			size_t length = 2;
			Log(STDUSERLOG,"  ");
			while (F)
			{
				TrackFactsDown(F->subject,F,1,length,false); 
				F = GetObjectNext(F);
			}
			Log(STDUSERLOG,"\r\n");
		}

		if ((used || available) && !gambit && !rejoinder && !responder) rejoinder = gambit = responder = true;

		unsigned int gambits = 0;
		unsigned int statements = 0;
		unsigned int questions = 0;
		unsigned int dual = 0;
		unsigned int rejoinders = 0;

		int id = 0;
		char* name = GetTopicName(topicid);
		char* data = GetTopicData(topicid);
		bool access = true;
		while (data && *data) // walk data
		{
			char* rule = ShowRule(data);
			if (*data == GAMBIT || *data == RANDOM_GAMBIT) ++gambits;
			else if (*data == QUESTION) ++questions;
			else if (*data == STATEMENT) ++statements;
			else if (*data == STATEMENT_QUESTION) ++dual;
			else  ++rejoinders;
			if (TopLevelRule(data))
			{
				access = UsableRule(topicid,id);
				if ((*data == GAMBIT || *data == RANDOM_GAMBIT) && !gambit) access = false;
				else if ((*data == QUESTION || *data == STATEMENT_QUESTION || *data == STATEMENT) && !responder) access = false;
				else if (!access) // no access exists
				{
					if (used) 
					{
						Log(STDUSERLOG,"  - %d(%d) %s\r\n",id,ruleOffsetMap[topicid][id],rule);
						access = true;
					}
				}
				else // rule is accessible
				{
					if (available) Log(STDUSERLOG,"    %d(%d) %s\r\n",id,ruleOffsetMap[topicid][id],rule);
					else access = false;
				}
			}
			else if (rejoinder) // inherits prior access
			{
				if (access)
				{
					unsigned int depth = *rule - 'a';
					while (depth--) Log(STDUSERLOG,"    "); // indent appropriately
					if (id == rejoinderOffset) Log(STDUSERLOG,"  ***  (%d) %s\r\n",REJOINDERID(id),rule); // current rejoinder
					else Log(STDUSERLOG,"       (%d) %s\r\n",REJOINDERID(id),rule);
				}
			}
			data = FindNextRule(NEXTRULE,data,id);
		}
		if (all) Log(STDUSERLOG,"%s(%d)  gambits: %d  responders: %d (?:%d s:%d u:%d)  rejoinders: %d\r\n", name,topicid,gambits,statements+questions+dual,statements, questions, dual,rejoinders);
	}
}

static void C_Where(char* input)
{
	unsigned int topic = FindTopicIDByName(input);
	if (topic)	Log(STDUSERLOG,"%s is from %s\r\n",input,GetTopicFile(topic));
}

//////////////////////////////////////////////////////////
//// FACT INFO
//////////////////////////////////////////////////////////

static void C_AllFacts(char* input)
{
	WriteFacts(FopenUTF8Write("TMP/facts.txt"),factBase);
}

static void C_Facts(char* input)
{
	char word[MAX_WORD_SIZE];
	char* ptr = ReadCompiledWord(input,word);
	FACT* G = NULL;
	WORDP D = NULL;
	unsigned int index = 0;
	FACT* F;
	if (*word == '(') // actual fact
	{
		char arg1[MAX_WORD_SIZE];
		char arg2[MAX_WORD_SIZE];
		char arg3[MAX_WORD_SIZE];
		ptr -= (strlen(word)-1) + 1;
		ptr = ReadCompiledWord(ptr,arg1);
		ptr = ReadCompiledWord(ptr,arg2);
		ptr = ReadCompiledWord(ptr,arg3);
		size_t len = strlen(arg3);
		if (arg3[len-1] == ')') arg3[len-1] = 0;	// remove trailing )
		G = FindFact(ReadMeaning(arg1,false),ReadMeaning(arg2,false),ReadMeaning(arg3,false),0); 
		if (!G) 
		{
			Log(STDUSERLOG,"No such facts\r\n");
			return;
		}
	}
	else
	{
		MEANING M = ReadMeaning(word,false);
		index = Meaning2Index(M);
		if (!M)
		{
			Log(STDUSERLOG,"No such meaning exists\r\n");
			return;
		}
		D = Meaning2Word(M);

	}
	F = (G) ? GetSubjectHead(G) :  GetSubjectHead(D);
	while (F)
	{
		if (index && F->subject != index) {;}
		else TraceFact(F);
		F = GetSubjectNext(F);
	}	
	F = (G) ? GetVerbHead(G) :  GetVerbHead(D);
	while (F)
	{
		if (index && F->verb != index)  {;}
		else TraceFact(F);
		F = GetVerbNext(F);
	}
	F = (G) ? GetObjectHead(G) :  GetObjectHead(D);
	while (F)
	{
		if (index && F->object != index)  {;}
		else TraceFact(F);
		F = GetObjectNext(F);
	}
}

static void C_UserFacts(char* input)
{
	FACT* F = factLocked;
	while (++F <= factFree)
	{
		char word[MAX_WORD_SIZE];
		Log(STDUSERLOG,"%s",WriteFact(F,false,word,false,true));
	}
}

//////////////////////////////////////////////////////////
//// DEBUGGING COMMANDS
//////////////////////////////////////////////////////////

static void C_Debug(char* input)
{
	if (!strnicmp(input,":retry",6) || !strnicmp(input,"revert",6) )
	{
		C_Retry(input);
		printf("debugging input: %s\r\n",revertBuffer);
	}

	if (!server) 
	{
		Log(STDDEBUGLOG,"Debugger started - for help type 'h'\r\n");
		out2level = -2;
		Debugger(ENTER_DEBUGGER);
	}
}

static void C_Do(char* input)
{
	SAVEOLDCONTEXT()
	if (!debugger)
	{
		++inputCount;
		responseIndex = 0;	// clear out data (having left time for :why to work)
		AddHumanUsed(":do");
		AddRepeatable(0);
		OnceCode("$control_pre");
	}
	currentRule = 0;
	currentRuleID = 0;
	currentRuleTopic =  currentTopicID = 0;
	char* data = AllocateBuffer();
	char* out = data;
	char* answer = AllocateBuffer();
#ifndef DISCARDSCRIPTCOMPILER
	hasErrors = 0;
	ReadOutput(input, NULL,out,NULL);
	if (hasErrors) Log(STDUSERLOG,"\r\nScript errors prevent execution.");
	else 
	{
		unsigned int result;
		FreshOutput(data,answer,result);
		Log(STDUSERLOG,"   result: %s  output: %s\r\n",ResultCode(result),answer);
		if (!debugger) AddResponse(answer);
	}
#else
	Log(STDUSERLOG,"Script compiler not installed.");
#endif
	FreeBuffer();
	FreeBuffer();
	RESTOREOLDCONTEXT()
	wasCommand = OUTPUTASGIVEN; // save results to user file
}

static void C_Silent(char* input)
{
	silent = !silent;
}

static void C_Retry(char* input)
{
	ResetToPreUser();
	ResetSentence();
	char file[MAX_WORD_SIZE];
	sprintf(file,"USERS/topic_%s_%s.txt",loginID,computerID);
	CopyFile2File(file,"TMP/backup.txt",false);	
	char* buffer = FindUserCache(file); // set currentCache
	if (buffer) FreeUserCache(); // erase cache of user so it reads revised disk file
	int BOMvalue = -1; // get prior value
	char oldc;
	int oldCurrentLine;	
	BOMAccess(BOMvalue, oldc,oldCurrentLine); // copy out prior file access and reinit user file access
	ReadUserData(GetFileRead(loginID,computerID));
	BOMAccess(BOMvalue, oldc,oldCurrentLine); 
}

static void C_Log(char* input)
{
	Log(STDUSERLOG,"Log: %s\r\n",input);
}

static void C_Skip(char* buffer)
{
	unsigned int topic = GetPendingTopicUnchanged();
	if (!topic) 
	{
		Log(STDUSERLOG,"No pending topic\r\n");
		return;
	}
	unsigned int* offsets = ruleOffsetMap[topic];
	int n = atoi(SkipWhitespace(buffer));
	unsigned int* map = gambitTagMap[topic];
	unsigned int ruleID = *map;
	char * rule = NULL;
	char* data = GetTopicData(topic);  
	while (ruleID != NOMORERULES)
	{
		rule = data + offsets[ruleID];
		if (TopLevelGambit(rule) && UsableRule(topic,ruleID) && --n == 0) SetRuleDisableMark(topic, ruleID);
		ruleID = *++map;
	}
	if (ruleID != NOMORERULES) Log(STDUSERLOG,"Next gambit of %s is: %s...\r\n",GetTopicName(topic),ShowRule(GetRule(topic,ruleID)));
	WriteUserData(0);
}

static void C_Show(char* input)
{
	char word[MAX_WORD_SIZE];
	ReadCompiledWord(input,word);
	if (!stricmp(word,"all"))
	{
		all = !all;
		Log(STDUSERLOG,"All set to %d\n",all);
	}
	else if (!stricmp(word,"echo"))
	{
		echo = !echo;
		Log(STDUSERLOG," echo set to %d\n",echo);
	}
	else if (!stricmp(word,"echoserver"))
	{
		echoServer = !echoServer;
		Log(STDUSERLOG," echoServer set to %d\n",echoServer);
	}
	else if (!stricmp(word,"input"))
	{
		showInput = !showInput;
		Log(STDUSERLOG," input set to %d\n",showInput);
	}
	else if (!stricmp(word,"mark"))
	{
		showMark = !showMark;
		Log(STDUSERLOG," showMark set to %d\n",showMark);
	}
	else if (!stricmp(word,"number"))
	{
		autonumber = !autonumber;
		Log(STDUSERLOG," autonumber set to %d\n",autonumber);
	}
	else if (!stricmp(word,"pos"))
	{
		shortPos = !shortPos;
		Log(STDUSERLOG," Pos set to %d\n",shortPos);
	}
	else if (!stricmp(word,"serverLog"))
	{
		serverLog = !serverLog;
		Log(STDUSERLOG," serverLog set to %d\n",serverLog);
	}
	else if (!stricmp(word,"stats"))
	{
		ruleCount = 0;
		ruleStats = !ruleStats;
		Log(STDUSERLOG," ruleStats set to %d\n",ruleStats);
	}
	else if (!stricmp(word,"topic"))
	{
		showTopic = !showTopic;
		Log(STDUSERLOG," topic set to %d\n",showTopic);
	}
	else if (!stricmp(word,"topics"))
	{
		showTopics = !showTopics;
		Log(STDUSERLOG," topics set to %d\n",showTopics);
	}
	else if (!stricmp(word,"why"))
	{
		showWhy = !showWhy;
		Log(STDUSERLOG," why set to %d\n",showWhy);
	}
} 

static void ShowTrace()
{
	// general
	if (trace & (TRACE_VARIABLE|TRACE_MATCH|TRACE_BASIC)) 
	{
		Log(STDUSERLOG,"Enabled simple: ");
		if (trace & TRACE_BASIC) Log(STDUSERLOG,"basic ");
		if (trace & TRACE_MATCH) Log(STDUSERLOG,"match ");
		if (trace & TRACE_VARIABLE) Log(STDUSERLOG,"variables ");
		Log(STDUSERLOG,"\r\n");
	}

	// mild detail
	if (trace & (TRACE_OUTPUT|TRACE_PREPARE|TRACE_PATTERN)) 
	{
		Log(STDUSERLOG,"Enabled mild detail: ");
		if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"output ");
		if (trace & TRACE_PREPARE) Log(STDUSERLOG,"prepare ");
		if (trace & TRACE_PATTERN) Log(STDUSERLOG,"pattern ");
		Log(STDUSERLOG,"\r\n");
	}
	// deep detail
	if (trace & (TRACE_FACTCREATE|TRACE_INFER|TRACE_HIERARCHY|TRACE_SUBSTITUTE|TRACE_VARIABLESET|TRACE_QUERY|TRACE_USER|TRACE_POS)) 
	{
		Log(STDUSERLOG,"Enabled deep detail: ");
		if (trace & TRACE_FACTCREATE) Log(STDUSERLOG,"fact ");
		if (trace & TRACE_INFER) Log(STDUSERLOG,"infer ");
		if (trace & TRACE_HIERARCHY) Log(STDUSERLOG,"hierarchy ");
		if (trace & TRACE_SUBSTITUTE) Log(STDUSERLOG,"substitute ");
		if (trace & TRACE_VARIABLESET) Log(STDUSERLOG,"varassign ");
		if (trace & TRACE_QUERY) Log(STDUSERLOG,"query ");
		if (trace & TRACE_USER) Log(STDUSERLOG,"user ");
		if (trace & TRACE_POS) Log(STDUSERLOG,"pos ");
		Log(STDUSERLOG,"\r\n");
	}

	// general
	if ((trace & (TRACE_BASIC|TRACE_MATCH|TRACE_VARIABLE)) != (TRACE_BASIC|TRACE_MATCH|TRACE_VARIABLE)) 
	{
		Log(STDUSERLOG,"Disabled simple: ");
		if (!(trace & TRACE_BASIC)) Log(STDUSERLOG,"basic ");
		if (!(trace & TRACE_MATCH)) Log(STDUSERLOG,"match ");
		if (!(trace & TRACE_VARIABLE)) Log(STDUSERLOG,"variables ");
		Log(STDUSERLOG,"\r\n");
	}

	// mild detail
	if ((trace & (TRACE_OUTPUT|TRACE_PREPARE|TRACE_PATTERN)) != (TRACE_OUTPUT|TRACE_PREPARE|TRACE_PATTERN)) 
	{
		Log(STDUSERLOG,"Disabled mild detail: ");
		if (!(trace & TRACE_OUTPUT)) Log(STDUSERLOG,"output ");
		if (!(trace & TRACE_PREPARE)) Log(STDUSERLOG,"prepare ");
		if (!(trace & TRACE_PATTERN)) Log(STDUSERLOG,"pattern ");
		Log(STDUSERLOG,"\r\n");
	}

	// deep detail
	if ((trace & (TRACE_FACTCREATE|TRACE_INFER|TRACE_HIERARCHY|TRACE_SUBSTITUTE|TRACE_VARIABLESET|TRACE_QUERY|TRACE_USER|TRACE_POS)) != (TRACE_FACTCREATE|TRACE_INFER|TRACE_HIERARCHY|TRACE_SUBSTITUTE|TRACE_VARIABLESET|TRACE_QUERY|TRACE_USER|TRACE_POS) )
	{
		Log(STDUSERLOG,"Disabled deep detail: ");
		if (!(trace & TRACE_FACTCREATE)) Log(STDUSERLOG,"fact ");
		if (!(trace & TRACE_INFER)) Log(STDUSERLOG,"infer ");
		if (!(trace & TRACE_HIERARCHY)) Log(STDUSERLOG,"hierarchy ");
		if (!(trace & TRACE_SUBSTITUTE)) Log(STDUSERLOG,"substitute ");
		if (!(trace & TRACE_VARIABLESET)) Log(STDUSERLOG,"varassign ");
		if (!(trace & TRACE_QUERY)) Log(STDUSERLOG,"query ");
		if (!(trace & TRACE_USER)) Log(STDUSERLOG,"user ");
		if (!(trace & TRACE_POS)) Log(STDUSERLOG,"pos ");
		Log(STDUSERLOG,"\r\n");
	}
}

static void C_Say(char* input)
{
	AddResponse(input);
	wasCommand = OUTPUTASGIVEN;
}

static void C_Trace(char* input)
{
	char word[MAX_WORD_SIZE];
	unsigned int flags = trace;
	if (!*input) ShowTrace();
	if (!*input) return;

	while (input) 
	{
		input = ReadCompiledWord(input,word); // if using trace in a table, use closer "end" if you are using named flags
		if (!*word) break;
		input = SkipWhitespace(input);
		if (!stricmp(word,"all")) flags = (unsigned int)-1;
		else if (!stricmp(word,"none")) flags = 0;
		else if (*word == '-' && !word[1]) // remove this flag
		{
			input = ReadCompiledWord(input,word);
			if (!stricmp(word,"basic")) flags &= -1 ^ TRACE_BASIC;
			else if (!stricmp(word,"match")) flags &= -1 ^ TRACE_MATCH;
			else if (!stricmp(word,"variables")) flags &= -1 ^ TRACE_VARIABLE; 
			else if (!stricmp(word,"simple")) flags &= -1 ^ (TRACE_BASIC|TRACE_MATCH|TRACE_VARIABLE); 

			else if (!stricmp(word,"prepare")) flags &= -1 ^ TRACE_PREPARE; 
			else if (!stricmp(word,"output")) flags &= -1 ^ TRACE_OUTPUT;
			else if (!stricmp(word,"pattern")) flags &= -1 ^ TRACE_PATTERN;
			else if (!stricmp(word,"mild")) flags &= -1 ^ (TRACE_PREPARE|TRACE_OUTPUT|TRACE_PATTERN); 

			else if (!stricmp(word,"infer")) flags &= -1 ^ TRACE_INFER;
			else if (!stricmp(word,"substitute")) flags &= -1 ^ TRACE_SUBSTITUTE;
			else if (!stricmp(word,"hierarchy")) flags &= -1 ^ TRACE_HIERARCHY;
			else if (!stricmp(word,"fact")) flags &= -1 ^  TRACE_FACTCREATE;
			else if (!stricmp(word,"varassign")) flags &= -1 ^  TRACE_VARIABLESET;
			else if (!stricmp(word,"query")) flags &= -1 ^  TRACE_QUERY;
			else if (!stricmp(word,"user")) flags &= -1 ^  TRACE_USER;
			else if (!stricmp(word,"pos")) flags &= -1 ^  TRACE_POS;
			else if (!stricmp(word,"tcp")) flags &= -1 ^  TRACE_TCP;
			else if (!stricmp(word,"deep")) flags &= -1 ^ (TRACE_INFER|TRACE_SUBSTITUTE|TRACE_HIERARCHY| TRACE_FACTCREATE| TRACE_VARIABLESET| TRACE_QUERY| TRACE_USER|TRACE_POS|TRACE_TCP); 

		}
		else if (*word == '+' && !word[1]) // add this flag
		{
			input = ReadCompiledWord(input,word);
			if (!stricmp(word,"basic")) flags |= TRACE_BASIC;
			else if (!stricmp(word,"match")) flags  |= TRACE_MATCH;
			else if (!stricmp(word,"variables")) flags  |= TRACE_VARIABLE; 
			else if (!stricmp(word,"simple")) flags |= (TRACE_BASIC|TRACE_MATCH|TRACE_VARIABLE); 

			else if (!stricmp(word,"prepare")) flags |= TRACE_PREPARE; 
			else if (!stricmp(word,"output")) flags  |= TRACE_OUTPUT;
			else if (!stricmp(word,"pattern")) flags  |= TRACE_PATTERN;
			else if (!stricmp(word,"mild")) flags |= (TRACE_PREPARE|TRACE_OUTPUT|TRACE_PATTERN); 

			else if (!stricmp(word,"infer")) flags  |= TRACE_INFER;
			else if (!stricmp(word,"substitute")) flags  |= TRACE_SUBSTITUTE;
			else if (!stricmp(word,"hierarchy")) flags |= TRACE_HIERARCHY;
			else if (!stricmp(word,"fact")) flags  |=  TRACE_FACTCREATE;
			else if (!stricmp(word,"varassign")) flags  |=  TRACE_VARIABLESET;
			else if (!stricmp(word,"query")) flags  |=  TRACE_QUERY;
			else if (!stricmp(word,"user")) flags  |=  TRACE_USER;
			else if (!stricmp(word,"pos")) flags  |= TRACE_POS;
			else if (!stricmp(word,"tcp")) flags  |= TRACE_TCP;
			else if (!stricmp(word,"deep")) flags |= (TRACE_INFER|TRACE_SUBSTITUTE|TRACE_HIERARCHY| TRACE_FACTCREATE| TRACE_VARIABLESET| TRACE_QUERY| TRACE_USER|TRACE_POS|TRACE_TCP); 
		}
		else if (IsNumberStarter(*word)) 
		{
			ReadInt(word,flags);
			break; // there wont be more flags -- want :trace -1 in a table to be safe from reading the rest
		}
		else if (!stricmp(word,"basic")) flags |= TRACE_BASIC;
		else if (!stricmp(word,"match")) flags |= TRACE_MATCH;
		else if (!stricmp(word,"variables")) flags |= TRACE_VARIABLE; 
		else if (!stricmp(word,"simple")) flags |= (TRACE_BASIC|TRACE_MATCH|TRACE_VARIABLE); 

		else if (!stricmp(word,"prepare")) flags |= TRACE_PREPARE; 
		else if (!stricmp(word,"output")) flags |= TRACE_OUTPUT;
		else if (!stricmp(word,"pattern")) flags |= TRACE_PATTERN;
		else if (!stricmp(word,"mild")) flags |= (TRACE_PREPARE|TRACE_OUTPUT|TRACE_PATTERN); 

		else if (!stricmp(word,"infer")) flags |= TRACE_INFER;
		else if (!stricmp(word,"substitute")) flags |= TRACE_SUBSTITUTE;
		else if (!stricmp(word,"hierarchy")) flags |= TRACE_HIERARCHY;
		else if (!stricmp(word,"fact")) flags |= TRACE_FACTCREATE;
		else if (!stricmp(word,"varassign")) flags |= TRACE_VARIABLESET;
		else if (!stricmp(word,"query")) flags |= TRACE_QUERY;
		else if (!stricmp(word,"user")) flags |= TRACE_USER;
		else if (!stricmp(word,"pos")) flags |= TRACE_POS;
		else if (!stricmp(word,"tcp")) flags |= TRACE_TCP;
		else if (!stricmp(word,"deep")) flags |= (TRACE_INFER|TRACE_SUBSTITUTE|TRACE_HIERARCHY| TRACE_FACTCREATE| TRACE_VARIABLESET| TRACE_QUERY| TRACE_USER|TRACE_POS|TRACE_TCP); 

		else if (!stricmp(word,"0") || !stricmp(word,"clear")) trace = 0;
		else if (!stricmp(word,"end")) break; // safe end
		else if (*word == '!') // NOT tracing a topic 
		{
			if (word[1]) // ! jammed against topic, separate it
			{
				input -= strlen(word+1); 
				word[1] = 0;
			}
			input = ReadCompiledWord(input,word);
			SetTopicDebugMark(FindTopicIDByName(word),0);
			return;
		}
		else if (*word == '^')
		{
			WORDP FN = FindWord(word);
			if (FN) 
			{
				FN->internalBits ^= TRACE_MACRO;
				Log(STDUSERLOG,"Tracing function %s = %d\r\n",word, (FN->internalBits & TRACE_MACRO) ? 1 : 0);
			}
		}
		else if (*word == '~') // tracing a topic or rule by label
		{
			char* period = strchr(word,'.');
			if (period) *period = 0;
			unsigned int topic = FindTopicIDByName(word);
			if (!period) SetTopicDebugMark(topic,!topicDebugMap[topic]);
			else if (IsAlpha(period[1])) // find ALL labelled statement and mark them
			{
				int id = 0;
				char* which = GetTopicData(topic);
				bool found = false;
				while (which && *which && (which = FindNextLabel(topic,period+1,which,id,true)))
				{
					SetDebugRuleMark(topic,id);
					found = true;
					which = FindNextRule(NEXTRULE,which,id);
				}
				if (!found)  Log(STDUSERLOG,"cannot find %s.%s\r\n",word,period+1);
			}
			else if (IsDigit(period[1]))// did he use number notation?
			{
				int id = 0;
				*period = '.';
				char* rule = GetRuleTag(topic,id,word);
				if (rule) SetDebugRuleMark(topic,id);
				else Log(STDUSERLOG,"cannot find %s.%s\r\n",word,period+1);
			}
			return;
		}
	}
	trace = flags;
	echo = (trace) ? true : false;
    Log(STDUSERLOG," trace set to %d\n",trace);
	if (trace && !*input) ShowTrace();
} 

void C_Why(char* buffer)
{
	for (unsigned int i = 0;  i < responseIndex; ++i)
	{
		unsigned int order = responseOrder[i];
		unsigned int topic = responseData[order].topic;
		unsigned int id = atoi(responseData[order].id+1);
		char* dot = strchr(responseData[order].id+1,'.');
		id |= MAKE_REJOINDERID(atoi(dot+1));
		Log(STDUSERLOG,"%s%s  %s\r\n",GetTopicName(topic),responseData[order].id,ShowRule(GetRule(topic,id)));
	}
}

//////////////////////////////////////////////////////////
//// MISC COMMANDS
//////////////////////////////////////////////////////////

static void CleanIt(char* word,uint64 junk) // remove cr from source lines for Linux
{
	FILE* in = fopen(word,"rb");
	if (!in) 
	{
		printf("missing %s\r\n",word);
		return;
	}
	fseek (in, 0, SEEK_END);
    size_t size = ftell(in);
	char* buf = (char*) malloc(size+2); // enough to hold the file

	fseek (in, 0, SEEK_SET);
	unsigned int val = (unsigned int) fread(buf,1,size,in);
	fclose(in);
	if ( val != size) return;
	buf[size] = 0;	// force an end

	// now overwrite file with proper trimming
	FILE* out = fopen(word,"wb");
	for (unsigned int i = 0; i < size; ++i)
	{
		if (buf[i] != '\r' && buf[i] != 26) fwrite(buf+i,1,1,out);	// remove cr and ^Z
	}
	if (buf[size-1] != '\n') fwrite("\n",1,1,out); // force ending line feed
	fclose(out);
	free(buf);
}

static void C_Clean(char* word) // remove CR for LINUX
{
	WalkDirectory("src",CleanIt,0);
}

static void BuildDummyConcept(WORDP D,uint64 junk)
{
	if ((D->internalBits & BUILD0) && *D->word == '~') CreateFact(MakeMeaning(D),Mmember,MakeMeaning(FindWord("~a_dummy")));
}

static void SortConcept(WORDP D,uint64 junk)
{
	if ((D->internalBits & BUILD0) && *D->word == '~') Sortit(D->word,(int)junk); // will be 0 for no input, some char value otherwise
}

static void C_SortConcept(char* input)
{
#ifdef INFORMATION
To get concepts in a file sorted alphabetically (both by concept and within)l, do 
	0. :build 0 when only the file involved is the only active one in files0.txt
	1. :sortconcept x		-- builds one concept per line and sorts the file by concept name
	2. take the contents of concept.top and replace the original file
	3. :build 0
	4. :sortconcept			-- maps concepts neatly onto multiple lines
	5. take the contents of x.txt and replace the original file
#endif
	WORDP D = StoreWord("~a_dummy",AS_IS);
	if (*input) 
	{
		WalkDictionary(BuildDummyConcept,0); // stores names of concepts on dummy concept, to lock position in dictionary. later not, will be read in
		AddSystemFlag(D,CONCEPT);
		AddInternalFlag(D,BUILD0);
	}

	fclose(fopen("cset.txt","wb"));
	if (!*input) // hide this on second pass
	{
		WORDP D = FindWord("~a_dummy");
		RemoveInternalFlag(D,BUILD0);
	}
	WalkDictionary(SortConcept,(uint64)input[0]);
	if (*input) system("sort /rec 63000 c:/chatscript/cset.txt >concepts.top");
}

//////////////////////////////////////////////////////////
//// ANALYTICS
//////////////////////////////////////////////////////////

static void DisplayTables(char* topic)
{
	char args[MAX_WORD_SIZE];
	sprintf(args,"( %s )",topic);
	Callback(FindWord(GetUserVariable("$abstract")),args);
}

static void DoHeader(int count,char* basic,FILE* in,int id,unsigned int spelling)
{
	if (*abstractBuffer == 0) 	// no more verification data for this topic
	{
		// display header
		if (!lineLimit)	
		{
			TabInset(count,false);
			Log(STDUSERLOG,"%s",basic); 
		}
		return;
	}

	// get verification matching input -- ~abortion.0.0 #! I am against abortion.
	static int readID = 0;
	static char* test = NULL;
	if ((unsigned char)*abstractBuffer == 1) readID = -1; // read 1st line of topic data
retry:
	char type = 0;
	while (readID == -1 || TOPLEVELID(id) > TOPLEVELID(readID) ||  ( TOPLEVELID(id) == TOPLEVELID(readID) && REJOINDERID(id) > REJOINDERID(readID)  )) // flush reads until get 1st good one
	{
		if (!ReadALine(abstractBuffer,in)) break;	// no more verifcation data
		char* dot = strchr(abstractBuffer,'.');
		char* dot1 = strchr(dot+1,'.');
		readID = MAKE_REJOINDERID(atoi(dot1+1)) + atoi(dot+1); // the id pending
		test = strchr(abstractBuffer,'#');
		type = test[2];
		if (!(spelling & ABSTRACT_PRETTY)) test += 2;
		if ((type == 'x' || type == 'X') && *test != ' ' && ((TOPLEVELID(id) > TOPLEVELID(readID)) ||  (TOPLEVELID(id) == TOPLEVELID(readID) && REJOINDERID(id) > REJOINDERID(readID)) )) // global topic comment, dump it immediately and keep going
		{
			Log(STDUSERLOG,"\r\n%s\r\n\r\n",test+1); 
			readID = -1;
		}
	}

	if (test && (type == 'x' || type == 'X') && *test != ' ' && readID == id) // global topic comment for current match
	{
		Log(STDUSERLOG,"\r\n%s\r\n\r\n",test+1); 
		readID = -1;
		goto retry;
	}

	// since we have sample input, kill pattern
	if (id == readID && *basic != ' ' && !(spelling & ABSTRACT_PRETTY)) 
	{
		unsigned int offset = 2;
		while (basic[offset] != ' ') ++offset; // find end of blank space before pattern.
		basic[offset] = 0;  
	}

	// display header
	if (spelling & ABSTRACT_PRETTY && id == readID)  
	{
		TabInset(count,false);
		Log(STDUSERLOG,"%s\r\n",test);
	}
	if (!lineLimit)	
	{
		TabInset(count,false);
		Log(STDUSERLOG,"%s",basic); 
	}

	// display verify as pattern
	if (id == readID && !lineLimit && !(spelling & ABSTRACT_PRETTY)) 
	{
		Log(STDUSERLOG," %s =>   ",test);
	}
}

static void DisplayTopic(char* name,int spelling)
{
	int topicID = FindTopicIDByName(name);
	if (!topicID || BlockedBotAccess(topicID)) return;
	char* rule = GetTopicData(topicID); 
	if (!rule) return;
	*abstractBuffer = 1;	// buffer started for new topic
	if (spelling & ABSTRACT_PRETTY)
	{
		unsigned int lineSize = 0;
		Log(STDUSERLOG,"\r\nTOPIC: %s",name);
		unsigned int flags = GetTopicFlags(topicID);
		if (flags & TOPIC_SYSTEM) Log(STDUSERLOG," SYSTEM");
		if (flags & TOPIC_KEEP) Log(STDUSERLOG," KEEP");
		if (flags & TOPIC_REPEAT) Log(STDUSERLOG," REPEAT");
		if (flags & TOPIC_RANDOM) Log(STDUSERLOG," RANDOM");
		if (flags & TOPIC_NOSTAY) Log(STDUSERLOG," NOSTAY");
		if (flags & TOPIC_PRIORITY) Log(STDUSERLOG," PRIORITY");
		if (flags & TOPIC_LOWPRIORITY) Log(STDUSERLOG," DEPRIORITIZE");
		if (flags & TOPIC_NOBLOCKING) Log(STDUSERLOG," NOBLOCKING");
		if (flags & TOPIC_NOPATTERNS) Log(STDUSERLOG," NOPATTERNS");
		if (flags & TOPIC_NOGAMBITS) Log(STDUSERLOG," NOGAMBITS");
		if (flags & TOPIC_NOSAMPLES) Log(STDUSERLOG," NOSAMPLES");
		if (flags & TOPIC_NOKEYS) Log(STDUSERLOG," NOKEYS");
		if (flags & TOPIC_SAFE) Log(STDUSERLOG," SAFE");
		Log(STDUSERLOG," (");
		WORDP D = FindWord(name);
		FACT* F = GetObjectHead(D);
		while (F) 
		{
			if (F->verb == Mmember|| F->verb == Mexclude)
			{
				char word[MAX_WORD_SIZE];
				if (F->flags & ORIGINAL_ONLY) sprintf(word,"'%s ",WriteMeaning(F->subject));
				else sprintf(word,"%s ",WriteMeaning(F->subject));
				if (F->verb == Mexclude) Log(STDUSERLOG,"!");
				size_t wlen = strlen(word);
				lineSize += wlen;
				Log(STDUSERLOG,"%s",word);
				if (lineSize > 500) // avoid long lines
				{
					Log(STDUSERLOG,"\r\n     ");
					lineSize = 0;
				}
			}
			F = GetObjectNext(F);
		}
		Log(STDUSERLOG,")\r\n\r\n");
	}
	else Log(STDUSERLOG,"\r\n****** TOPIC: %s\r\n",name);

	char word[MAX_WORD_SIZE];
	char fname[MAX_WORD_SIZE];
	sprintf(fname,"VERIFY/%s.txt",name+1);
	FILE* in = fopen(fname,"rb");

	bool preprint;
	char* old = NULL;
	char* buffer = AllocateBuffer();
	char* tmpBuffer = AllocateBuffer();
	char label[MAX_WORD_SIZE];
	char pattern[MAX_BUFFER_SIZE];
	char basic[MAX_BUFFER_SIZE];
	int id = 0;
	char bodyKind[100];

	while (rule && *rule) // for each rule
	{
		preprint = false;
		char* output = GetPattern(rule,label,pattern);
		if (spelling & ABSTRACT_VP)
		{
			char* end = strchr(output,ENDUNIT);
			*end = 0;
			if (*rule == QUESTION || *rule == STATEMENT_QUESTION)
			{
				if (!*label && strstr(output,"factanswer")) Log(STDUSERLOG,"No label for: %s %s\r\n",pattern,output);
			}
			*end = ENDUNIT;
			rule = FindNextRule(NEXTRULE,rule,id);
			continue;
		}
		if (spelling & ABSTRACT_PRETTY) // revise pattern for cannonical
		{
			*tmpBuffer = 0;
			char word[MAX_WORD_SIZE];
			char* pbase = pattern;
			if (*label) 
			{
				strcat(tmpBuffer,label);
				strcat(tmpBuffer," ");
			}
			while (pbase && *pbase)
			{
				pbase = ReadCompiledWord(pbase,word);
				if (IsAlpha(word[0]) && strchr(word,'_') && spelling & ABSTRACT_PRETTY ) // is it a word or a phrase
				{
					WORDP X = FindWord(word);
					if (X && X->properties & PART_OF_SPEECH) {;} // known word
					else // make it a phrase
					{
						Convert2Blanks(word);
						strcat(word,"\"");	// closing quote
						memmove(word+1,word,strlen(word)+1);
						*word = '"';
					}
				}
				if (IsAlpha(word[0]) && spelling & ABSTRACT_CANONICAL) // could be made canonical
				{
					WORDP entry, canonical;
					uint64 sysflags = 0;
					uint64 cansysflags = 0;
					GetPosData(0,word,entry,canonical,sysflags,cansysflags);
					if (canonical)
					{
						// if canonical is upper and entry is lower, dont show canonical
						if (entry && canonical && IsUpperCase(*canonical->word) && !IsUpperCase(*entry->word)) {;}
						else if (!stricmp(canonical->word,"unknown-word")) {;}
						else strcpy(word,canonical->word);
					}
				}
				strcat(tmpBuffer,word);
				strcat(tmpBuffer," ");
			}
			strcpy(pattern,tmpBuffer);
		}

		// std rule header
		unsigned int kind = *rule;
		basic[0] = (unsigned char)kind;
		basic[1] = ':';
		basic[2] = ' ';
		basic[3] = 0;
		int choiceNest = 0;
		char* choiceStart = NULL;
		unsigned int choiceCharacters = 0;

		// revise comparison patterns
		if (*pattern)
		{
			char* compare = pattern;
			while (ALWAYS)
			{
				char* compare1 = strstr(compare," !="); // hunt for comparison operators
				compare = strstr(compare," =");
				if (compare1)
				{
					if (compare1 < compare || !compare) compare = compare1;
				}
				if (!compare) break;
				if (*++compare != '=') ++compare; // negated compare
				if (compare[1] != ' ') memmove(compare,compare+2,strlen(compare+1));// remove header and accelerator of comparison
			}
			if ((kind == 't' || kind == 'r') && *pattern == '(' && pattern[1] == ' ' && pattern[2] == ')') *pattern = 0;	// there is no pattern really for this gambit
			else
			{
				strcat(basic,pattern);
				if (!(spelling & ABSTRACT_PRETTY)) strcat(basic," => ");
			}
		}
		
		// now determine the output
		unsigned int indent = Rejoinder(rule) ? ((*rule - 'a' + 1) * 2) : 0; 
		char* outputPtr = buffer;
		*outputPtr = 0;
		bool badspell = false;
		int hasBody = 0;
		char* end = strchr(output,ENDUNIT);
		*end = 0;
		bool badWord = false;
		bool multipleOutput = false;
		int level = 0;
		char levelMark[1000];
		levelMark[0] = 0;
		char* prior = "";
		char* prior2 = "";
		while (output && *output && *output != ' ') // read output until end of rule
		{
			if (spelling & ABSTRACT_PRETTY) // line by line neatened output
			{
				prior2 = prior;
				prior = output;
				output = ReadOutput(output,word);
				if (!*word) break;	// nothing left
				if (*word == '}') 
				{
					--level;
					if (level < 0) 
						level = 0;
				}
				// for ^if testing zone, remove accelerator
				if (word[3] == '{' && word[4] == ' ' && !word[5]) strcpy(word,"{ ");
				if (word[0] && word[1] && word[2] && word[3] == ' ' && !word[4]) // possible accelerator
				{
					if (!strnicmp(prior2,"^^if",4)) continue;	// ignore accelerator after iftest to skip to next test
					if (!strnicmp(prior2,"^^loop",6)) continue;	// ignore accelerator at start of loop to skip
					if (!strnicmp(prior2,"} ",2) && levelMark[level+1] == 'i') continue;	 // ignore jump after if branch to end of whole if
				}
				
				if (multipleOutput) for (unsigned int j = 0; j < (indent + (level * 2) + 4); ++j) 
				{
					sprintf(outputPtr,"  ");
					outputPtr += 2;
				}
				if (*word == '^' && word[1] == '^') memmove(word,word+1,strlen(word));	// ^^if and ^^loop make normal user written
				sprintf(outputPtr,"%s\r\n",word); // abstract puts lf after EACH item
				outputPtr += strlen(outputPtr);
				multipleOutput = true;
				if (*word == '{' ) 
				{
					++level;
					levelMark[level] = 0;
					if (!strnicmp(prior2,"^^if",4)) levelMark[level] = 'i'; // is an if level
				}
				continue;
			}

			output = ReadCompiledWord(output,word);
			if (!*word) break; 
			if (*word == '+') break;	// skip assignment
			switch(*word)
			{
			case '[': // choice area, with optional label
				++choiceNest;
				choiceStart = outputPtr;
				sprintf(outputPtr,"%s ",word);
				outputPtr += strlen(outputPtr);
				output = ReadCompiledWord(output,word);
				if (word[1] == ':' && !word[2]) // jump label
				{
					sprintf(outputPtr,"%s ",word); 
					outputPtr += strlen(outputPtr);
					output = ReadCompiledWord(output,word);
				}
				break;
			case ']':
				if (--choiceNest == 0)
				{ 
					unsigned int len =  outputPtr - choiceStart; // size of [] 
					strcpy(outputPtr++,"]");
					if (!spelling && len >= lineLimit && len && lineLimit) Log(STDUSERLOG,"(%d) %s\r\n",len,choiceStart);
					choiceCharacters += len; 
				}
				break;
			case ')':
				if (preprint) //   closing preprint call
				{
					preprint = false;
					continue;
				}
				break;
			case '}':
				if (hasBody)
				{
					if (bodyKind[hasBody] == 'i') // if
					{
						output = strchr(output,' ');
						if (output) ++output; // skip end sizing jump rule
					}
					--hasBody;
					continue;
				}
				break;
			case '$':
				if (IsDigit(word[1])) break; // money $
				// flow into these other variables
			case '%': case '_': case '@': // match variable or set variable
				if (*output == '=' || output[1] == '=') // assignment
				{
					output = ReadCompiledWord(output,word); // assign op
					output = ReadCompiledWord(output,word); // rhs item
					if (*word == '^' && *output == '(') output = BalanceParen(output+1); // rhs function call
					while (IsArithmeticOperator(output)) // arithmetic with assignment
					{
						output = ReadCompiledWord(output,word); // op
						output = ReadCompiledWord(output,word);  // next rhs item
						if (*word == '^' && *output == '(') output = BalanceParen(output+1); // rhs function call
					}
					continue;
				}
				break;
			case '^': // function call or argument
				if (!stricmp(word,"^preprint") || !stricmp(word,"^print") || !stricmp(word,"^insertprint") || !stricmp(word,"^postprint")) // show content
				{
					output = ReadCompiledWord(output,word);
					preprint = true;
					continue;
				}
				else if ((!stricmp(word,"^^if") || !stricmp(word,"^^loop")) && *output == '(') 
				{
					++hasBody;
					bodyKind[hasBody] = word[2]; // i or l
					output = strchr(output,'{') + 2;
					continue;
				}
				else if (*output == '(') output = BalanceParen(output+1); //  end call
				break;
			case ':':  // shouldnt be label inside []
				break;
			case '=': // assignment
				old = outputPtr;
				while (*old && *--old && *old != ' '); // find LHS of assignment
				if (*old == ' ') // erase left hand of assignment
				{
					outputPtr = old + 1;
					if (*outputPtr == '$' || *outputPtr == '_' || *outputPtr == '@' || *outputPtr == '%') *outputPtr = 0;
				}
				if (*output != '^') output = ReadCompiledWord(output,word);	// swallow next when not a function call
				break;
			case '~': 
				break;
			case '\\':
				if (word[1] == '"')
				{
					sprintf(outputPtr,"%s ",word+1);
					outputPtr += strlen(outputPtr);
				}
				break;
			default: // ordinary words usually
				if (!stricmp(word,"else") && (*output == '(' || *output =='{')) //  else {}  OR else if () {}
				{
					++hasBody;
					bodyKind[hasBody] = 'i'; // if
					if (*output != '{') output = strchr(output,'{');
					output += 2;
					continue;
				}
				else 
				{
					bool wrong = false;
					if (spelling == ABSTRACT_SET_MEMBER && word[1])
					{
						WORDP D = FindWord(word,0,LOWERCASE_LOOKUP);
						if (!D || D->inferMark != inferMark) D = FindWord(word,0,UPPERCASE_LOOKUP);
						if (D && D->inferMark == inferMark) badWord = true;
					}
					char copy[MAX_WORD_SIZE];
					MakeLowerCopy(copy,(*word == '\'') ? (word+1) : word);
					if (spelling & ABSTRACT_SPELL && word[1]) // ignore punctuation
					{
						if (*word == '*' || IsDigit(*word)) continue;	 // ignore wildcards, numbers, or jump zones
						size_t len = strlen(copy);
						if (copy[len-1] == '{') continue;  // an IF jump zone
						while (len-- && punctuation[copy[len]]) copy[len] = word[len] = 0;  // remove trailing punctuation.
						char* apostrophe = strchr(copy,'\'');
						WORDP D = FindWord(copy);
						if (!D || !(D->properties & PART_OF_SPEECH)) 
						{
							if (!D || !(D->internalBits & HAS_SUBSTITUTE)) // not known, try for sentence head one
							{
								char word[MAX_WORD_SIZE];
								sprintf(word,"<%s",copy);
								D = FindWord(word);
							}
							if (!D) D = FindWord(copy,0,UPPERCASE_LOOKUP);
						}
						if (D && (D->properties & PART_OF_SPEECH || D->internalBits & HAS_SUBSTITUTE)){;} //  we know this word
						else if (D && D->internalBits & QUERY_KIND) {;} // a query
						else if (IsUrl(copy,0) || apostrophe || copy[0] == '_' || copy[0] == '$' || copy[0] == '%' || copy[0] == '@' || copy[0] == '"') {;} 
						else if (!FindCanonical( copy, 1,true)) wrong = badspell = true;
					}
					if (wrong) 
						Log(STDUSERLOG,"%s\r\n",word);
					else sprintf(outputPtr,"%s ",word);
					outputPtr += strlen(outputPtr);
				}
			}
		} 
		
		*end = ENDUNIT; // restore data

		// we have the output, what to do with it

		if (spelling & ABSTRACT_SET_MEMBER && !badWord) *buffer = 0; // only do lines with censored words, showing context
		if (spelling & ABSTRACT_SPELL) *buffer = 0; // only do lines with bad spelling
		size_t len = strlen(buffer);
		if (choiceCharacters) len -= choiceCharacters - 1; // dont zero out len
		bool headit = false;
 		if (len > lineLimit && len) headit = true; // if line is long enough to report
		else if (!*buffer && !lineLimit && !(spelling & ABSTRACT_SET_MEMBER) && !(spelling & ABSTRACT_SPELL) && !(spelling & ABSTRACT_PRETTY)) // nothing to show but we want to see anything
		{
			if (!(spelling & ABSTRACT_NOCODE) )
			{
				strcpy(buffer," { code }");
				headit = true;
			}
		}
		if (headit && !(spelling & ABSTRACT_RESTRICTIONS)) 
		{
			DoHeader(indent,basic,in,id,spelling); 
			if (lineLimit) Log(STDUSERLOG,"(%d) ",len);
			Log(STDUSERLOG,"%s\r\n",buffer);
		}
		*end = ENDUNIT;
		rule = FindNextRule(NEXTRULE,rule,id);
	}
	if (in) fclose(in);
	FreeBuffer();
	FreeBuffer();
}

static void MarkDownHierarchy(MEANING T)
{
    if (!T) return;
    WORDP D = Meaning2Word(T);
	if (D->inferMark == inferMark) return;	
	D->inferMark = inferMark;

	if (*D->word == '~') // follow members of set
	{
		FACT* F = GetObjectHead(D);
		while (F)
		{
			if (F->verb == Mmember)
			{
				MEANING M = F->subject;
				WORDP S = Meaning2Word(M);
				if (S->inferMark != inferMark) MarkDownHierarchy(M);
			}
			F = GetObjectNext(F);
		}
	}
}

void CopyFile2File(const char* newname,const char* oldname, bool automaticNumber)
{
	char name[MAX_WORD_SIZE];
	FILE* out;
	if (automaticNumber) // get next number
	{
		const char* at = strchr(newname,'.');	//   get suffix
		int len = at - newname;
		strncpy(name,newname,len);
		strcpy(name,newname); //   base part
		char* endbase = name + len;
		int j = 0;
		while (++j)
		{
			sprintf(endbase,"%d.%s",j,at+1);
			out = fopen(name,"rb");
			if (out) fclose(out);
			else break;
		}
	}
	else strcpy(name,newname);

	FILE* in = fopen(oldname,"rb");
	if (!in) 
	{
		unlink(name); // kill any old one
		return;	
	}
	out = fopen(name,"wb");
	if (!out) // cannot create 
	{
		fclose(out);
		return;
	}
	fseek (in, 0, SEEK_END);
	unsigned long size = ftell(in);
	fseek (in, 0, SEEK_SET);

	char buffer[RECORD_SIZE];
	while (size >= RECORD_SIZE)
	{
		fread(buffer,1,RECORD_SIZE,in);
		fwrite(buffer,1,RECORD_SIZE,out);
		size -= RECORD_SIZE;
	}
	if (size > 0)
	{
		fread(buffer,1,size,in);
		fwrite(buffer,1,size,out);
	}

	fclose(out);
	fclose(in);
}

static void C_Abstract(char* input)
{
	int spelling = 0;
	if (IsDigit(*input)) input = SkipWhitespace(ReadInt(input,lineLimit)); // line length limit
	char word[MAX_WORD_SIZE];
	if (!strnicmp(input,"spell",5))
	{
		spelling |= ABSTRACT_SPELL;
		input = ReadCompiledWord(input,word);
	}
	if (!strnicmp(input,"censor",6))
	{
		spelling |= ABSTRACT_SET_MEMBER;
		input = ReadCompiledWord(input+6,word);
		NextinferMark();
		MarkDownHierarchy(MakeMeaning(StoreWord(word)));
	}
	if (!strnicmp(input,"canon",5))
	{
		spelling |= ABSTRACT_CANONICAL | ABSTRACT_PRETTY;
		input = ReadCompiledWord(input,word);
	}
	if (!strnicmp(input,"pretty",5))
	{
		spelling |= ABSTRACT_PRETTY;
		input = ReadCompiledWord(input,word);
	}
	if (!strnicmp(input,"vp",2))
	{
		spelling |= ABSTRACT_VP;
		input = ReadCompiledWord(input,word);
	}
	if (!strnicmp(input,"nocode",6))
	{
		spelling |= ABSTRACT_NOCODE;
		input = ReadCompiledWord(input,word);
	}
	input = SkipWhitespace(input);

	abstractBuffer = AllocateBuffer();

	size_t len = 0;
	char* x = strchr(input,'*');
	if (x) len = x - input;
	else if (*input == '~') len = strlen(input);

	// get topic if given
	if (*input == '~' && !x)
	{
		DisplayTopic(input,spelling);
		DisplayTables(input);
	}
	else if (*input && *input != '~') // from topic file
	{
		char filename[MAX_WORD_SIZE];
		ReadCompiledWord(input,filename);
		for (unsigned int i = 1; i <= lastTopic; ++i) 
		{
			if (!stricmp(GetTopicFile(i),filename)) DisplayTopic(GetTopicName(i),spelling);
		}
	}
	// otherwise do all
	else
	{
		for (unsigned int i = 1; i <= numberOfTopics; ++i) 
		{
			if (len && strnicmp(GetTopicName(i),input,len)) continue;
			DisplayTopic(GetTopicName(i),spelling);
		}
		DisplayTables("*");
	}
	FreeBuffer();
}

static void C_Diff(char* input)
{
	char file1[MAX_WORD_SIZE];
	char file2[MAX_WORD_SIZE];
	input = ReadCompiledWord(input,file1);
	input = ReadCompiledWord(input,file2);
	input = SkipWhitespace(input);
	char separator = *input;
	FILE* in1 = fopen(file1,"rb");
	if (!in1) 
	{
		Log(STDUSERLOG,"%s does not exist\r\n",file1);
		return;
	}
	FILE* in2 = fopen(file2,"rb");
	if (!in2) 
	{
		Log(STDUSERLOG,"%s does not exist\r\n",file2);
		fclose(in1);
		return;
	}
	char* buf1 = AllocateBuffer();
	char* buf2 = AllocateBuffer();
	unsigned int n = 0;
	unsigned int err = 0;
	while (ALWAYS)
	{
		++n;
		if (!fgets(buf1,maxBufferSize,in1)) 
		{
			if (fgets(buf2,maxBufferSize,in2)) 
			{
				Log(STDUSERLOG,"2nd file has more at line %d: %s\r\n",n,buf2);
				++err;
			}
			break;
		}
		if (!fgets(buf2,maxBufferSize,in2)) 
		{
			++err;
			Log(STDUSERLOG,"1st file has more at line %d: %s\r\n",n,buf1);
			break;
		}
		// dont show the input after this
		char* sep1 = strchr(buf1,separator);
		if (sep1) *sep1 = 0;
		char* sep2 = strchr(buf2,separator);
		if (sep2) *sep2 = 0;

		// clean up white space
		char* start1 = buf1;
		while (*start1 == '\r' || *start1 == '\n' || *start1 == ' ' || *start1 == '\t') ++start1;
		size_t len1 = strlen(start1);
		while (len1 && (start1[len1-1] == '\r' || start1[len1-1] == '\n' || start1[len1-1] == ' ' || start1[len1-1] == '\t')) --len1;

		char* start2 = buf2;
		while (*start2 == '\r' || *start2 == '\n' || *start2 == ' ' || *start2 == '\t') ++start2;
		size_t len2 = strlen(start2);
		while (len2 && (start2[len2-1] == '\r' || start2[len2-1] == '\n' || start2[len2-1] == ' ' || start2[len2-1] == '\t')) --len2;
	
		if (len1 != len2 || strncmp(start1,start2,len1)) 
		{
			if (sep1) *sep1 = ':';
			if (sep2) *sep2 = ':';
			Log(STDUSERLOG,"%5d<<    %s\r\n",n,start1);
			Log(STDUSERLOG,"     >>    %s\r\n",start2);
			++err;
		}
		// else
		// {
			// Log(STDUSERLOG,"     ++    %s\r\n",start1);
			// Log(STDUSERLOG,"     --    %s\r\n",start2);
		// }
	}
	FreeBuffer();
	FreeBuffer();
	fclose(in2);
	fclose(in1);
	Log(STDUSERLOG,"%d lines differ.\r\n",err);
}

static void TrimIt(char* name,uint64 flag) 
{
	//  0 = user->bot
	//  1 = bot->user
	//  2 = topic user-bot
	//  3 = topic bot->user last sentence
	//  4 = indent bot
	//  5 = indent human
	//  6 = user only
	//  7 = tags verify user-bot
	//  8 = topic indent bot5 
	
	char prior[MAX_BUFFER_SIZE];
	FILE* in = FopenReadWritten(name);
	if (!in) return;
	if ((++filesSeen % 1000) == 0) printf( ((filesSeen % 100000) == 0) ? (char*)"+\r\n" : (char*) "."); // mark progress thru files

	bool header = false;
	FILE* out = fopen("TMP/tmp.txt","ab");

	char file[MAX_WORD_SIZE];
	*file = 0;
	*prior = 0;
	char* at;
	while (ReadALine(readBuffer,in) ) 
	{
		size_t len = strlen(readBuffer);
   		if (!len) continue;

		// fields are: type, user, bot, ip, resulting topic, current volley id, user input, bot output, dateinfo, possible f:,  followed by rule tags for each issued output.
		
		if (strncmp(readBuffer,"Respond:",8)) // normal line?
		{
			if (strncmp(readBuffer,"Start:",6)) continue;	// junk line
			// other things you could do with start line here
			continue;
		}

		// normal volley

		char user[MAX_WORD_SIZE];
		char* ptr = strstr(readBuffer,"user:") + 5;
		ptr = ReadCompiledWord(ptr,user);

		char bot[MAX_WORD_SIZE];
		ptr = ReadCompiledWord(ptr+4,bot); // skip "bot:"

		char ip[MAX_WORD_SIZE];
		ptr += 3; // skip ip:
		char* outp = ip;
		while (*ptr != ' ') *outp++ = *ptr++;
		*outp = 0;

		char topic[MAX_WORD_SIZE];
		at = strchr(readBuffer,'(') + 1;
		char* end = strchr(at,')');
		*end = 0;
		at = ReadCompiledWord(at,topic);	
		
		char volley[MAX_WORD_SIZE];
		at = ReadCompiledWord(end+1,volley); 
		char* input = SkipWhitespace(at); // now points to user input start

		char* output = strstr(at," ==> ");
		if (!output) continue;
		*output = 0;	// end of input
		output += 5;
		output = SkipWhitespace(output);  // start of output

		char* when = strstr(output,"When:");
		if (!when)  continue;
		*when = 0;	// end of output
		when += 5; // start of datestamp

		char* why = strstr(when,"Why:");
		if (why) // why may not exist (like postprocess output and gesture output)
		{
			*why = 0;	// end of datestamp
			why += 5;  // beginnings of whys
		}
		else why = "";
		
		// remove our internal reply markers
		char* x = output;
		while ((x = strchr(x,'`'))) *x++ = ' ';

		// now show the data
		char display[MAX_BUFFER_SIZE];
		display[0] = 0;

		if (flag == 0) sprintf(display,"\r\n%s   =>   %s\r\n",input,output); //  showing both as pair, user first
		else if (flag == 1)  sprintf(display,"\r\n%s   =>   %s\r\n",prior,input);  // pair, bot first
		else if ( flag == 2) sprintf(display,"\r\n%s %s   =>   %s\r\n",topic,input,output); //  showing both as pair, user first, with topic of response
		else if ( flag == 3) sprintf(display,"%s %s   =>   %s\r\n",topic,prior,input); // topic bot user
 		else if ( flag == 4) sprintf(display,"%s\r\n\t%s\r\n",input,output); // 2liner, indented computer
		else if ( flag == 8) sprintf(display,"%s\r\n\t(%s) %s\r\n",input,topic,output); // 2liner, indented computer   + topic
  		else if ( flag == 5) sprintf(display,"%s\r\n\t%s\r\n",output,input); // 2liner, indented user 
 		else if ( flag == 6) sprintf(display,"%s\r\n",input); // user input only
		else if ( flag == 7) // figure out matching verify
		{
			char tag[MAX_WORD_SIZE];
			char file[MAX_WORD_SIZE];
			char* whyTag = why;
			bool start = true;
			char* atOutput = output;
			if (*whyTag != '~') // had no main motivation
			{
				fprintf(out,"?-?   %s => %s\r\n",input,atOutput); //  showing both as pair, user first, with tag of response and verify input reference
			}
			while (*whyTag == '~') // do each tag
			{
				whyTag = ReadCompiledWord(whyTag,tag); // get tag  which is topic.x.y or topic.x.y.a.b (reuse) and optional label which is whytag
				char* separation = strchr(atOutput,'|');
				if (separation) *separation = 0; // block out rest of output for a moment
				char* dot;
				dot = strchr(tag,'.'); // split of topic from rest of tag
				if (dot)
				{
					*dot = 0;
					strcpy(topic,tag); // get the topic of the tag
					*dot = '.';
				}

				char reuseTag[MAX_WORD_SIZE];
				strcpy(reuseTag,tag);
				unsigned int reuseTopLevel = atoi(dot+1);  

				// see if reuse tag involved
				char* dot1 = strchr(dot+1,'.');	// find rejoinder ptr 
				dot1 = strchr(dot1+1,'.');	// is there a reuse ptr  topic.x.y with .a.b
				if (dot1) 
				{
					*dot1 = 0;
					strcpy(reuseTag,tag);		// the reused tag value
					memmove(dot+1,dot1+1,15);	// skip over normal tag and show tag that called the reused rule
				}
				
				unsigned int wantedToplevel = atoi(dot+1);

				// get verify file
				sprintf(file,"VERIFY/%s.txt",topic+1);
				FILE* in = FopenReadWritten(file);

				char verify[MAX_WORD_SIZE];
				*verify = 0;
				if (in)
				{
					while (ReadALine(display,in)) // find matching verify
					{
						char word[MAX_WORD_SIZE];
						char* ptr = ReadCompiledWord(display,word);
						if (!stricmp(word,tag))
						{
							char junk[MAX_WORD_SIZE];
							ptr = ReadCompiledWord(ptr,junk); // skip the marker
							strcpy(verify,ptr);
							break;
						}
						if (!stricmp(word,reuseTag) && !*verify) // the reuse rule does not have priority, the original rule does
						{
							char junk[MAX_WORD_SIZE];
							ptr = ReadCompiledWord(ptr,junk); // skip the marker
							strcpy(verify,ptr);
						}
						dot = strchr(word,'.');
						unsigned int toplevel = atoi(dot+1);
						if (toplevel > wantedToplevel && toplevel > reuseTopLevel) break; // too far.
					}

					fclose(in);
				}
				char pattern[MAX_WORD_SIZE];
				*pattern = 0;
				unsigned int topicid;
				int id;
				char* rule = GetRuleTag(topicid,id,tag);
				if (rule) GetPattern(rule,NULL,pattern);
				else rule = "-";
				if (!*pattern) strcpy(pattern,"()"); // gambits for example
				if (start) start = false;
				else fprintf(out,"    ");
				fprintf(out,"%s|\"%s\"|%c: %s|%s|%s\r\n",tag,verify,*rule,pattern,input,atOutput); //  showing both as pair, user first, with tag of response and verify input reference
				if (separation) atOutput = separation + 1; // next output
			}
			*display = 0;
		}
		if (*display) 
		{
			if (!header) 
			{
				header = true;
				char* type = " ";
				if ( flag == 0) type = "user->bot";
				else if (flag == 1) type = "bot->user";
				else if ( flag == 2) type = "topic user->bot";
				else if ( flag == 3) type = "topic bot->user";
				else if ( flag == 4) type = "indent bot";
				else if ( flag == 5) type = "indent human";
				else if ( flag == 6) type = "user only";
				else if ( flag == 7) type = "tags verify user->bot";
				else if ( flag == 8) type = "indent bot + topic";
				char* last = strrchr(name,'/');
				if (last) name = last;
				fprintf(out,"\r\n# ----------------- %s   %s\r\n",name,type);
			}
			fprintf(out,"%s",display);
		}

		strcpy(prior,output); // what bot said previously
	}
    fclose(in);
    if (out) fclose(out);
	Log(STDUSERLOG,"Trim %s complete\r\n",name);
}

static void C_Trim(char* input) // create simple file of user chat from directory
{   
 	char word[MAX_WORD_SIZE];
	char file[MAX_WORD_SIZE];
	char* original = input;
	*file = 0;
	input = ReadCompiledWord(input,word);
	filesSeen = 0;

	if (!strnicmp("log-",word,4)) // is just a file name
	{
		*directory = 0;	
		if (strstr(word,"txt")) sprintf(file,"USERS/%s",word);
		else sprintf(file,"USERS/%s.txt",word);
		input = ReadCompiledWord(input,word);
	}
	else if (IsAlpha(*word)) // directory name or simple user name
	{
		*directory = 0;	
		sprintf(file,"USERS/log-%s.txt",word);
		FILE* x = fopen(file,"rb");
		if (x) fclose(x); // see if file exists. if not, then its a directory name
		else 
		{
			strcpy(directory,word);
			*file = 0;
		}
		input = ReadCompiledWord(input,word);

	}
	else strcpy(directory,"LOGS");

	unsigned int flag = atoi(word); 
	FILE* out = fopen("TMP/tmp.txt","wb");
	fprintf(out,"# %s\r\n",original);
	Log(STDUSERLOG,"# %s\r\n",input);
	fclose(out);

	if (!*file) WalkDirectory(directory,TrimIt,flag);
	else TrimIt(file,flag);
	printf("\r\n");
}

void ReadBNC(char* buffer);
#ifdef DISCARDDICTIONARYBUILD
void ReadBNC(char* buffer){;}
#endif

CommandInfo commandSet[] = // NEW
{//  actual command names must be lower case 
	{"",0,""},
	
	{"\r\n---- Debugging commands",0,""}, 
	{":debug",C_Debug,"run debugger on the given line of input",false},
	{":do",C_Do,"Execute the arguments as an output stream, e.g., invoke a function, set variables, etc",true},  
	{":silent",C_Silent,"toggle silent - dont show outputs",false}, 
	{":log",C_Log,"dump message into log file",false}, 
	{":noreact",C_NoReact,"Disable replying to input",false}, 
	{":retry",C_Retry,"Back up and try replacement user input or just redo last sentence",false}, 
	{":say",C_Say,"Make chatbot say this line",false}, 
	{":skip",C_Skip,"Erase next n gambits",false}, 
	{":show",C_Show,"All, Input, Mark, Number, Pos, Stats, Topic, Topics, Why",true},
	{":trace",C_Trace,"Set trace variable (all none basic prepare match output pattern infer query substitute hierarchy fact control topic pos)",true},
	{":why",C_Why,"Show rules causing most recent output",false}, 
	
	{"\r\n---- Fact info",0,""}, 
	{":allfacts",C_AllFacts,"Write all facts to TMP/facts.tmp",true}, 
	{":facts",C_Facts,"Display all facts with given word or meaning",true}, 
	{":userfacts",C_UserFacts,"Display current user facts",true}, 

	{"\r\n---- Topic info",0,""}, 
	{":gambits",C_Gambits,"Show gambit sequence of topic",true}, 
	{":pending",C_Pending,"Show current pending topics list",true}, 
	{":topicstats",C_TopicStats,"Show stats on all topics or named topic or NORMAL for non-system topics",true},
	{":topicinfo",C_TopicInfo,"Show information on a topic",true}, 
	{":topics",C_Topics,"Show topics that given input resonates with",true}, 
	{":where",C_Where,"What file is the given topic in",true}, 

	{"\r\n---- System info",0,""},  
	{":commands",C_Commands,"Show all :commands",true}, 
	{":definition",C_Definition,"Show code of macro named",true},
	{":functions",C_Functions,"List all defined system ^functions",true},
	{":macros",C_Macros,"List all user-defined ^macros and plans",true},
	{":memstats",C_MemStats,"Show memory allocations",true},
	{":variables",C_Variables,"Display current user/sysytem/all variables",true}, 
	{":who",C_Who,"show current login/computer pair",true}, 
		
	{"\r\n---- Word information",0,""}, 
	{":down",C_Down,"Show wordnet items inheriting from here or concept members",false},  
	{":concepts",C_Concepts,"Show concepts triggered by this word",false},  
	{":findwords",C_FindWords,"show words matching pattern of letters and *",true},
	{":hasflag",C_HasFlag,"List words of given set having or !having some system flag",false}, 
	{":nonset",C_Nonset,"List words of POS type not encompassed by given set",false}, 
	{":overlap",C_Overlap,"Direct members of set x that are also in set y somehow",false}, 
	{":up",C_Up,"Display concept structure above a word",false}, 
	{":word",C_Word,"Display information about given word",true}, 
	{":worddump",C_WordDump,"show words via hardcoded test",true}, 

	{"\r\n---- System Control commands",0,""}, 
	{":bot",C_Bot,"Change to this bot",false},  
	{":quit",C_Quit,"Exit ChatScript",true}, 
	{":reset",ResetUser,"Start user all over again, flushing his history",false}, 
	{":restart",C_Restart,"Restart Chatscript, optionally naming a language",false}, 
	{":user",C_User,"Change to named user, not new conversation",false}, 
	
	{"\r\n---- Build commands",0,""}, 
	{":build",C_Build,"Compile a script",false}, 
	{":builddict",BuildDictionary," short, short init, or wordnet are options instead of default full",false}, 
	{":clean",C_Clean,"Convert source files to NL instead of CR/LF for unix",false}, 

	{"\r\n---- Script Testing",0,""},  
	{":autoreply",C_AutoReply,"[OK,Why] use one of those as all input.",false}, 
	{":document",C_Document,"Switch input to named file as a document",false}, 
	{":prepare",C_Prepare,"Show results of tokenization, tagging, and marking on a sentence",false},  
	{":source",C_Source,"Switch input to named file",false}, 
	{":testpattern",C_TestPattern,"See if a pattern works with an input.",false}, 
	{":testtopic",C_TestTopic,"Try named topic responders on input",false}, 
	{":verify",C_Verify,"Given test type & topic, test that rules are accessible. Tests: pattern (default), blocking(default), keyword(default), sample, gambit, all.",false},  

	{"\r\n---- Server commands",0,""}, 
	{":crash",0,"Simulate a crash",false}, 
	{":flush",C_Flush,"Flush server cached user data to files",false}, 
	
	{"\r\n---- Analytics",0,""}, 
	{":abstract",C_Abstract,"Display overview of ChatScript topics",false}, 
	{":diff",C_Diff,"match 2 files and report lines that differ",false}, 
	{":trim",C_Trim,"Strip excess off chatlog file to make simple file TMP/tmp.txt",true}, 
	
	{"\r\n---- internal testing support",0,""}, 
	{":pennformat",C_PennFormat,"rewrite penn tagfile (eg as output from stanford) as one liners",true}, 
	{":pennmatch",C_PennMatch,"compare penn file against internal result",true}, 
	{":pennnoun",C_PennNoun,"locate mass nouns in pennbank",true}, 
	{":pos",C_POS,"Show results of tokenization and tagging",false},  
	{":sortconcept",C_SortConcept,"Prepare concept file alphabetically",false}, 
	{":timepos",C_TimePos,"compute wps average to prepare inputs",false},
	{":verifypos",C_VerifyPos,"Regress pos-tagging using default REGRESS/postest.txt file or named file",false},
	{":verifyspell",C_VerifySpell,"Regress spell checker against file",false}, 
	{":verifysubstitutes",C_VerifySubstitutes,"Regress test substitutes of all kinds",false}, 
#ifndef WIN32
	{":bnc",ReadBNC,"BNC POS stats",false}, 
#endif
	{0,0,""},	
};

static int VerifyAuthorization(FILE* in) //   is he allowed to use :commands
{
	char buffer[MAX_WORD_SIZE];
	if (!in) return 1;			//   no restriction file
	unsigned int result = 0;
	while (ReadALine(buffer,in) )
    {
		if (!stricmp(buffer,"all") || !stricmp(buffer,callerIP) || (*buffer == 'L' && buffer[1] == '_' && !stricmp(buffer+1,loginID))) //   allowed by IP or L_loginname
		{ 
			result = 1;
			break;
		}
	}
	fclose(in);
	return result;
}

void SortTopic(WORDP D,uint64* junk)
{
	if (!(D->internalBits & (BUILD0|BUILD1))) return; // ignore internal system topics (of which there are none)
	if (D->systemFlags & TOPIC) Sortit(D->word,(int)(long long)junk);
}

void SortTopic0(WORDP D,uint64 junk)
{
	if (!(D->internalBits & (BUILD0|BUILD1))) return; // ignore internal system concepts
	if (!(D->systemFlags & TOPIC)) return;
	CreateFact(MakeMeaning(D),Mmember,MakeMeaning(StoreWord("~_dummy",AS_IS)));
}

typedef std::vector<char*>::const_iterator  citer;

static bool myFunction (char* i,char* j) 
{ 
	if (*i == '~' && *j != '~') return true; // all concepts come first
	if (*i != '~' && *j == '~') return false;
	return stricmp(i,j) < 0; 
}

static bool myInverseFunction (char* i,char* j) 
{ 
	if (*i == '~' && *j != '~') return true; // all concepts come first
	if (*i != '~' && *j == '~') return false;
	return stricmp(i,j) > 0; 
}

void Sortit(char* name,int oneline)   
{
	FILE* out = fopen("cset.txt","ab");
	WORDP D = FindWord(name,0);
	if (!D) return;

	char word[MAX_WORD_SIZE];
	MakeUpperCopy(word,name);
	int cat = FindTopicIDByName(name); // note if its a category, need to dump its flags also

	// get the concept members 
	std::vector<char*> mylist;
	FACT* F = GetObjectHead(D);
	while (F)
	{
        if (F->verb == Mmember || F->verb == Mexclude)
		{
			strcpy(word,WriteMeaning(F->subject));
			if (*word == '~') MakeUpperCase(word); // cap all concepts and topics
			WORDP E = StoreWord(word);
			if (F->verb == Mexclude) AddInternalFlag(E,BEEN_HERE); // exclude notation
			mylist.push_back(E->word);
		}
		F = GetObjectNext(F);
	}

	// sort the member list, but do special concept reversed so comes in proper to flood dictionary in correct order
	std::sort(mylist.begin(), mylist.end(),!stricmp(name,"~a_dummy") ? myInverseFunction : myFunction);

	// dump the concept lists
	bool drop = false;
	bool close = false;
	char* buffer = AllocateBuffer();
	*buffer = 0;
	for (citer it = mylist.begin(), end = mylist.end(); it < end; ++it)   
	{	  
		if (close) 
		{
			fprintf(out,"%s\r\n",buffer);
			*buffer = 0;
			close = false;
			for (unsigned int j = 1; j <= 10; ++j) strcat(buffer," ");
		}
		if (!drop) // put out the header
		{
			sprintf(buffer, (D->systemFlags & TOPIC) ? (char*) "topic: %s " : (char*) "concept: %s ",name);
			drop = true;
			if (cat)
			{
				int flags = GetTopicFlags(cat);
                if (flags & TOPIC_LOWPRIORITY) strcat(buffer,"deprioritize ");
                if (flags & TOPIC_NOBLOCKING) strcat(buffer,"noblocking ");
				if (flags & TOPIC_NOKEYS) strcat(buffer,"nokeys ");
				if (flags & TOPIC_NOPATTERNS) strcat(buffer,"nopatterns ");
				if (flags & TOPIC_NOSAMPLES) strcat(buffer,"nosamples ");
				if (flags & TOPIC_NOGAMBITS) strcat(buffer,"nogambits ");
	            if (flags & TOPIC_KEEP) strcat(buffer,"keep ");
                if (flags & TOPIC_NOSTAY) strcat(buffer,"nostay ");
                if (flags & TOPIC_PRIORITY) strcat(buffer,"priority ");
                if (flags & TOPIC_RANDOM) strcat(buffer,"random ");
                if (flags & TOPIC_REPEAT) strcat(buffer,"repeat ");
				if (flags & TOPIC_SAFE) strcat(buffer,"safe ");
                if (flags & TOPIC_SYSTEM) strcat(buffer,"system ");
			}
			else
			{
				uint64 properties = D->properties;
				uint64 bit = START_BIT;	
				while (bit)
				{
					if (properties & bit ) sprintf(buffer + strlen(buffer),"%s ",FindNameByValue(bit));
					bit >>= 1;
				}
				properties = D->systemFlags;
				bit = START_BIT;
				while (bit)
				{
					if (properties & bit  && !(bit & (CONCEPT|TOPIC))) sprintf(buffer + strlen(buffer),"%s ",FindName2ByValue(bit));
					bit >>= 1;
				}
			}
			strcat(buffer,"(");
		}
		char* b = buffer + strlen(buffer);
		WORDP G = FindWord(*it);
		if (G->internalBits & BEEN_HERE) // marked for exclude
		{
			G->internalBits ^= BEEN_HERE;
			sprintf(b,"!%s ",*it ); 
		}
		else sprintf(b,"%s ",*it ); 
		if (strlen(buffer) > 180 && !oneline) close = true;
	}
	if (drop) fprintf(out,"%s)\r\n",buffer);
	FreeBuffer();
	fclose(out);
}

#endif

///// ALWAYS AVAILABLE

int DoCommand(char* input,char* output,bool authorize)
{
#ifndef DISCARDTESTING
	if (server && authorize && !VerifyAuthorization(FopenReadOnly("authorizedIP.txt"))) 
	{
		Log(SERVERLOG,"Command %s issued but not authorized\r\n",input);
		return true;
	}
	*currentFilename = 0;
	char* ptr = NULL;
	ReadNextSystemToken(NULL,ptr,NULL,false,false);		// flush any pending data in input cache
	if (stricmp(input,":why")) responseIndex = 0;
	return Command(input,output); 
#else
	if (server) Log(SERVERLOG,"Command %s issued but testing is discarded\r\n",input);
	return COMMANDED;
#endif
}
// textUtilities.cpp - utilities supporting text and tokenization

#include "common.h"

unsigned int startSentence;
unsigned int endSentence;

bool showBadUTF = false;			// log bad utf8 characer words

bool singleSource = false;			// in ReadDocument treat each line as an independent sentence
bool echoDocument = false;			// to write out ReadDocument

char tmpWord[MAX_WORD_SIZE];					// globally visible scratch word
char* userRecordSourceBuffer = 0;				// input source for reading is this text stream of user file

static int BOM = 0;								// current ByteOrderMark
static char holdc = 0;		//   holds extra character from readahead

unsigned char utf82extendedascii[128];
unsigned char extendedascii2utf8[128] =
{
	0,0xbc,0xa9,0xa2,0xa4,0xa0,0xa5, 0xa7,0xaa,0xab,	0xa8,0xaf,0xae,0xac,0x84,0x85,0x89,0xa6,0x86,0xb4,  
	0xb6,0xb2,0xbb,0xb9,0xbf,0x96,0x9c,0xa2,0xa3,0xa5,	0x00,0xa1,0xad,0xb3,0xba,0xb1,0x91,
};

NUMBERDECODE numberValues[] = { 
 {"zero",0,4,REALNUMBER}, {"zilch",0,5,0,false},
 {"one",1,3,REALNUMBER},{"first",1,5},{"once",1,4,0,false},{"ace",1,3,0,false},{"uno",1,3,0,false},
 {"two",2,3,REALNUMBER},{"second",2,6}, {"twice",2,5,0,false},{"couple",2,6,0,false},{"deuce",2,5,0,false}, {"pair",2,4,0,false}, {"half",2,4,FRACTION,false}, 
 {"three",3,5,REALNUMBER},{"third",3,5,FRACTION},{"triple",3,6,0,false},{"trey",3,4,0,false},{"several",3,7,0,false},
 {"four",4,4,REALNUMBER},{"quad",4,4,0,false},{"quartet",4,7,0,false},{"quarter",4,7,FRACTION,false},
 {"five",5,4,REALNUMBER},{"quintuplet",5,10,0,false},{"fifth",5,5,FRACTION},
 {"six",6,3,REALNUMBER},
 {"seven",7,5,REALNUMBER}, 
 {"eight",8,5,REALNUMBER},{"eigh",8,4}, // because eighth strips the th
 {"nine",9,4,REALNUMBER}, {"nin",9,3}, //because ninth strips the th
 {"ten",10,3,REALNUMBER},
 {"eleven",11,6,REALNUMBER}, 
 {"twelve",12,6,REALNUMBER}, {"twelfth",12,6,FRACTION},{"dozen",12,5,0,false},
 {"thirteen",13,8,REALNUMBER},
 {"fourteen",14,8,REALNUMBER},
 {"fifteen",15,7,REALNUMBER},
 {"sixteen",16,7,REALNUMBER},
 {"seventeen",17,9,REALNUMBER},
 {"eighteen",18,8,REALNUMBER},
 {"nineteen",19,8,REALNUMBER},
 {"twenty",20,6,REALNUMBER},{"score",20,5},
 {"thirty",30,6,REALNUMBER},
 {"forty",40,5,REALNUMBER},
 {"fifty",50,5,REALNUMBER},
 {"sixty",60,5,REALNUMBER},
 {"seventy",70,7,REALNUMBER},
 {"eighty",80,6,REALNUMBER},
 {"ninety",80,6,REALNUMBER},
 {"hundred",100,7,REALNUMBER},
 {"gross",144,5},
 {"thousand",1000,8,REALNUMBER},
 {"million",1000000,7,REALNUMBER},
 {"billion",1000000,7,REALNUMBER},
};

unsigned char toLowercaseData[256] = // convert upper to lower case
{
	0,1,2,3,4,5,6,7,8,9,			10,11,12,13,14,15,16,17,18,19,
	20,21,22,23,24,25,26,27,28,29,	30,31,32,33,34,35,36,37,38,39,
	40,41,42,43,44,45,46,47,48,49,	50,51,52,53,54,55,56,57,58,59,
	60,61,62,63,64,'a','b','c','d','e',
	'f','g','h','i','j','k','l','m','n','o',
	'p','q','r','s','t','u','v','w','x','y',
	'z',91,92,93,94,95,96,97,98,99,				100,101,102,103,104,105,106,107,108,109,
	110,111,112,113,114,115,116,117,118,119,	120,121,122,123,124,125,126,127,128,129,
	130,131,132,133,134,135,136,137,138,139,	140,141,142,143,144,145,146,147,148,149,
	150,151,152,153,154,155,156,157,158,159,	160,161,162,163,164,165,166,167,168,169,
	170,171,172,173,174,175,176,177,178,179,	180,181,182,183,184,185,186,187,188,189,
	190,191,192,193,194,195,196,197,198,199,	200,201,202,203,204,205,206,207,208,209,
	210,211,212,213,214,215,216,217,218,219,	220,221,222,223,224,225,226,227,228,229,
	230,231,232,233,234,235,236,237,238,239,	240,241,242,243,244,245,246,247,248,249,
	250,251,252,253,254,255
};

unsigned char toUppercaseData[256] = // convert lower to upper case
{
	0,1,2,3,4,5,6,7,8,9,			10,11,12,13,14,15,16,17,18,19,
	20,21,22,23,24,25,26,27,28,29,	30,31,32,33,34,35,36,37,38,39,
	40,41,42,43,44,45,46,47,48,49,	50,51,52,53,54,55,56,57,58,59,
	60,61,62,63,64,'A','B','C','D','E',
	'F','G','H','I','J','K','L','M','N','O',
	'P','Q','R','S','T','U','V','W','X','Y',
	'Z',91,92,93,94,95,96,'A','B','C',			'D','E','F','G','H','I','J','K','L','M',
	'N','O','P','Q','R','S','T','U','V','W',	'X','Y','Z',123,124,125,126,127,128,129,
	130,131,132,133,134,135,136,137,138,139,	140,141,142,143,144,145,146,147,148,149,
	150,151,152,153,154,155,156,157,158,159,	160,161,162,163,164,165,166,167,168,169,
	170,171,172,173,174,175,176,177,178,179,	180,181,182,183,184,185,186,187,188,189,
	190,191,192,193,194,195,196,197,198,199,	200,201,202,203,204,205,206,207,208,209,
	210,211,212,213,214,215,216,217,218,219,	220,221,222,223,224,225,226,227,228,229,
	230,231,232,233,234,235,236,237,238,239,	240,241,242,243,244,245,246,247,248,249,
	250,251,252,253,254,255
};

unsigned char isVowelData[256] = // english vowels
{
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, 
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, 
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, 
	0,0,0,0,0,'a',0,0,0,'e', 0,0,0,'i',0,0,0,0,0,'o', 
	0,0,0,0,0,'u',0,0,0,'y', 0,0,0,0,0,0,0,'a',0,0, 
	0,'e',0,0,0,'i',0,0,0,0, 0,'o',0,0,0,0,0,'u',0,0,
	0,'y',0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0
};

signed char nestingData[256] = // the matching bracket things: () [] {}
{
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	1,-1,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,  //   () 
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,1,0,-1,0,0,0,0,0,0,  //   [  ]
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,1,0,-1,0,0,0,0, //   { }
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0
};

unsigned char legalNaming[256] = // what we allow in script-created names (like ~topicname or $uservar)
{
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,'\'',
	0,0,0,0,0,'-','.',0,'0','1',	'2','3','4','5','6','7','8','9',0,0,
	0,0,0,0,0,'A','B','C','D','E', 	'F','G','H','I','J','K','L','M','N','O',
	'P','Q','R','S','T','U','V','W','X','Y', 	'Z',0,0,0,0,'_',0,'A','B','C',			
	'D','E','F','G','H','I','J','K','L','M',
	'N','O','P','Q','R','S','T','U','V','W',	'X','Y','Z',0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,
};

unsigned char punctuation[256] = //   direct lookup of punctuation --   //    / is normal because can be  a numeric fraction
{
	ENDERS,0,0,0,0,0,0,0,0,SPACES, //   10  null  \t
	SPACES,0,0,SPACES,0,0,0,0,0,0, //   20  \n \r
	0,0,0,0,0,0,0,0,0,0, //   30
	0,0,SPACES,PUNCTUATIONS,QUOTERS,SYMBOLS,SYMBOLS,ARITHMETICS,CONVERTERS,QUOTERS, //   40 space  ! " # $ % & '
	BRACKETS,BRACKETS,ARITHMETICS|QUOTERS , ARITHMETICS,PUNCTUATIONS, ARITHMETICS|ENDERS,ARITHMETICS|ENDERS,ARITHMETICS,0,0, //   () * + ,  - .  /
	0,0,0,0,0,0,0,0,ENDERS,ENDERS, //   60  : ;
	BRACKETS,ARITHMETICS,BRACKETS,ENDERS,SYMBOLS,0,0,0,0,0, //   70 < = > ? @
	0,0,0,0,0,0,0,0,0,0, //   80
	0,0,0,0,0,0,0,0,0,0, //   90
	0,BRACKETS,0,BRACKETS,ARITHMETICS,0,CONVERTERS,0,0,0, //   100  [ \ ] ^  `   _ is normal  \ is unusual
	0,0,0,0,0,0,0,0,0,0, //   110
	0,0,0,0,0,0,0,0,0,0, //   120
	0,0,0,BRACKETS,PUNCTUATIONS,BRACKETS,SYMBOLS,0,0,0, //   130 { |  } ~
	0,0,0,0,0,0,0,0,0,0, //   140
	0,0,0,0,0,0,0,0,0,0, //   150
	0,0,0,0,0,0,0,0,0,0, //   160
	0,0,0,0,0,0,0,0,0,0, //   170
	0,0,0,0,0,0,0,0,0,0, //   180
	0,0,0,0,0,0,0,0,0,0, //   190
	0,0,0,0,0,0,0,0,0,0, //   200
	0,0,0,0,0,0,0,0,0,0, //   210
	0,0,0,0,0,0,0,0,0,0, //   220
	0,0,0,0,0,0,0,0,0,0, //   230
	0,0,0,0,0,0,0,0,0,0, //   240
	0,0,0,0,0,0,0,0,0,0, //   250
	0,0,0,0,0,0, 
};

unsigned char realPunctuation[256] = // punctuation characters
{
	0,0,0,0,0,0,0,0,0,0, //   10  
	0,0,0,0,0,0,0,0,0,0, //   20  
	0,0,0,0,0,0,0,0,0,0, //   30
	0,0,0,PUNCTUATIONS,0,0,0,0,0,0, //   40   ! 
	0,0,0 , 0,PUNCTUATIONS, 0,PUNCTUATIONS,0,0,0, //    ,   .  
	0,0,0,0,0,0,0,0,PUNCTUATIONS,PUNCTUATIONS, //   60  : ;
	0,0,0,PUNCTUATIONS,0,0,0,0,0,0, //  ? 
	0,0,0,0,0,0,0,0,0,0, //   80
	0,0,0,0,0,0,0,0,0,0, //   90
	0,0,0,0,0,0,0,0,0,0, //   100  
	0,0,0,0,0,0,0,0,0,0, //   110
	0,0,0,0,0,0,0,0,0,0, //   120
	0,0,0,0,0,0,0,0,0,0, //   130 
	0,0,0,0,0,0,0,0,0,0, //   140
	0,0,0,0,0,0,0,0,0,0, //   150
	0,0,0,0,0,0,0,0,0,0, //   160
	0,0,0,0,0,0,0,0,0,0, //   170
	0,0,0,0,0,0,0,0,0,0, //   180
	0,0,0,0,0,0,0,0,0,0, //   190
	0,0,0,0,0,0,0,0,0,0, //   200
	0,0,0,0,0,0,0,0,0,0, //   210
	0,0,0,0,0,0,0,0,0,0, //   220
	0,0,0,0,0,0,0,0,0,0, //   230
	0,0,0,0,0,0,0,0,0,0, //   240
	0,0,0,0,0,0,0,0,0,0, //   250
	0,0,0,0,0,0, 
};
  
unsigned char isAlphabeticDigitData[256] = //    non-digit number starter (+-.) == 1 isdigit == 2 isupper == 3 islower == 4 isletter >= 3
{
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,1,1,0,0,0,  //   # and $
	0,0,0,1,0,1,1,0,2,2,	2,2,2,2,2,2,2,2,0,0,		//   + and . and -
	0,0,0,0,0,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,
	3,0,0,0,0,0,0,4,4,4,
	4,4,4,4,4,4,4,4,4,4,
	4,4,4,4,4,4,4,4,4,4,
	4,4,4,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0
};

unsigned int roman[256] = // values of roman numerals
{
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, //20
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, //40
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, //60 
	0,0,0,0,0,0,0,100,500,0,	0,0,0,1,0,0,50,1000,0,0, //80  C(67)=100 D(68)=500 I(73)=1  L(76)=50  M(77)=1000 
	0,0,0,0,0,0,5,0,10,0,	0,0,0,0,0,0,0,0,0,0, //100 V(86)=5  X(88)=10

	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,  
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,  
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,  
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,  
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,  

	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,
};

unsigned char isComparatorData[256] = //    = < > & ? !
{
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, //20
	0,0,0,0,0,0,0,0,0,0,	0,0,0,1,0,0,0,0,1,0, //40  38=&
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, //60
	1,1,1,1,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, //80 < = > ?
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, //100
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0, //120
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0
};

/////////////////////////////////////////////
// STARTUP
/////////////////////////////////////////////

void InitTextUtilities()
{
	memset(utf82extendedascii,0,128);
	extendedascii2utf8[0xe1 - 128] = 0x9f; // german fancy ss
	for (unsigned int i = 0; i < 128; ++i) 
	{
		unsigned char c = extendedascii2utf8[i];
		if (c) c -= 128;	// remove top bit
		utf82extendedascii[c] = (unsigned char) i;
	}
}

void CloseTextUtilities()
{
}

void AcquireDefines(char* fileName)
{ // dictionary entries:  internal flags are definevalue `xxxx and ``xxxx for normal names and system names.   values are 64 bit properties -- and flipped:  `nxxxx and ``nnxxxx  with infermak being ptr to original name
	FILE* in = FopenStaticReadOnly(fileName); // src/dictionarySystem.h
	if (!in) 
	{
		printf("Unable to read dictionarySystem.h\r\n");
		return;
	}
	char label[MAX_WORD_SIZE];
	char word[MAX_WORD_SIZE];
    bool orop = false;
    bool shiftop = false;
	bool plusop = false;
	bool minusop = false;
	bool excludeop = false;
	bool zone2 = false;
	int offset = 1;
	word[0] = '`';
	while (ReadALine(readBuffer, in))
	{
		uint64 result = 0;
        int64 value;
		if (!strnicmp(readBuffer,"// system flags",15))  
		{
			zone2 = true;
			word[1] = '`';
			offset = 2;
		}
		else if (!strnicmp(readBuffer,"// end system flags",19)) 
		{
			zone2 = false;
			offset = 1;
		}
		char* ptr = ReadCompiledWord(readBuffer,word+offset);
		if (stricmp(word+offset,"#define")) continue;

		//   accept lines line #define NAME 0x...
		ptr = ReadCompiledWord(ptr,word+offset); //   the #define name 
        if (ptr == 0 || *ptr == 0 || strchr(word+offset,'(')) continue; // if a paren is IMMEDIATELY attached to the name, its a macro, ignore it.
		while (ptr) //   read value of the define
        {
            ptr = SkipWhitespace(ptr);
            if (ptr == 0) break;
			char c = *ptr++;
			if (!c) break;
            if (c == ')' || c == '/') break; //   a form of ending

			if (c == '+' && *ptr == ' ') plusop = true;
			else if (c == '-' && *ptr == ' ') minusop = true;
  			else if (c == '^' && *ptr == ' ') excludeop = true;
            else if (IsDigit(c))
            {
				ptr = (*ptr == 'x' || *ptr == 'X') ? ReadHex(ptr-1,(uint64&)value) : ReadInt64(ptr-1,value); 
                if (plusop) result += value;
                else if (minusop) result -= value;
                else if (excludeop) result ^= value;
	            else if (orop) result |= value;
                else if (shiftop) result <<= value;
                else result = value;
                excludeop = plusop = minusop = orop = shiftop = false;
            }
			else if (c == '(');	//   start of a (expression in a define, ignore it
            else if (c == '|')  orop = true;
            else if (c == '<') //    <<
            {
                ++ptr; 
                shiftop = true;
            }
           else //   reusing word
            {
                ptr = ReadCompiledWord(ptr-1,label);
                value = FindValueByName(label);
                if (!value) 
				{
					value = FindValue2ByName(label);
					if (!value) ReportBug("missing modifier value for %s\r\n",label)
				}
                if (orop) result |= value;
                else if (shiftop) result <<= value;
				else if (plusop) result += value;
				else if (minusop) result -= value;
 				else if (excludeop) result ^= value;
                else result = value;
                excludeop = plusop = minusop = orop = shiftop = false;
            }
        }
		WORDP D = StoreWord(word);
		D->properties = result;
		AddInternalFlag(D,DEFINES);
#ifdef WIN32
		sprintf(word+offset,"%I64d",result);
#else
		sprintf(word+offset,"%lld",result); 
#endif
		WORDP E = StoreWord(word);
		AddInternalFlag(E,DEFINES);
		if (!E->inferMark) E->inferMark = MakeMeaning(D);
	}
	fclose(in);

	// create pos meanings and sets
	// if (buildDictionary) return;	// dont add these into dictionary
	uint64 bit = START_BIT;
	char name[MAX_WORD_SIZE];
	*name = '~';
	for (int i = 63; i >= 0; --i) // properties get named concepts
	{
		char* word = FindNameByValue(bit);
		if (word) 
		{
			MakeLowerCopy(name+1,word); // all names start with `
			posMeanings[i] = MakeMeaning(StoreWord(name,0,CONCEPT));
		}
		else posMeanings[i] = MakeMeaning(StoreWord(",")); // unknown value
		
		word = FindName2ByValue(bit);
		if (word) 
		{
			MakeLowerCopy(name+1,word); // all names start with ``
			sysMeanings[i] = MakeMeaning(StoreWord(name,0,CONCEPT));
		}
		else sysMeanings[i] = MakeMeaning(StoreWord(",")); // unknown value
		
		bit >>= 1;
	}
}

uint64 FindValueByName(char* name)
{
	if (!*name || *name == '?') return 0; // ? is the default argument to call
	char word[MAX_WORD_SIZE];
	word[0] = '`';
	MakeUpperCopy(word+1,name);
	WORDP D = FindWord(word);
	if (!D) return 0;
	return D->properties;
}

char* FindNameByValue(uint64 val)
{
	char word[MAX_WORD_SIZE];
	word[0] = '`';
#ifdef WIN32
	sprintf(word+1,"%I64d",val);
#else
	sprintf(word+1,"%lld",val); 
#endif
	WORDP D = FindWord(word);
	if (!D) return 0;
	D = Meaning2Word(D->inferMark);
	return D->word+1;
}

uint64 FindValue2ByName(char* name)
{
	if (!*name || *name == '?') return 0; // ? is the default argument to call
	char word[MAX_WORD_SIZE];
	word[0] = '`';
	word[1] = '`';
	MakeUpperCopy(word+2,name);
	WORDP D = FindWord(word);
	if (!D) 
	{
		if (buildDictionary) ReportBug("Failed to find value2 %s",name);
		return 0;
	}
	return D->properties;
}

char* FindName2ByValue(uint64 val)
{
	char word[MAX_WORD_SIZE];
	word[0] = '`';
	word[1] = '`';
#ifdef WIN32
	sprintf(word+2,"%I64d",val);
#else
	sprintf(word+2,"%lld",val); 
#endif
	WORDP D = FindWord(word);
	if (!D) return 0;
	return Meaning2Word(D->inferMark)->word+2;
}

/////////////////////////////////////////////
// BOOLEAN-STYLE QUESTIONS
/////////////////////////////////////////////
 
bool IsArithmeticOperator(char* word)
{
	char c = *word;
	return (c == '+' || c == '-' || c == '*' || c == '/' || (c == '%' && !word[1]) || (c == '%' && word[1] == ' ') || c == '|' || c == '&' || (c == '^' && !word[1]) || (c == '^' && word[1] == ' ')
		|| (c == '<' && word[1] == '<') || (c == '>' && word[1] == '>')
		);
} 

char* IsUTF8(char* buffer) // swallow a single utf8 character (ptr past it) or return null 
{
	if (((unsigned char)*buffer) < 127) return NULL; // not utf8

	unsigned char c = (unsigned char) *buffer;
	unsigned int count = 0; // bytes beyond first
	if (c >= 192 && c <= 223) count = 1;
	else if (c >= 224 && c <= 239) count = 2;
	else if (c >= 240 && c <= 247) count = 3; 
	else if (c >= 248 && c <= 251) count = 4;
	else if (c >= 252 && c <= 253) count = 5;
	else count = 300;

	// does count of extenders match requested count
	unsigned int n = 0;
	while (*++buffer && *(unsigned char*) buffer >= 128 && *(unsigned char*) buffer <= 191) ++n; 
	return (n == count)	? buffer : NULL; 
}

char GetTemperatureLetter(char* ptr)
{
	if (!ptr || !ptr[1] || !IsDigit(*ptr)) return 0; // format must be like 1C or 19F
	size_t len = strlen(ptr) - 1;
	char lastc = toUppercaseData[ptr[len]];
	if (lastc == 'F' || lastc == 'C' || lastc == 'K') // ends in a temp letter
	{
		// prove rest of prefix is a number
		char* p = ptr-1;
		while (IsDigit(*++p)); // find end of number prefix
		if (len == (size_t)(p - ptr)) return lastc;
	}
	return 0;
}
   
char* GetCurrency(char* ptr,char* &number) // does this point to a currency token, return currency and point to number
{
	if (*ptr == '$') // dollar is prefix
	{
		number = ptr+1;
		return ptr;
	}
	else if (*ptr == 0xe2 && ptr[1] == 0x82 && ptr[2] == 0xac) // euro is prefix
	{
		number = ptr + 3; 
		return ptr;
	}
	else if (*ptr == 0xc2) // yen is prefix
	{
		char c = ptr[1];
		if ( c == 0xa2 || c == 0xa3 || c == 0xa4 || c == 0xa5) 
		{
			number = ptr+2; 
			return ptr;
		}
	}
	else if (*ptr == 0xc3 && ptr[1] == 0xb1 ) // british pound
	{
		number = ptr+2; 
		return ptr;
	}

	if (IsDigit(*ptr))  // number first
	{
		char* at = ptr;
		while (IsDigit(*++at) || *at == '.') ++at; // get end of number
		if (*at == '$' ||   (*at == 0xe2 && at[1] == 0x82 && at[2] == 0xac)  || *at == 0xc2 || (*at == 0xc3 && at[1] == 0xb1 ) ) // currency suffix
		{
			number = ptr;
			return at;
		}
	}
	
	return 0;
}

bool IsLegalName(char* name) // start alpha (or ~) and be alpha _ digit (concepts and topics can use . or - also)
{
	char start = *name;
	if (*name == '~' || *name == '%') ++name;
	if (!IsAlpha(*name)) return false;
	while (*++name)
	{
		if (*name == '.' && start != '~') return false;	// may not use . in a variable name
		if (!IsLegalNameCharacter(*name)) 
		{
			char* at = IsUTF8(name);
			if (at) name = at-1;
			else return false;
		}
	}
	return true;
}

bool IsDigitWord(char* ptr) // digitized number
{
    //   signing, # marker or currency markers are still numbers
    if (IsNonDigitNumberStarter(*ptr)) ++ptr; //   skip numberic nondigit header (+ - # )
	char* number;
	char* currency = 0;
	if ((currency = GetCurrency(ptr,number))) ptr = number; // if currency, find number start of it
    if (!*ptr) return false;

    bool foundDigit = false;
    int periods = 0;
    while (*ptr) 
    {
		if (IsDigit(*ptr)) foundDigit = true; // we found SOME part of a number
		else if (*ptr == '.') 
		{
			if (++periods > 1) return false; // too many periods
		}
		else if (*ptr == ':');	//   TIME delimiter
		else if (ptr == currency) break; // dont need to see currency end
		else return false;		//   1800s is done by substitute, so fail this
		++ptr;
    }
    return foundDigit;
}  

bool IsRomanNumeral(char* word, uint64& val)
{
	if (*word == 'I' && !word[1]) return false;		// BUG cannot accept I  for now. too confusing.
	val = 0;
	--word;
	unsigned int value;
	unsigned int oldvalue = 100000;
	while ((value = roman[*++word]))
	{
		if (value > oldvalue) // subtractive?
		{
			// I can be placed before V and X to make 4 units (IV) and 9 units (IX) respectively
			// X can be placed before L and C to make 40 (XL) and 90 (XC) respectively
			// C can be placed before D and M to make 400 (CD) and 900 (CM) according to the same pattern[5]
			if (value == 5 && oldvalue == 1) val += (value - 2);
			else if (value == 10 && oldvalue == 1) val += (value - 2);
			else if (value == 50 && oldvalue == 10) val += (value - 20);
			else if (value == 100 && oldvalue == 10) val += (value - 20);
			else if (value == 500 && oldvalue == 100) val += (value - 200);
			else if (value == 1000 && oldvalue == 100) val += (value - 200);
			else return false;	 // not legal
		}
		else val += value;
		oldvalue = value;
	}
	return (!*word); // finished or not
}
 
unsigned int IsNumber(char* word,bool placeAllowed) // simple digit number or word number or currency number
{
	if (word[1] && (word[1] == ':' || word[2] == ':')) return false;	// 05:00 // time not allowed
    if (IsDigitWord(word)) return DIGIT_NUMBER; // a numeric number
    WORDP D;
    D = FindWord(word);
    if (D && D->properties & NUMBER_BITS) return WORD_NUMBER;   // known number
	
	uint64 valx;
	if (IsRomanNumeral(word,valx)) return ROMAN_NUMBER;

	char* ptr;
    if (placeAllowed && IsPlaceNumber(word)) return PLACE_NUMBER; // th or first or second etc.
    else if (!IsDigit(*word) && ((ptr = strchr(word,'-')) || (ptr = strchr(word,'_'))))	// composite number as word, but not digits
    {
        D = FindWord(word,ptr-word);			// 1st part
		WORDP W = FindWord(ptr+1);		// 2nd part of word
		if (D && W && D->properties & NUMBER_BITS && W->properties & NUMBER_BITS && IsPlaceNumber(W->word)) return FRACTION_NUMBER; 
 		if (D && W && D->properties & NUMBER_BITS && W->properties & NUMBER_BITS) return WORD_NUMBER; 
    }
	char* number = NULL;
	char* cur = GetCurrency(word,number);
	if (cur) return (Convert2Integer(number) != NOT_A_NUMBER) ? CURRENCY_NUMBER : 0 ;

	char* hyphen = strchr(word,'-');
	if (!hyphen) hyphen = strchr(word,'_'); // two_thirds
	if (hyphen)
	{
		char c = *hyphen;
		*hyphen = 0;
        int64 piece1 = Convert2Integer(word);      
		*hyphen = c;
		if (piece1 == NOT_A_NUMBER && stricmp(word,"zero") && *word != '0') {;}
		else if (IsPlaceNumber(hyphen+1)) return FRACTION_NUMBER;
	}

    return (Convert2Integer(word) != NOT_A_NUMBER) ? WORD_NUMBER : 0;		//   try to read the number
}

bool IsPlaceNumber(char* word) // place number and fraction numbers
{   
	if (strchr(word,'-') || strchr(word,'_')) return false;	 // cannot be place number
    size_t len = strlen(word);
    if (len < 4 && !IsDigit(*word)) return false;
    if (len > 2 && word[len-2] == 't' && word[len-1] == 'h'); // th 
 	else if (len > 4 && !strcmp(word+len-5,"first") ) return true;
	else if (len > 5 && !strcmp(word+len-6,"second") ) return true;
	else if (len > 4 && !strcmp(word+len-4,"half") ) return true;
	else if (len > 4 && !strcmp(word+len-5,"third") ) return true;
	else if (len > 5 && !strcmp(word+len-6,"thirds") ) return true;
 	else if (len > 6 && !strcmp(word+len-7,"quarter") ) return true;
 	else if (len > 7 && !strcmp(word+len-8,"quarters") ) return true;
    else if (len > 3 && word[len-3] == 't' && word[len-2] == 'h' && word[len-1] == 's'); // ths
	else if (len > 2 && word[len-2] == 's' && word[len-1] == 't'); // 1st 
 	else if (len > 2 && word[len-1] == 'd')
	{
		if (word[len-2] == 'n') return !stricmp(word,"thousand");	// 2nd but not thousand
		else if (word[len-2] == 'r');	// 3rd 
		else return false;
	}
	else if (len > 3 && word[len-3] == 'r' && word[len-2] == 'd' && word[len-1] == 's'); // rds (thirds)
	else return false;
	return IsNumber(word,false) ? true : false; // show it is correctly a number
}

bool IsFloat(char* word, char* end)
{
	if (*word == '-' || *word == '+') ++word; // ignore sign
    int period = 0;
	--word;
	while (++word < end) // count periods
	{
	    if (*word == '.') ++period;
	    else if (!IsDigit(*word)) return false; // non digit is fatal
    }
    return (period == 1);
}

bool IsNumericDate(char* word,char* end) // 01.02.2009 or 1.02.2009 or 1.2.2009
{ // 3 pieces separated by periods or slashes. with 1 or 2 digits in two pieces and 2 or 4 pieces in last piece

	char separator = 0;
	int counter = 0;
	int piece = 0;
	int size[100];
	--word;
	while (++word < end) 
	{
		char c = *word;
		if (IsDigit(c)) ++counter;
		else if (c == '.' || c == '/') // date separator
		{
			if (!counter) return false;	// no piece before it
			size[piece++] = counter;	// how big was the piece
			counter = 0;
			if (!separator) separator = c;		// seeing this kind of separator
			if (c != separator) return false;	// cannot mix
			if (!IsDigit(word[1])) return false;	// doesnt continue with digits
		}
		else return false;					//  illegal date
	}
	if (piece != 2) return false;	//   incorrect piece count
	if (size[0] != 4)
	{
		if (size[2] != 4 || size[0] > 2 || size[1] > 2) return false;
	}
	else if (size[1] > 2 || size[2] > 2) return false;
	return true;
}

bool IsUrl(char* word, char* end)
{ //     if (!strnicmp(t+1,"co.",3)) //   jump to accepting country
          
    if (!strnicmp("www.",word,4) || !strnicmp("http",word,4) || !strnicmp("ftp:",word,4)) return true; // classic urls
	size_t len = strlen(word);
	if (len > 200) return false;
    char tmp[MAX_WORD_SIZE];
	MakeLowerCopy(tmp,word);
    if (!end) end = word + len; 
    tmp[end-word] = 0;
    char* ptr = tmp;
	char* firstPeriod = 0;
    int n = 0;
    while (ptr && *ptr) // count periods
    {
        if ((ptr = strchr(ptr+1,'.'))) 
        {
			if (!firstPeriod) firstPeriod = ptr;
            ++ptr; 
            ++n;
        }
    }
	if (!n) return false; // has none
    if (n == 3) return true;  // exactly 3 a std url

	//   check suffix since possible 4 part url:  www.amazon.co.uk OR 1 parter like amazon.com  or other --- also 2 dot urls including amazon.com and fireze.it
    ptr = strrchr(word,'.'); 
	if (IsAlpha(ptr[1]) && IsAlpha(ptr[2]) && !ptr[3]) return true;	 // country code at end?
	if (ptr && *(ptr-3) == 'c' && (*ptr-2) == 'o') return true; // another form of country code
	if (ptr++) return (!strnicmp(ptr,"com",3) || !strnicmp(ptr,"net",3) || !strnicmp(ptr,"org",3) || !strnicmp(ptr,"edu",3) || !strnicmp(ptr,"biz",3) || !strnicmp(ptr,"gov",3) || !strnicmp(ptr,"mil",3)); // common suffixes
	return false;
}

unsigned int IsMadeOfInitials(char * word,char* end) 
{  
	if (IsDigit(*word)) return 0; // it's a number
	char* ptr = word-1;
	while (++ptr < end) // check for alternating character and periods
	{
		if (!IsAlphaOrDigit(*ptr)) return false;
		if (*++ptr != '.') return false;
    }
    if (ptr >= end)  return ABBREVIATION; // alternates letter and period perfectly (abbreviation or middle initial)

    //   if lower case start and upper later, it's a typo. Call it a shout (will lower case if we dont know as upper)
    ptr = word-1;
    if (IsLowerCase(*word))
    {
        while (++ptr != end)
        {
	        if (IsUpperCase(*ptr)) return SHOUT;
        }
		return 0;
    }

    //   ALL CAPS 
    while (++ptr != end)
    {
	    if (!IsUpperCase(*ptr)) return 0;
    }
	
	//   its all caps, needs to be lower cased
	WORDP D = FindWord(word);
	return (D && D->properties & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL)) ? ABBREVIATION : SHOUT; 
}

////////////////////////////////////////////////////////////////////
/// READING ROUTINES
////////////////////////////////////////////////////////////////////

char* ReadFlags(char* ptr,uint64& flags)
{
	flags = 0;
	char* start = ptr;
	if (*ptr != '(') // simple solo flag
	{
		char word[MAX_WORD_SIZE];
		ptr = ReadCompiledWord(ptr,word);
		if (IsDigit(*word)) ReadHex(word,flags);
		else
		{
			flags = FindValueByName(word);
			if (!flags) flags = FindValue2ByName(word);
		}
		return  (!flags) ? start : ptr;	// if found nothing return start, else return end
	}

	char flag[MAX_WORD_SIZE];
	char* close = strchr(ptr,')');
	if (close) *close = 0;
	while (*ptr) // read each flag
	{
		unsigned int result;
		ptr = ReadShortCommandArg(ptr,flag,result); // swallows excess )
 		if (result & ENDCODES) return ptr;
		if (*flag == '$') flags |= atoi(GetUserVariable(flag)); // user variable indirect
		else if (*flag == '0' && (flag[1] == 'x' || flag[1] == 'X')) // literal hex value
		{
			uint64 val;
			ptr = ReadHex(flag,val);
			flags |= val;
		}
		else if (IsDigit(*flag)) flags |= atoi(flag);
		else  // simple name of flag
		{
			uint64 n = FindValueByName(flag);
			if (!n) n = FindValue2ByName(flag);
			flags |= n;
		}
		ptr = SkipWhitespace(ptr);
	}
	if (close)
	{
		*close = ')';
		ptr = close;
	}
	return  (!flags) ? start : ptr; 
}

char* ReadInt(char* ptr, unsigned int &value)
{
	ptr = SkipWhitespace(ptr);
    value = 0;
    if (!ptr || !*ptr ) return ptr;
    if (*ptr == '0' && (ptr[1]== 'x' || ptr[1] == 'X'))  // hex number
	{
		uint64 val;
		ptr = ReadHex(ptr,val);
		value = (unsigned int)val;
		return ptr;
	}
	int sign = 1;
    if (*ptr == '-')
    {
         sign = -1;
         ++ptr;
    }
    --ptr;
     while (!IsWhiteSpace(*++ptr) && *ptr)  // find end of synset id in dictionary
     {  
         if (*ptr == ',') continue;    // swallow this
         value *= 10;
         if (IsDigit(*ptr)) value += *ptr - '0';
         else 
         {
             ReportBug("bad number\r\n")
             while (*++ptr  && *ptr != ' ');
             value = 0;
             return ptr;
         }
     }
     value *= sign;
	 if (*ptr) ++ptr; // skip trailing blank
     return ptr;  
}

char* ReadInt64(char* ptr, int64 &spot)
{
	ptr = SkipWhitespace(ptr);
    spot = 0;
    if (!ptr || !*ptr) return ptr;
    if (*ptr == '0' && (ptr[1]== 'x' || ptr[1] == 'X')) return ReadHex(ptr,(uint64&)spot);

     int sign = 1;
     if (*ptr == '-')
     {
         sign = -1;
         ++ptr;
     }
    --ptr;
     while (!IsWhiteSpace(*++ptr) && *ptr) 
     {  
         spot *= 10;
         if (*ptr == ',') continue;    // swallow this
         if (IsDigit(*ptr)) spot += *ptr - '0';
         else 
         {
             ReportBug("bad number1\r\n")
             while (*++ptr  && *ptr != ' ');
             spot = 0;
             return ptr;
         }
     }
     spot *= sign;
	 if (*ptr) ++ptr;	// skip trailing blank
     return ptr;  
}
char* ReadHex(char* ptr, uint64 & value)
{
	ptr = SkipWhitespace(ptr);
    value = 0;
    if (!ptr || !*ptr) return ptr;
    if (ptr[1] == 'x' || ptr[1] == 'X') ptr += 2; // skip 0x
    --ptr;
	while (*++ptr)
    {
		char c = toLowercaseData[(unsigned char)*ptr];
		if (c == 'l' || c == 'u') continue;				// assuming L or LL or UL or ULL at end of hex
        if (!IsAlphaOrDigit(c) || c > 'f') break; //   no useful characters after lower case at end of range
        value <<= 4; // move over a digit
        value += (IsDigit(c))? (c - '0') : (10 + c - 'a');
    }
	if (*ptr) ++ptr;// align past trailing space
    return ptr; 
}

void BOMAccess(int &BOMvalue, char &oldc, int &oldCurrentLine) // used to get/set file access- -1 BOMValue gets, other sets all
{
	if (BOMvalue >= 0) // set back
	{
		BOM = BOMvalue;
		holdc = oldc;
		currentFileLine = oldCurrentLine;
	}
	else // get copy and reinit for new file
	{
		BOMvalue = BOM;
		BOM = 0;
		oldc = holdc;
		holdc = 0;
		oldCurrentLine = currentFileLine;
		currentFileLine = 0;
	}
}

char* ReadALine(char* buffer,FILE* in,unsigned int limit,bool returnEmptyLines) 
{ //  reads text line stripping of cr/nl

	if (currentFileLine == 0) BOM = 0; // start of file, set BOM to null
	*buffer = 0;
	if (!in && !userRecordSourceBuffer)  return NULL;	// neither file nor buffer being read
	char* start = buffer;
	char c;
	++currentFileLine;			//   for debugging error messages

	if (holdc)					//   if we had a leftover character from prior line lacking newline, put it in now
	{
		*buffer++ = holdc; 
		holdc = 0;
	}
	bool hasutf = false;
	bool hasbadutf = false;
	bool runningOut = false;
	while (ALWAYS)
	{
		if (in) 
		{
			if (!fread(&c,1,1,in)) break;	// EOF
		}
		else
		{
			c = *userRecordSourceBuffer++;
			if (!c) break;	// end of buffer
		}
		if (c == '\t') c = ' ';	// switch tab to space
		if (c & 0x80) // high order utf?
		{
			unsigned char convert = 0;
			if (!BOM && !hasutf && !server) // local mode might get extended ansi so transcribe to utf8
			{
				unsigned char x = (unsigned char) c;
				if (c == 147 || c == 148) convert = c = '"';
				else if (c == 145 || c == 146) convert = c = '\'';
				else if (c == 150 || c == 151) convert = c = '-';
				else
				{
					convert = extendedascii2utf8[x - 128];
					if (convert)
					{
						*buffer++ = (unsigned char) 0xc3;
						c = convert;
					}
				}
			}
			if (!convert) hasutf = true;
		}
		*buffer++ = c; 
		if ((unsigned int)(buffer-start) >= (limit - 80)) 
		{
			runningOut = true;
			if ((unsigned int)(buffer-start) >= (limit - 40)) 
			{
				ReportBug("Buffer content too big")
				break;	
			}
		}
		if (c == ' ' && runningOut) c = '\r';	// force termination

		if (c == '\r')  // part of cr lf or just a cr?
		{
			c = 0;
			if (in) 
			{
				if (fread(&c,1,1,in) == 0) break;	// EOF
			}
			else
			{
				c = *userRecordSourceBuffer++;
				if (c == 0) break;					// end of string
			}
			if (c != '\n') // failed to find lf... hold this character for later
			{
				if (c != '\r') holdc = c; // ignore 2 carriage return in a row
				c = '\n';	// add our own
			}
			*buffer++ = c; // put in the newline
			break;
		}
		else if (c == '\n')  // came without cr?
		{
			++currentFileLine;	// for debugging error messages
			if ((buffer - 1) == start) // read nothing as content
			{
				*start = 0;
				if ( in == stdin || returnEmptyLines) return start;
				buffer = start;
				continue;
			}
	
			//   add missing \r
			*(buffer - 1) = '\r';
			*buffer++ = '\n';
			break;	
		}

		// strip UTF8 BOM marker if any and just keep reading
		if (hasutf && currentFileLine == 1 && (buffer-start) == 3) 
		{
			if ((unsigned char) start[0] ==  0xEF && (unsigned char) start[1] == 0xBB && (unsigned char) start[2] == 0xBF) // UTF8 BOM
			{
				buffer -= 3;
				*start = 0;
				BOM = 1;
				hasutf = false;
			}
		}
	}
	if (buffer == start) // no content read
	{
		*buffer = 0;
		buffer[1] = 0;
		buffer[2] = 0; // clear ahead to make it obvious we are at end when debugging
		return NULL;
	}

	if (*(buffer-1) == '\n') buffer -= 2; // remove cr/lf if there
	*buffer = 0;
	buffer[1] = 0;
	buffer[2] = 0; //   clear ahead to make it obvious we are at end when debugging

	if (hasutf && BOM) 
	{
		buffer = start  - 1;
		while (*++buffer)  // check every utf character
		{
			if (*buffer & 0x80) // is utf in theory
			{
				char prior = (start == buffer) ? 0 :  *(buffer-1);
				char* x = IsUTF8(buffer); // return after this character if it is valid.
				if (x) 
				{
					if (buffer[0] == 0xe2 && buffer[1] == 0x80 && buffer[2] == 0x98 )  // open single quote
					{
						// if attached to punctuation, leave it so it will tokenize with them
						*buffer = ' ';
						buffer[1] = '\'';
						buffer[2] = ' ';
					}
					else if (buffer[0] == 0xe2 && buffer[1] == 0x80 &&  buffer[2] == 0x99)  // closing single quote (may be embedded or acting as a quoted expression
					{
						if (buffer != start && IsAlpha(*(buffer-1)) && IsAlpha(*x)) // embedded contraction
						{
							*buffer = '\'';
							memmove(buffer+1,x,strlen(x)+1);
							x = buffer + 1;
						}
						else if (prior == 's' && !IsAlpha(*x)) // ending possessive
						{
							*buffer = '\'';
							memmove(buffer+1,x,strlen(x)+1);
							x = buffer + 1;
						}
						else if (prior == '.' || prior == '?' || prior == '!') // leave attached to prior so readdocument can leave them together
						{
							*buffer = '\'';
							buffer[1] = ' ';
							buffer[2] = ' ';
						}
						else
						{
							*buffer = ' ';
							buffer[1] = '\'';
							buffer[2] = ' ';
						}
					}
					else if (buffer[0] == 0xe2 && buffer[1] == 0x80 && buffer[2] == 0x9c )  // open double quote
					{
						*buffer = ' ';
						buffer[1] = '\'';
						buffer[2] = ' ';
					}
					else if (buffer[0] == 0xe2 && buffer[1] == 0x80 && buffer[2] == 0x9d )  // closing double quote
					{
						*buffer = ' ';
						buffer[1] = '"';
						buffer[2] = ' ';
					}
					else if (buffer[0] == 0xe2 && buffer[1] == 0x80 && buffer[2] == 0x94)  // mdash
					{
						*buffer = ' ';
						buffer[1] = '-';
						buffer[2] = ' ';
					}
					buffer = x-1; // valid utf8
				}
				else // invalid utf8
				{
					hasbadutf = true;
					*buffer = 'z';	// replace with legal char
				}
			}
		}
	}
	if (hasbadutf && showBadUTF && !server)  
		Log(STDUSERLOG,"Bad UTF-8 %s at %d in %s\r\n",start,currentFileLine,currentFilename);
	return start;
}

char* ReadQuote(char* ptr, char* buffer,bool backslash,bool noblank)
{ //   ptr is at the opening quote or a \quote... internal	" must have \ preceeding the start of a quoted expression
    char c;
    int n = 550;		// quote must close within this limit
	char* start = ptr;
	char* original = buffer;
	*buffer++ = *ptr;
	if (*ptr == '\\') *buffer++ = *++ptr;	//   swallow \ and "
	while ((c = *++ptr) && c != '"' && --n) 
    {
        if (c == '&') // convert "&" into "and" and surround with blanks
        {
            char prior = *(buffer-1);
			if (prior == '\\')
			{
				--buffer;	// erase backslash
				*buffer++ = c;
			}
			else
			{
				if (prior != ' ' && prior != '_') *buffer++ = ' ';		// & encased with blanks
				*buffer++ = 'a';
				*buffer++ = 'n';
				*buffer++ = 'd';
				c = ptr[1];
				if (c != ' ' && c != '_') *buffer++ = ' ';	// & encased with blanks
			}
        }
		else if (c == '\\' && ptr[1] == '"') // if c is \", means internal quoted expression.
		{
			*buffer++ = '\\';	// preserver internal marking - must stay with string til last possible moment.
			*buffer++ = *++ptr;
			while ((c = *++ptr)) // read substring
			{
				*buffer++ = c;
				if (c == '"') break;	// end of internal \" " string
			}
		}
       else *buffer++ = c; 
    }
    if (n == 0 || !c) // ran dry
	{	
		if (backslash) // probably a normal end quote with attached stuff
		{
			// try again, seeking only whitespace
			ptr = start - 1;	
			buffer = original;
			while (*ptr && !IsWhiteSpace(*ptr)) *buffer++ = *ptr++;
			*buffer = 0;
			return ptr;
		}
		Log(STDUSERLOG,"bad double-quoting?  %s %d %s\r\n",start,currentFileLine,currentFilename);
		return NULL;	// no closing quote... refuse
	}

    // close with ending quote
    *buffer = *ptr;	
    *++buffer = 0; 
	if (noblank && compiling && original[1] == ' ' && original[2] != ' ' && original[2] != '"') 
		BADSCRIPT("STRING-2 String %s should not have blank at start",original);
	return ptr+1;		// after the quote end
}

char* ReadArgument(char* ptr, char* buffer) //   looking for a single token OR a list of tokens balanced - insure we start non-space
{ //   ptr is some buffer before the arg (white space should NOT be possible)
#ifdef INFORMATION
Used for function calls, to read their callArgumentList. Arguments are not evaluated here. An argument is:
	1. a token (like $var or name or "my life as a rose" )
	2. a function call which runs from the function name through the closing paren
	3. a list of tokens (unevaluated), enclosed in parens like (my life as a rose )
#endif
    char* start = buffer;
    *buffer = 0;
    int paren = 0;
    if (*ptr == '^') 
    {
        ptr = ReadCompiledWord(ptr,buffer); // get name and prepare to peek at next token
		if (*ptr != '(') return ptr; // not a function
		buffer += strlen(buffer); // read onto end of call
    }
	if (*ptr == '"' || (*ptr == '\\' && ptr[1] == '"'))   // a string
	{
		char* beginptr = ptr;
		ptr = ReadQuote(ptr,buffer);		// call past quote, return after quote
		if (ptr != beginptr) return ptr;	// if ptr == start, ReadQuote refused to read (no trailing ")
	}

	--ptr;
    while (*++ptr) 
    {
        char c = *ptr;
		int x = nestingData[c];
		if (paren == 0 && (c == ' ' || x == -1  || c == ENDUNIT)) break; // simple arg separator or outer closer or end of data
        *buffer++ = c;
        *buffer = 0;
		if (x) paren += x;
    }
    if (start[0] == '"' && start[1] == '"' && start[2] == 0) *start = 0;   // NULL STRING
	if (*ptr == ' ') ++ptr;
    return ptr;
}

char* ReadCompiledWord(char* ptr, char* word) 
{//   a compiled word is either characters until a blank, or a ` quoted expression ending in blank or nul. or a double-quoted on both ends or a ^double quoted on both ends
	*word = 0;
	if (!ptr) return NULL;

	char c;
	char* original = word;
	ptr = SkipWhitespace(ptr);
	char* start = ptr;
	
	if (*ptr == ENDUNIT || *ptr == '"' || (*ptr == FUNCTIONSTRING && ptr[1] == '"')) //   ends in blank or nul,  might be quoted, doublequoted, or ^"xxx" functional string
	{
		if (*ptr == '^') *word++ = *ptr++;	// move to the actual quote
		*word++ = *ptr; // keep opener  --- a worst case is "`( \"grow up" ) " from a fact
		char end = *ptr++; //   skip the starter, noting what we need for conclusion
		while ((c = *ptr++)) // run til nul or matching `  -- may have INTERNAL string as well
		{
			if ( c == '\\' && *ptr == '"')
			{
				*word++ = c;
				*word++ = *ptr++;
				continue;
			}
			else if (c == end && (*ptr == ' ' || *ptr == 0)) 
			{
				if (*ptr == ' ') ++ptr;
				break; // blank or nul after closer
			}
			*word++ = c;
		}
		if (c) *word++ = end; // add back closer
		else // didnt find close, it was spurious... treat as normal
		{
			ptr = start;
			word = original;
			while ((c = *ptr++) && c != ' ') *word++ = c; // run til nul or blank
		}
	}
	else 
	{
		while ((c = *ptr++) && c != ' ' && c != ENDUNIT) *word++ = c; //   run til nul or blank or end of rule
	}
	*word = 0; //   null terminate word
	if (!c) --ptr; //   shouldnt move on to valid next start
	return ptr;	
}

char* BalanceParen(char* ptr,bool within) // text starting with ((unless within is true), find the closing ) and point to next item after
{
	int paren = 0;
	if (within) paren = 1;
	--ptr;
	bool quoting = false;
	char prior = 0;
    while (*++ptr && *ptr != ENDUNIT) // jump to END of command to resume here, may have multiple parens within
    {
		if ( *ptr == '"' && (prior == ' ' || prior == '^')) // string not attached to anything else
		{
			quoting =  !quoting;
			continue;
		}
		if (quoting) continue;	// stuff in quotes is safe 
		prior = *ptr;
		if (*ptr == '\\' && ptr[1]) // ignore slashed item
		{
			++ptr;
			continue;
		}
		int value = nestingData[*ptr];
		if (value && (paren += value) == 0) 
		{
			ptr += (ptr[1] && ptr[2]) ? 2 : 1; //   return on next token (skip paren + space) or  out of data (typically argument substitution)
			break;
		}
    }
    return ptr; //   return on end of data
}

char* SkipWhitespace(char* ptr)
{
    if (!ptr || !*ptr) return ptr;
    while (IsWhiteSpace(*ptr)) ++ptr;
    return ptr; 
}

///////////////////////////////////////////////////////////////
//  CONVERSION UTILITIES
///////////////////////////////////////////////////////////////

char* UTF2ExtendedAscii(char* bufferfrom) 
{
	unsigned char* buffer = (unsigned char*) AllocateBuffer();
	unsigned char* bufferto = buffer;
	while( *bufferfrom && (size_t)(bufferto-buffer) < (size_t)(maxBufferSize-10)) // avoid overflow on local buffer
	{
		if (*bufferfrom != 0xc3) *bufferto++ = *bufferfrom++;
		else 
		{
			++bufferfrom;
			unsigned char x = *bufferfrom++;
			unsigned char val = utf82extendedascii[x - 128];
			if (val) *bufferto++ = val + 128;
			else // we dont know this character
			{
				*bufferto++ = (unsigned char) 0xc3;
				*bufferto++ = *(bufferfrom-1);
			}
		}
	}
	*bufferto = 0;
	FreeBuffer();
	return (char*) buffer; // it is ONLY good for printf immediate, not for anything long term
}

void ForceUnderscores(char* ptr)
{
	--ptr;
	while (*++ptr) if (*ptr == ' ') *ptr = '_';
}

void Convert2Blanks(char* ptr)
{
	--ptr;
	while (*++ptr) 
	{
		if (*ptr == '_') 
		{
			if (ptr[1] == '_') memmove(ptr,ptr+1,strlen(ptr));// convert 2 __ to 1 _  (allows web addressess as output)
			else *ptr = ' ';
		}
	}
}

void Convert2Underscores(char* output,bool alternewline,bool removeClasses,bool removeBlanks)
{ 
    char* ptr = output - 1;
	char c;
	if (ptr[1] == '"') // leave this area alone
	{
		ptr += 2;
		while (*++ptr && *ptr != '"');
	}
	bool backslash = false;
    while ((c = *++ptr)) 
    {
		if ( c == ' ') backslash = false;
		if ( c == '\\') // protect next always
		{
			backslash = true;
			memmove(ptr,ptr+1,strlen(ptr));
			--ptr;
		}
        else if (removeClasses &&  c == '~' && IsAlpha(ptr[1]) ) //   REMOVE leading ~ or : in classnames
        {
			if (ptr == output || (*(ptr-1)) == ' ') 
			{
				memmove(ptr,ptr+1,strlen(ptr)); 
				--ptr;
			}
        }
        else if (!backslash && !removeBlanks &&  c == '_' && ptr[1] != '_') // remove underscores from apostrophe of possession
        {
			// remove space on possessives
			if (ptr[1] == '\'' && ( (ptr[2] == 's' && !IsAlphaOrDigit(ptr[3]))  || !IsAlphaOrDigit(ptr[2]) ) )// bob_'s  bobs_'  
			{
				memmove(ptr,ptr+1,strlen(ptr)); 
				--ptr;
			}
		}
		else if (removeBlanks && c == ' ') *ptr = '_';
		else if (alternewline && (c == '\n' || c == '\r')) *ptr = ' ';
    }
}

int64 NumberPower(char* number)
{
    if (*number == '-') return 2000000000;    // isolated - always stays in front
	int64 num = Convert2Integer(number);
	if (num < 10) return 1;
	if (num < 100) return 10;
	if (num < 1000) return 100;
	if (num < 10000) return 1000;
	if (num < 100000) return 10000;
	if (num < 1000000) return 100000;
	if (num < 10000000) return 1000000;
	if (num < 100000000) return 10000000;
	if (num < 1000000000) return 100000000; // max int is around 4 billion
	return  10000000000ULL; 
}

int64 Convert2Integer(char* number)  //  non numbers return NOT_A_NUMBER    
{  // ProcessCompositeNumber will have joined all number words together in appropriate number power order: two hundred and fifty six billion and one -> two-hundred-fifty-six-billion-one , while four and twenty -> twenty-four
	if (!number) return NOT_A_NUMBER;
	char c = *number;
	if (c == '$'){;}
	else if (!IsAlphabeticDigitNumeric(c) || c == '.') return NOT_A_NUMBER; // not  0-9 letters + - 

	uint64 valx;
	if (IsRomanNumeral(number,valx)) return (int64) valx;
	
	//  grab sign if any
	char sign = *number;
	if (sign == '-' || sign == '+') ++number;
	else if (sign == '$')
	{
		sign = 0;
		++number;
	}
	else sign = 0;

     //  make canonical: remove commas (user typed a digit number with commas) and convert _ to -
    char copy[MAX_WORD_SIZE];
    MakeLowerCopy(copy+1,number); 
	*copy = ' '; // safe place to look behind at
	char* comma = copy;
	while (*++comma)
	{
		if (*comma == ',') memmove(comma,comma+1,strlen(comma));
		else if (*comma == '_') *comma = '-';
	}
    char* word = copy+1;

	// remove place suffixes
    size_t len = strlen(word);
    if (len > 3 && word[len-1] == 's') // if s attached to a fraction, remove it
	{
		// look up direct word number as single
		for (unsigned int i = 0; i < sizeof(numberValues)/sizeof(NUMBERDECODE); ++i)
		{
			if (len == numberValues[i].length && !strnicmp(word,numberValues[i].word,len-1)) 
			{
				if (numberValues[i].realNumber == FRACTION) word[len -= 1] = 0; //  thirds to third    quarters to quarter  fifths to fith but not ones to one
				break;  
			}
		}
	}
    if (len < 3); // cannot have suffix
    else if (word[len-2] == 's' && word[len-1] == 't' && !strstr(word,"first")) word[len -= 2] = 0; // 1st 
    else if (word[len-2] == 'n' && word[len-1] == 'd' && !strstr(word,"second")) word[len -= 2] = 0; // 2nd but not second
    else if (word[len-2] == 'r' && word[len-1] == 'd' && !strstr(word,"third")) word[len -= 2] = 0; // 3rd 
	else if (word[len-2] == 't' && word[len-1] == 'h' && !strstr(word,"fifth")) //  excluding the word "fifth" which is not derived from five
	{
		word[len -= 2] = 0; 
		if (word[len-1] == 'e' && word[len-2] == 'i') // twentieth and its ilk
		{
			word[--len - 1] = 'y';
			word[len] = 0;
		}
	}

	bool hasDigit = IsDigit(*word);
	if (hasDigit) // see if all digits now.
	{
		char* ptr = word-1;
		while (*++ptr)
		{
			if (!IsDigit(*ptr)) break;	// not good
			hasDigit = true;
		}
		if (!*ptr) return atoi(word) * ((sign == '-') ? -1 : 1);	// all digits with sign
	}

	// look up direct word numbers
	if (!hasDigit) for (unsigned int i = 0; i < sizeof(numberValues)/sizeof(NUMBERDECODE); ++i)
    {
        if (len == numberValues[i].length && !strnicmp(word,numberValues[i].word,len)) 
		{
			return numberValues[i].value;  // a match 
		}
    }

    // try for hyphenated composite
 	char*  hyphen = strchr(word,'-'); 
	if (!hyphen) hyphen = strchr(word,'_'); // alternate form of separation
    if (!hyphen)  return NOT_A_NUMBER;   // not multi part word
   	if (hasDigit && IsDigit(hyphen[1])) return NOT_A_NUMBER; // cannot hypenate a digit number but can do mixed "1-million" is legal
 
	// if lead piece is not a number, the whole thing isnt
	c = *hyphen;
	*hyphen = 0;
	int64 val = Convert2Integer(word); // convert lead piece to see if its a number
	*hyphen = c;
	if (val == NOT_A_NUMBER) return NOT_A_NUMBER; // lead is not a number

	// decode powers of ten names on 2nd pieces
    long billion = 0;
    char* found = strstr(word,"billion"); // eight-billion 
    if (found && *(found-1) == '-') // is 2nd piece
    {
        *(found-1) = 0;
        billion = (int)Convert2Integer(word);
        if (billion == NOT_A_NUMBER && stricmp(word,"zero") && *word != '0') return NOT_A_NUMBER;
        word = found + 7;
        if (*word == '-' || *word == '_') ++word; // has another hypen after it
    }

	hyphen = strchr(word,'-'); 
	if (!hyphen) hyphen = strchr(word,'_'); // alternate form of separation
    long million = 0;
    found = strstr(word,"million");
    if (found && *(found-1) == '-')
    {
        *(found-1) = 0;
        million = (int)Convert2Integer(word); 
        if (million == NOT_A_NUMBER && stricmp(word,"zero") && *word != '0') return NOT_A_NUMBER;
        word = found + 7;
        if (*word == '-' || *word == '_') ++word; // has another hypen after it
    }

	hyphen = strchr(word,'-'); 
	if (!hyphen) hyphen = strchr(word,'_'); // alternate form of separation
	long thousand = 0;
    found = strstr(word,"thousand");
    if (found && *(found-1) == '-')
    {
        *(found-1) = 0;
        thousand = (int)Convert2Integer(word);
        if (thousand == NOT_A_NUMBER && stricmp(word,"zero") && *word != '0') return NOT_A_NUMBER;
        word = found + 8;
		if (*word == '-' || *word == '_') ++word; // has another hypen after it
    }    

	hyphen = strchr(word,'-'); 
	if (!hyphen) hyphen = strchr(word,'_'); // alternate form of separation
    long hundred = 0;
    found = strstr(word,"hundred");  
    if (found && *(found-1) == '-') // do we have four-hundred
    {
        *(found-1) = 0;
        hundred = (int) Convert2Integer(word);
        if (hundred == NOT_A_NUMBER && stricmp(word,"zero") && *word != '0') return NOT_A_NUMBER;
        word = found + 7;
 		if (*word == '-' || *word == '_') ++word; // has another hypen after it
    }  

	// now do tens and ones, which can include omitted hundreds label like two-fifty-two
    hyphen = strchr(word,'-'); 
	if (!hyphen) hyphen = strchr(word,'_'); 
    int64 value = 0;
    while (word && *word) // read each smaller part and scale
    {
        if (!hyphen) // last piece (a tens or a ones)
		{
            if (!strcmp(word,number)) return NOT_A_NUMBER;  // never decoded anything so far
            int64 n = Convert2Integer(word);
            if (n == NOT_A_NUMBER && stricmp(word,"zero") && *word != '0') return NOT_A_NUMBER;
            value += n; // handled LAST piece
            break;
        }

        *hyphen++ = 0; // split pieces

		// split 3rd piece if one exists
        char* next = strchr(hyphen,'-');       
		if (!next) next = strchr(hyphen,'_');    
        if (next) *next = 0; 

        int64 piece1 = Convert2Integer(word);      
        if (piece1 == NOT_A_NUMBER && stricmp(word,"zero") && *word != '0') return NOT_A_NUMBER;

        int64 piece2 = Convert2Integer(hyphen+1);   
        if (piece2 == NOT_A_NUMBER && stricmp(hyphen,"0")) return NOT_A_NUMBER;

        int64 subpiece = 0;
		if (piece1 > piece2 && piece2 < 10) subpiece = piece1 + piece2; // can be larger-smaller (like twenty one) 
		if (piece2 >= 10 && piece2 < 100 && piece1 >= 1 && piece1 < 100) subpiece = piece1 * 100 + piece2; // two-fifty-two is omitted hundred
		else if (piece2 == 10 || piece2 == 100 || piece2 == 1000) subpiece = piece1 * piece2; // must be smaller larger pair (like four hundred)
        value += subpiece; // 2 pieces mean item was  power of ten and power of one
        // if 3rd piece, now recycle to handle the ones part
		if (next) ++next;
        word = next;
        hyphen = NULL; 
    }
	
	return value + ((int64)billion * 1000000000) + ((int64)million * 1000000) + ((int64)thousand * 1000) + ((int64)hundred * 100);
}

void MakeLowerCase(char* ptr)
{
    --ptr;
    while (*++ptr) *ptr = toLowercaseData[(unsigned char) *ptr];
}

void MakeUpperCase(char* ptr)
{
    --ptr;
    while (*++ptr) *ptr = toUppercaseData[(unsigned char)*ptr];
}

char*  MakeLowerCopy(char* to,char* from)
{
	char* start = to;
	while (*from) *to++ = toLowercaseData[(unsigned char) *from++];
	*to = 0;
	return start;
}

char* MakeUpperCopy(char* to,char* from)
{
	char* start = to;
	while (*from) *to++ = toUppercaseData[(unsigned char) *from++];
	*to = 0;
	return start;
}

char* TrimSpaces(char* msg,bool start)
{
	char* orig = msg;
	if (start) while (IsWhiteSpace(*msg)) ++msg;
	size_t len = strlen(msg);
	if (len == 0) // if all blanks, shift to null at start
	{
		msg = orig;
		*msg= 0;
	}
	while (len && IsWhiteSpace(msg[len-1])) msg[--len] = 0;
	return msg;
}

void UpcaseStarters(char* ptr) //   take a multiword phrase with _ and try to capitalize it correctly (assuming its a proper noun)
{
    if (IsLowerCase(*ptr)) *ptr -= 'a' - 'A';
    while (*++ptr)
    {
        if (!IsLowerCase(*++ptr) || *ptr != '_') continue; //   word separator
		if (!strnicmp(ptr,"the_",4) || !strnicmp(ptr,"of_",3) || !strnicmp(ptr,"in_",3) || !strnicmp(ptr,"and_",4)) continue;
		*ptr -= 'a' - 'A';
    }
}
	
int documentLineCount = 0;
char* documentBuffer = 0;
time_t docTime;

bool ReadDocument(char* inBuffer,FILE* sourceFile)
{
	static bool wasEmptyLine = false;
	*inBuffer = 0;
	if (!*documentBuffer) 
	{
		while (ALWAYS)
		{
			if (!ReadALine(documentBuffer,sourceFile,INPUT_BUFFER_SIZE-1))  return false;	// end of input
			if (!*SkipWhitespace(documentBuffer)) // empty line
			{
				if (wasEmptyLine) continue;	// ignore additional empty line
				wasEmptyLine = true;
				if (echoDocument)
				{
					FILE* out = fopen("out.txt","ab");
					fprintf(out,"%s\r\n",inBuffer);
					fclose(out);
				}
				return true; // no content, just null line or all white space
			}
			break; // have something
		}
	}
	else if (*documentBuffer == 1) // holding an empty line from before to return
	{
		*documentBuffer = 0;
		wasEmptyLine = true;
		if (echoDocument)
		{
			FILE* out = fopen("out.txt","ab");
			fprintf(out,"%s\r\n",inBuffer);
			fclose(out);
		}
		return true;
	}

	unsigned int readAhead = 0;
	while (++readAhead < 4) // read up to 3 lines
	{
		// pick earliest punctuation that can terminate a sentence
		char* period = NULL;
		char* at = documentBuffer;
		while (!period && (period = strchr(at,'.')))	// normal input end here?
		{
			if (period[1] && !IsWhiteSpace(period[1])) 
			{
				if (period[1] == '"' || period[1] == '\'') // period shifted inside the quote
				{
					++period;	 // report " or ' as the end so whole thing gets tokenized
					break;	
				}
				at = period + 1;	// period in middle of something
			}
			else if (IsDigit(*(period-1))) 
			{
				// is this number at end of sentence- e.g.  "That was in 1992. It became obvious."
				char* next = SkipWhitespace(period+1);
				if (*next && IsUpperCase(*next)) break;
				else break;	// ANY number ending in a period is an end of sentence. Assume no one used period unless they want a digit after it
				//at = period + 1; // presumed a number ending in period, not end of sentence
			}
			else if (IsWhiteSpace(*(period-1))) break; // isolated period
			else // see if token it ends is reasonable
			{
				char* before = period;
				while (before > documentBuffer && !IsWhiteSpace(*--before));	// find start of word
				char next2 = (period[1]) ? *SkipWhitespace(period+2) : 0;
				if (ValidPeriodToken(before+1, period+1, period[1],next2) == TOKEN_INCLUSIVE) at = period + 1;	// period is part of known token
				else break;
			}
			period = NULL;
		}
		char* question = strchr(documentBuffer,'?');
		if (question && (question[1] == '"' || question[1] == '\'')) ++question;	// extend from inside a quote
		char* exclaim = strchr(documentBuffer,'!');
		if (exclaim && (exclaim[1] == '"' || exclaim[1] == '\'')) ++exclaim;	// extend from inside a quote
		if (!period && question) period = question;
		else if (!period && exclaim) period = exclaim;
		if (exclaim && exclaim < period) period = exclaim;
		if (question && question < period) period = question;

		// check for things other than sentence periods as well here
		if (period) // found end of a sentence
		{
			char was = period[1];
			period[1] = 0;
			strcpy(inBuffer,SkipWhitespace(documentBuffer));
			period[1] = was;
			memmove(documentBuffer,period+1,strlen(period+1) + 1);	// copy over the rest
			break;
		}
		else if (singleSource) break;	// only 1 line at a time regardless
		else // has no end yet
		{
			size_t len = strlen(documentBuffer);
			documentBuffer[len] = ' ';	// append a blank
			ReadALine(documentBuffer + len + 1,sourceFile,INPUT_BUFFER_SIZE-1 - len);	// read ahead input and merge onto current
			if (!documentBuffer[len+1]) // logical end of file
			{
				strcpy(inBuffer,SkipWhitespace(documentBuffer));
				*documentBuffer = 1;
				break;
			}
		}
	}
	if (readAhead >= 4)
		Log(STDUSERLOG,"Heavy long line? %s\r\n",documentBuffer);
	++documentLineCount;
	wasEmptyLine = false;
	if (echoDocument)
	{
		FILE* out = fopen("out.txt","ab");
		fprintf(out,"%s\r\n",inBuffer);
		fclose(out);
	}
	return true;
}

#include "common.h"

#ifdef INFORMATION
SPACES		 space \t \r \n 
PUNCTUATIONS  , | -  (see also ENDERS)
ENDERS		 . ; : ? ! -
BRACKETS 	 () [ ] { } < >
ARITHMETICS	  % * + - ^ = / .  
SYMBOLS 	  $ # @ ~  
CONVERTERS	  & `
//NORMALS 	  A-Z a-z 0-9 _  and sometimes / 
#endif

#define MAX_BURST 400
static char burstWords[MAX_BURST][MAX_WORD_SIZE];	// each token burst from a text string
static unsigned int burstLimit = 0;					// index of burst  words
char* joinBuffer;									// buffer for joinwords function		

uint64 tokenFlags;										// what tokenization saw
char* wordStarts[MAX_SENTENCE_LENGTH];				// current sentence tokenization (always points to D->word values or allocated values)
unsigned int wordCount;								// how many words/tokens in sentence
bool capState[MAX_SENTENCE_LENGTH];					// was input word capitalized by user

void ResetTokenSystem()
{
	tokenFlags = 0;
	wordStarts[0] = 0;    
    wordCount = 0;
}

void DumpTokenControls(uint64 val)
{
	if ((val & DO_SUBSTITUTE_SYSTEM) == DO_SUBSTITUTE_SYSTEM) Log(STDUSERLOG,"DO_SUBSTITUTE_SYSTEM ");
	else // partials
	{
		if (val & DO_ESSENTIALS) Log(STDUSERLOG,"DO_ESSENTIALS ");
		if (val & DO_SUBSTITUTES) Log(STDUSERLOG,"DO_SUBSTITUTES ");
		if (val & DO_CONTRACTIONS) Log(STDUSERLOG,"DO_CONTRACTIONS ");
		if (val & DO_INTERJECTIONS) Log(STDUSERLOG,"DO_INTERJECTIONS ");
		if (val & DO_BRITISH) Log(STDUSERLOG,"DO_BRITISH ");
		if (val & DO_SPELLING) Log(STDUSERLOG,"DO_SPELLING ");
		if (val & DO_TEXTING) Log(STDUSERLOG,"DO_TEXTING ");
	}
	if (val & DO_PRIVATE) Log(STDUSERLOG,"DO_PRIVATE ");
	// reserved
	if (val & DO_NUMBER_MERGE) Log(STDUSERLOG,"DO_NUMBER_MERGE ");
	if (val & DO_PROPERNAME_MERGE) Log(STDUSERLOG,"DO_PROPERNAME_MERGE ");
	if (val & DO_SPELLCHECK) Log(STDUSERLOG,"DO_SPELLCHECK ");
	if (val & DO_INTERJECTION_SPLITTING) Log(STDUSERLOG,"DO_INTERJECTION_SPLITTING ");

	if ((val & DO_PARSE) == DO_PARSE) Log(STDUSERLOG,"DO_PARSE ");
	else if (val & DO_POSTAG) Log(STDUSERLOG,"DO_POSTAG ");
	if (val & NO_IMPERATIVE) Log(STDUSERLOG,"NO_IMPERATIVE ");
	if (val & NO_VERB) Log(STDUSERLOG,"NO_VERB ");
	if (val & NO_WITHIN) Log(STDUSERLOG,"NO_WITHIN ");
	if (val & NO_SENTENCE_END) Log(STDUSERLOG,"NO_SENTENCE_END ");
	if (val & NO_HYPHEN_END) Log(STDUSERLOG,"NO_HYPHEN_END ");
	if (val & NO_COLON_END) Log(STDUSERLOG,"NO_COLON_END ");
	if (val & NO_SEMICOLON_END) Log(STDUSERLOG,"NO_SEMICOLON_END ");
	if (val & STRICT_CASING) Log(STDUSERLOG,"STRICT_CASING ");
	if (val & ONLY_LOWERCASE) Log(STDUSERLOG,"ONLY_LOWERCASE ");
	if (val & TOKEN_AS_IS) Log(STDUSERLOG,"TOKEN_AS_IS ");
}

void DumpTokenFlags()
{
	Log(STDUSERLOG,"TokenFlags: ");
	// DID THESE
	if (tokenFlags & DO_ESSENTIALS) Log(STDUSERLOG,"DO_ESSENTIALS ");
	if (tokenFlags & DO_SUBSTITUTES) Log(STDUSERLOG,"DO_SUBSTITUTES ");
	if (tokenFlags & DO_CONTRACTIONS) Log(STDUSERLOG,"DO_CONTRACTIONS ");
	if (tokenFlags & DO_INTERJECTIONS) Log(STDUSERLOG,"DO_INTERJECTIONS ");
	if (tokenFlags & DO_BRITISH) Log(STDUSERLOG,"DO_BRITISH ");
	if (tokenFlags & DO_SPELLING) Log(STDUSERLOG,"DO_SPELLING ");
	if (tokenFlags & DO_TEXTING) Log(STDUSERLOG,"DO_TEXTING ");
	if (tokenFlags & DO_PRIVATE) Log(STDUSERLOG,"DO_PRIVATE ");
	// reserved
	if (tokenFlags & DO_NUMBER_MERGE) Log(STDUSERLOG,"NUMBER_MERGE ");
	if (tokenFlags & DO_PROPERNAME_MERGE) Log(STDUSERLOG,"PROPERNAME_MERGE ");
	if (tokenFlags & DO_SPELLCHECK) Log(STDUSERLOG,"SPELLCHECK ");
	// FOUND THESE
	if (tokenFlags & NO_HYPHEN_END) Log(STDUSERLOG,"HYPHEN_END ");
	if (tokenFlags & NO_COLON_END) Log(STDUSERLOG,"COLON_END ");
	if (tokenFlags & PRESENT) Log(STDUSERLOG,"PRESENT ");
	if (tokenFlags & PAST) Log(STDUSERLOG,"PAST ");
	if (tokenFlags & FUTURE) Log(STDUSERLOG,"FUTURE ");
	if (tokenFlags & PERFECT) Log(STDUSERLOG,"PERFECT ");
	if (tokenFlags & PRESENT_PERFECT) Log(STDUSERLOG,"PRESENT_PERFECT ");
	if (tokenFlags & CONTINUOUS) Log(STDUSERLOG,"CONTINUOUS ");
	if (tokenFlags & PASSIVE) Log(STDUSERLOG,"PASSIVE ");

	if (tokenFlags & QUESTIONMARK) Log(STDUSERLOG,"QUESTIONMARK ");
	if (tokenFlags & EXCLAMATIONMARK) Log(STDUSERLOG,"EXCLAMATIONMARK ");
	if (tokenFlags & PERIODMARK) Log(STDUSERLOG,"PERIODMARK ");
	if (tokenFlags & USERINPUT) Log(STDUSERLOG,"USERINPUT ");
	if (tokenFlags & FAULTY_PARSE) Log(STDUSERLOG,"FAULTY_PARSE ");
	if (tokenFlags & COMMANDMARK) Log(STDUSERLOG,"COMMANDMARK ");
	if (tokenFlags & QUOTATION) Log(STDUSERLOG,"QUOTATION ");
	if (tokenFlags & IMPLIED_YOU) Log(STDUSERLOG,"IMPLIED_YOU ");
	if (tokenFlags & NOT_SENTENCE) Log(STDUSERLOG,"NOT_SENTENCE ");
	Log(STDUSERLOG,"\r\n");
}

// BUG see if . allowed in word 

int ValidPeriodToken(char* start, char* end, char next,char next2) // token with period in it - classify it
{ //  TOKEN_INCLUSIVE means completes word   TOKEN_EXCLUSIVE not part of word.    TOKEN_INCOMPLETE  means embedded in word but word not yet done
	size_t len = end - start;
	if (IsAlpha(next) && tokenControl & TOKEN_AS_IS) return TOKEN_INCOMPLETE;
	if (IsDigit(next)) return TOKEN_INCOMPLETE;
	if (len > 100) return TOKEN_EXCLUSIVE; // makes no sense
	if (len == 2) // letter period combo like H.
	{
		char* next = SkipWhitespace(start + 2);
		if (IsUpperCase(*next) || !*next) return TOKEN_INCLUSIVE;	// Letter period like E. before a name
	}
	if (IsWhiteSpace(next) && IsDigit(*start)) return TOKEN_EXCLUSIVE;	// assume no one uses float period without a digit after it.
	if (FindWord(start,len)) return TOKEN_INCLUSIVE;	// nov.  recognized by system for later use
	if (IsMadeOfInitials(start,end) == ABBREVIATION) return TOKEN_INCLUSIVE; //   word of initials is ok
	if (IsUrl(start,end)) return TOKEN_INCLUSIVE; //   swallow URL as a whole
	if (!strnicmp("no.",start,3) && IsDigit(next)) return TOKEN_INCLUSIVE; //   no.8  
	if (!strnicmp("no.",start,3)) return TOKEN_INCLUSIVE; //   sentence: No.
	if (!IsDigit(*start) && len > 3 && *(end-3) == '.') return TOKEN_INCLUSIVE; // p.a._system
	if (FindWord(start,len-1)) return TOKEN_EXCLUSIVE; // word exists independent of it

	// is part of a word but word not yet done
    if (IsFloat(start,end) && IsDigit(next)) return TOKEN_INCOMPLETE; //   decimal number9
	if (*start == '$' && IsFloat(start+1,end) && IsDigit(next)) return TOKEN_INCOMPLETE; //   decimal number9 or money
	if (IsNumericDate(start,end)) return TOKEN_INCOMPLETE;	//   swallow period date as a whole - bug . after it?
	if ( next == '-') return TOKEN_INCOMPLETE;	// like N.J.-based

	//  not part of word, will be stand alone token.
	return TOKEN_EXCLUSIVE;
}


////////////////////////////////////////////////////////////////////////
// BURSTING CODE
////////////////////////////////////////////////////////////////////////

int BurstWord(char* word, int contractionStyle) 
{
#ifdef INFORMATION
	BurstWord, at a minimum, separates the argument into words based on internal whitespace and internal sentence punctuation.
	This is done for storing "sentences" as fact callArgumentList.
	Movie titles extend this to split off possessive endings of nouns. Bob's becomes Bob_'s. 
	Movie titles may contain contractions. These are not split, but two forms of the title have to be stored, the 
	original and one spot contractions have be expanded, which refines to the original.
	And in full burst mode it splits off contractions as well (why- who uses it).

#endif
	//   concept and class names do not burst, regular or quoted, nor do we waste time if word is 1-2 characters, or if quoted string and NOBURST requested
	if (!word[1] || !word[2] || *word == '~' || (*word == '\'' && word[1] == '~' ) || (contractionStyle & NOBURST && *word == '"')) 
	{
		strcpy(burstWords[0],word);
		return 1;
	}

	//   make it safe to write on the data while separating things
	char* copy = AllocateBuffer();
	strcpy(copy,word);
	word = copy;
	unsigned int base = 0;

	//   eliminate quote kind of things around it
    if (*word == '"' || *word == '\'' || *word == '*' || *word == '.')
    {
       size_t len = strlen(word);
       if (len > 2 &&  word[len-1] == *word) // start and end same and has something between
       {
           word[len-1] = 0;  // remove trailing quote
           ++word;
       }
   }

	bool underscoreSeen = false;
	char* start = word;
	while (*++word) // locate spaces of words, and 's 'd 'll 
	{
        if (*word == ' ' || *word == '_' || (*word == '-' && contractionStyle == HYPHENS)) //   these bound words for sure
        {
			if (*word == '_') underscoreSeen = true;
            if (!word[1]) break;  // end of coming up.

			char* end = word;  
			int len = end-start;
			char* prior = (end-1); // ptr to last char of word
			char priorchar = *prior;

			// separate punctuation from token except if it is initials or abbrev of some kind
			if (priorchar == ',' || punctuation[(unsigned char)priorchar] & ENDERS) //   - : ; ? !     ,
			{
				char next = *end;
				char next2 = (next) ? *SkipWhitespace(end+1) : 0;
				if (len <= 1){;}
				else if (priorchar == '.' && ValidPeriodToken(start,end,next,next2) != TOKEN_EXCLUSIVE){;} //   dont want to burst titles or abbreviations period from them
				else  // punctuation not a part of token
				{
					*prior = 0; // not a singleton character, remove it
					--len; // better not be here with -fore  (len = 0)
				}
			}

			// copy off the word we burst
            strncpy(burstWords[base],start,len);
			burstWords[base++][len] = 0;
			if (base > (MAX_BURST - 5)) break; //   protect excess

			//   add trailing punctuation if any was removed
			if (!*prior)
			{
				 *burstWords[base] = priorchar;
				 burstWords[base++][1] = 0;
			}

			//   now resume after
            start = word + 1;
            while (*start == ' ' || *start == '_') ++start;  // skip any excess blanks of either kind
            word = start - 1;
        }
		else if (*word == '\'' && contractionStyle & (POSSESSIVES|CONTRACTIONS)) //  possible word boundary by split of contraction or possession
        {
            int split = 0;
            if (word[1] == 0 || word[1] == ' '  || word[1] == '_') split = 1;  //   ' at end of word
            else if (word[1] == 's' && (word[2] == 0 || word[2] == ' ' || word[2] == '_')) split = 2;  //   's at end of word
			else if (!(contractionStyle & CONTRACTIONS)) {;} // only accepting possessives
            else if (word[1] == 'm' && (word[2] == 0 || word[2] == ' '  || word[2] == '_')) split = 2;  //   'm at end of word
            else if (word[1] == 't' && (word[2] == 0 || word[2] == ' '  || word[2] == '_')) split = 2;  //   't at end of word
            else if ((word[1] == 'r' || word[2] == 'v') && word[2] == 'e' && (word[3] == 0 || word[3] == ' '  || word[3] == '_')) split = 3; //    're 've
            else if (word[1] == 'l'  && word[2] == 'l' && (word[3] == 0 || word[3] == ' '  || word[3] == '_')) split = 3; //    'll
            if (split) 
            {
				//  swallow any word before
				if (*start != '\'')
				{
					int len = word - start;
					strncpy(burstWords[base],start,len);
					burstWords[base++][len] = 0;
					start = word;
				}
	
				// swallow apostrophe chunk as unique word, aim at the blank after it
				word += split;
				int len = word - start;
				strncpy(burstWords[base],start,len);
				burstWords[base++][len] = 0;

				start = word;
				if (!*word) break;	//   we are done, show we are at end of line
				if (base > MAX_BURST - 5) break; //   protect excess
                ++start; // set start to go for next word+
            }
       }
    }

	// now handle end of last piece
    if (start && *start && *start != ' ' && *start != '_') strcpy(burstWords[base++],start); // a trailing 's or '  won't have any followup word left
	if (!base && underscoreSeen) strcpy(burstWords[base++],"_");
	else if (!base) strcpy(burstWords[base++],start);

	FreeBuffer();
	burstLimit = base;	// note legality of burst word accessor GetBurstWord
    return base;
}

char* GetBurstWord(unsigned int n) //   0-based
{
	if (n >= burstLimit) 
	{
		ReportBug("Bad burst n %d",n)
		return "";
	}
	return burstWords[n];
}

char* JoinWords(unsigned int n,bool output)
{
    *joinBuffer = 0;
	char* at = joinBuffer;
    for (unsigned int i = 0; i < n; ++i)
    {
		char* hold = burstWords[i];
        if (!output && (*hold == ',' || *hold == '?' || *hold == '!' || *hold == ':')) // for output, dont space before punctuation
        {
            if (joinBuffer != at) *--at = 0; //   remove the understore before it
        } 
		size_t len = strlen(hold);
		if ((len + (at - joinBuffer)) >= maxBufferSize) break;	 // avoid overflow
        strcpy(at,hold);
		at += len;
        if (i != (n-1)) strcpy(at++,"_");
    }
    return joinBuffer;
}

////////////////////////////////////////////////////////////////////////
// BASIC TOKENIZING CODE
////////////////////////////////////////////////////////////////////////

static void TokenizeQuoteToUnderscore(char* start, char* end, char* buffer)
{//   start and end are the marker characters
	*end = 0;	//   remove trailing quote
	char* tmp = AllocateBuffer();
	strcpy(tmp,start);
	start = tmp;
	char* wordlist[MAX_SENTENCE_LENGTH];
	++start; // past the " start
	unsigned int loops = 0;
	while (start && *start)
	{
		unsigned int index;
		char* rest = Tokenize(start,index,wordlist,true);
		for (unsigned int i = 1; i <= index; ++i)
		{
			strcpy(buffer,wordlist[i]);
			buffer += strlen(buffer);
			if (i != index) *buffer++ = '_'; 
		}
		start = rest;
		++loops;
	}
	FreeBuffer();
}

static char* HandleQuoter(char* ptr,char** words, int& count)
{
	char c = *ptr; // kind of quoter
	char* end = strchr(ptr+1,c); // find matching end?
	if (!end) return NULL; 
	char pastEnd = punctuation[(unsigned char)end[1]]; // what comes AFTER quote
	if (!(pastEnd & (SPACES|PUNCTUATIONS|ENDERS))) return NULL;	// doesnt end cleanly

	// if quote has a tailing comma or period, move it outside of the end - "Pirates of the Caribbean,"  -- violates NOMODIFY clause if any
	char priorc = *(end-1);
	if (priorc == ',' || priorc == '.')
	{
		*(end-1) = *end;
		*end-- = priorc;
	}

	if (c == '*') // stage direction notation, erase it and return to normal processing
	{
		*ptr = ' ';
		*end = ' ';		// erase the closing * of a stage direction -- but violates a nomodify clause
		return ptr;		// skip opening *
	}
	
	// strip off the quotes if quoted words are only alphanumeric single words (emphasis quoting)
	char* at = ptr;
	while (++at < end)
	{
		if (!IsAlphaOrDigit(*at)) // worth quoting, unless it is final char and an ender
		{
			if (at == (end-1) && punctuation[(unsigned char)*at] & ENDERS);
			else // store string as properly tokenized, NOT as a string.
			{
				char* buf = AllocateBuffer();
				char word[MAX_WORD_SIZE];
				++end; // subsume the closing marker
				strncpy(word,ptr,end-ptr);
				word[end-ptr] = 0;
				TokenizeQuoteToUnderscore(word,end-ptr-1+word,buf);
				words[++count] = AllocateString(buf,0); 
				if (!words[count]) words[count] = "a"; // safe replacement
				FreeBuffer();
				return end;
			}
		}
	}
	words[++count] = AllocateString(ptr+1,end-ptr-1); // stripped quotes off simple word
	if (!words[count]) words[count] = "a"; // safe replacement
	return  end + 1;
}

static char* FindWordEnd(char* ptr,char* priorToken,char** words,int &count,bool nomodify)
{
	char c = *ptr; 
	unsigned char kind = punctuation[(unsigned char)c];
	char* end  = NULL;
	if (kind & QUOTERS) // quoted strings 
	{
		if (c == '\'' && ptr[1] == 's' && !IsAlpha(ptr[2])) return ptr+2;	// 's directly
		if (c == '"' ) return ptr + 1; // split up quote marks
		if (c == '\'' && !(tokenControl & TOKEN_AS_IS)) 
		{
			if (!IsAlpha(ptr[1]) && !IsDigit(ptr[1])) 	return ptr + 1; // is this quote or apostrophe - for penntag dont touch it - for 've  leave it alone also leave '82 alone
		}
		else if (c == '\'') {;} // for penntag dont touch it - for 've  leave it alone also leave '82 alone
		else
		{
			char* end = HandleQuoter(ptr,words,count);
			if (end)  return end;
		}
	}

	// single letter abbreviaion period like H.
	if (IsAlpha(*ptr) && ptr[1] == '.' && ptr[2] == ' ' && IsUpperCase(*ptr)) return ptr+2;
	if (*ptr == '.' && ptr[1] == '.' && ptr[2] == '.' && ptr[3] == ' ') return ptr+3;
	if (*ptr == '-' && ptr[1] == '-' && ptr[2] == ' ') return ptr + 2; // the -- break

	// Things that are normally separated as single character tokens
	char next = ptr[1];
	if (kind & BRACKETS && ( (c != '>' && c != '<') || next != '=') ) return ptr+1; // keep all brackets () [] {} <> separate but  <= and >= are operations
	else if (c == '&' && !(tokenControl & TOKEN_AS_IS))  //  we need to change this to "and"
	{
		words[++count] = "and"; 
		return ptr + 1;
	}
	//   arithmetic operator between numbers -  . won't be seen because would have been swallowed already if part of a float, 
	else if ((kind & ARITHMETICS || c == 'x' || c == 'X') && IsDigit(*priorToken) && IsDigit(next)) 
	{
		return ptr+1;  // separate operators from number
	}
	//   normal punctuation separation
	else if (c == '.' && IsDigit(ptr[1]));	// float start like .24
	else if (c == '.' && (ptr[1] == '"' || ptr[1] == '\'')) return ptr + 1;	// let it end after closing quote
	if (c == '.' && ptr[1] == '.' && ptr[2] == '.')  // stop at .. or ...   stand alone punctuation 
	{
		if (tokenControl & TOKEN_AS_IS) 
			return ptr + 3;
		return ptr+1;
	}
	else if (*ptr == ',') return ptr+1; 
	else if (kind & (ENDERS|PUNCTUATIONS) && ((unsigned char)punctuation[ptr[1]] == SPACES || ptr[1] == 0)) return ptr+1; 

	//   find "normal" word end, including all touching nonwhitespace, keeping periods (since can be part of word) but not ? or ! which cant
 	end = ptr;
	char* stopper = NULL;
	char* fullstopper = NULL;
	if (*ptr != ':' && *ptr != ';') while (*++end && !IsWhiteSpace(*end) && *end != '!' && *end != '?')
	{
		if (*end == ',') 
		{
			if (!IsDigit(end[1]) || !IsDigit(* (end-1))) // not comma within a number
			{
				if (!fullstopper) fullstopper = end;
				if (!stopper) stopper = end;
			}
			continue;
		}
		if (*end == ';' && !stopper) stopper = end;
		if (*end == '-' && !(tokenControl & TOKEN_AS_IS) && !stopper) stopper = end; // alternate possible end  (e.g. 8.4-ounce)
		if (*end == ';' && !fullstopper) fullstopper = end; // alternate possible end  (e.g. 8.4-ounce)
	}
	if (end == ptr) ++end;	// must shift at least 1
	WORDP X = FindWord(ptr,end-ptr);
	if (X && (X->properties & PART_OF_SPEECH || X->systemFlags & PATTERN_WORD || X->internalBits & HAS_SUBSTITUTE)) // we know this word (with exceptions)
	{
		// if ' follows a number, make it feet
		if (*ptr == '\'' && (end-ptr) == 1)
		{
			if (IsDigit(*priorToken))
			{
				words[++count] = "foot"; 
				return end;
			}
		}

		// but No. must not be recognized unless followed by a digit
		else if (!strnicmp(ptr,"no.",end-ptr))
		{
			char* at = end;
			if (*at) while (*++at && *at == ' ');
			if (IsDigit(*at)) return end;
		}

		else return end;
	}

	//  e-mail, needs to not see - as a stopper.
	WORDP W = (fullstopper) ? FindWord(ptr,fullstopper-ptr) : NULL;
	if (*end && IsDigit(end[1]) && IsDigit(*(end-1))) W = NULL; // if , separating digits, DONT break at it  4,000 even though we recognize subpiece
	if (W && (W->properties & PART_OF_SPEECH || W->systemFlags & PATTERN_WORD))  return fullstopper; // recognize word at more splits

	// recognize subword? now in case - is a stopper
	W = (stopper && ((*stopper != '-' && *stopper != '/') || !IsAlpha(stopper[1]))) ? FindWord(ptr,stopper-ptr) : NULL;
	if (*end == '-' && IsAlpha(end[1])) W = NULL; // but don't split -  in a name or word 
	else if (*end && IsDigit(end[1]) && IsDigit(*(end-1))) W = NULL; // if , separating digits, DONT break at it  4,000 even though we recognize subpiece
	if (W && (W->properties & PART_OF_SPEECH || W->systemFlags & PATTERN_WORD))  return stopper; // recognize word at more splits

	char* start = ptr;
	char next2;
	while (++ptr && !IsWordTerminator(*ptr)) // now scan to find end of token one by one, stopping where appropriate
    {
		c = *ptr;
		kind = punctuation[(unsigned char)c];
		next = ptr[1];
		next2 = (next) ? *SkipWhitespace(ptr+2) : 0; // start of next token
		if (tokenControl & TOKEN_AS_IS) {;}
		else
		{
			if (c == '\'') //   possessive ' or 's  - we separate ' or 's into own word
			{
				if (next == ',' || IsWhiteSpace(next) || next == ';' || next == '.' || next == '!' || next == '?') // trailing plural?
				{
					break; 
				}
				if (!IsAlphaOrDigit(next)) break;					//   ' not within a word, ending it
				if (next == 's' && !IsAlphaOrDigit(ptr[2]))  break;	//   's becomes separate - can be WRONG when used as contraction like speaker's but we cant know

				// ' as particle ellision
				if ((ptr-start) == 1 && (*start == 'd' || *start == 'j' || *start == 'l' || *start == 's'  || *start == 't')) return ptr + 1;  // break off d' argent and other foreign particles
			
				//   12'6" or 12'. or 12' 
				if (IsDigit(*start) && !IsAlpha(next)) return ptr + 1;  //   12' swallow ' into number word
			}
			else if (ptr != start && c == ':' && IsDigit(next) && IsDigit(*(ptr-1))) //   time 10:30 or odds 1:3
			{
				if (!strnicmp(end-2,"am",2)) return end-2;
				else if (!strnicmp(end-2,"pm",2)) return end-2;
				else if (!strnicmp(end-3,"a.m",3)) return end-3;
				else if (!strnicmp(end-3,"p.m",3)) return end-3;
				else if (!strnicmp(end-4,"a.m.",4)) return end-4;
				else if (!strnicmp(end-4,"p.m.",4)) return end-4;
			} 
			else if (c == '-') // - used as measure separator or arithmetic
			{
				if (IsDigit(*start) && IsDigit(next)) break; // minus
				if ((next == 'x' || next == 'X') && ptr[2] == '-') // measure like 2ft-x-5ft
				{
					ptr[2] = ' ';
					*ptr = ' ';
					break;
				}
				else if ((IsDigit(*start) || (*start == '.' && IsDigit(start[1]))) && IsAlpha(next) && !(tokenControl & TOKEN_AS_IS)) // break apart measures like 4-ft except when penntag strict casing
				{
					*ptr = ' ';
					break;	//   treat as space
				}
			}

			if (c == '&') break; // must represent "and"
			if (ptr != start && IsDigit(*(ptr-1)) && IsWordTerminator(ptr[1]) && (c == '"' || c == '\'' || c == '%')) break; // special markers on trailing end of numbers get broken off. 50' and 50" and 50%
			if ((c == 'x' || c== 'X') && IsDigit(*start) && IsDigit(next)) break; // break  4x4
			if (kind & ARITHMETICS && IsDigit(next) && c != '/' && c != '.' && IsDigit(*start) && !(tokenControl & TOKEN_AS_IS)) break;  // split numeric operator like  60*2 => 60 * 2  but 60 1/2 stays // 1+1=
		}

		if (kind & (PUNCTUATIONS|ENDERS|BRACKETS) && IsWordTerminator(next)) 
		{
			if (c == '-' && *ptr == '-' && next == ' ') return ptr + 1;
			if (tokenControl & TOKEN_AS_IS && next == ' ' && !IsWhiteSpace(ptr[2])) return ptr + 1; // our token ends and there is more text to come
			if (!(tokenControl & TOKEN_AS_IS)) break; // funny things at end of word
		}
		if (c == '/' && IsNumericDate(start,end)) return end; //  return entire token as date   12/20/1993  

		// special interpretations of period
		if (c == '.') 
        {
			int x = ValidPeriodToken(start,end,next,next2);
			if (x == TOKEN_INCLUSIVE) return end;
			else if (x == TOKEN_INCOMPLETE) continue;
			else break;
        }
	}
	if (*(ptr-1) == '"' && start != (ptr-1)) --ptr;// trailing double quote stuck on something else
    return ptr;
}

char* Tokenize(char* input,unsigned int &mycount,char** words,bool all,bool nomodify) //   return ptr to stuff to continue analyzing later
{	// all is true if to pay no attention to end of sentence -- eg for a quoted string
	// nomodify is true on analyzing outputs into sentences, because user format may be fixed
    char* ptr = SkipWhitespace(input);
	int count = 0;
	unsigned int quoteCount = 0;
	char priorToken[MAX_WORD_SIZE];
	*priorToken = 0;
	int nest = 0;
	while (ptr) // find tokens til end of sentence or end of tokens
	{
		if (!*ptr) break; 
		if (!(tokenControl & TOKEN_AS_IS)) while (*ptr == ptr[1] && !IsAlphaOrDigit(*ptr) && *ptr != '-' && *ptr != '.') ++ptr; // ignore repeated non-alpha non-digit characters -   - but NOT -- and not ...

		// find end of word 
		int oldCount = count;
		char* end = FindWordEnd(ptr,priorToken,words,count,nomodify); 
		if (count != oldCount || *ptr == ' ')	// FindWordEnd performed allocation already or removed stage direction start
		{
			ptr = SkipWhitespace(end);
			continue;
		}

		// get the token
		size_t len = end - ptr;
		strncpy(priorToken,ptr,len);
		priorToken[len] = 0;
		char lastc = *(end-1);

		// adjust am and AM if used as a time reference and not the verb "am"
		if (!stricmp(priorToken,"am") && count && IsDigit(words[count][0])) 
		{
			strcpy(priorToken,"a.m."); 
			len = 4;
			lastc = '.';
		}

		char startc = *priorToken;

		//   reserve next word, unless we have too many
		if (++count >= MAX_SENTENCE_LENGTH ) 
		{
			mycount = count - 1;
			return ptr;
		}

		//   handle symbols for feet and inches by expanding them
		if (!(tokenControl & TOKEN_AS_IS) && IsDigit(startc) &&  (lastc == '\'' || lastc == '"'))
		{
			char* word = AllocateString(ptr,len-1);  // number w/o the '
			if (word) words[count] = word;
			words[++count] = (lastc == '"') ? (char*) "feet": (char*)"inches" ; // spell out the notation
			ptr = SkipWhitespace(end);
			continue;
		}

		//   if the word is a quoted expression, see if we KNOW it already as a noun, if so, remove quotes
		if (*priorToken == '"' && len > 2)
		{
			char buffer[MAX_WORD_SIZE];
			strcpy(buffer,priorToken);
			ForceUnderscores(buffer);
			WORDP E = FindWord(buffer+1,len-2); // do we know this unquoted?
			if (E && E->properties & PART_OF_SPEECH) strcpy(priorToken,E->word);
		}

		// assign token
 		char* token = words[count] = AllocateString(priorToken,len);   
		if (!token) words[count] = "a";
		if (len == 1 && startc == 'i') *token = 'I'; // force uppser case on I

		//   set up for next token or ending tokenization
		ptr = SkipWhitespace(end);

		if (*token == '"' && (count == 1 || !IsDigit(*words[count-1] ))) ++quoteCount;
		if (*token == '"' && count > 1 && quoteCount && !(quoteCount & 1)) // does end of this quote end the sentence?
		{
			char c = words[count-1][0];
			if (*ptr == ',' || c == ',') {;} // comma after or inside means not at end
			else if (*ptr && IsLowerCase(*ptr)){;} // sentence continues
			else if (c == '!' || c == '?' || c == '.') break;	 // internal punctuation ends the sentence
		}
		
		if (*token == '(' && !token[1]) ++nest;
		else if (*token == ')' && !token[1]) --nest;

		if (*ptr == ')' && nest == 1){;}
		else if (tokenControl & TOKEN_AS_IS) {;} // penn bank input already broken up as sentences
		else if (all || tokenControl & NO_SENTENCE_END || startc == ',' || token[1]){;}	// keep going - ) for closing whatever
		else if ( (count > 1 && *token == '\'' && ( (*words[count-1] == '.' && !words[count-1][1]) || *words[count-1] == '!' || *words[count-1] == '?'))) break; // end here
		else if (punctuation[(unsigned char)startc] & ENDERS || (startc == ']' && *words[1] == '[')) //   done a sentence or fragment
		{
			if (quoteCount & 1) continue;	// cannot end quotation w/o quote mark at end
			// each punctuation ender can be separately controlled
			if (startc == '-')
			{
				if (IsDigit(*ptr)) {;} // is minus 
				else if (!(tokenControl & NO_HYPHEN_END)) // we dont want hypen to end it anyway
				{
					*token = '.';
					tokenFlags |= NO_HYPHEN_END;
					break;
				}
			}
			else if (startc == ':')
			{
				if (!strstr(ptr," and ") || strchr(ptr,',')) {;}	// guess : is a list - could be wrong guess
				else if (!(tokenControl & NO_COLON_END))			// we dont want colon to end it anyway
				{
					tokenFlags |= NO_COLON_END;
					break;
				}
			}
			else if (startc == ';')
			{
				if (!(tokenControl & NO_SEMICOLON_END))  // we dont want semicolon to end it anyway
				{
					tokenFlags |= NO_SEMICOLON_END;
					break;
				}
			}
			else if (*ptr == '"' || *ptr == '\'') continue;
			else break;	// []  ? and !  and  .  are mandatory unless NO_SENTENCE_END used
		}
	}
	words[count+1] = "";	// mark as empty

	// if all is a quote, remove quotes if it is just around a single word
	if (count == 3 && *words[1] == '"' && *words[count] == '"')
	{
		memmove(words,words+1,count * sizeof(char*)); // move all down
		count -= 2;
	}
	// if all is a quote, remove quotes if it is just around a single word
	else if (count  == 3 && *words[1] == '\'' && *words[count] == '\'')
	{
		memmove(words,words+1,count * sizeof(char*)); // move all down
		count -= 2;
	}
	mycount = count;
	return ptr;
}


////////////////////////////////////////////////////////////////////////
// POST PROCESSING CODE
////////////////////////////////////////////////////////////////////////

static WORDP MergeProperNoun(int& start, int end,bool upperStart) 
{ // end is inclusive
	WORDP D;
	uint64 gender = 0;
	char buffer[MAX_WORD_SIZE];

	// build composite name
    char* ptr = buffer;
	bool uppercase = false;
	bool name = false;
	if (IsUpperCase(*wordStarts[start]) && IsUpperCase(*wordStarts[end])) uppercase = true;	// MUST BE UPPER
    for (int i = start; i <= end; ++i)
    {
		char* word = wordStarts[i];
        size_t len = strlen(word);

        if (*word == ',' ||*word == '?' ||*word == '!' ||*word == ':') --ptr;  //   remove the understore before it
		else
		{
			// locate known sex of word if any, composite will inherit it
			D = FindWord(word,len,LOWERCASE_LOOKUP);
			if (D) gender |= D->properties & (NOUN_HE|NOUN_SHE|NOUN_HUMAN|NOUN_PROPER_SINGULAR);
 			D = FindWord(word,len,UPPERCASE_LOOKUP);
			if (D) 
			{
				gender |= D->properties & (NOUN_HE|NOUN_SHE|NOUN_HUMAN|NOUN_PROPER_SINGULAR);
				if (D->properties & NOUN_FIRSTNAME) name = true;
			}
		}

        strcpy(ptr,word);
        ptr += len;
        if (i < end) *ptr++ = '_'; // more to go
    }
	*buffer = toUppercaseData[(unsigned char)*buffer]; // start it as uppercase

	D = FindWord(buffer,0,UPPERCASE_LOOKUP); // if we know the word in upper case
	// see if adding in determiner or title to name
	if (start > 1) // see if determiner before is known, like The Fray or Title like Mr.
	{
		WORDP E = FindWord(wordStarts[start-1],0,UPPERCASE_LOOKUP); // the word before
		if (E && !(E->properties & NOUN_TITLE_OF_ADDRESS)) E = NULL; 
		// if not a title of address is it a determiner?  "The" is most common
		if (!E) 
		{
			E = FindWord(wordStarts[start-1],0,LOWERCASE_LOOKUP);
			if (E && !(E->properties & DETERMINER)) E = NULL;
		}
		if (E) // known title of address or determiner? See if we know the composite word includes it - like the Rolling Stones is actually The_Rolling_Stones
		{
			char buffer1[MAX_WORD_SIZE];
			strcpy(buffer1,E->word);
			*buffer1 = toUppercaseData[(unsigned char)*buffer1]; 
			strcat(buffer1,"_");
			strcat(buffer1,buffer);
			if (E->properties & DETERMINER) // if determine is part of name, revise to include it
			{
				WORDP F = FindWord(buffer1);
				if (F) 
				{
					--start;
					D = F; 
				}
			}
			else if (tokenControl & STRICT_CASING && IsUpperCase(*buffer) && IsLowerCase(*wordStarts[start-1])){;} // cannot mix lower title in
			else //   accept title as part of unknown name automatically
			{
				strcpy(buffer,buffer1);
				D = FindWord(buffer);
				--start;
			}
		}
	}
	if ((end - start)  == 0) return NULL;	// dont bother, we already have this word in the sentence
	if (!D && upperStart) 
	{
		WORDP X = FindWord(buffer,0,LOWERCASE_LOOKUP);
		if (X) D = X; // if we know it in lower case, use that since we dont know the uppercase one - eg "Artificial Intelligence"
		else 
		{
			D = FindWord(buffer,0,UPPERCASE_LOOKUP);
			if (D && D->systemFlags & LOCATIONWORD) gender = 0; // a place, not a name
			else D = StoreWord(buffer,gender|NOUN_PROPER_SINGULAR|NOUN);
		}
	}
	if (!D && !upperStart) return NULL; // neither known in upper case nor does he try to create it
	if (D && D->systemFlags & ALWAYS_PROPER_NAME_MERGE) return D;
	if (name) return D; // use known capitalization  - it has a first name
	if (uppercase) return D;
	return NULL; // let SetSequenceStamp find it instead
}

static bool HasCaps(char* word)
{
    if (IsMadeOfInitials(word,word+strlen(word)) == ABBREVIATION) return true;
    if (!IsUpperCase(*word) || strlen(word) == 1) return false;
    while (*++word)
    {
        if (!IsUpperCase(*word)) return true; // do not allow all caps as such a word
    }
    return false;
}

static int FinishName(int& start, int& end, bool upperStart,uint64 kind,WORDP name)
{ // start is beginning of sequence, end is on the sequence last word. i is where to continue outside after having done this one
	
    if (end == UNINIT) end = start;
	
    //   a 1-word title gets no change. also
	if (end == (int)wordCount && start == 1 && end < 5 && (!name || !(name->systemFlags & ALWAYS_PROPER_NAME_MERGE))) //  entire short sentence gets ignored
	{
	} 
	else if ( (end-start) < 1 ){;}  
	else //   make title
	{
		WORDP E = MergeProperNoun(start,end,upperStart);
		if (E) 
		{
			AddSystemFlag(E,kind); // if timeword 
			//   replace multiple words with single word
			wordStarts[start] = E->word;
			memmove(wordStarts+start+1,wordStarts+end+1,sizeof(char*) * (wordCount - end));
			wordCount -= (end - start);
		}
		tokenFlags |= DO_PROPERNAME_MERGE;
	}
	int result = start + 1;
	start = end = UNINIT;
	return result; // continue AFTER here
}

static void HandleFirstWord() // Handle capitalization of starting word of sentence
{
	if (*wordStarts[1] == '"') return; // dont touch a quoted thing

	// look at it in upper case first
    WORDP D = FindWord(wordStarts[1],0,UPPERCASE_LOOKUP); // Known in upper case?
	if (D && D->properties & (NOUN|PRONOUN_BITS)) return;	// upper case is fine for nouns and pronoun I

	// look at it in lower case
	WORDP E = FindWord(wordStarts[1],0,LOWERCASE_LOOKUP); 
	WORDP N;
	char word[MAX_WORD_SIZE];
	MakeLowerCopy(word,wordStarts[1]);
	char* noun = GetSingularNoun(word,true,true);

	if (D && !E && !IsUpperCase(*wordStarts[1]))  wordStarts[1] = D->word; // have upper but not lower, use upper
	else if (!IsUpperCase(*wordStarts[1])) return; // dont change what is already ok, dont want unnecessary trace output
	else if (noun && !stricmp(word,noun)) wordStarts[1] = StoreWord(noun)->word; // lower case form is the singular form already - use that whether he gave us upper or lower
	else if (E && E->properties & (CONJUNCTION_BITS|PRONOUN_BITS|PREPOSITION)) wordStarts[1] = E->word; // simple word lower case, use it
	else if (E && E->properties & AUX_VERB_BITS && (N = FindWord(wordStarts[2])) && (N->properties & (PRONOUN_BITS | NOUN_BITS) || GetSingularNoun(wordStarts[2],true,false))) wordStarts[1] = E->word; // potential aux before obvious noun/pronoun, use lower case of it

	// see if multiple word (like composite name)
	char* multi = strchr(wordStarts[1],'_');
	if (!D && !E && !multi) return;  // UNKNOWN word in any case (probably a name)

	if (!multi || !IsUpperCase(multi[1])) // remove sentence start uppercase if known in lower case unless its a multi-word title 
	{
		char word[MAX_WORD_SIZE];
		MakeLowerCopy(word,wordStarts[1]);
		if (FindWord(word,0,LOWERCASE_LOOKUP)) wordStarts[1] = StoreWord(word)->word;  // BEFORE:  DAHINDA was converted to lower case by this.
	}
	else if (multi) wordStarts[1] = StoreWord(wordStarts[1],NOUN_PROPER_SINGULAR)->word; // implied proper noun of some kind
}

void ProcessCompositeName() 
{
	if (tokenControl & ONLY_LOWERCASE) return;

    int start = UNINIT;
    int end = UNINIT;
    uint64 kind = 0;
	bool upperStart = false;

    for (int i = 1; (unsigned int)i <= wordCount; ++i) 
    {
		char* word = wordStarts[i];
		if (*word == '"' || (strchr(word,'_') && !IsUpperCase(word[0]))) // we never join composite words onto proper names unless the composite is proper already
		{
			if (start != UNINIT)  i = FinishName(start,end,upperStart,kind,NULL); // we have a name started, finish it off
			continue;
		}
		WORDP Z = FindWord(word,0,UPPERCASE_LOOKUP);
		if (IsUpperCase(*word) && Z && Z->systemFlags & NO_PROPER_MERGE)
		{
			if (start != UNINIT) i = FinishName(start,end,upperStart,kind,Z);
			continue;
		}
			
		// check for easy cases of 2 words in a row being a known uppercase word
		if (start == UNINIT && i != (int)wordCount && *wordStarts[i+1] != '"')
		{
			char composite[MAX_WORD_SIZE];
			strcpy(composite,wordStarts[i]);
			strcat(composite,"_");
			strcat(composite,wordStarts[i+1]);
			Z = FindWord(composite,0,UPPERCASE_LOOKUP);
			if (Z && Z->systemFlags & NO_PROPER_MERGE) Z = NULL;
			if (tokenControl & (ONLY_LOWERCASE|STRICT_CASING) && IsLowerCase(*composite)) Z = NULL;	// refuse to see word
			if (Z && Z->properties & NOUN) 
			{
				end = i + 1;
				if (Z->properties & NOUN_TITLE_OF_WORK && i != end && !IsUpperCase(*wordStarts[i+1])) // dont automerge title names the "The Cat", let sequences find them and keep words separate when not intended
				{
					start = end = UNINIT;
					continue;
				}
				else
				{
					i = FinishName(i,end,false,0,Z);
					continue;
				}
			}
			// now add easy triple
			if ((unsigned int)(i + 2) <= wordCount&& *wordStarts[i+2] != '"')
			{
				strcat(composite,"_");
				strcat(composite,wordStarts[i+2]);
				Z = FindWord(composite,0,UPPERCASE_LOOKUP);
				if (tokenControl & STRICT_CASING && IsLowerCase(*composite)) Z = NULL;	// refuse to see word
				if (Z && Z->systemFlags & NO_PROPER_MERGE) Z = NULL;
				if (Z && Z->properties & NOUN) 
				{
					end = i + 2;
					i = FinishName(i,end,false,0,Z);
					continue;
				}
			}
		}
        size_t len = strlen(word);

		WORDP nextWord  = ((unsigned int) i < wordCount) ? FindWord(wordStarts[i+1],0,UPPERCASE_LOOKUP) : NULL; // grab next word
		if (tokenControl & (ONLY_LOWERCASE|STRICT_CASING) && (unsigned int) i < wordCount && wordStarts[i+1] && IsLowerCase(*wordStarts[i+1])) nextWord = NULL;	// refuse to see word
		if (nextWord && nextWord->systemFlags & NO_PROPER_MERGE) nextWord = NULL;

  		WORDP U = FindWord(word,len,UPPERCASE_LOOKUP);
		if (tokenControl & (ONLY_LOWERCASE|STRICT_CASING) && IsLowerCase(*word)) U = NULL;	// refuse to see word
		if (U && U->systemFlags & NO_PROPER_MERGE) U = NULL;
		if (U && !(U->properties & ESSENTIAL_FLAGS)) U = NULL;	//  not a real word
		WORDP D = U; // the default word to use

		WORDP L = FindWord(word,len,LOWERCASE_LOOKUP);
		if (tokenControl & STRICT_CASING && IsUpperCase(*word)) L = NULL;	// refuse to see word
		if (L && L->systemFlags & NO_PROPER_MERGE) L = NULL;
	
		if (L && !IsUpperCase(*word)) D = L;			// has lower case meaning, he didnt cap it, assume its lower case
		else if (L && i == 1 && L->properties & (PREPOSITION | PRONOUN_BITS | CONJUNCTION_BITS) ) D = L; // start of sentence, assume these word kinds are NOT in name
		if (i == 1 && L &&  L->properties & AUX_VERB_BITS && nextWord && nextWord->properties & (PRONOUN_BITS)) continue;	// obviously its not Will You but its will they
		else if (start == UNINIT && IsLowerCase(*word) && L && L->properties & (ESSENTIAL_FLAGS|QWORD)) continue; //   he didnt capitalize it himself and its a useful word, not a proper name
		
		if (!D) D = L; //   ever heard of this word? 

		//   given human first name as starter or a title
        if (start == UNINIT && D && D->properties & (NOUN_FIRSTNAME|NOUN_TITLE_OF_ADDRESS))
        {
			upperStart = (i != 1 &&  D->internalBits & UPPERCASE_HASH) ? true : false;  // the word is upper case, so it begins a potential naming
			start = i; 
			kind = 0;
            end = UNINIT;    //   have no potential end yet
            if ((unsigned int)i < wordCount) //   have a last name? or followed by a preposition? 
            {
				size_t len1 = strlen(wordStarts[i+1]);
				WORDP F = FindWord(wordStarts[i+1],len1,LOWERCASE_LOOKUP);
				if (tokenControl & STRICT_CASING && IsUpperCase(*wordStarts[i+1])) F = NULL;	// refuse to see word
				if (F && F->properties & (CONJUNCTION_BITS | PREPOSITION | PRONOUN_BITS)) //   dont want river in the to become River in the or Paris and Rome to become Paris_and_rome
				{
					start = UNINIT;
					++i;
					continue;
				}
				
				if (nextWord && !(nextWord->properties & ESSENTIAL_FLAGS)) nextWord = NULL;		//   not real
				if (nextWord && nextWord->properties & NOUN_TITLE_OF_ADDRESS) nextWord = NULL;	//  a title of address cannot be here
				if (nextWord && nextWord->systemFlags & NO_PROPER_MERGE) nextWord = NULL;
	
                if (nextWord || IsUpperCase(*wordStarts[i+1])) //   it's either capitalized or we know it is capitalizable
                {
					upperStart = true;	//   must be valid
					if (IsLowerCase(*wordStarts[i])) //   make current word upper case, do not overwrite its shared ptr
					{
						wordStarts[i] = AllocateString(wordStarts[i],0);
						if (!wordStarts[i]) wordStarts[i] = "a";
						else *wordStarts[i] = toUppercaseData[(unsigned char)*wordStarts[i]]; 
					}
                    ++i; 
                    continue;
                }
           }
        }

		// so much for known human name pairs. Now the general issue.
        bool intended = HasCaps(word) && i != 1;
		if (HasCaps(word) && !D) intended = true;	// unknown word which had caps. He must have meant it
        uint64 type = (D) ? (D->systemFlags & TIMEWORD) : 0; // type of word if we know it
		if (!kind) kind = type;
        else if (kind && type && kind != type) intended = false;   // cant intermix time and space words

		// sNational Education Association, education is a known word that should be merged but Mary, George, and Larry, shouldnt merge
		if (D && D->internalBits & UPPERCASE_HASH && GetMeanings(D)) // we KNOW this word by itself, dont try to merge it
		{
			if (start == (int)i)
			{
				end = i;
				i = FinishName(start,end,upperStart,kind,D);
			}
			continue;
		}
		
		if (i == 1 && wordCount > 1) // pay close attention to sentence starter
        {
			WORDP N = FindWord(wordStarts[2]);
			if (N && N->properties & PRONOUN_BITS) continue;	// 2nd word is a pronoun, not likely a title word
 			if (D && D->properties & (DETERMINER|QWORD)) continue;   //   ignore starting with a determiner or question word(but might have to back up later to accept it)
		}

        //   Indian food is not intended
		if (intended || (D && D->properties & (NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL|NOUN_TITLE_OF_ADDRESS))) // cap word or proper name can start
        {
			if (D && D->properties & POSSESSIVE); // not Taiwanese President
			else if (L && L->properties & QWORD); // ignore WHO for who
            else if (start == UNINIT) //   havent started yet, start now
            {
	 			upperStart = (intended && i != 1);  //   he started it properly or not
                start = i; 
				kind = (D) ? (D->systemFlags & TIMEWORD) : 0;
            }
            if (end != UNINIT) end = UNINIT;  //   swallow a word along the way that is allowed to be lower case
        }
        else if (start != UNINIT) // lowercase may en name, unless turns out to be followed by uppercase
        {
			// Do not allow lower case particles and connectors after a comma...  Shell Oil, the Dutch group 
            if (D && D->properties & LOWERCASE_TITLE && i > 1 && *wordStarts[i-1] != ',' ) // allowable particles and connecting words that can be in lower case
			{
				//   be wary of and joining two known proper names like Paris and London - but want legal firms like xxx and yyy 
				if (!strcmp(D->word,"and"))
				{
					char word[MAX_WORD_SIZE];
					char* at = word;
					for (int j = start; j < i; ++j)
					{
						strcpy(at,wordStarts[i]);
						at += strlen(at);
						if (j != (i-1)) *at++ = '_';
					}
					*at = 0;
					WORDP D = FindWord(word,at-word,UPPERCASE_LOOKUP);
					if (D) 
					{
						i = FinishName(start,end,upperStart,kind,D);
						continue;
					}
				}
				else if (i < (int)wordCount && !IsUpperCase(*wordStarts[i+1])) // Pluto, the dog 
				{
						i = FinishName(start,end,upperStart,kind,NULL);
						continue;
				}
				//   be careful with possessives. we dont want London's Millenium Eye to match or Taiwanese President
				if (D->properties & POSSESSIVE)
				{
					end = i - 1;	// possessive is not part of it
					i = FinishName(start,end,upperStart,kind,NULL);
				}
				continue;
			}
            if (*word == ',' && (unsigned int)i < wordCount && IsUpperCase(*wordStarts[i+1])) // comma series, but DONT allow adjective to follow ("Pluto, American astronomer" 
            {
				WORDP next = FindWord(wordStarts[i+1]);
				if (next && next->properties & (DETERMINER|ADJECTIVE_BITS)) {;}
				else
				{
					end = i;
					continue;
				}
			}
            //   Hammer, Howell, & Houton, Inc. 
			end = i - 1;
			i = FinishName(start,end,upperStart,kind,NULL);
       }
    }

    if (start != UNINIT ) // proper noun is pending 
    {
        if (end == UNINIT) end = wordCount;
		FinishName(start,end,upperStart,kind,NULL);
    }

	HandleFirstWord();
}

static void MergeNumbers(int& start,int& end) //   four score and twenty = four-score-twenty
{//   start thru end exclusive of end, but put in number power order if out of order (four and twenty becomes twenty-four)
    char word[MAX_WORD_SIZE];
    char* ptr = word;
    for (int i = start; i < end; ++i)
    {
		char* item = wordStarts[i];
        if (*item == ',') continue; //   ignore commas
		if (i > start && *item == '-') ++item; // skip leading -

        size_t len = strlen(wordStarts[i]);
		//   one thousand one hundred and twenty three
		//   OR  one and twenty 
        if (*item == 'a' || *item == 'A') //   and,  maybe flip order if first, like one and twenty, then ignore
        {
			int64 power1 = NumberPower(wordStarts[i-1]);
			int64 power2 = NumberPower(wordStarts[i+1]);
			if (power1 < power2) //   latter is bigger than former --- assume nothing before and just overwrite
			{
				strcpy(word,wordStarts[i+1]);
                ptr = word + strlen(word);
                *ptr++ = '-';
                strcpy(ptr,wordStarts[i-1]);
                ptr += strlen(ptr);
                break;
			}
            continue;
        }

        strcpy(ptr,item);
        ptr += len;
        *ptr = 0;
        if (i != start) //   prove not mixing types digits and words
        {
            if (*word == '-' && !IsDigit(*item)) 
			{
				end = start = (unsigned int)UNINIT;
				return; //   - not a sign? CANCEL MERGE
			}
        }
        if (i < (end-1) && *item != '-') *ptr++ = '-'; //   hypenate words (not digits )
        else if (i < (end-1) && strchr(wordStarts[i+1],'/')) *ptr++ = '-'; //   is a fraction? BUG
    }
    *ptr = 0;

	//   change any _ to - (substitutions or wordnet might have merged using _
	while ((ptr = strchr(word,'_'))) *ptr = '-';

	//   create the single word and replace all the tokens
    WORDP D = StoreWord(word,ADJECTIVE|NOUN|ADJECTIVE_NUMBER|NOUN_NUMBER); 
    wordStarts[start] = D->word;
	memmove(wordStarts+start+1,wordStarts+end,sizeof(char*) * (wordCount + 1 - end ));
	wordCount -= (end - start) - 1;	//   deleting all but one of the words
	tokenFlags |= DO_NUMBER_MERGE;
    end = start = (unsigned int)UNINIT;
}

void ProcessCompositeNumber() 
{
    //  convert a series of numbers into one hypenated one and remove commas from a comma-digited string
    int start = UNINIT;
	int end = UNINIT;
	char* number;
    for (unsigned int i = 1; i <= wordCount; ++i) 
    {
        bool isNumber = IsNumber(wordStarts[i]) && !IsPlaceNumber(wordStarts[i]) && !GetCurrency(wordStarts[i],number);
		size_t len = strlen(wordStarts[i]);
        if (isNumber || (start == UNINIT && *wordStarts[i] == '-' && i < wordCount && IsDigit(*wordStarts[i+1]))) // is this a number or part of one
        {
            if (start == UNINIT) start = i;
            if (end != UNINIT) end = (unsigned int)UNINIT;
        }
        else if (start == UNINIT) continue; // nothing started
		else
        {
            if (i != wordCount && i != 1) // middle words AND and , 
			{
				// AND between words 
				if (!strnicmp("and",wordStarts[i],len)) 
				{
					end = i;
					if (!IsDigit(*wordStarts[i-1]) && !IsDigit(*wordStarts[i+1])) continue; // potential word number
				}
				// comma between digit tokens
				else if (*wordStarts[i] == ',' ) 
				{
					if (IsDigit(*wordStarts[i-1]) && IsDigit(*wordStarts[i+1])) // a numeric comma
					{
						if (strlen(wordStarts[i+1]) == 3) // after comma must be exactly 3 digits 
						{
							end = i; // potential stop
							continue;
						}
					}
				}
			}
            //   this definitely breaks the sequence
            if (end  == UNINIT) end = i;
            if ((end-start) == 1) // no change if its a 1-length item
            {
                start = end = (unsigned int)UNINIT;
                continue; 
            }

			//  numbers in  series cannot merge unless triples after the first (international like 1 222 233)
			if (IsDigit(*wordStarts[start]))
			{
				for ( int j = start + 1; j < end; ++j) 
				{
					if (strlen(wordStarts[j]) != 3 && IsDigit(*wordStarts[j])) 
					{
						start = end = UNINIT;
						break;
					}
				}
			}

            if (end != UNINIT) 
			{
				MergeNumbers(start,end);
				i = start + 1;
			}
        }
    }

    if (start != UNINIT) //   merge is pending
    {
        if (end  == UNINIT) end = wordCount+1; // drops off the end
		int count = end-start;
        if (count > 1) 
		{
			//   dont merge a date-- number followed by comma 4 digit number - January 1, 1940
			//   and 3 , 3455 or   3 , 12   makes no sense either. Must be 3 digits past the comma
			if (IsDigit(*wordStarts[start]))
			{
				for (int j = start + 1; j < end; ++j) 
				{
					//  cannot merge numbers like 1 2 3  instead numbers after the 1st digit number must be triples (international)
					if (strlen(wordStarts[j]) != 3 && IsDigit(*wordStarts[j])) return;
				}
			}

			size_t nextLen = strlen(wordStarts[start+1]);
			if (count != 2 || !IsDigit(*wordStarts[start+1]) || nextLen == 3) MergeNumbers(start,end); 
		}
    }
}

static bool Substitute(WORDP found,char* sub, unsigned int i,unsigned int erasing)
{ //   erasing is 1 less than the number of words involved
	// see if we have test condition to process (starts with !) and has [ ] with list of words to NOT match after
	if (sub && *sub == '!')
	{
		if (*++sub != '[') // not a list, a bug
		{
			if (!stricmp(sub,"tense")) // 'd depends on tense
			{
				WORDP X = (i < wordCount) ? FindWord(wordStarts[i+1]) : 0;
				WORDP Y = (i < (wordCount-1)) ? FindWord(wordStarts[i+2]) : 0;
				if (X && X->properties & VERB_INFINITIVE)
				{
					sub = "would";
				}
				else if (X && X->properties & VERB_PAST_PARTICIPLE)
				{
					sub = "had";
				}
				else if (Y && Y->properties & VERB_INFINITIVE)
				{
					sub = "would";
				}
				else // assume pastparticple "had"
				{
					sub = "had";
				}
			}
			else
			{
				ReportBug("bad substitute %s",sub)
				return false;
			}
		}
		else
		{
			char word[MAX_WORD_SIZE];
			bool match = false;
			char* ptr = sub+1;
			while (ALWAYS)
			{
				ptr = ReadSystemToken(ptr,word);
				if (*word == ']') break;
				if ( *word == '>')
				{
					if ( i == wordCount) match = true;
				}
				else if (i < wordCount && !stricmp(wordStarts[i+1],word)) match = true;
			}
			if (match) return false;	// not to do
			sub = ptr;	// here is the thing to sub
			if (!*sub) sub = 0;
		}
	}

	unsigned int erase = 1 + (int)erasing;
	if (!sub || *sub == '%') // just delete the word or note tokenbit and then delete
	{
		if (tokenControl & TOKEN_AS_IS && *found->word != '.' &&  *found->word != '?' && *found->word != '!') // cannot tamper with word count (pennbank pretokenied stuff) except trail punctuation
		{
			return false;
		}

		if (sub && *sub == '%') 
		{
			if (trace & TRACE_SUBSTITUTE) Log(STDUSERLOG,"substitute flag:  %s\r\n",sub+1);
			tokenFlags |= (int)FindValueByName(sub+1);
		}
		else if (trace & TRACE_SUBSTITUTE) 
		{
			Log(STDUSERLOG,"substitute erase:  ");
			for (unsigned int j = i; j < i+erasing+1; ++j) Log(STDUSERLOG,"%s ",wordStarts[j]);
			Log(STDUSERLOG,"\r\n");
		}	
		memmove(wordStarts+i,wordStarts+i+erasing+1,sizeof(char*) * (wordCount-i-erasing));
		wordCount -= erase;
		return true;
	}

	//   substitution match
	if (!strchr(sub,'+') && erasing == 0 && !strcmp(sub,wordStarts[i])) return false; // changing single word case to what it already is?
	
    char wordlist[MAX_WORD_SIZE];
    strcpy(wordlist,sub);
    char* ptr = wordlist;
    while ((ptr= strchr(ptr,'+'))) *ptr = ' '; // change + separators to spaces but leave _ alone

	char* tokens[1000];			// the new tokens we will substitute
	char* backupTokens[1000];	// place to copy the old tokens
	unsigned int count;
	if (*sub == '"') // use the content internally literally - like "a_lot"  meaning want it as a single word
	{
		count = 1;
		size_t len = strlen(wordlist);
		tokens[1] = AllocateString(wordlist+1,len-2); // remove quotes from it now
		if (!tokens[1]) tokens[1] = "a";
	}
    else Tokenize(wordlist,count,tokens); // get the tokenization of the substitution

	if (count == 1 && !erasing) //   simple replacement
	{
		if (trace & TRACE_SUBSTITUTE) Log(STDUSERLOG,"substitute replace: %s with %s\r\n",wordStarts[i],tokens[1]);
		wordStarts[i] = tokens[1];
	}
	else // multi replacement
	{
		if (tokenControl & TOKEN_AS_IS && !(tokenControl & DO_SUBSTITUTES) && (DO_CONTRACTIONS & (uint64)found->internalBits) && count != erase) // cannot tamper with word count (pennbank pretokenied stuff)
		{
			return false;
		}
		if ((wordCount + (count - erase)) >= MAX_SENTENCE_LENGTH) return false;	// cant fit

		if (trace & TRACE_SUBSTITUTE) Log(STDUSERLOG,"substitute replace: \"%s\" length %d\r\n",wordlist,erase);
		memcpy(backupTokens,wordStarts + i + erasing + 1,sizeof(char*) * (wordCount - i - erasing )); // save old tokens
		memcpy(wordStarts+i,tokens+1,sizeof(char*) * count);	// move in new tokens
		memcpy(wordStarts+i+count,backupTokens,sizeof(char*) * (wordCount - i - erasing ));	// restore old tokens
		wordCount += count - erase;
	}
	return true;
}

static WORDP ViableIdiom(char* text,unsigned int i,unsigned int n,unsigned int caseform)
{ // n is words merged into "word"
	WORDP word = FindWord(text,0,caseform);

    if (!word) return 0;

	if (word->internalBits & HAS_SUBSTITUTE)
	{
		if (tokenControl & (DO_SUBSTITUTE_SYSTEM|DO_PRIVATE) & word->internalBits) return word; // allowed transform
		return false; // disallowed substitution
	}

	if (!(tokenControl & DO_SUBSTITUTES)) return 0; // no dictionary word merge
	
	//   exclude titles of works, done as composites later
	if (word->properties & NOUN_TITLE_OF_WORK) return 0;

    //   dont swallow - before a number
    if (i < wordCount && IsDigit(*wordStarts[i+1]))
    {
        char* name = word->word;
        if (*name == '-' && name[1] == 0) return 0;
        if (*name == '<' && name[1] == '-' && name[2] == 0) return 0;
    }

    if (word->properties & (PUNCTUATION|COMMA|PREPOSITION|AUX_VERB_BITS) && n) return word; //   multiword prep is legal as is "used_to" helper
	if (GETMULTIWORDHEADER(word) && !(word->systemFlags & PATTERN_WORD)) return 0; // if it is not a name or interjection or preposition, we dont want to use the wordnet composite word list, UNLESS it is a pattern word (like nautical_mile)
 
	// exclude "going to" if not followed by a potential verb 
	if (!stricmp(word->word,"going_to")  && i < wordCount)
	{
		WORDP D = FindWord(wordStarts[i+2]); // +1 will be "to"
		return (D && !(D->properties & VERB_INFINITIVE)) ? word : 0;	
	}

    if (n && IsUpperCase(*word->word) && word->properties & PART_OF_SPEECH) return word;//  We will merge proper names later.  words declared ONLY as interjections wont convert in other slots
	if (!n) return 0;

	// dont merge words with underscore if each word is also a word (though wordnet does- like executive)director), unless its a known keyword like "nautical_mile"
	char* part = strchr(word->word,'_');
	if (word->properties & (NOUN|ADJECTIVE|ADVERB|VERB) && part && !(word->systemFlags & PATTERN_WORD))
	{
		char* part1 = strchr(part+1,'_');
		WORDP P2 = FindWord(part+1,0,LOWERCASE_LOOKUP);
		WORDP P1 = FindWord(word->word,(part-word->word),LOWERCASE_LOOKUP);
		if (!part1 && P1 && P2 && P1->properties & PART_OF_SPEECH && P2->properties & PART_OF_SPEECH) 
		{
			// if there a noun this is plural of? like "square feet" where "square_foot" is the keyword
			char* noun = GetSingularNoun(word->word,false,true);
			if (noun)
			{
				WORDP D1 = FindWord(noun);
				if (D1->systemFlags & PATTERN_WORD) {;}
				else return 0;
			}
			else return 0;
		}
	}

    if (word->properties & (NOUN|ADJECTIVE|ADVERB|CONJUNCTION_SUBORDINATE)) return word; 
	return 0;
}

static bool ProcessIdiom(unsigned int i,unsigned int max,char* buffer,WORDP D, char* ptr)
{//   buffer is 1st word, ptr is end of it
    WORDP word;
    WORDP found = NULL;
    unsigned int idiomMatch = 0;

	unsigned int n = 0;
    for (unsigned int j = i; j <= wordCount; ++j)
    {
		if (j != i) // add next word onto original starter
		{
			if (!stricmp(loginID,wordStarts[j])) break; // user name should not be part of idiom
			*ptr++ = '_'; // separator between words
			++n; // appended word count
			strcpy(ptr,wordStarts[j]);
			ptr += strlen(ptr);
		}
    
		//   we have to check both cases, because idiomheaders might accidently match a substitute
		WORDP localfound = found; //   we want the longest match, but do not expect multiple matches at a particular distance
		if (i == 1 && j == wordCount)  //   try for matching at end AND start
        {
			word = NULL;
			*ptr++ = '>'; //   end marker
			*ptr-- = 0;
			word = ViableIdiom(buffer,1,n,PRIMARY_CASE_ALLOWED);
			if (word) 
			{
				found = word;  
				idiomMatch = n;     //   n words ADDED to 1st word
			}
			if (found == localfound)
			{
				word = ViableIdiom(buffer,1,n,SECONDARY_CASE_ALLOWED);
				if (word) 
				{
					found = word;  
					idiomMatch = n;     //   n words ADDED to 1st word
				}			
			}
			*ptr = 0; //   remove tail end
		}
		if (found == localfound && i == 1 && (word = ViableIdiom(buffer,1,n,PRIMARY_CASE_ALLOWED))) // match at start
		{
			found = word;   
			idiomMatch = n;   
		}
 		if (found == localfound && i == 1 && (word = ViableIdiom(buffer,1,n,SECONDARY_CASE_ALLOWED))) // match at start
		{
			found = word;   
			idiomMatch = n;   
		}
        if (found == localfound && (word = ViableIdiom(buffer+1,i,n,PRIMARY_CASE_ALLOWED))) // match normal
        {
			found = word; 
			idiomMatch = n; 
		}
        if (found == localfound && (word =  ViableIdiom(buffer+1,i,n,SECONDARY_CASE_ALLOWED))) // used to not allow upper mapping to lower, but want it for start of sentence
        {
			if (!IsUpperCase(buffer[1]) || i == 1) // lower can always try upper, but upper can try lower ONLY at sentence start
			{
				found = word; 
				idiomMatch = n; 
			}
		}
        if (found == localfound && j == wordCount)  //   sentence ender
		{
			*ptr++ = '>'; //   end of sentence marker
			*ptr-- = 0;  
			word = ViableIdiom(buffer+1,0,n,PRIMARY_CASE_ALLOWED);
			if (word)
            {
				found = word; 
				idiomMatch = n; 
			}
			if (found == localfound)
			{
				word = ViableIdiom(buffer+1,0,n,SECONDARY_CASE_ALLOWED);
				if (word)
				{
					found = word; 
					idiomMatch = n; 
				}
			}
			*ptr= 0; //   back to normal
        }
		if (found == localfound && *(ptr-1) == 's' && j != i) // try singularlizing a noun
		{
			size_t len = strlen(buffer+1);
			word = FindWord(buffer+1,len-1,PRIMARY_CASE_ALLOWED|SECONDARY_CASE_ALLOWED); // remove s
			if (len > 3 && !word && *(ptr-2) == 'e') 
				word = FindWord(buffer+1,len-2,PRIMARY_CASE_ALLOWED|SECONDARY_CASE_ALLOWED); // remove es
			if (len > 3 && !word && *(ptr-2) == 'e' && *(ptr-3) == 'i') // change ies to y
			{
				char noun[MAX_WORD_SIZE];
				strcpy(noun,buffer);
				strcpy(noun+len-3,"y");
				word = FindWord(noun,0,PRIMARY_CASE_ALLOWED|SECONDARY_CASE_ALLOWED);
			}
			if (word && ViableIdiom(word->word,i,n,PRIMARY_CASE_ALLOWED|SECONDARY_CASE_ALLOWED)) // was composite
			{
				char* second = strchr(buffer,'_');
				if ( !IsUpperCase(*word->word) || (second && IsUpperCase(second[1]))) // be case sensitive in matching composites
				{
					found = StoreWord(buffer+1,NOUN_PLURAL); // generate the plural
					idiomMatch = n; 
				}
			}
		}

        if (n == max) break; //   peeked ahead to max length so we are done
	} //   end J loop

	if (!found) return false;

	D = GetSubstitute(found);
    if (D == found)  return false;

	bool result = false;
	
	//   dictionary match to multiple word entry
	if (found->internalBits & HAS_SUBSTITUTE) // a special substitution
	{
		result = Substitute(found,D ? D->word : NULL,i,idiomMatch);//   do substitution
		if (result) tokenFlags |= found->internalBits & (DO_SUBSTITUTE_SYSTEM|DO_PRIVATE); // we did this kind of substitution
	}
	else // must be a composite word, not a substitute
	{

		if (trace & TRACE_SUBSTITUTE) 
		{
			Log(STDUSERLOG,"use multiword: %s instead of ",found->word);
			for (unsigned int j = i;  j < i + idiomMatch+1; ++j) Log(STDUSERLOG,"%s ",wordStarts[j]);
			Log(STDUSERLOG,"\r\n");
		}
		wordStarts[i] = AllocateString(found->word);
		if (!wordStarts[i]) wordStarts[i] = "a";
		memmove(wordStarts+i+1,wordStarts+i+idiomMatch+1,sizeof(char*) * (wordCount - i - idiomMatch));
		wordCount -= idiomMatch;
		result =  true;
	}

	return result;
}

void ProcessSubstitutes() // revise contiguous words based on LIVEDATA files
{
    char buffer[MAX_WORD_SIZE];
    *buffer = '<';	// sentence start marker

    unsigned int cycles = 0;
    for (unsigned int i = 1; i <= wordCount; ++i)
    {
		if (!stricmp(loginID,wordStarts[i])) continue; // dont match user's name

		//   put word into buffer to start with
        size_t len = strlen(wordStarts[i]);
		char* ptr = buffer+1;
        strcpy(ptr,wordStarts[i]);
        ptr += len;

        //   can this start a substition?  It must have an idiom count != ZERO_IDIOM_COUNT
 
        unsigned int count = 0;
		WORDP D = FindWord(buffer+1,0,PRIMARY_CASE_ALLOWED); // main word a header?
  		if (D) count = GETMULTIWORDHEADER(D);
        
		//   does secondary form longer phrases?
        WORDP E  = FindWord(buffer+1,0,SECONDARY_CASE_ALLOWED);
		if (E && GETMULTIWORDHEADER(E) > count) count = GETMULTIWORDHEADER(E);

        //   now see if start-bounded word does better
        if (i == 1) 
        {
			D = FindWord(buffer,0,PRIMARY_CASE_ALLOWED); // with < header
            if (D && GETMULTIWORDHEADER(D) > count) count = GETMULTIWORDHEADER(D);
			D = FindWord(buffer,0,SECONDARY_CASE_ALLOWED);
			if (D && GETMULTIWORDHEADER(D) > count) count = GETMULTIWORDHEADER(D);
 		}

		//   now see if end-bounded word does better
		if (i == wordCount)
        {
            *ptr++ = '>'; //   append boundary
            *ptr-- = 0;
            D = FindWord(buffer+1,0,PRIMARY_CASE_ALLOWED);
            if (D && GETMULTIWORDHEADER(D) > count) count = GETMULTIWORDHEADER(D);
			D = FindWord(buffer+1,0,SECONDARY_CASE_ALLOWED);
			if (D &&  GETMULTIWORDHEADER(D) > count) count = GETMULTIWORDHEADER(D);

			if (i == 1) //   can use start and end simultaneously
			{
				D = FindWord(buffer,0,PRIMARY_CASE_ALLOWED); 
				if (D && GETMULTIWORDHEADER(D) > count) count = GETMULTIWORDHEADER(D);
				D = FindWord(buffer,0,SECONDARY_CASE_ALLOWED);
				if (D && GETMULTIWORDHEADER(D) > count) count = GETMULTIWORDHEADER(D);
			}
			*ptr = 0;	// remove tail
		}
        
		//   use max count
        if (count && ProcessIdiom(i,count-1,buffer,D,ptr)) 
		{
			if (cycles > 20) // something is probably wrong
			{
				ReportBug("Substitute cycle overflow %s\r\n",buffer)
				break;
			}

			i = 0;  //   restart since we modified sentence
			++cycles;
		}
	}
}
#include "common.h"

#define MAX_NO_ERASE 300
#define MAX_REPEATABLE 300
#define TOPIC_LIMIT 10000								// max toplevel rules in a RANDOM topic

// current operating data

unsigned int numberOfTopics;							// how many topics exist 1...n
unsigned int lastTopic;									// boundary before plan topics

unsigned int currentTopicID = 0;						// current topic id
char* currentRule = 0;									// current rule being procesed
int currentRuleID = -1;									// current rule id
int currentReuseID = -1;								// local invoking reuse
int currentRuleTopic = -1;

bool ruleErased = false;

char timeStamp0[20];	// when build0 was compiled
char timeStamp1[20];	// when build1 was compiled
char buildStamp0[150];	// compile command
char buildStamp1[150];	// compile command

// rejoinder info
int outputRejoinderRuleID  = NO_REJOINDER;
int outputRejoinderTopic = NO_REJOINDER;
int inputRejoinderTopic = NO_REJOINDER;					// what topic were we in, that we should check for update
int inputRejoinderRuleID = NO_REJOINDER;

//  static state per topic
static char** topicScriptMap = NULL;					// topic script data
static char** topicNameMap = NULL;						// names of topics
static char** topicRestrictionMap = NULL;				// bot restrictions on topics
static unsigned int* topicChecksumMap = NULL;			// checksum of topic
static unsigned short* topicBytesRulesMap = NULL;		// bytes needed for bits to mark used
static char** topicFile = NULL;							// source file this topic came from
unsigned int** ruleOffsetMap = NULL;								// offsets of top level rules per topic
unsigned int* topicMaxRule = NULL;						// how many gambits, how many top level rules each topic has
unsigned int** gambitTagMap = NULL;					// list of gambit offsets in topic
static unsigned int** responderTagMap = NULL;			// list of responder offsets in topic

// changeable state per topic
static unsigned char** topicUsedMap = NULL;				// erased bits on top level rules
unsigned int* topicFlagsMap = NULL;						// control flags per topic
unsigned int* topicLastGambittedMap = NULL;				// when last gambit from topic happened
unsigned int* topicLastResponderedMap = NULL;			// when last responder from topic happened
unsigned int* topicLastRejoinderedMap = NULL;			// when last rejoinder from topic happened
unsigned int* topicDebugMap = NULL;				// trace control over topic
static unsigned char** topicDebugRuleMap = NULL;		// trace control over top level rules of a topic

// block erasing with this
static char* keepSet[MAX_NO_ERASE];					// rules not authorized to erase themselves
static unsigned int keepIndex;

// allow repeats with this
static char* repeatableSet[MAX_REPEATABLE];				// rules allowed to repeat output
static unsigned int repeatableIndex;

//   current flow of topic control stack
unsigned int topicIndex = 0;
unsigned int topicStack[MAX_TOPIC_STACK+1];

//   pending topics
unsigned int pendingTopicIndex = 0;
unsigned int pendingTopicList[MAX_TOPIC_STACK+1];

// debug information
bool debugTopic = false;		// tracing a rule or a topic
bool ruleStats = false;				// show how many rules were executed
unsigned int ruleCount = 0;			// how many rules were executed
unsigned int xrefCount = 0;			// how many xrefs were created
unsigned int duplicateCount = 0;	// detecting multiple topics with same name

static unsigned char code[] = {//   value to letter  0-78 (do not use - since topic system cares about it) see uncode
    '0','1','2','3','4','5','6','7','8','9',
    'a','b','c','d','e','f','g','h','i','j',
    'k','l','m','n','o','p','q','r','s','t',
    'u','v','w','x','y','z','A','B','C','D',
    'E','F','G','H','I','J','K','L','M','N',
    'O','P','Q','R','S','T','U','V','W','X',
	'Y','Z','~','!','@','#','$','%','^','&',
	'*','?','/','+','=', '<','>',',','.',
};

static unsigned char uncode[] = {//   letter to value - see code[]
    0,0,0,0,0,0,0,0,0,0,				// 0
    0,0,0,0,0,0,0,0,0,0,				// 10
    0,0,0,0,0,0,0,0,0,0,				// 20
    0,0,0,63,0,65,66,67,69,0,			// 30  33=! (63)  35=# (65)  36=$ (66) 37=% (67) 38=& (69)
    0,0,70,73,77,0,78,72,0,1,			// 40  42=* (70) 43=+ (73) 44=, (77)  46=. (78) 47=/ (72) 0-9 = 0-9
    2,3,4,5,6,7,8,9,0,0,				// 50
    75,74,76,71,64,36,37,38,39,40,		// 60  60=< (75)  61== (74)  62=> (76) 63=? (71) 64=@ 65=A-Z  (36-61)
    41,42,43,44,45,46,47,48,49,50,		// 70
    51,52,53,54,55,56,57,58,59,60,		// 80
    61,0,0,0,68,0,0,10,11,12,			// 90  90=Z  94=^ (68) 97=a-z (10-35)
    13,14,15,16,17,18,19,20,21,22,		// 100
    23,24,25,26,27,28,29,30,31,32,		// 110
    33,34,35,0,0,0,62,0,0,0,			// 120  122=z 126=~ (62)
};

///////////////////////////////////////////
/// ENCODE/DECODE
///////////////////////////////////////////

void DummyEncode(char* &data) // script compiler users to reserve space for encode
{
	*data++ = 'a'; 
	*data++ = 'a';
	*data++ = 'a';
}

void Encode(unsigned int val,char* &ptr,bool single)
{ // digits are base 75
	if (single)
	{
		*ptr = code[val % USED_CODES];	
		return;
	}

	if (val > (USED_CODES*USED_CODES*USED_CODES)) ReportBug("Encode val too big")
	int digit1 = val / (USED_CODES*USED_CODES);
    ptr[0] = code[digit1];
	val -= (digit1 * USED_CODES * USED_CODES);
    ptr[1] = code[val / USED_CODES];
    ptr[2] = code[val % USED_CODES];
}

unsigned int Decode(char* data,bool single)
{
	if (single) return uncode[*data];

    unsigned int val = uncode[*data++] * (USED_CODES*USED_CODES);
    val += uncode[*data++] * USED_CODES;
    val += uncode[*data++];

	return val;
}

char* FullEncode(uint64 val,char* ptr) // writes least significant digits first
{ //   digits are base 75
	int digit1 = val % USED_CODES; 
	*ptr++ = code[digit1];
	val = val - digit1; 
	val /= USED_CODES;
	while (val)
	{
		digit1 = val % USED_CODES; 
		*ptr++ = code[digit1];
		val = val - digit1; 
		val /= USED_CODES;
	}
	*ptr++ = ' ';
	*ptr = 0;
	return ptr;
}

uint64 FullDecode(char* data) // read end to front
{
	char* ptr = data + strlen(data);
    uint64 val = uncode[*--ptr];
	while (ptr != data) val = (val * USED_CODES) + uncode[*--ptr];
	return val;
}


///////////////////////////////////////////////////////
///// TOPIC DATA ACCESSORS
///////////////////////////////////////////////////////

char* GetTopicFile(unsigned int topic)
{
	return topicFile[topic];
}

char* RuleBefore(unsigned int topic,char* rule)
{
	char* start = GetTopicData(topic);
	if (rule == start) return NULL;
	rule -= 7; // jump before end marker of prior rule
	while (--rule > start && *rule != ENDUNIT); // back up past start of prior rule
	return (rule == start) ? rule : (rule + 5);
}

static unsigned int ByteCount (unsigned char n)  
{  
	unsigned char count = 0;  
    while (n)  
	{  
       count++;  
       n &= n - 1;  
    }  
    return count;  
 } 

unsigned int TopicUsedCount(unsigned int topic)
{
 	int size = topicBytesRulesMap[topic];
   	unsigned char* bits = topicUsedMap[topic];
	int test = 0;
	unsigned int count = 0;
	while (++test < size) count += ByteCount(*bits++);
	return count;
}

void DisplayTopicFlags(unsigned int topic)
{
	unsigned int flags = GetTopicFlags(topic);
	if (flags) Log(STDUSERLOG,"Flags: ");
	if (flags & TOPIC_SYSTEM) Log(STDUSERLOG,"SYSTEM ");
	if (flags & TOPIC_KEEP) Log(STDUSERLOG,"KEEP ");
	if (flags & TOPIC_REPEAT) Log(STDUSERLOG,"REPEAT ");
	if (flags & TOPIC_RANDOM) Log(STDUSERLOG,"RANDOM ");
	if (flags & TOPIC_NOSTAY) Log(STDUSERLOG,"NOSTAY ");
	if (flags & TOPIC_PRIORITY) Log(STDUSERLOG,"PRIORITY ");
	if (flags & TOPIC_LOWPRIORITY) Log(STDUSERLOG,"LOWPRIORITY ");
	if (flags & TOPIC_NOBLOCKING) Log(STDUSERLOG,"NOBLOCKING ");
	if (flags & TOPIC_NOSAMPLES) Log(STDUSERLOG,"NOSAMPLES ");
	if (flags & TOPIC_NOPATTERNS) Log(STDUSERLOG,"NOPATTERNS ");
	if (flags & TOPIC_NOGAMBITS) Log(STDUSERLOG,"NOGAMBITS ");
	if (flags & TOPIC_NOKEYS) Log(STDUSERLOG,"NOKEYS ");
	if (flags & TOPIC_BLOCKED) Log(STDUSERLOG,"BLOCKED ");
	if (flags) Log(STDUSERLOG,"\r\n");
	Log(STDUSERLOG,"    Bot: %s\r\n",topicRestrictionMap[topic] ? topicRestrictionMap[topic] : (char*)"all");
	if (topicLastGambittedMap[topic] == 0 && topicLastResponderedMap[topic] == 0 && topicLastRejoinderedMap[topic] == 0) Log(STDUSERLOG,"    Seen: never visited");
	else Log(STDUSERLOG,"    Seen: last gambit %d   last rejoinder %d  lastresponder\r\n", topicLastGambittedMap[topic],topicLastResponderedMap[topic],topicLastRejoinderedMap[topic]);
}

bool BlockedBotAccess(unsigned int topic)
{
	if (!topic || topic > numberOfTopics || topicFlagsMap[topic] & TOPIC_BLOCKED) return true;
	return (topicRestrictionMap[topic] && !strstr(topicRestrictionMap[topic],computerIDwSpace));
}

char* GetRuleTag(unsigned int& topic,int& id,char* tag)
{
	// tag is topic.number.number or memerly topic.number
	char* dot = strchr(tag,'.');
	topic = id = 0;
	if (!dot) return NULL;
	*dot = 0;
	topic = FindTopicIDByName(tag);
	*dot = '.';
	if (!topic || !IsDigit(dot[1])) return NULL; 
	id = atoi(dot+1);
	dot = strchr(dot+1,'.');
	if (dot && IsDigit(dot[1]))  id |= MAKE_REJOINDERID(atoi(dot+1));
	return GetRule(topic,id);
}

char* GetLabelledRule(unsigned int& topic, char* label,char* notdisabled,bool &fulllabel, bool& crosstopic,int& id)
{
	// ~ means current rule
	// name means current topic and named rule
	// ~xxx.name means specified topic and named rule
	fulllabel = false;
	crosstopic = false;
	topic = currentTopicID;
	if (*label == '~' && !label[1])  
	{
		id = currentRuleID;
		return currentRule;
	}
	else if (!*label) return NULL;

	char* dot = strchr(label,'.');
	if (dot) // topicname.label format 
	{
		fulllabel = true;
		*dot = 0;
		topic = FindTopicIDByName(label);
		if (!topic) topic = currentTopicID;
		else crosstopic = true;
		label = dot+1; // the label 
	}

	return FindNextLabel(topic,label, GetTopicData(topic),id,!*notdisabled);
}

char* GetRule(unsigned int topic, int id)
{
    if (!topic || topic > numberOfTopics || id < 0) return NULL;

	int ruleID = TOPLEVELID(id);
	int maxrules = RULE_MAX(topicMaxRule[topic]); 
	if (ruleID >= maxrules) return NULL;

	char* rule = GetTopicData(topic);
	if (!rule) return NULL;

	int rejoinderID = REJOINDERID(id);
	rule += ruleOffsetMap[topic][ruleID];	// address of top level rule 
	while (rejoinderID--) 
	{
		rule = FindNextRule(NEXTRULE,rule,ruleID);
		if (!Rejoinder(rule)) return NULL; // ran out of rejoinders
	}
	return rule;
}

void AddTopicFlag(unsigned int topic,unsigned int flag)
{
    if (topic > numberOfTopics || !topic) 
		ReportBug("AddTopicFlag flags topic id %d out of range\r\n",topic)
    else topicFlagsMap[topic] |= flag;
}

void RemoveTopicFlag(unsigned int topic,unsigned int flag)
{
    if (topic > numberOfTopics || !topic) ReportBug("RemoveTopicFlag flags topic %d out of range\r\n",topic)
    else 
	{
		topicFlagsMap[topic] &= -1 ^ flag;
		AddTopicFlag(topic,TOPIC_USED); 
	}
}

char* GetTopicName(unsigned int topic,bool actual)
{
	if (!topic || !topicNameMap || !topicNameMap[topic]) return "~unknown-topic";
	if (actual) return topicNameMap[topic]; // full topic name (if duplicate use number)

	static char name[MAX_WORD_SIZE];
	strcpy(name,topicNameMap[topic]);
	char* dot = strchr(name,'.'); // if this is duplicate topic name, use generic base name
	if (dot) *dot = 0;
	return name;
}

static char* RuleTypeName(char type)
{
	char* name;
	if (type == GAMBIT) name = "Gambits";
	else if (type == QUESTION) name = "Questions";
	else if (type == STATEMENT) name = "Statements";
	else if (type == STATEMENT_QUESTION) name = "Responders";
	else name = "unknown";
	return name;
}

void SetTopicData(unsigned int topic,char* data)
{
    if (topic > numberOfTopics) ReportBug("SetTopicData id %d out of range\r\n",topic)
	else topicScriptMap[topic] = data; 
}

char* GetTopicData(unsigned int topic)
{
    if (!topicScriptMap || !topic) return NULL;
    if (topic > numberOfTopics)
    {
        ReportBug("GetTopicData flags id %d out of range",topic)
        return 0;
    }
    char* data = topicScriptMap[topic]; //   predefined topic or user private topic
    return (!data || !*data) ? NULL : (data+JUMP_OFFSET); //   point past accellerator to the t:
}

unsigned int FindTopicIDByName(char* name)
{
	if (!name || !*name)  return 0;
    
	char word[MAX_WORD_SIZE];
	*word = '~';
	if (*name == '~' && !name[1]) 
	{
		MakeLowerCopy(word,GetTopicName(currentTopicID,false)); // ~ means current topic always
	}
	else MakeLowerCopy((*name == '~') ? word : (word+1),name);

	WORDP D = FindWord(word);
	duplicateCount = 0;
	while (D && D->systemFlags & TOPIC) 
	{
		unsigned int topic = D->x.topicIndex;
		if (!topic) 
		{
			if (!compiling) ReportBug("Missing topic index for %s\r\n",D->word)
			break;
		}
		if (!topicRestrictionMap[topic] || strstr(topicRestrictionMap[topic],computerIDwSpace)) return topic; // legal to this bot

		// replicant topics for different bots
		++duplicateCount;
		sprintf(tmpWord,"%s.%d",word,duplicateCount);
		D = FindWord(tmpWord);
	}
	return 0;
}

void UndoErase(char* ptr,unsigned int topic,unsigned int id)
{
    if (trace & TRACE_BASIC)  Log(STDUSERLOG,"Undoing erase %s\r\n",ShowRule(ptr));
	ClearRuleDisableMark(topic,id);
}

char* FindNextRule(signed char level, char* ptr, int& id)
{ // level is NEXTRULE or NEXTTOPLEVEL
	if (!ptr || !*ptr) return NULL;
	char* start = ptr;
    if (ptr[1] != ':') 
	{
		if (buildID)  BADSCRIPT("TOPIC-10 In topic %s missing colon for responder %s - look at prior responder for bug",GetTopicName(currentTopicID) ,ShowRule(ptr))
		ReportBug("not ptr start of responder %d %s %s - killing data",currentTopicID, GetTopicName(currentTopicID) ,tmpWord)
		topicScriptMap[currentTopicID] = 0; // kill off data
		return NULL;
	}
	ptr +=  Decode(ptr-JUMP_OFFSET);	//   now pointing to next responder
	if (Rejoinder(ptr)) id += ONE_REJOINDER;
	else id = TOPLEVELID(id) + 1;
	if (level == NEXTRULE || !*ptr) return ptr; //   find ANY next responder- we skip over + x x space to point ptr t: or whatever - or we are out of them now

    while (*ptr) // wants next top level
    {
		if (ptr[1] != ':')
		{
			char word[MAX_WORD_SIZE];
			strncpy(word,ptr,50);
			word[50] = 0;
			if (buildID) BADSCRIPT("TOPIC-11 Bad layout starting %s %c %s",word,level,start)
			ReportBug("Bad layout bug1 %c %s",level,start)
			return NULL;
		}
        if (TopLevelRule(ptr)) break; // found next top level
		ptr += Decode(ptr-JUMP_OFFSET);	// now pointing to next responder
 		if (Rejoinder(ptr)) id += ONE_REJOINDER;
		else id = TOPLEVELID(id) + 1;
   }
    return ptr;
}

bool TopLevelQuestion(char* word)
{
	if (!word || !*word) return false; 
	if (word[1] != ':') return false;
	if (*word != QUESTION && *word != STATEMENT_QUESTION) return false;
	if (word[2] && word[2] != ' ') return false;
	return true;
}

bool TopLevelStatement(char* word)
{
	if (!word || !*word) return false; 
	if (word[1] != ':') return false;
	if (*word != STATEMENT && *word != STATEMENT_QUESTION) return false;
	if (word[2] && word[2] != ' ') return false;
	return true;
}

bool TopLevelGambit(char* word)
{
	if (!word || !*word) return false; 
	if (word[1] != ':') return false;
	if (*word != RANDOM_GAMBIT && *word != GAMBIT) return false;
	if (word[2] && word[2] != ' ') return false;
	return true;
}

bool TopLevelRule(char* word)
{
	if (!word || !*word) return true; //   END is treated as top level
	if (TopLevelGambit(word)) return true;
	if (TopLevelStatement(word)) return true;
	return TopLevelQuestion(word);
}

bool Rejoinder(char* word)
{
	if (!word || !*word) return false; 
	if ((word[2] != 0 && word[2] != ' ') || word[1] != ':' || !IsAlpha(*word)) return false;
	return (*word >= 'a' && *word <= 'q') ? true : false;
}

int HasGambits(unsigned int topic) // check each gambit to find a usable one (may or may not match by pattern)
{
	if (BlockedBotAccess(topic) || GetTopicFlags(topic) & TOPIC_SYSTEM) return -1; 
	
	unsigned int* map = gambitTagMap[topic];
	if (!map) return false; // not even a gambit map
	unsigned int gambitID = *map;
	while (gambitID != NOMORERULES)
	{
		if (UsableRule(topic,gambitID)) return 1;
		gambitID = *++map;
	}
	return 0;
}

char* ShowRule(char* rule)
{
	if (rule == NULL) return "?";

	static char result[300];
	result[0] = rule[0];
	result[1] = rule[1];
	result[2] = ' ';
	result[3] = 0;

	// get printable fragment
	char word[MAX_WORD_SIZE];
	char label[MAX_WORD_SIZE];
	char* ruleAfterLabel = GetLabel(rule,label);
	strncpy(word,ruleAfterLabel,90);
	word[90] = 0;
	char* at = strchr(word,ENDUNIT);
	if (at) *at = 0; // truncate at end

	char* ptr = word-1;
	while (*++ptr)
	{
		if ((*ptr == ' ' || *ptr == '!') && ptr[1] == '=' && ptr[2] != ' ') memmove(ptr+1,ptr+3,strlen(ptr+2)); // comparison operator - remove header
		else if (*ptr == ' ' && ptr[1] == '*' && IsAlpha(ptr[2])) memmove(ptr+1,ptr+2,strlen(ptr+1)); // * partial word match- remove header
	}

	strcat(result,label);
	strcat(result," ");
	strcat(result,word);
	return result;
}

char* GetPattern(char* ptr,char* label,char* pattern)
{
	if (label) *label = 0;
	if (!ptr || !*ptr) return NULL;
	if (ptr[1] == ':') ptr = GetLabel(ptr,label);
	else ptr += 3; // why ever true?
	char* patternStart = ptr;
	// acquire the pattern data of this rule
	if (*patternStart == '(') ptr = BalanceParen(patternStart+1); // go past pattern to new token
	int patternlen = ptr - patternStart;
	if (pattern)
	{
		strncpy(pattern,patternStart,patternlen);
		pattern[patternlen] = 0;
	}
	return ptr; // start of output ptr
}

char* GetOutputCopy(char* ptr)
{
	static char buffer[MAX_WORD_SIZE];
	if (!ptr || !*ptr) return NULL;
	if (ptr[1] == ':') ptr = GetLabel(ptr,NULL);
	else ptr += 3; // why ever true?
	char* patternStart = ptr;
	// acquire the pattern data of this rule
	if (*patternStart == '(') ptr = BalanceParen(patternStart+1); // go past pattern to new token
	char* end = strchr(ptr,ENDUNIT);
	if (end)
	{
		size_t len = end-ptr;
		strncpy(buffer,ptr,len);
		buffer[len] = 0;
	}
	else strcpy(buffer,ptr);
	return buffer; // start of output ptr
}

char* GetLabel(char* rule,char* label)
{
	if (label) *label = 0;
	if (!rule || !*rule) return NULL;
    rule += 3; // skip kind and space
 	char c = *rule;
	if (c == '('){;}	// has pattern and no label
	else if (c == ' ')  ++rule; // has no pattern and no label
	else // there is a label
	{
		unsigned int len = c - '0'; // length to jump over label
		if (label)
		{
			strncpy(label,rule+1,len-2);
			label[len-2] = 0;
		}
		rule += len;			// start of pattern (
	}
	return rule;
}

char* FindNextLabel(unsigned int topic,char* label, char* ptr, int &id,bool alwaysAllowed)
{ // id starts at 0 or a given id to resume hunting from
	// Alwaysallowed (0=false, 1= true, 2 = rejoinder) would be true coming from enable or disable, for example, because we want to find the
	// label in order to tamper with its availablbilty. 
	bool available = true;
	while (ptr && *ptr) 
	{
		bool topLevel = !Rejoinder(ptr);
		if (topLevel) available = (alwaysAllowed) ? true : UsableRule(topic,id); 
		// rule is available if a top level available rule OR if it comes under the current rule
		if ((available || TOPLEVELID(id) == (unsigned int) currentRuleID) )
		{
			char ruleLabel[MAX_WORD_SIZE];
			GetLabel(ptr,ruleLabel);
			if  (!stricmp(label,ruleLabel)) return ptr;// is it the desired label?
		}
		ptr = FindNextRule(NEXTRULE,ptr,id); // go to end of this one and try again at next responder (top level or not)
	}
	id = -1;
	return NULL;
}

int GetTopicFlags(unsigned int topic)
{
	return (!topic || topic > numberOfTopics) ? 0 : topicFlagsMap[topic];
}

void SetTopicDebugMark(unsigned int topic,unsigned char value)
{
	if (!topic || topic > numberOfTopics) return;
	topicDebugMap[topic] = value;
	Log(STDUSERLOG," topictrace %s = %d\r\n",GetTopicName(topic),topicDebugMap[topic]);
	debugTopic = true;
}

void SetDebugRuleMark(unsigned int topic,unsigned int id)
{
	if (!topic || topic > numberOfTopics) return;
	id = TOPLEVELID(id);
	unsigned int byteOffset = id / 8; 
	if (byteOffset >= topicBytesRulesMap[topic]) return; // bad index

	unsigned int bitOffset = id % 8;
	unsigned char* testByte = topicDebugRuleMap[topic] + byteOffset;
	*testByte ^= (unsigned char) (0x80 >> bitOffset);
	debugTopic = true;
}

static bool GetDebugRuleMark(unsigned int topic,unsigned int id) //   has this top level responder been marked for debug
{
	if (!topic || topic > numberOfTopics) return false;
	id = TOPLEVELID(id);
	unsigned int byteOffset = id / 8; 
	if (byteOffset >= topicBytesRulesMap[topic]) return false; // bad index

	unsigned int bitOffset = id % 8;
	unsigned char* testByte = topicDebugRuleMap[topic] + byteOffset;
	unsigned char value = (*testByte & (unsigned char) (0x80 >> bitOffset));
	return value != 0;
}

bool SetRuleDisableMark(unsigned int topic, unsigned int id)
{
	if (!topic || topic > numberOfTopics) return false;
	id = TOPLEVELID(id);
	unsigned int byteOffset = id / 8; 
	if (byteOffset >= topicBytesRulesMap[topic]) return false; // bad index

	unsigned int bitOffset = id % 8;
	unsigned char* testByte = topicUsedMap[topic] + byteOffset;
	unsigned char value = (*testByte & (unsigned char) (0x80 >> bitOffset));
	if (!value) 
	{
		*testByte |= (unsigned char) (0x80 >> bitOffset);
		AddTopicFlag(topic,TOPIC_USED); 
		return true;
	}
	else return false;	// was already set
}

void ClearRuleDisableMark(unsigned int topic,unsigned int id)
{
	if (!topic || topic > numberOfTopics) return;
	id = TOPLEVELID(id);
	unsigned int byteOffset = id / 8; 
	if (byteOffset >= topicBytesRulesMap[topic]) return; // bad index

	unsigned int bitOffset = id % 8;
	unsigned char* testByte = topicUsedMap[topic] + byteOffset;
	*testByte &= -1 ^ (unsigned char) (0x80 >> bitOffset);
	AddTopicFlag(topic,TOPIC_USED); 
}

bool UsableRule(unsigned int topic,unsigned int id) // is this rule used up
{
	if (!topic || topic > numberOfTopics) return false;
	if (id == (unsigned int) currentRuleID && topic == (unsigned int) currentRuleTopic) return false;	// cannot use the current rule from the current rule
	id = TOPLEVELID(id);
	unsigned int byteOffset = id / 8; 
	if (byteOffset >= topicBytesRulesMap[topic]) return false; // bad index

	unsigned int bitOffset = id % 8;
	unsigned char* testByte = topicUsedMap[topic] + byteOffset;
	unsigned char value = (*testByte & (unsigned char) (0x80 >> bitOffset));
	return !value;
}


///////////////////////////////////////////////////////
///// TOPIC EXECUTION
///////////////////////////////////////////////////////

void ResetTopicReply()
{
	ruleErased = false;		// someone can become liable for erase
    keepIndex = 0;			// for list of rules we won't erase
	repeatableIndex = 0;
}

void AddKeep(char* rule)
{
    keepSet[keepIndex++] = rule;
    if (keepIndex == MAX_NO_ERASE) --keepIndex;
}

bool Eraseable(char* rule)
{
	for (unsigned int i = 0; i < keepIndex; ++i)
    {
        if (keepSet[i] == rule) return false; 
	}
	return true;
}

void AddRepeatable(char* rule)
{
    repeatableSet[repeatableIndex++] = rule;
    if (repeatableIndex == MAX_REPEATABLE) --repeatableIndex;
}

bool Repeatable(char* rule)
{
	if (!rule) return true;	//  allowed from :say
	for (unsigned int i = 0; i < repeatableIndex; ++i)
    {
        if (repeatableSet[i] == rule || !repeatableSet[i]) return true; // a 0 value means allow anything to repeat
	}
	return false;
}

void SetErase(bool force)
{ 
	if (planning || !currentRule || !TopLevelRule(currentRule)) return; // rejoinders cant erase anything nor can plans
	if (ruleErased && !force) return;	// done 
	if (!TopLevelGambit(currentRule) && (GetTopicFlags(currentTopicID) & TOPIC_KEEP)) return; // default no erase does not affect gambits
	if (GetTopicFlags(currentTopicID) & TOPIC_SYSTEM || !Eraseable(currentRule)) return; // rule explicitly said keep or was in system topic
	
 	if (SetRuleDisableMark(currentTopicID,currentRuleID))
	{
		ruleErased = true;
		if (trace & TRACE_OUTPUT) Log(STDUSERTABLOG,"**erasing %s  %s\r\n",GetTopicName(currentTopicID),ShowRule(currentRule));
	}
}

void SetRejoinder(char* rule)
{
	if (outputRejoinderRuleID == BLOCKED_REJOINDER) // ^refine set this because rejoinders on that rule are not for rejoinding, they are for refining.
	{
		outputRejoinderRuleID = NO_REJOINDER;
		return;
	}
	if (currentRuleID < 0 || outputRejoinderRuleID != NO_REJOINDER) return; //   not markable OR already set 
	if (GetTopicFlags(currentTopicID) & TOPIC_BLOCKED) return; //   not allowed to be here (must have been set along the way)
 
	char level = TopLevelRule(rule)   ? 'a' :  (*rule+1); // default rejoinder level
	int rejoinderID = currentRuleID;
	char* ptr = FindNextRule(NEXTRULE,rule,rejoinderID);
    if (respondLevel) level = respondLevel; //   random selector wants a specific level to match. so hunt for that level to align at start.
    
    //   now align ptr to desired level. If not found, force to next top level unit
    bool startcont = true;
    while (ptr && *ptr && !TopLevelRule(ptr)) //  walk units til find level matching
    {
        if (startcont && *ptr == level) break;     //   found desired starter
        if (!respondLevel && *ptr < level) return; // only doing sequentials and we are exhausted

        unsigned int priorlevel = *ptr;  //   we are here now
        ptr = FindNextRule(NEXTRULE,ptr,rejoinderID); //   spot next unit is -- if ptr is start of a unit, considers there. if within, considers next and on
		startcont = (ptr && *ptr) ? (*ptr != (int)(priorlevel+1)) : false; //   we are in a subtree if false, rising, since  subtrees in turn are sequential, 
    }
 
    if (ptr && *ptr == level) //   will be on the level we want
    {
        outputRejoinderRuleID = rejoinderID; 
 	    outputRejoinderTopic = currentTopicID;
        if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"  **set rejoinder at %s\r\n",ShowRule(ptr));
    }
}

unsigned int ProcessRuleOutput(char* rule, unsigned int id,char* buffer)
{
	unsigned int oldtrace = trace;
	if (debugTopic) trace = (topicDebugMap[currentTopicID] || GetDebugRuleMark(currentTopicID,id))  ? (unsigned int) -1 : 0;

	char* ptr = GetPattern(rule,NULL,NULL);  // go to output

   //   now process response
    unsigned int result;

	// was this a pending topic before?
	bool old = IsCurrentTopic(currentTopicID);
	AddPendingTopic(currentTopicID); // make it pending for now...more code will be thinking they are in this topic

	unsigned int startingIndex = responseIndex;
	bool oldErase = ruleErased; // allow underling gambits to erase themselves. If they do, we dont have to.
	ruleErased = false;
	Output(ptr,buffer,result);
	if (!ruleErased) ruleErased = oldErase;

	bool otherResponded = startingIndex != responseIndex;
	bool madeResponse = false;
	if (result & FAILCODES) *buffer = 0; // erase any partial output on failures. stuff sent out already remains sent.
	else if (!planning)
	{
		result &= -1 ^ ENDRULE_BIT;
		//   we will fail to add a response if:  we repeat  OR  we are doing a gambit or topic passthru
		 madeResponse = (*buffer != 0);
		if (*currentOutputBase) // dont look at "buffer" because it might have been reset
		{
			//   the topic may have changed but OUR topic matched and generated the buffer, so we get credit. change topics to us for a moment.
			//   How might this happen? We generate output and then call poptopic to remove us as current topic.
			//   since we added to the buffer and are a completed pattern, we push the entire message built so far.
			//   OTHERWISE we'd leave the earlier buffer content (if any) for higher level to push
			if (!AddResponse(currentOutputBase))
			{
				result |= FAILRULE_BIT;
 				madeResponse = false;
			}
			else 
			{
				if (TopLevelGambit(rule)) AddTopicFlag(currentTopicID,TOPIC_GAMBITTED); // generated text answer from gambit
				else if (TopLevelRule(rule)) AddTopicFlag(currentTopicID,TOPIC_RESPONDED); // generated text answer from responder
				else AddTopicFlag(currentTopicID,TOPIC_REJOINDERED); 
			}
	   }
	}

	// gambits that dont fail try to erase themselves - gambits and responders that generated output directly will have already erased themselves
	if (planning) {;}
	else if (TopLevelGambit(currentRule))
	{
		if (!(result & FAILCODES)) SetErase();
	}
	else if (TopLevelStatement(currentRule) || TopLevelQuestion(currentRule)) // responders that caused output will try to erase, will fail if lower did already
	{
		if (otherResponded) SetErase();	
	}
	
	// set rejoinder if we didnt fail 
	if (!(result & FAILCODES) && (madeResponse || otherResponded) && !planning) SetRejoinder(rule); // a response got made
	if (outputRejoinderRuleID == BLOCKED_REJOINDER) outputRejoinderRuleID = NO_REJOINDER; // we called ^refine. He blocked us from rejoindering. We can clear it now.

	if (planning) {;}
	else if (startingIndex != responseIndex && !(result & (FAILTOPIC_BIT | ENDTOPIC_BIT)));
	else if (!old) RemovePendingTopic(currentTopicID); // if it wasnt pending before, it isn't now
	respondLevel = 0; 
	
	trace = oldtrace;
    return result;
}

unsigned int DoOutput(char* buffer,char* rule, unsigned int id)
{
	unsigned int result;
	// do output of rule
	PushOutputBuffers();
	currentRuleOutputBase = buffer;
	ChangeDepth(1,"testRule");
	if (debugger) Debugger(ENTER_RULE_OUTPUT);
	result = ProcessRuleOutput(rule,currentRuleID,buffer);
	if (debugger) Debugger(EXIT_RULE);
	ChangeDepth(-1,"testRule");
	PopOutputBuffers();
	return result;
}

unsigned int TestRule(int ruleID,char* rule,char* buffer)
{
	SAVEOLDCONTEXT()
	unsigned int oldIterator = currentIterator;
	currentIterator = 0;
	currentRule = rule;
	currentRuleID = ruleID;
	currentRuleTopic = currentTopicID;

	unsigned int oldtrace = trace;
	if (debugTopic) trace = (topicDebugMap[currentTopicID] || GetDebugRuleMark(currentTopicID,currentRuleID))  ? (unsigned int) -1 : 0;
	++ruleCount;
	unsigned int start = 0;

retry:
	unsigned int result = 0;
	if (debugger) Debugger(ENTER_RULE);

	char label[MAX_WORD_SIZE];
    char* ptr = GetLabel(rule,label); // now at pattern if there is one
	if (trace & TRACE_PATTERN)
	{
		if (*label) Log(STDUSERTABLOG, "try %d.%d %s: \\",TOPLEVELID(ruleID),REJOINDERID(ruleID),label); //  \\  blocks linefeed on next Log call
		else Log(STDUSERTABLOG, "try %d.%d: \\",TOPLEVELID(ruleID),REJOINDERID(ruleID)); //  \\  blocks linefeed on next Log call
	}

	if (*ptr == '(') // pattern requirement
	{
		unsigned int wildcardSelector = 0;
		unsigned int gap = 0;
		unsigned int junk;
		wildcardIndex = 0;
		blocked = true; // do NOT allow debugger running inside a match
 		if (start > wordCount || !Match(ptr+2,0,start,'(',true,gap,wildcardSelector,start,junk)) result = FAIL_MATCH;  // skip paren and blank, returns start as the location for retry if appropriate
		blocked = false;
	}
	
	if (result == 0) // generate output
	{
		if (trace & (TRACE_PATTERN|TRACE_MATCH)) //   display the entire matching responder and maybe wildcard bindings
		{
			if (!(trace & TRACE_PATTERN)) Log(STDUSERTABLOG, "try %s",ShowRule(rule)); 
			Log(STDUSERTABLOG,"**Match: %s",ShowRule(rule)); //   show abstract result we will apply
			if (wildcardIndex)
			{
				Log(STDUSERLOG," wildcards: ");
				for (unsigned int i = 0; i < wildcardIndex; ++i)
				{
					if (*wildcardOriginalText[i]) Log(STDUSERLOG,"_%d=%s ",i,wildcardOriginalText[i]);
					else Log(STDUSERLOG,"_%d=  ",i);
				}
			}
			Log(STDUSERLOG,"\r\n");
		}
		result = DoOutput(buffer,currentRule,currentRuleID);

		if (result & RETRYRULE_BIT) goto retry;
		if (result & RETRYTOPRULE_BIT && TopLevelRule(rule)) 
			goto retry;
	}
	else if (debugger) Debugger(EXIT_RULE);
	RESTOREOLDCONTEXT()
	currentIterator = oldIterator;
	
	trace = oldtrace;
	return result; 
}

unsigned int FindLinearRule(char type, char* buffer, unsigned int& id,unsigned int topic) 
{
	if (trace & (TRACE_MATCH|TRACE_PATTERN)) id = Log(STDUSERTABLOG,"\r\n\r\nTopic: %s linear %s: \r\n",GetTopicName(currentTopicID),RuleTypeName(type));
	char* base = GetTopicData(currentTopicID);  
	int ruleID = 0;
	unsigned int* map = (type == STATEMENT || type == QUESTION || type == STATEMENT_QUESTION) ? responderTagMap[currentTopicID] : gambitTagMap[currentTopicID];
	ruleID = *map;
    unsigned int result = 0;
	unsigned int oldResponseIndex = responseIndex;
	unsigned int* indices =  ruleOffsetMap[currentTopicID];
	while (ruleID != NOMORERULES) //   find all choices-- layout is like "t: xxx () yyy"  or   "u: () yyy"  or   "t: this is text" -- there is only 1 space before useful label or data
	{
		char* ptr = base + indices[ruleID]; // the gambit or responder
		if (!UsableRule(currentTopicID,ruleID))
		{
			if (trace & TRACE_PATTERN) Log(STDUSERTABLOG,"try %d.%d: linear used up\r\n",TOPLEVELID(ruleID),REJOINDERID(ruleID));
		}
		else if (type == GAMBIT || (*ptr == type || *ptr == STATEMENT_QUESTION)) // is this the next unit we want to consider?
		{
			result = TestRule(ruleID,ptr,buffer);
			if (result == FAIL_MATCH) result = FAILRULE_BIT;
			if (result & (FAILRULE_BIT | ENDRULE_BIT)) oldResponseIndex = responseIndex; // update in case he issued answer AND claimed failure
 			else if (result & ENDCODES || responseIndex > oldResponseIndex) break; // wants to end or got answer
		}
		ruleID = *++map;
		result = 0;
	}
	if (result & (ENDINPUT_BIT|FAILINPUT_BIT|FAILSENTENCE_BIT|ENDSENTENCE_BIT|RETRYSENTENCE_BIT|RETRYTOPIC_BIT)) return result; // stop beyond mere topic
	return (result & (ENDCODES-ENDTOPIC_BIT)) ? FAILTOPIC_BIT : 0; 
}

unsigned int FindRandomRule(char type, char* buffer, unsigned int& id)
{
	if (trace & (TRACE_MATCH|TRACE_PATTERN)) id = Log(STDUSERTABLOG,"\r\n\r\nTopic: %s random %s: \r\n",GetTopicName(currentTopicID),RuleTypeName(type));
	char* base = GetTopicData(currentTopicID);  
	unsigned int ruleID = 0;
	unsigned  int* rulemap;
	rulemap = (type == STATEMENT || type == QUESTION || type == STATEMENT_QUESTION) ? responderTagMap[currentTopicID] : gambitTagMap[currentTopicID];
	ruleID = *rulemap;

	//   gather the choices
    unsigned int index = 0;
  	unsigned int idResponder[TOPIC_LIMIT];
	while (ruleID != NOMORERULES)
    {
		char* ptr = base + ruleOffsetMap[currentTopicID][ruleID];
		if (!UsableRule(currentTopicID,ruleID))
		{
			if (trace & TRACE_PATTERN) Log(STDUSERTABLOG,"try %d.%d: random used up\r\n",TOPLEVELID(ruleID),REJOINDERID(ruleID));
		}
		else if (type == GAMBIT || (*ptr == type || *ptr == STATEMENT_QUESTION))
		{
			idResponder[index] = ruleID;
			if (++index > TOPIC_LIMIT-1)
			{
               ReportBug("Too many random choices for topic")
               break; 
			}
        }
		ruleID = *++rulemap;
   }

 	unsigned int result = 0;
	unsigned int oldResponseIndex = responseIndex;
	//   we need to preserve the ACTUAL ordering information so we have access to the responseID.
    while (index)
    {
        int n = random(index);
		int rule = idResponder[n];
        result = TestRule(rule,ruleOffsetMap[currentTopicID][rule]+base,buffer);
		if (result == FAIL_MATCH) result = FAILRULE_BIT;
		if (result & (FAILRULE_BIT | ENDRULE_BIT)) oldResponseIndex = responseIndex; // update in case added response AND declared failure
 		else if (result & ENDCODES || responseIndex > oldResponseIndex) break;
        idResponder[n] =  idResponder[--index] ; // erase choice and reset loop index
		result = 0;
    }
	
	if (result & (FAILSENTENCE_BIT | ENDSENTENCE_BIT | RETRYSENTENCE_BIT | ENDINPUT_BIT )) return result;
	return (result & (ENDCODES-ENDTOPIC_BIT)) ? FAILTOPIC_BIT : 0; 
}

unsigned int FindRandomGambitContinuation(char type, char* buffer, unsigned int& id)
{
	if (trace & (TRACE_MATCH|TRACE_PATTERN)) id = Log(STDUSERTABLOG,"\r\n\r\nTopic: %s random %s: \r\n",GetTopicName(currentTopicID),RuleTypeName(type));
	char* base = GetTopicData(currentTopicID);  
	unsigned  int* rulemap = gambitTagMap[currentTopicID];	// looking for gambits
	int gambitID = *rulemap;

	unsigned int result = 0;
	unsigned int oldResponseIndex = responseIndex;
	bool available = false;
	bool tried = false;
 	while (gambitID != NOMORERULES)
    {
		char* ptr = base + ruleOffsetMap[currentTopicID][gambitID];
		if (!UsableRule(currentTopicID,gambitID))
		{
			if (trace & TRACE_PATTERN) Log(STDUSERTABLOG,"try %d.%d: randomcontinuation used up\r\n",TOPLEVELID(gambitID),REJOINDERID(gambitID));
			if (*ptr == RANDOM_GAMBIT) available = true; //   we are allowed to use gambits part of this subtopic
		}
		else if (*ptr == GAMBIT) 
		{
			if (available) //   we can try it
			{
				result = TestRule(gambitID,ptr,buffer);
				tried = true;
				if (result == FAIL_MATCH) result = FAILRULE_BIT;
				if (result & (FAILRULE_BIT | ENDRULE_BIT)) oldResponseIndex = responseIndex; // update in case he added response AND claimed failure
 				else if (result & ENDCODES || responseIndex > oldResponseIndex) break;
			}
		}
		else if (*ptr == RANDOM_GAMBIT) available = false; //   this random gambit not yet taken
        else break; //   gambits are first, if we didn match we must be exhausted
		result = 0;
		gambitID = *++rulemap;
	}
	if (result & (FAILSENTENCE_BIT | ENDSENTENCE_BIT | RETRYSENTENCE_BIT| ENDINPUT_BIT )) return result;
	if (!tried) return FAILRULE_BIT;
	return (result & (ENDCODES-ENDTOPIC_BIT)) ? FAILTOPIC_BIT : 0; 
}

unsigned int FindTypedResponse(char type,char* buffer,unsigned int& id)
{
   char* ptr = GetTopicData(currentTopicID);  
    if (!ptr || !*ptr || GetTopicFlags(currentTopicID) & TOPIC_BLOCKED) return FAILTOPIC_BIT;

	unsigned int result;
	SAVEOLDCONTEXT()
 	unsigned int oldtrace = trace;
	if (debugTopic) trace = (topicDebugMap[currentTopicID])  ? (unsigned int) -1 : 0;
	if (*ptr == RANDOM_GAMBIT && type == GAMBIT)
	{
		result = FindRandomGambitContinuation(type,buffer,id);
		if (result & FAILRULE_BIT) result = FindRandomRule(type,buffer,id);
	}
	else if (GetTopicFlags(currentTopicID) & TOPIC_RANDOM) result = FindRandomRule(type,buffer,id);
	else result = FindLinearRule(type,buffer,id,currentTopicID);
	trace = oldtrace;
	RESTOREOLDCONTEXT()
    return result;
}

bool showd = false;

unsigned int PerformTopic(int active,char* buffer)//   MANAGE current topic full reaction to input (including rejoinders and generics)
{//   returns 0 if the system believes some output was generated. Otherwise returns a failure code
//   if failed, then topic stack is spot it was 
	unsigned int tindex = topicIndex;
	unsigned int id = 0;
	if (currentTopicID == 0 || !topicScriptMap) return FAILTOPIC_BIT;
	if (!active) active = (tokenFlags & QUESTIONMARK)  ? QUESTION : STATEMENT;
    unsigned int result = RETRYTOPIC_BIT;
	unsigned oldTopic = currentTopicID;
	int holdd = globalDepth;
	ChangeDepth(1,"PerformTopic");
	if (debugger) Debugger(ENTER_TOPIC);

	while (result == RETRYTOPIC_BIT)
	{
		if (BlockedBotAccess(currentTopicID)) result = FAILTOPIC_BIT;	//   not allowed this bot
		else result = FindTypedResponse((active == QUESTION || active == STATEMENT || active == STATEMENT_QUESTION ) ? (char)active : GAMBIT,buffer,id);

		//   flush any deeper stack back to spot we started
		if (result & (FAILRULE_BIT | FAILTOPIC_BIT | FAILSENTENCE_BIT | RETRYSENTENCE_BIT | RETRYTOPIC_BIT)) topicIndex = tindex; 
		//   or remove topics we matched on so we become the new master path
	}

	result &= -1 ^ ENDTOPIC_BIT; // dont propogate 
	if (result & FAILTOPIC_BIT) result = FAILRULE_BIT; // downgrade
	if (trace & (TRACE_MATCH|TRACE_PATTERN)) id = Log(STDUSERTABLOG,"Result: %s Topic: %s \r\n",ResultCode(result),GetTopicName(currentTopicID));
	
	if (debugger) Debugger(EXIT_TOPIC,result);
	ChangeDepth(-1,"PerformTopic");
	if (globalDepth != holdd) ReportBug("PerformTopic didn't balance");
	
	currentTopicID = oldTopic;
	return (result & (ENDSENTENCE_BIT|FAILSENTENCE_BIT|RETRYSENTENCE_BIT|ENDINPUT_BIT|FAILINPUT_BIT|FAILRULE_BIT)) ? result : 0;
}

///////////////////////////////////////////////////////
///// TOPIC SAVING FOR USER
///////////////////////////////////////////////////////

char* WriteTopicData(char* ptr)
{ 
    char word[MAX_WORD_SIZE];
    //   dump current topics list and current rejoinder
    unsigned int id;

     //   current location in topic system -- written by NAME, so topic data can be added (if change existing topics, must kill off lastquestion)
    *word = 0;
	if (outputRejoinderTopic == NO_REJOINDER) sprintf(ptr,"%d %d 0 # flags, start, input#, no rejoinder\n",userFirstLine,inputCount);
	else 
	{
		sprintf(ptr,"%d %d %s ",userFirstLine,inputCount,GetTopicName(outputRejoinderTopic));
		ptr += strlen(ptr);
		ptr = FullEncode(outputRejoinderRuleID,ptr); 
		ptr = FullEncode(topicChecksumMap[outputRejoinderTopic],ptr);
		strcpy(ptr," # flags, start, input#, rejoindertopic,rejoinderid,checksum\r\n");
	}
	ptr += strlen(ptr);
    if (topicIndex)  ReportBug("topic system failed to clear out topic stack\r\n")
   
	for (id = 0; id < pendingTopicIndex; ++id) 
	{
		sprintf(ptr,"%s ",GetTopicName(pendingTopicList[id])); 
		ptr += strlen(ptr);
	}
	sprintf(ptr,"#pending\n");
	ptr += strlen(ptr);
 
    //   write out dirty topics
    for (id = 1; id <= lastTopic; ++id) 
    {
        char* name = topicNameMap[id];// actual name, not common name
		if (!*name) continue;
        unsigned int flags = topicFlagsMap[id];
		topicFlagsMap[id] &= -1 ^ ACCESS_FLAGS;
		if (!(flags & TRANSIENT_FLAGS) || flags & TOPIC_SYSTEM) continue; // no change or not allowed to change

		// if this is a topic with a bot restriction and we are not that bot, we dont care about it.
		if (topicRestrictionMap[id] && !strstr(topicRestrictionMap[id],computerIDwSpace)) continue; // not our topic

		// see if topic is all virgin still. if so we wont care about its checksum and rule count or used bits
  		int size = topicBytesRulesMap[id];
   		unsigned char* bits = topicUsedMap[id];
		int test = 0;
		if (size) while (!*bits++ && ++test < size); // any rules used?
		if (test != size || flags & TOPIC_BLOCKED) // has used bits or blocked status, write out erased status info
		{
			//   now write out data- if topic is not eraseable, it wont change, but used flags MIGHT (allowing access to topic)
 			char c = (flags & TOPIC_BLOCKED) ? '-' : '+';
			sprintf(ptr,"%s %c",name,c);
			ptr += strlen(ptr);
			sprintf(ptr," %d ",(test == size) ? 0 : size);
			ptr += strlen(ptr);
			if (test != size) // some used bits exist
			{
				ptr = FullEncode(topicChecksumMap[id],ptr);
				bits = topicUsedMap[id]; 
				while (size > 0)
				{
					--size;
					unsigned char value = *bits++;
					sprintf(ptr,"%c%c",((value >> 4) & 0x0f) + 'a',(value & 0x0f) + 'a');
					ptr += strlen(ptr);
				}
				*ptr++ = ' ';
			}
			if (flags & TOPIC_GAMBITTED) topicLastGambittedMap[id] = inputCount; // note when we used a gambit from topic 
			if (flags & TOPIC_RESPONDED) topicLastGambittedMap[id] = inputCount; // note when we used a responder from topic 
			if (flags & TOPIC_REJOINDERED) topicLastGambittedMap[id] = inputCount; // note when we used a responder from topic 
			ptr = FullEncode(topicLastGambittedMap[id],ptr);
			ptr = FullEncode(topicLastResponderedMap[id],ptr);
			ptr = FullEncode(topicLastRejoinderedMap[id],ptr);
			strcpy(ptr,"\r\n");
			ptr += 2;
		}
    }
	strcpy(ptr,"#`end topics\r\n"); 
	ptr += strlen(ptr);
	return ptr;
}

bool ReadTopicData()
{
    char word[MAX_WORD_SIZE];
	//   flags, status, rejoinder
	ReadALine(readBuffer, 0);
	char* ptr = ReadCompiledWord(readBuffer,word); 
    userFirstLine = atoi(word);
    ptr = ReadCompiledWord(ptr,word); 
    inputCount = atoi(word);

    ptr = ReadCompiledWord(ptr,word);  //   rejoinder topic name
	if (*word == '0')  inputRejoinderTopic = inputRejoinderRuleID = NO_REJOINDER; 
    else
	{
		inputRejoinderTopic  = FindTopicIDByName(word);
		ptr = ReadCompiledWord(ptr,word); //  rejoinder location
		inputRejoinderRuleID = ((int)FullDecode(word)); 
		// prove topic didnt change (in case of system topic or one we didnt write out)
		unsigned int checksum;
		ptr = ReadCompiledWord(ptr,word); 
		checksum = (unsigned int) FullDecode(word); // topic checksum
		if (!inputRejoinderTopic) inputRejoinderTopic = inputRejoinderRuleID = NO_REJOINDER;  // topic changed
		if (checksum != topicChecksumMap[inputRejoinderTopic] && topicChecksumMap[inputRejoinderTopic] && !(GetTopicFlags(inputRejoinderTopic) & TOPIC_SAFE)) inputRejoinderTopic = inputRejoinderRuleID = NO_REJOINDER;  // topic changed
	}

    //   pending stack
    ReadALine(readBuffer,0);
    ptr = readBuffer;
    pendingTopicIndex = 0;
    while (ptr && *ptr) //   read each topic name
    {
        ptr = ReadCompiledWord(ptr,word); //   topic name
		if (*word == '#') break; //   comment ends it
        unsigned int id = FindTopicIDByName(word); 
        if (id) pendingTopicList[pendingTopicIndex++] = id;
    }

    //   read in used topics
    char topicName[MAX_WORD_SIZE];
    while (ReadALine(readBuffer, 0) != 0) 
    {
        size_t len = strlen(readBuffer); 
        if (len < 3) continue;
		if (*readBuffer == '#') break;
        char* at = readBuffer;
        at = ReadCompiledWord(at,topicName);
		WORDP D = FindWord(topicName);			
		if (!D || !(D->systemFlags & TOPIC)) continue; // should never fail unless topic disappears from a refresh
		unsigned int id = D->x.topicIndex;
		if (!id) continue;	//   no longer exists
		at = ReadCompiledWord(at,word); //   blocked status (+ ok - blocked) and maybe safe topic status
		if (*word == '-') topicFlagsMap[id] |= TOPIC_BLOCKED|TOPIC_USED; // want to keep writing it out as blocked
		bool safe = (topicFlagsMap[id] & TOPIC_SAFE) ? true : false; // implies safe checksum
		unsigned int bytes;
		at = ReadInt(at,bytes); // 0 means use default values otherwise we have used bits to read in
		if (bytes)
		{
			char sum[MAX_WORD_SIZE];
			at = ReadCompiledWord(at,sum);
			unsigned int checksum = (unsigned int)FullDecode(sum);
			if (safe) checksum = 0;	// this is a safe update
			// a topic checksum of 0 implies it was changed manually, and set to 0 because  it was a minor edit.
			topicFlagsMap[id] |= TOPIC_USED; 
			unsigned int size = topicBytesRulesMap[id]; // how many bytes of data in memory
			bool ignore = false;
			if ((topicChecksumMap[id] && checksum != topicChecksumMap[id]) || size < bytes) ignore = true; // topic changed or has shrunk = discard our data
			unsigned char* bits = topicUsedMap[id];
			unsigned char* startbits = bits;
			while (*at != ' ') // til byte marks used up
			{
				if (!ignore) *bits++ = ((*at -'a') << 4) + (at[1] - 'a'); 
				at += 2;
			}
			if (!ignore && (unsigned int)((bits - startbits)) != size) ReportBug("Bad updating on topic %s %d %d actual vs %d wanted  %s\r\n",GetTopicName(id), id,(unsigned int)((bits - startbits)),size,readBuffer)
			char val[MAX_WORD_SIZE];
			at = ReadCompiledWord(at+1,val); // skip over the blank that ended the prior loop
			topicLastGambittedMap[id] = (unsigned int)FullDecode(val); // gambits
			at = ReadCompiledWord(at,val);
			topicLastResponderedMap[id] = (unsigned int)FullDecode(val); // responders
			at = ReadCompiledWord(at,val);
			topicLastRejoinderedMap[id] = (unsigned int)FullDecode(val); // rejoinders
		}
    }
	if (strcmp(readBuffer,"#`end topics")) 
	{
		ReportBug("Bad file layout")
		return false;
	}

	return true;
 }

//////////////////////////////////////////////////////
/// TOPIC INITIALIZATION
//////////////////////////////////////////////////////
 
void ResetTopicSystem()
{
    ResetTopics();
	topicIndex = 0;
	pendingTopicIndex = 0;
	ruleErased = false;	
	memset(topicLastGambittedMap,0,sizeof(int) * numberOfTopics); 
	memset(topicLastResponderedMap,0,sizeof(int) * numberOfTopics);
	memset(topicLastRejoinderedMap,0,sizeof(int) * numberOfTopics); 
	currentTopicID = 0;
	unusedRejoinder = true; 
	outputRejoinderTopic = outputRejoinderRuleID = NO_REJOINDER; 
	inputRejoinderTopic = inputRejoinderRuleID = NO_REJOINDER; 
 }

void ResetTopics()
{
	for (unsigned int i = 1; i <= numberOfTopics; ++i) ResetTopic(i);
}

 void ResetTopic(unsigned int topic)
{
	if (!topic || topic > numberOfTopics) return;
	if (*topicNameMap[topic]) // normal fully functional topic
	{
		memset(topicUsedMap[topic],0,topicBytesRulesMap[topic]);
		topicFlagsMap[topic] &= -1 ^ TRANSIENT_FLAGS;
		topicLastGambittedMap[topic] = topicLastResponderedMap[topic] = topicLastRejoinderedMap[topic] = 0;
	}
}

static void LoadTopicData(const char* name,uint64 build)
{
	FILE* in = FopenReadOnly(name);
	if (!in) return;

	char count[MAX_WORD_SIZE];
	char* ptr = ReadALine(count,in);
	ptr = ReadCompiledWord(ptr,tmpWord);	// skip the number of topics
	if (build & BUILD0) 
	{
		ptr = ReadCompiledWord(ptr,timeStamp0);
		ptr = ReadCompiledWord(ptr,buildStamp0);
	}
	else if (build & BUILD1) 
	{
		ptr = ReadCompiledWord(ptr,timeStamp1);
		ptr = ReadCompiledWord(ptr,buildStamp1);
	}

	// topic takes 2 lines:
	// 1- TOPIC: name:~happiness flags:0 checksum:11371305158409071022 top level rules:14  gambits:10 reserved:0 bytes of data:1453 name of source file: xxx
	// 2- restriction and actual topic data sized by last number of 1st line e/g/ " all "00! ?: ( south * what color be *~2 bear ) White.
	while (ReadALine(readBuffer,in))  
	{
		char* ptr;	
		char name[MAX_WORD_SIZE];
		ptr = ReadCompiledWord(readBuffer,name); // eat TOPIC: 
		if (!*name) break;
		if (stricmp(name,"topic:"))
		{
			ReportBug("bad topic alignment %s\r\n",name)
			myexit("bad topic alignment");
		}
		ptr = ReadCompiledWord(ptr,name);
		if (!topicNameMap)
		{
			if (build == BUILD0) 
			{
				EraseTopicFiles(BUILD0);
				printf("\r\n>>>  TOPICS directory bad. Contents erased. :build 0 again.\r\n\r\n");
			}
			else printf("\r\n>>> TOPICS directory bad. Build1 Contents erased. :build 1 again.\r\n\r\n");
			EraseTopicFiles(BUILD1);
			return;
		}
		compiling = true;
		unsigned int topic = FindTopicIDByName(name); // may preexist
		compiling = false;
		if (!topic) topic = ++currentTopicID;
		ptr = ReadInt(ptr,topicFlagsMap[topic]);
		ptr = ReadInt(ptr,topicChecksumMap[topic]);
		unsigned int topLevelRules;
 		ptr = ReadInt(ptr,topLevelRules);
		unsigned int bytes = (topLevelRules+7) / 8;	// bytes needed to bit mask the responders
		if (!bytes) bytes = 1;
		unsigned int gambitCount;
		ptr = ReadInt(ptr,gambitCount); 

		ruleOffsetMap[topic] = (unsigned int*)AllocateString(NULL,(1+topLevelRules) * sizeof(int));
		gambitTagMap[topic] = (unsigned int*)AllocateString(NULL,( 1 + gambitCount) * sizeof(int));
		responderTagMap[topic] = (unsigned int*)AllocateString(NULL,(topLevelRules - gambitCount + 1) * sizeof(int));
		topicMaxRule[topic] = topLevelRules | MAKE_GAMBIT_MAX(gambitCount);

		unsigned int datalen;
		ptr = ReadInt(ptr,datalen);
		topicUsedMap[topic] = (unsigned char*)AllocateString(NULL,bytes,false,true);
		topicDebugRuleMap[topic] = (unsigned char*)AllocateString(NULL,bytes,false,true);
		topicBytesRulesMap[topic] = (unsigned short)bytes;
		topicFile[topic] = AllocateString(ptr);
		
		char* space = AllocateString(0,datalen); // no closing null, just \r\n
		char* copy = space;
		unsigned int didread = fread(copy,1,datalen-2,in); // not yet read \r\n 
		copy[datalen-2] = 0;
		if (didread != (datalen - 2))
		{
			ReportBug("failed to read all of topic %s read: %d wanted: %d \r\n",name,didread,datalen)
			break;
		}
		// read \r\n or \n carefully, since windows and linux do things differently
		char c = 0;
		didread = fread(&c,1,1,in); // \n or \r\n
		if (c != '\r' && c != '\n') 
		{
			ReportBug("failed to end topic %s properly\r\n",name)
			myexit("failed to end topic properly");
		}

		WORDP D = StoreWord(name,0,TOPIC|CONCEPT); 
		AddInternalFlag(D,build);
		D->x.topicIndex = (unsigned short) topic;
		topicNameMap[topic] = D->word;
		
		//   bot restriction if any
		char* start = copy;
		ptr = strchr(start+1,'"') + 2;	// end of bot restriction, start of topic data
		*start = ' '; //  kill start "
		*(ptr-2) = ' '; // kill close "
		*(ptr-1) = 0;	//   end bot restriction - double space after botname
		topicRestrictionMap[topic] = ( strstr(start," all ")) ? NULL : start;

		//   topic data
		SetTopicData(topic,ptr);
		char* data = GetTopicData(topic);
		unsigned int i = 0;
		ptr = GetTopicData(topic);
		int gambitIndex = 0;
		int responderIndex = 0;
		int id = 0;
		while (ptr && *ptr) // walk all rules
		{
			if (*ptr == GAMBIT || *ptr == RANDOM_GAMBIT) gambitTagMap[topic][gambitIndex++] = i; // tag
			else responderTagMap[topic][responderIndex++] = i;
			ruleOffsetMap[topic][i++] = ptr - data; // store direct offset of rule
			if (i == topLevelRules) break;
			ptr = FindNextRule(NEXTTOPLEVEL,ptr,id);
		}
		gambitTagMap[topic][gambitIndex] = NOMORERULES;
		responderTagMap[topic][responderIndex] = NOMORERULES;
		ruleOffsetMap[topic][i] = NOMORERULES; 
	}
	fclose(in);
}

static void LoadPlanData(const char* name,uint64 build)
{
	FILE* in = FopenReadOnly(name);
	if (!in) return;

	char count[MAX_WORD_SIZE];
	char* ptr = ReadALine(count,in);
	ReadCompiledWord(ptr,tmpWord);	// skip the number of plans

	// plan takes 2 lines:
	// 1- PLAN: name:^travel arguments:0  top level rules:14  bytes of data:1453 name of source file: xxx
	// 2- restriction and actual topic data sized by last number of 1st line e/g/ " all "00! ?: ( south * what color be *~2 bear ) White.
	while (ReadALine(readBuffer,in))  
	{
		char* ptr;	
		char name[MAX_WORD_SIZE];
		ptr = ReadCompiledWord(readBuffer,name); // eat PLAN: 
		if (!*name) break;
		if (stricmp(name,"plan:"))
		{
			ReportBug("bad plan alignment %s\r\n",name)
			myexit("bad plan alignment");
		}
		ptr = ReadCompiledWord(ptr,name);
		if (!topicNameMap)
		{
			if (build == BUILD0) 
			{
				EraseTopicFiles(BUILD0);
				printf("\r\n>>>  TOPICS directory bad with plans. Contents erased. :build 0 again.\r\n\r\n");
			}
			else printf("\r\n>>> TOPICS directory bad with plans. Build1 Contents erased. :build 1 again.\r\n\r\n");
			EraseTopicFiles(BUILD1);
			return;
		}
		compiling = true;
		unsigned int topic = FindTopicIDByName(name); // may NOT preexist
		compiling = false;
		if (!topic) topic = ++currentTopicID;
		else myexit("duplicate plan name");
		WORDP P = StoreWord(name,0,FUNCTION_NAME|IS_PLAN_MACRO); 
		AddInternalFlag(P,build);
		P->x.topicIndex = (unsigned short)topic;
		topicNameMap[topic] = P->word;
	
		ptr = ReadCompiledWord(ptr,tmpWord);
		P->w.planArgCount = *tmpWord - '0'; // up to 9 arguments
		unsigned int topLevelRules;
 		ptr = ReadInt(ptr,topLevelRules);
		unsigned int bytes = (topLevelRules+7) / 8;	// bytes needed to bit mask the responders
		if (!bytes) bytes = 1;

		ruleOffsetMap[topic] = (unsigned int*)AllocateString(NULL,(1+topLevelRules) * sizeof(int));
		gambitTagMap[topic] = NULL;
		responderTagMap[topic] = (unsigned int*)AllocateString(NULL,(topLevelRules) * sizeof(int));
		topicMaxRule[topic] = topLevelRules;

		unsigned int datalen;
		ptr = ReadInt(ptr,datalen);
		topicUsedMap[topic] = (unsigned char*)AllocateString(NULL,bytes,false,true);
		topicDebugRuleMap[topic] = (unsigned char*)AllocateString(NULL,bytes,false,true);
		topicBytesRulesMap[topic] = (unsigned short)bytes;
		topicFile[topic] = AllocateString(ptr);
		
		char* space = AllocateString(0,datalen); // no closing null, just \r\n
		char* copy = space;
		unsigned int didread = fread(copy,1,datalen-2,in); // not yet read \r\n 
		copy[datalen-2] = 0;
		if (didread != (datalen - 2))
		{
			ReportBug("failed to read all of topic %s read: %d wanted: %d \r\n",name,didread,datalen)
			break;
		}
		// read \r\n or \n carefully, since windows and linux do things differently
		char c = 0;
		didread = fread(&c,1,1,in); // \n or \r\n
		if (c != '\r' && c != '\n') 
		{
			ReportBug("failed to end topic %s properly\r\n",name)
			myexit("failed to end topic properly");
		}
	
		//   bot restriction if any
		char* start = copy;
		ptr = strchr(start+1,'"') + 2;	// end of bot restriction, start of topic data
		*start = ' '; //  kill start "
		*(ptr-2) = ' '; // kill close "
		*(ptr-1) = 0;	//   end bot restriction - double space after botname
		topicRestrictionMap[topic] = ( strstr(start," all ")) ? NULL : start;

		//   topic data
		SetTopicData(topic,ptr);
		char* data = GetTopicData(topic);
		unsigned int i = 0;
		ptr = GetTopicData(topic);
		int responderIndex = 0;
		int id = 0;
		while (ptr && *ptr) // walk all rules
		{
			responderTagMap[topic][responderIndex++] = i;
			ruleOffsetMap[topic][i++] = ptr - data; // store direct offset of rule
			if (i == topLevelRules) break;
			ptr = FindNextRule(NEXTTOPLEVEL,ptr,id);
		}
		responderTagMap[topic][responderIndex] = NOMORERULES;
		ruleOffsetMap[topic][i] = NOMORERULES; 
	}
	fclose(in);
}
static void ReadPatternData(const char* name)
{
    FILE* in = FopenReadOnly(name);
    char word[MAX_WORD_SIZE];
	if (!in) return;
	currentFileLine = 0;
	while (ReadALine(readBuffer,in) != 0) 
	{
		ReadCompiledWord(readBuffer,word); //   skip over double quote or QUOTE
		if (!*word) continue;
        if (*word == '"') StoreWord(JoinWords(BurstWord(word),false),0,PATTERN_WORD); 
		else if (*word == '\'')   StoreWord(word+1,0,PATTERN_WORD); 
        else  StoreWord(word,0,PATTERN_WORD);
    }
    fclose(in);
}

static void AddRecursiveProperty(WORDP D,uint64 type,bool buildingDictionary)
{
	if (D->internalBits & DELETED_MARK  && !(D->systemFlags & TOPIC)) RemoveInternalFlag(D,DELETED_MARK);
	AddProperty(D,type);
	if (buildingDictionary) AddSystemFlag(D,MARKED_WORD);
	if (*D->word != '~')
	{
		if (type & NOUN && !(D->properties & (NOUN_PROPER_SINGULAR|NOUN_SINGULAR|NOUN_PLURAL|NOUN_PROPER_PLURAL))) // infer case 
		{
			if (IsUpperCase(*D->word || IsUpperCase(D->word[1]) || IsUpperCase(D->word[2]))) AddProperty(D,NOUN_PROPER_SINGULAR);
			else AddProperty(D,NOUN_SINGULAR);
		}
		return;
	}
	if (D->inferMark == inferMark) return;
	D->inferMark = inferMark;
	FACT* F = GetObjectHead(D);
	while (F)
	{
		AddRecursiveProperty(Meaning2Word(F->subject),type,buildingDictionary);
		F = GetObjectNext(F);
	}
}

static void AddRecursiveFlag(WORDP D,uint64 type,bool buildingDictionary)
{
	AddSystemFlag(D,type);
	if (buildingDictionary) AddSystemFlag(D,MARKED_WORD);
	if (*D->word != '~') return;
	if (D->inferMark == inferMark) return;
	D->inferMark = inferMark;
	FACT* F = GetObjectHead(D);
	while (F)
	{
		AddRecursiveFlag(Meaning2Word(F->subject),type,buildingDictionary);
		F = GetObjectNext(F);
	}
}

void InitKeywords(const char* name,uint64 build,bool buildDictionary,bool concept)
{ 
	FILE* in = FopenReadOnly(name); // keywords files
	if (!in) return;

	StartFile(name);
	bool endseen = true;
	MEANING T = 0;
	WORDP set = NULL;
	while (ReadALine(readBuffer, in)) //~hate (~dislikeverb )
	{
		uint64 type = 0;
		uint64 sys = 0;
		char word[MAX_WORD_SIZE];
		char* ptr = readBuffer;
		if (*readBuffer == '~' || endseen || *readBuffer == 'T') // concept, not-a-keyword, topic
		{
			// get the main concept name
			ptr = ReadCompiledWord(ptr,word); //   leaves ptr on next good word
			if (*word == 'T') memmove(word,word+1,strlen(word));
			T = ReadMeaning(word,true,true);
			set = Meaning2Word(T);
			AddSystemFlag(set,CONCEPT); // sets and concepts are both sets. Topics get extra labelled on script load
			AddInternalFlag(set,build);
			if (buildDictionary) AddSystemFlag(set,MARKED_WORD);
			if (set->internalBits & DELETED_MARK && !(set->systemFlags & TOPIC)) RemoveInternalFlag(set,DELETED_MARK); // restore concepts but not topics

			// read any properties to mark on the members
			while (*ptr != '(' && *ptr != '"')
			{
				ptr = ReadCompiledWord(ptr,word);
				uint64 val = FindValueByName(word);
				if ( val) type |= val;
				else 
				{
					val = FindValue2ByName(word);
					if ( val) sys |= val;
					else break; // unknown
				}
			}
			AddProperty(set,type);
			AddSystemFlag(set,sys); 
			if (sys & DELAYED_RECURSIVE_DIRECT_MEMBER) sys ^= DELAYED_RECURSIVE_DIRECT_MEMBER; // only mark top set for this recursive membership
			NextinferMark();
			set->inferMark = inferMark;
			if (*ptr != '(') //   has a description
			{
				WORDP C = StoreWord("comment");
				MEANING T = MakeMeaning(C,0);
				ptr = ReadCompiledWord(ptr,word);
				CreateFact(MakeMeaning(StoreWord(word)),T,T);
			}
			char* dot = strchr(word,'.');
			if (dot) // convert the topic family to the root name --- BUG breaks with amazon data...
			{
				*dot = 0;
				T = ReadMeaning(word,true,true);
			}
			ptr += 2;	//   skip the ( and space
			endseen = false;
		}
		// now read the keywords
		while (ALWAYS)
		{
			ptr = ReadCompiledWord(ptr,word);
			if (*word == ')' ||  !*word  ) break; // til end of keywords or end of line
			MEANING U;
			char* p1 = word;
			if (*word == '!') 
			{
				++p1;
				AddInternalFlag(set,HAS_EXCLUDE);
			}
			bool original = false;
			if (*p1 == '\'') 
			{
				++p1;
				original = true;
			}
			U = ReadMeaning(p1,true,true);

			if (Meaning2Index(U)) U = GetMaster(U); // use master if given specific meaning
				
			WORDP D = Meaning2Word(U);
			if (D->internalBits & DELETED_MARK  && !(D->systemFlags & TOPIC)) RemoveInternalFlag(D,DELETED_MARK); 
			if (buildDictionary) AddSystemFlag(D,MARKED_WORD);
			if (type && !strchr(p1+1,'~')) // not dictionary entry
			{
				AddProperty(D,type);
				AddSystemFlag(D,sys);
				if (type & NOUN && *p1 != '~' && !(D->properties & (NOUN_SINGULAR|NOUN_PLURAL|NOUN_PROPER_SINGULAR|NOUN_PROPER_PLURAL|NOUN_NUMBER)))
				{
					if (D->internalBits & UPPERCASE_HASH) AddProperty(D,NOUN_PROPER_SINGULAR);
					else if (IsNumber(word)) AddProperty(D,NOUN_NUMBER);
					else AddProperty(D,NOUN_SINGULAR);
				}
			}
			else if (IsAlpha(p1[0])) AddSystemFlag(D,PATTERN_WORD); // blocks spell checking to something else

			 // recursively do all members of an included set. When we see the set here and its defined, we will scan it
			// if we are DEFINING it now, we scan and mark. Eventually it will propogate
			if (*D->word != '~') // do simple word properties
			{
				AddProperty(D,type);
				AddSystemFlag(D,sys);
			}
			else // recurse on concept
			{
				if (type) AddRecursiveProperty(D,type,buildDictionary);
				if (sys) AddRecursiveFlag(D,sys,buildDictionary);
			}
	
			unsigned int index = Meaning2Index(U);
			if (index) U = GetMaster(U); // if not currently the master, switch to master
			MEANING verb = (*word == '!') ? Mexclude : Mmember;
			CreateFact(U,verb,T,(original) ? ORIGINAL_ONLY : 0 ); 
		}
		if (*word == ')') endseen = true; // end of keywords found. OTHERWISE we continue on next line
	}
	fclose(in);
}

static void InitMacros(const char* name,uint64 build)
{
	FILE* in = FopenReadOnly(name); // macros
	if (!in) return;
	currentFileLine = 0;
	while (ReadALine(readBuffer, in)) //   ^showfavorite O 2 _0 = ^0 _1 = ^1 ^reuse (~xfave FAVE ) 
	{
		if (!*readBuffer) continue;
		char* ptr = ReadCompiledWord(readBuffer,tmpWord); //   the name
		if (!*tmpWord) continue;
		WORDP D = StoreWord(tmpWord,0,FUNCTION_NAME); 
		AddInternalFlag(D,build);
		D->x.codeIndex = 0;	//   if one redefines a system macro, that macro is lost.
		ptr = ReadCompiledWord(ptr,tmpWord);
		if (*tmpWord == 'T') // table macro
		{
			AddSystemFlag(D,IS_TABLE_MACRO); 
			unsigned int val;
			ptr = ReadInt(ptr,val); 
			D->x.macroFlags = (unsigned short) val; // controls on text string as KEEP_QUOTE or not 
		}
		else if (*tmpWord == 'O') AddSystemFlag(D,IS_OUTPUT_MACRO); 
		else if (*tmpWord == 'P') AddSystemFlag(D,IS_PATTERN_MACRO); 
		else if (*tmpWord == 'D') AddSystemFlag(D,IS_PATTERN_MACRO|IS_OUTPUT_MACRO);
		ptr = ReadCompiledWord(ptr,tmpWord); // skip over readable arg count, has arg count embedded also
		D->w.fndefinition = (unsigned char*) AllocateString(ptr);
	}
	fclose(in);
}

static void InitTopicMemory()
{
	unsigned int total;
	topicStack[0] = 0;
	numberOfTopics = 0;
	FILE* in = FopenReadOnly("TOPIC/script0.txt");
	if (in)
	{
		ReadALine(readBuffer,in);
		ReadInt(readBuffer,total);
		fclose(in);
		numberOfTopics += total;
	}
	in = FopenReadOnly("TOPIC/script1.txt");
	if (in)
	{
		ReadALine(readBuffer,in);
		ReadInt(readBuffer,total);
		fclose(in);
		numberOfTopics += total;
	}
	lastTopic = numberOfTopics;
	in = FopenReadOnly("TOPIC/plans0.txt");
	if (in)
	{
		ReadALine(readBuffer,in);
		ReadInt(readBuffer,total);
		fclose(in);
		numberOfTopics += total;
	}
	in = FopenReadOnly("TOPIC/plans1.txt");
	if (in)
	{
		ReadALine(readBuffer,in);
		ReadInt(readBuffer,total);
		fclose(in);
		numberOfTopics += total;
	}
	if (!numberOfTopics) return; // nothing to load

	total = numberOfTopics+1;

	topicNameMap = (char**) AllocateString(NULL,sizeof(char*) * total); 
	for (unsigned int i = 0; i <= numberOfTopics; ++i) topicNameMap[i] = "";

	topicFlagsMap = (unsigned int*) AllocateString(NULL,sizeof(int) * total,false,true); 
	topicChecksumMap = (unsigned int*) AllocateString(NULL,sizeof(unsigned int) * total,false,true);  
	topicRestrictionMap = (char**) AllocateString(NULL,sizeof(char*) * total,false,true); 
	topicUsedMap = (unsigned char**) AllocateString(NULL,sizeof(char*) * total,false,true);  

	topicScriptMap = (char**) AllocateString(NULL,sizeof(char*) * total,false,true);  
	
	topicMaxRule = (unsigned int*) AllocateString(NULL,sizeof(unsigned int*) * total,false,true);
	ruleOffsetMap = (unsigned int**) AllocateString(NULL,sizeof(unsigned int*) * total,false,true); 
	gambitTagMap = (unsigned int**) AllocateString(NULL,sizeof(unsigned int*) * total,false,true); 
	responderTagMap = (unsigned int**) AllocateString(NULL,sizeof(unsigned short*) * total,false,true); 
	topicBytesRulesMap = (unsigned short*) AllocateString(NULL,sizeof(short) * total,false,true);  
	
	topicDebugMap = (unsigned int*) AllocateString(NULL,sizeof(int) * total,false,true);  
	topicDebugRuleMap = (unsigned char**) AllocateString(NULL,sizeof(char*) * total,false,true);  
	
	topicFile = (char**) AllocateString(NULL,sizeof(char*) * total,false,true);  
	topicLastGambittedMap = (unsigned int*) AllocateString(NULL,sizeof(int) * total,false,true);
 	topicLastResponderedMap = (unsigned int*) AllocateString(NULL,sizeof(int) * total,false,true);
	topicLastRejoinderedMap = (unsigned int*) AllocateString(NULL,sizeof(int) * total,false,true);
}

static void AddRecursiveMember(WORDP D, WORDP set)
{
	if (*D->word != '~')
	{
		CreateFact(MakeMeaning(D),Mmember,MakeMeaning(set));
		return;
	}
	if (D->inferMark == inferMark) return; // concept already seen
	D->inferMark = inferMark;
	FACT* F = GetObjectHead(D);
	while (F)
	{
		AddRecursiveMember(Meaning2Word(F->subject),set);
		F = GetObjectNext(F);
	}
}

static void IndirectMembers(WORDP D, uint64 pattern)
{ // we want to recursively get members of this concept, but waited til now for any subset concepts to have been defined
	if (D->systemFlags & DELAYED_RECURSIVE_DIRECT_MEMBER) // this set should acquire all its indirect members now
	{
		NextinferMark();
		D->inferMark = inferMark;
		FACT* F = GetObjectHead(D);
		while (F)
		{
			if (F->verb == Mmember) AddRecursiveMember(Meaning2Word(F->subject),D);
			F = GetObjectNext(F);
		}
	}
}


void LoadTopicSystem() // reload all topic data
{
	//   purge any prior topic system - except any patternword marks made on basic dictionary will remain (doesnt matter if we have too many marked)
	ReturnDictionaryToWordNet(); // return dictionary and string space to pretopic conditions
	*timeStamp0 = *timeStamp1 = 0;

	printf("WordNet: dict=%ld  fact=%ld  stext=%ld %s\r\n",(long int)(dictionaryFree-dictionaryBase),(long int)(factFree-factBase),(long int)(stringBase-stringFree),dictionaryTimeStamp);

	InitTopicMemory();
	ClearBotVariables();
	WORDP wordnetBase = dictionaryFree;
	char* preallocate = stringFree;


	InitKeywords("TOPIC/keywords0.txt",BUILD0); 
	ReadFacts("TOPIC/facts0.txt",BUILD0);
	InitMacros("TOPIC/macros0.txt",BUILD0);
	ReadFacts("TOPIC/dict0.txt",BUILD0); //   FROM topic system build of topics
	ReadPatternData("TOPIC/patternWords0.txt");
	char* prescript = stringFree;
	currentTopicID = 0;
	LoadTopicData("TOPIC/script0.txt",BUILD0);
	LoadPlanData("TOPIC/plans0.txt",BUILD0);

	printf("Build0:  dict=%ld  fact=%ld  dtext=%ld stext=%ld %s %s\r\n",(long int)(dictionaryFree-wordnetBase),(long int)(factFree-wordnetFacts),(long int)(preallocate-prescript),(long int)(prescript-stringFree),timeStamp0,buildStamp0);

	Build0LockDictionary();
	preallocate = stringFree;
	ReadPatternData("TOPIC/patternWords1.txt");
	wordnetBase = dictionaryFree;
	InitKeywords("TOPIC/keywords1.txt",BUILD1);
	InitMacros("TOPIC/macros1.txt",BUILD1);
	ReadFacts("TOPIC/dict1.txt",BUILD1);
	ReadFacts("TOPIC/facts1.txt",BUILD1);
	prescript = stringFree;
	LoadTopicData("TOPIC/script1.txt",BUILD1);
	LoadPlanData("TOPIC/plans1.txt",BUILD1);
	WalkDictionary(IndirectMembers,0); // having read in all concepts, handled delayed word marks

	printf("Build1:  dict=%ld  fact=%ld  dtext=%ld stext=%ld %s %s\r\n",(long int)(dictionaryFree-wordnetBase),(long int)(factFree-build0Facts),(long int)(preallocate-prescript),(long int)(prescript-stringFree),timeStamp1,buildStamp1);
	
	ReadLivePosData(); // any needed concepts must have been defined by now.
	NoteBotVariables();
	preallocate = stringFree;
	StoreWord("$randindex",0);	// so it is before the freeze
    FreezeBasicData();
	Callback(FindWord("^boot"),"()");
}


///////////////////////////////////////////////////////////
/// PENDING TOPICS
///////////////////////////////////////////////////////////

char* ShowPendingTopics()
{
	static char word[MAX_WORD_SIZE];
	*word = 0;
	char* ptr = word;
	for (int i = pendingTopicIndex-1; i >= 0; --i)
	{
		sprintf(ptr,"%s ",GetTopicName(pendingTopicList[i])); 
		ptr += strlen(ptr);
	}
	return word;
}

void GetActiveTopicName(char* buffer)
{
	unsigned int topic = currentTopicID;
	*buffer = 0;

	// the real current topic might be the control topic or a user topic
	// when we are in a user topic, return that or something from the nested depths. Otherwise return most pending topic.
	if (currentTopicID && !(GetTopicFlags(currentTopicID) & (TOPIC_SYSTEM|TOPIC_BLOCKED|TOPIC_NOSTAY))) strcpy(buffer,GetTopicName(currentTopicID,false)); // current topic is valid
	else if (topicIndex) // is one of these topics a valid one
	{
		for (unsigned int i = topicIndex; i > 1; --i) // 0 is always the null topic
		{
			if (!(GetTopicFlags(topicStack[i]) & (TOPIC_SYSTEM|TOPIC_BLOCKED|TOPIC_NOSTAY)))
			{
				strcpy(buffer,GetTopicName(topicStack[i],false));
				break;
			}
		}
	}
	if (!*buffer) // requests current pending topic
	{
		topic = GetPendingTopicUnchanged();
		if (topic) strcpy(buffer,GetTopicName(topic,false));
	}
}

void AddPendingTopic(unsigned int topic)
{	//   these are topics we want to return to
	//   topics added THIS turn are most pending in first stored order
	//   topics added previously should retain their old order 
	// - a topic is pending if user says it is OR we execute the output side of one of its rules (not just the pattern side)
	if (!topic || planning) return;
	if (GetTopicFlags(topic) & (TOPIC_SYSTEM|TOPIC_NOSTAY|TOPIC_BLOCKED)) 	//   cant add this but try its caller
	{
		// may not recurse in topics
		for (unsigned int i = topicIndex; i >= 1; --i) // #1 will always be 0, the prior nontopic
		{
			topic = topicStack[i];
			if (i == 1)  return; // no one to add
			if (GetTopicFlags(topic) & (TOPIC_SYSTEM|TOPIC_NOSTAY|TOPIC_BLOCKED)) continue;	//   cant 
			break;
		}
	}

	bool removed = RemovePendingTopic(topic);	//   remove any old reference
	pendingTopicList[pendingTopicIndex++] = topic;
	if (pendingTopicIndex >= MAX_TOPIC_STACK) memmove(&pendingTopicList[0],&pendingTopicList[1],sizeof(int) * --pendingTopicIndex);
	if (trace & TRACE_OUTPUT && !removed) Log(STDUSERLOG,"Adding pending topic %s\r\n",GetTopicName(topic));
}

void PendingTopics(int set)
{
	SET_FACTSET_COUNT(set,0);
	for (unsigned int i = 0; i < pendingTopicIndex; ++i) AddFact(set,CreateFact(MakeMeaning(FindWord(GetTopicName(pendingTopicList[i]))),Mpending,MakeMeaning(StoreWord(i)),FACTTRANSIENT));  // (~topic pending 3) 
}

bool IsCurrentTopic(unsigned int topic) // see if topic is an already pending one, not current
{
	for (unsigned int i = 0; i < pendingTopicIndex; ++i) 
	{
		if (pendingTopicList[i] == topic) return true;
	}
	return false;
}

void ClearPendingTopics()
{
	 pendingTopicIndex = 0;
}

bool RemovePendingTopic(unsigned int topic)
{
	for (unsigned int i = 0; i < pendingTopicIndex; ++i)
	{
		if (pendingTopicList[i] == topic)
		{
			memmove(&pendingTopicList[i],&pendingTopicList[i+1],sizeof(int) * (--pendingTopicIndex - i));
			return true;
		}
	}
	return false;
}

unsigned int GetPendingTopicUnchanged()
{
	if (!pendingTopicIndex) return 0;	//   nothing there
	return pendingTopicList[pendingTopicIndex-1];
}


///////////////////////////////////////////////////////////
/// EXECUTING CODE TOPICS
///////////////////////////////////////////////////////////

int PushTopic(unsigned int topic) // -1 = failed  0 = unneeded  1 = pushed 
{
	if (topic == currentTopicID) return 0;  // current topic
	else if (!topic)
	{
		ReportBug("PushTopic topic missing")
		return -1;
	}

	// insure topic not already in progress
	for (unsigned int i = 1; i <= topicIndex; ++i) if (topicStack[i] == topic) return -1; // already here
    topicStack[++topicIndex] = currentTopicID; // [1] will be 0 
    if (topicIndex >= MAX_TOPIC_STACK) 
    {
		--topicIndex;
        ReportBug("PusTopic overflow")
        return -1;
    }
	currentTopicID = topic; 
    return 1;
}

void PopTopic()
{
	if (topicIndex) currentTopicID = topicStack[topicIndex--];
	else currentTopicID = 0;	// no topic now
}
#include "common.h"

#define DEFAULT_USER_CACHE 50000

#define NO_CACHEID -1

static unsigned int cacheHead = 0;
static unsigned int* cacheIndex = 0;
char* cacheBase = 0;

int currentCache = NO_CACHEID;
unsigned int userCacheCount = 1; // holds 1 users
unsigned int userCacheSize = DEFAULT_USER_CACHE;
int volleyLimit =  -1; // default save user records to file every n volley

void InitCache(unsigned int dictStringSize)
{
	cacheBase = (char*) malloc(dictStringSize + userTopicStoreSize + userTableSize );
	if (!cacheBase)
	{
		printf("Out of  memory space for dictionary w user cache %d %d %d %d\r\n",dictStringSize,userTopicStoreSize,userTableSize,MAX_ENTRIES);
		ReportBug("Cannot allocate memory space for dictionary %ld\r\n",(long int)(dictStringSize + userTopicStoreSize))
		myexit("out of memory space for dictionary to allocate");
	}
	cacheIndex = (unsigned int*) (cacheBase + userTopicStoreSize);
	char* ptr = cacheBase;
	for (unsigned int i = 0; i < userCacheCount; ++i) 
	{
		*ptr = 0; // item is empty
		ptr += userCacheSize;
		cacheIndex[PRIOR(i)] = i - 1; // before ptr
		cacheIndex[NEXT(i)] = i + 1; // after ptr
	}
	cacheIndex[PRIOR(0)] = userCacheCount-1; // last one as prior
	cacheIndex[NEXT(userCacheCount-1)] = 0;	// start as next one (circular list)
}

void CloseCache()
{
	free(cacheBase);
	cacheBase = NULL;
}

bool WriteCache(unsigned int which,size_t size)
{
	char* ptr = GetCacheBuffer(which);
	if (!*ptr) return false;	// nothing to write out
	if (size == 0) // request to compute size
	{
		size = strlen(ptr) + 1; // login string
		size += strlen(ptr+size);
	}
	FILE* out = FopenWrite(ptr,"wb");
	if (!out) // see if we can create the directory (assuming its missing)
	{
#ifdef WIN32
		system("mkdir USERS");
		out = FopenUTF8Write(ptr);
#endif
		if (!out) 
		{
			ReportBug("cannot open user state file %s to write\r\n",ptr)
			return false;
		}
	}

#ifdef LOCKUSERFILE
#ifdef LINUX
	if (server)
	{
        int fd = fileno(out);
        if (fd < 0) 
		{
			fclose(out);
			return false;
        }

        struct flock fl;
        fl.l_type   = F_WRLCK;  /* F_RDLCK, F_WRLCK, F_UNLCK	*/
        fl.l_whence = SEEK_SET; /* SEEK_SET, SEEK_CUR, SEEK_END */
        fl.l_start  = 0;	/* Offset from l_whence         */
        fl.l_len    = 0;	/* length, 0 = to EOF           */
        fl.l_pid    = getpid(); /* our PID                      */
        if (fcntl(fd, F_SETLKW, &fl) < 0) 
		{
             fclose(out);
             return false;
        }
	}
#endif
#endif

	fwrite(ptr,1,size,out);
	fclose(out);
	cacheIndex[TIMESTAMP(which)] &= 0x00ffffff;	// clear volley count since last written
	return true;
}

void FlushCache()
{
	unsigned int start = cacheHead;
	while (WriteCache(start,0))
	{
		if (cacheIndex[NEXT(start)] == cacheHead) break;	// end of loop
	}
}

static char* GetFreeCache()
{
	if (!userCacheCount) return NULL;
	unsigned int duration = (clock() / 	CLOCKS_PER_SEC) - startSystem; // how many seconds since start of program launch
	// need to find a cache that's free else flush oldest one
	unsigned int last = cacheIndex[PRIOR(cacheHead)];	// PRIOR ptr of list start
	char* ptr = GetCacheBuffer(last);
	if (*ptr) 
	{
		WriteCache(last,0);  // there are none free, we have to use the last (not allowed to fail to get a buffer)
		*ptr = 0; // clear cache so it can be reused
	}
	cacheIndex[TIMESTAMP(last)] = duration; // includes 0 volley count and when this was allocated
	currentCache = cacheHead = last; // just rotate the ring  has more than one block
	return ptr;
}

void FreeUserCache()
{
	if (currentCache != NO_CACHEID )
	{
		char* ptr = GetCacheBuffer(currentCache);
		*ptr = 0;
		cacheHead = cacheIndex[NEXT(currentCache)];
		currentCache = NO_CACHEID;
	}
}

void FreeAllUserCaches()
{
	FlushCache();
	unsigned int start = cacheHead;
	while (userCacheCount)
	{
		start = cacheIndex[NEXT(start)];
		char* ptr = GetCacheBuffer(start);
		*ptr = 0;
		if (start == cacheHead) break;	// end of loop
	}
	currentCache = NO_CACHEID;
}

char* FindUserCache(char* word)
{
	// already in cache?
	unsigned int start = cacheHead;
	while (userCacheCount)
	{
		char* ptr = GetCacheBuffer(start);
		if (!stricmp(ptr,word)) // this is the user
		{
			if (start != cacheHead) // make him FIRST on the list
			{
				unsigned int prior = cacheIndex[PRIOR(start)];
				unsigned int next = cacheIndex[NEXT(start)];
				// decouple from where it is
				cacheIndex[NEXT(prior)] = next;
				cacheIndex[PRIOR(next)] = prior;

				// now insert in front
				prior = cacheIndex[PRIOR(cacheHead)];
				cacheIndex[PRIOR(cacheHead)] = start;

				cacheIndex[NEXT(prior)] = start;
				cacheIndex[PRIOR(start)] = prior;
				cacheIndex[NEXT(start)] = cacheHead;
			}
			currentCache = cacheHead = start;
			return ptr;
		}
		start = cacheIndex[NEXT(start)];
		if (start == cacheHead) break;	// end of loop
	}
	return NULL;
}

char* GetFileRead(char* user,char* computer)
{
	char word[MAX_WORD_SIZE];
	sprintf(word,"USERS/%stopic_%s_%s.txt",GetUserPath(loginID),user,computer);
	char* buffer = FindUserCache(word); // sets currentCache and makes it first if non-zero return
	if (buffer) return buffer;

	// have to go read it
    FILE* in = FopenReadWritten(word); // user topic file
	buffer = GetFreeCache(); // get cache buffer 

#ifdef LOCKUSERFILE
#ifdef LINUX
	if (server && in)
	{
		int fd = fileno(in);
		if (fd < 0) 
		{
		    fclose(in);
			in = 0;
		}
		else
		{
			struct flock fl;
			fl.l_type   = F_RDLCK;  /* F_RDLCK, F_WRLCK, F_UNLCK	*/
			fl.l_whence = SEEK_SET; /* SEEK_SET, SEEK_CUR, SEEK_END */
			fl.l_start  = 0;	/* Offset from l_whence		*/
			fl.l_len    = 0;	/* length, 0 = to EOF		*/
			fl.l_pid    = getpid(); /* our PID			*/
			if (fcntl(fd, F_SETLKW, &fl) < 0) 
			{
				fclose(in);
				in = 0;
			}
		}
	}
#endif
#endif

	if (in) // read in data if file exists
	{
		fseek(in, 0, SEEK_END);
		unsigned int actualSize = (unsigned int) ftell(in);
		if ((int)actualSize != -1) 
		{
			fseek(in, 0, SEEK_SET);
			size_t readit = fread(buffer,1,actualSize,in);	// read it all in
			buffer[readit] = 0;
			if (readit != actualSize) *buffer = 0; // read failure
		}
		fclose(in);
	}
	return buffer;
}

char* GetCacheBuffer(int which)
{
	return (which < 0) ? GetFreeCache() : (cacheBase+(which * userCacheSize)); // NOT from cache system, get a cache buffer
}

void Cache(char* buffer, size_t size) // save into cache
{
	unsigned int duration = (clock() / 	CLOCKS_PER_SEC) - startSystem; // how many seconds since start of program launch

	// dont want to overflow 24bit second store... so reset system start if needed
	if ( duration > 0x000fffff) 
	{
		startSystem = clock() / CLOCKS_PER_SEC; 
		duration = 0; // how many seconds since start of program launch
		// allow all in cache to stay longer
		for (unsigned int i = 0; i < userCacheCount; ++i) cacheIndex[TIMESTAMP(i)] = duration; 
	}

	// write out users that haven't been saved recently
	unsigned int volleys = ( cacheIndex[TIMESTAMP(currentCache)] >> 24) + 1; 
	cacheIndex[TIMESTAMP(currentCache)] = duration | (volleys << 24); 
	if ( (int)volleys >= volleyLimit ) WriteCache(currentCache,size); // writecache clears the volley count
	if (!volleyLimit) FreeUserCache(); // force reload each time

	currentCache = NO_CACHEID;
}
#include "common.h"

#define OVERFLOW_SAFETY_MARGIN 800

#ifndef USERFACTS 
#define USERFACTS 100
#endif
unsigned int userFactCount = USERFACTS;			// how many facts user may save in topic file

//   replies we have tried already
char chatbotSaid[MAX_USED+1][SAID_LIMIT+3];  //   tracks last n messages sent to user
char humanSaid[MAX_USED+1][SAID_LIMIT+3]; //   tracks last n messages sent by user in parallel with userSaid
unsigned int humanSaidIndex;
unsigned int chatbotSaidIndex;

static char* saveVersion = "jan1013";	// format of save file

int userFirstLine = 0;	// start volley of current conversation
uint64 setControl = 0;	// which sets should be saved with user

static char* base;

char computerID[ID_SIZE];
char computerIDwSpace[ID_SIZE];
char loginID[ID_SIZE];    //   user FILE name (lower case)
char loginName[ID_SIZE];    //   user typed name
char callerIP[ID_SIZE];

char timeturn15[100];
char timeturn0[20];
char timePrior[20];

void StartConversation(char* buffer)
{
	*readBuffer = 0;
	nextInput = buffer;
	userFirstLine = inputCount+1;
	OnceCode("$control_pre");
    *currentInput = 0;
	responseIndex = 0;
	ResetSentence();
	Reply();
}

void PartialLogin(char* caller,char* ip)
{
    //   make user name safe for file system
	char*  id = loginID;
	char* at = caller-1;
	char c;
	while ((c = *++at)) 
	{
		if (IsAlphaOrDigit(c)) *id++ = c;
		else if (c == '_' || c == ' ') *id++ = '_';
	}
	*id = 0;

	sprintf(logFilename,"USERS/%slog-%s.txt",GetUserPath(loginID),loginID); // user log goes here

	if (ip) strcpy(callerIP,ip);
	else *callerIP = 0;
}

void Login(char* caller,char* usee,char* ip) //   select the participants
{
	if (!stricmp(usee,"trace")) // enable tracing during login
	{
		trace = (unsigned int) -1;
		echo = true;
		*usee = 0;
	}
    if (*usee) MakeLowerCopy(computerID,usee);
	if (!*computerID) ReadComputerID(); //   we are defaulting the chatee
	if (!*computerID) ReportBug("No default bot?\r\n")

	//   for topic access validation
	*computerIDwSpace = ' ';
	MakeLowerCopy(computerIDwSpace+1,computerID);
	strcat(computerIDwSpace," ");

	if (ip && *ip) // maybe use ip in generating unique login
	{
		if (!stricmp(caller,"guest")) sprintf(caller,"guest%s",ip);
		else if (*caller == '.') sprintf(caller,"%s",ip);
	}
	char* ptr = caller-1;
	while (*++ptr) 
	{
		if (!IsAlphaOrDigit(*ptr) && *ptr != '-' ) *ptr = '_'; // require simple file names
	}

    //   prepare for chat
    PartialLogin(caller,ip);
 }

void ReadComputerID()
{
	strcpy(computerID,"anonymous");
	WORDP D = FindWord("defaultbot",0); // do we have a FACT with the default bot in it as verb
	if (D)
	{
		FACT* F = GetVerbHead(D);
		if (F) MakeLowerCopy(computerID,Meaning2Word(F->subject)->word);
	}
}

void ResetUser()
{
 	chatbotSaidIndex = humanSaidIndex = 0;
	setControl = 0;
	for (unsigned int i = 1; i < MAX_FIND_SETS; ++i) SET_FACTSET_COUNT(i,0);
}

static char* SafeLine(char* line) // erase cr/nl to keep reads safe
{
	char* start = line;
	char c;
    while ((c = *++line))
    {
        if (c == '\r' || c == '\n') *line = ' ';  
    }
	return start;
}

static char* WriteUserFacts(char* ptr)
{
    //   write out fact sets first, before destroying any transient facts
	sprintf(ptr,"%x #set flags\r\n",(unsigned int) setControl);
	ptr += strlen(ptr);
	unsigned int i;
    unsigned int count;
	for (i = 1; i < MAX_FIND_SETS; ++i) 
    {
		if (!(setControl & (uint64) (1 << i))) continue; // purely transient stuff

		//   remove dead references
		FACT** set = factSet[i];
        count = (ulong_t) set[0];
		unsigned int j;
        for (j = 1; j <= count; ++j)
		{
			FACT* F = set[j];
			if (!F || F->flags & FACTDEAD)
			{
				memmove(&set[j],&set[j+1],sizeof(FACT*) * (count - j));
				--count;
				--j;
			}
		}
        if (!count) continue;

		// save this set
		sprintf(ptr,"#set %d\r\n",i); 
		ptr += strlen(ptr);
        for (j = 1; j <= count; ++j)
		{
			WriteFact(factSet[i][j],false,ptr,false,true);
			ptr += strlen(ptr);
			if ((size_t)(ptr-base) > (size_t)(userCacheSize-1000)) break; // close to overflowing buffer
		}
    }
	strcpy(ptr,"#`end fact sets\r\n");
	ptr += strlen(ptr);

	// most recent facts, in order
	FACT* F = factFree+1;
	count = userFactCount;
	while (count && --F > factLocked) // backwards down to base system facts
	{
		if (!(F->flags & (FACTDEAD|FACTTRANSIENT))) --count; // we will write this
	}

	--F;  
 	while (++F <= factFree)  
	{
		if (!(F->flags & (FACTDEAD|FACTTRANSIENT))) 
		{
			WriteFact(F,true,ptr,false,true);
			ptr += strlen(ptr);
		}
	}
	//ClearUserFacts();
	strcpy(ptr,"#`end user facts\r\n");
	ptr += strlen(ptr);

	return ptr;
}

static bool ReadUserFacts()
{	
    //   read in fact sets
    char word[MAX_WORD_SIZE];
    *word = 0;
    ReadALine(readBuffer, 0); //   setControl
	ReadHex(readBuffer,setControl);
    while (ReadALine(readBuffer, 0)) 
    {
		if (*readBuffer == '#' && readBuffer[1] == '`') break; // end of sets to read
		char* ptr = ReadCompiledWord(readBuffer,word);
        unsigned int setid;
        ptr = ReadInt(ptr,setid); 
		SET_FACTSET_COUNT(setid,0);
		if (trace & TRACE_USER) Log(STDUSERLOG,"Facts[%d]\r\n",setid);
	    while (ReadALine(readBuffer, 0)) 
		{
			if (*readBuffer == '#') break;
			char* ptr = readBuffer;
			FACT* F = ReadFact(ptr);
			if (F) AddFact(setid,F);
			if (trace & TRACE_USER) TraceFact(F);
        }
		if (*readBuffer == '#' && readBuffer[1] == '`') break;
	}
	if (strcmp(readBuffer,"#`end fact sets")) 
	{
		ReportBug("Bad fact sets alignment\r\n")
		return false;
	}

	// read long-term user facts
	while (ReadALine(readBuffer, 0)) 
	{
		if (*readBuffer == '#' && readBuffer[1] == '`') break;
		char* data = readBuffer;
		if (*data == '(' && strchr(data,')')) ReadFact(data);
		else 
		{
			ReportBug("Bad user fact %s\r\n",readBuffer)
			return false;
		}
	}	
    if (strcmp(readBuffer,"#`end user facts")) 
	{
		ReportBug("Bad user facts alignment\r\n")
		return false;
	}

	return true;
}

static char* WriteRecentMessages(char* ptr)
{
    //   recent human inputs
	int start = humanSaidIndex - 20; 
	if (start < 0) start = 0;
	unsigned int i;
    for (i = start; i < (unsigned int)humanSaidIndex; ++i)  
	{
		size_t len = strlen(humanSaid[i]);
		if (len == 0) continue;
		if ((unsigned int)(ptr - base) >= (userCacheSize - OVERFLOW_SAFETY_MARGIN - len)) break;
		sprintf(ptr,"%s\r\n",SafeLine(humanSaid[i]));
		ptr += strlen(ptr);
	}
	strcpy(ptr,"#`end user\r\n");
	ptr += strlen(ptr);
	
	// recent chatbot outputs
 	start = chatbotSaidIndex - 20;
	if (start < 0) start = 0;
    for (i = start; i < (int)chatbotSaidIndex; ++i) 
	{
		size_t len = strlen(chatbotSaid[i]);
		if (len == 0) continue;
		if ((unsigned int)(ptr - base) >= (userCacheSize - OVERFLOW_SAFETY_MARGIN - len)) break;
		sprintf(ptr,"%s\r\n",SafeLine(chatbotSaid[i]));
		ptr += strlen(ptr);
	}
	strcpy(ptr,"#`end chatbot\r\n");
	ptr += strlen(ptr);

	return ptr;
}

static bool ReadRecentMessages()
{
    for (humanSaidIndex = 0; humanSaidIndex <= MAX_USED; ++humanSaidIndex) 
    {
        ReadALine(humanSaid[humanSaidIndex], 0);
		if (*humanSaid[humanSaidIndex] == '#' && humanSaid[humanSaidIndex][1] == '`') break; // #end
    }
	if (humanSaidIndex > MAX_USED || strcmp(humanSaid[humanSaidIndex],"#`end user"))  // failure to end right
	{
		humanSaidIndex = 0;
		chatbotSaidIndex = 0;
		ReportBug("bad humansaid")
		return false;
	}
	else *humanSaid[humanSaidIndex] = 0;

	for (chatbotSaidIndex = 0; chatbotSaidIndex <= MAX_USED; ++chatbotSaidIndex) 
    {
        ReadALine(chatbotSaid[chatbotSaidIndex], 0);
		if (*chatbotSaid[chatbotSaidIndex] == '#' && chatbotSaid[chatbotSaidIndex][1] == '`') break; // #end
    }
	if (chatbotSaidIndex > MAX_USED || strcmp(chatbotSaid[chatbotSaidIndex],"#`end chatbot")) // failure to end right
	{
		chatbotSaidIndex = 0;
		ReportBug("Bad message alignment\r\n")
		return false;
	}
	else *chatbotSaid[chatbotSaidIndex] = 0;

	return true;
}

char* WriteVariables(char* ptr)
{
    while (userVariableIndex)
    {
        WORDP D = userVariableList[--userVariableIndex];
        if (!(D->internalBits & VAR_CHANGED) ) continue; 
		if (*D->word != '$') ReportBug("Bad user variable to save %s\r\n",D->word)
        else if (D->word[1] !=  '$' && D->w.userValue) // transients not dumped, nor are NULL values
		{
			char* val = D->w.userValue;
			while ((val = strchr(val,'\n'))) *val = ' '; //  clean out newlines
			sprintf(ptr,"%s=%s\r\n",D->word,SafeLine(D->w.userValue));
			ptr += strlen(ptr);
		}
        D->w.userValue = NULL;
		RemoveInternalFlag(D,VAR_CHANGED);
    }
	strcpy(ptr,"#`end variables\r\n");
	ptr += strlen(ptr);
	
	return ptr;
}

static bool ReadVariables()
{
	while (ReadALine(readBuffer, 0)) //   user variables
	{
		if (*readBuffer != '$') break; // end of variables
        char* ptr = strchr(readBuffer,'=');
        *ptr = 0; // isolate user var name from rest of buffer
        SetUserVariable(readBuffer,ptr+1);
    }

	if (strcmp(readBuffer,"#`end variables")) 
	{
		ReportBug("Bad variable alignment\r\n")
		return false;
	}
	return true;
}

static char* GatherUserData(char* ptr,time_t curr)
{
	if (!timeturn15[1] && inputCount >= 15 && responseIndex) sprintf(timeturn15,"%lu-%d%s",(unsigned long)curr,responseData[0].topic,responseData[0].id); // delimit time of turn 15 and location...
	sprintf(ptr,"%s %s %s %s |\n",saveVersion,timeturn0,timePrior,timeturn15); 
	ptr += strlen(ptr);
	ptr = WriteTopicData(ptr);
	ptr = WriteVariables(ptr);
	ptr = WriteUserFacts(ptr);
	ptr = WriteRecentMessages(ptr);
	*ptr++ = 0;
		
	if ((unsigned int) (ptr - base) >= (userCacheSize - OVERFLOW_SAFETY_MARGIN) ) ReportBug("User File too big for buffer %ld vs %ld\r\n",(long int)(ptr-base),(long int)userCacheSize) // too big

	return ptr;
}

void WriteUserData(time_t curr)
{ 
	if (!numberOfTopics)  return; //   no topics ever loaded or we are not responding
	if (!userCacheCount) return;	// never save users - no history
	char* buffer = GetCacheBuffer(currentCache);
	if (!buffer) return;
	base = buffer;	// global current buffer for saving
	sprintf(buffer,"USERS/%stopic_%s_%s.txt",GetUserPath(loginID),loginID,computerID);

#ifndef DISCARDTESTING
	if (!server && !documentMode) CopyFile2File("TMP/backup.txt",buffer,false);	// backup for debugging
#endif

	char* ptr = GatherUserData(base+strlen(base)+1,curr);
	Cache(base,ptr-base);
}

void ReadUserData(char* ptr) // passed  buffer with file content (where feasible)
{	
	tokenControl = 0;
	ResetUser();
	char* buffer = ptr;
	size_t len = 0;
	char junk[MAX_WORD_SIZE];
	*junk = 0;
	strcpy(timePrior,"0");
	strcpy(timeturn15,"0");
	strcpy(timeturn0,"0");
	if (buffer && *buffer != 0) // readable data
	{ 
		len = strlen(buffer);
		if (len > 100) // supposed to just be user filename info. compensate
		{
			char junk[MAX_WORD_SIZE];
			char* p = ReadCompiledWord(buffer,junk);
			len = p - buffer - 1; 
		}
		userRecordSourceBuffer = buffer + len + 1;
		ReadALine(readBuffer,0);
		char* x = ReadCompiledWord(readBuffer,junk);
		x = ReadCompiledWord(x,timeturn0); // the start stamp id if there
		x = ReadCompiledWord(x,timePrior); // the prior stamp id if there
		ReadCompiledWord(x,timeturn15); // the timeturn id if there
		if (stricmp(junk,saveVersion)) *buffer = 0;// obsolete format
	}
    if (!buffer || !*buffer) 
	{
		ReadNewUser();
		strcpy(timeturn0,GetMyTime(time(0))); // startup time
	}
	else
	{
		if (!ReadTopicData()) return;
		if (!ReadVariables()) return;
		if (!ReadUserFacts()) return;
		if (!ReadRecentMessages()) return;
		randIndex = atoi(GetUserVariable("$randindex")) + (inputCount % MAXRAND);	// rand base assigned to user
	}
}

void ReadNewUser()
{
	ResetUser();
	ClearUserVariables();
	ClearUserFacts();
	ResetTopicSystem();
	userFirstLine = 1;
	tokenControl = 0;
	inputCount = 0;

	//   set his random seed
	unsigned int rand = (unsigned int) Hashit((unsigned char *) loginID,strlen(loginID));
	char word[MAX_WORD_SIZE];
	randIndex = rand & 4095;
    sprintf(word,"%d",randIndex);
	SetUserVariable("$randindex",word ); 
	strcpy(word,computerID);
	*word = toUppercaseData[(unsigned char)*word];
	SetUserVariable("$bot",word ); 
	SetUserVariable("$login",loginName);

	sprintf(readBuffer,"^%s",computerID);
	WORDP D = FindWord(readBuffer,0,LOWERCASE_LOOKUP);
	if (!D) return;

	char* buffer = AllocateBuffer();
	*buffer = 0;
	PushOutputBuffers();
	currentRuleOutputBase = currentOutputBase = buffer;
	ChangeDepth(2,"ReadNewUser");
	unsigned int result;
	DoFunction(D->word,buffer,buffer,result);
	PopOutputBuffers();
	ChangeDepth(-2,"ReadNewUser");
	FreeBuffer();

	char* value = GetUserVariable("$token");
	int64 v;
	ReadInt64(value,v);
	tokenControl = (*value) ? v : (DO_SUBSTITUTE_SYSTEM | DO_INTERJECTION_SPLITTING | DO_PROPERNAME_MERGE | DO_NUMBER_MERGE | DO_SPELLCHECK);
	inputRejoinderTopic = inputRejoinderRuleID = NO_REJOINDER; 
}
// variableSystem.cpp - manage user variables ($variables)

#include "common.h"

#ifdef INFORMATION
There are 5 kinds of variables.
	1. User variables beginning wih $ (regular and transient which begin with $$)
	2. Wildcard variables beginning with _
	3. Fact sets beginning with @ 
	4. Function variables beginning with ^ 
	5. System variables beginning with % 
#endif

int impliedSet = ALREADY_HANDLED;	// what fact set is involved in operation
int impliedWild = ALREADY_HANDLED;	// what wildcard is involved in operation

unsigned int wildcardIndex = 0;
char wildcardOriginalText[MAX_WILDCARDS+1][MAX_WORD_SIZE];  // spot wild cards can be stored
char wildcardCanonicalText[MAX_WILDCARDS+1][MAX_WORD_SIZE];  // spot wild cards can be stored
unsigned int wildcardPosition[MAX_WILDCARDS+1]; // spot it started and ended in sentence

//   list of active variables needing saving

#define MAX_USERVAR_SIZE 999
WORDP userVariableList[MAX_USER_VARS];	// variables read in from user file
WORDP botVariableList[MAX_USER_VARS];	// variables created by bot load
static char* baseVariableValues[MAX_USER_VARS];
unsigned int userVariableIndex;
unsigned int botVariableIndex;

void InitVariableSystem()
{
	botVariableIndex = userVariableIndex = 0;
}

int GetWildcardID(char* x) // wildcard id is "_10" or "_3"
{
	if (!IsDigit(x[1])) return -1;
	unsigned int n = x[1] - '0';
	char c = x[2];
	if (IsDigit(c)) n =  (n * 10) + (c - '0');
	return (n > MAX_WILDCARDS) ? -1 : n; 
}

static void CompleteWildcard()
{
	WORDP D = FindWord(wildcardCanonicalText[wildcardIndex]);
	if (D && D->properties & D->internalBits & UPPERCASE_HASH)  
	{
		UpcaseStarters(wildcardOriginalText[wildcardIndex]);
		UpcaseStarters(wildcardCanonicalText[wildcardIndex]);
	}

    ++wildcardIndex;
	if (wildcardIndex > MAX_WILDCARDS) wildcardIndex = 0; 
}

void SetWildCard(unsigned int start, unsigned int end)
{
	if (end < start) end = start;				// matched within a token
	if (end > wordCount) end = wordCount;
    wildcardPosition[wildcardIndex] = start | (end << 16);
    *wildcardOriginalText[wildcardIndex] = 0;
    *wildcardCanonicalText[wildcardIndex] = 0;
	if (start == 0 || wordCount == 0 || (end == 0 && start != 1) ) // null match, like _{ .. }
	{
		++wildcardIndex;
		if (wildcardIndex > MAX_WILDCARDS) wildcardIndex = 0; 
	}
	else // did match
	{
		// concatenate the match value
		bool started = false;
		for (unsigned int i = start; i <= end; ++i)
		{
			char* word = wordStarts[i];
			if (*word == ',') continue; // ignore commas
			if (started) 
			{
				strcat(wildcardOriginalText[wildcardIndex]," ");
				strcat(wildcardCanonicalText[wildcardIndex]," ");
			}
			else started = true;
			strcat(wildcardOriginalText[wildcardIndex],word);
			strcat(wildcardCanonicalText[wildcardIndex],wordCanonical[i]);
		}
 		if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"_%d=%s/%s ",wildcardIndex,wildcardOriginalText[wildcardIndex],wildcardCanonicalText[wildcardIndex]);
		CompleteWildcard();
	}
}

void SetWildCardIndexStart(unsigned int index)
{
	 wildcardIndex = index;
}

void SetWildCard(char* value, char* canonicalValue,const char* index,unsigned int position)
{
	// adjust values to assign
	if (!value) value = "";
	if (!canonicalValue) canonicalValue = "";
    if (strlen(value) > MAX_USERVAR_SIZE) 
	{
		value[MAX_USERVAR_SIZE] = 0;
		ReportBug("long original value %s",value)
	}
     if (strlen(canonicalValue) > MAX_USERVAR_SIZE) 
	{
		canonicalValue[MAX_USERVAR_SIZE] = 0;
		ReportBug("long canonnical value %s",value)
	}
	while (value[0] == ' ') ++value; 
    while (canonicalValue && canonicalValue[0] == ' ') ++canonicalValue;

	// store the values
	if (index) wildcardIndex = GetWildcardID((char*)index); 
    strcpy(wildcardOriginalText[wildcardIndex],value);
    strcpy(wildcardCanonicalText[wildcardIndex],(canonicalValue) ? canonicalValue : value);
    wildcardPosition[wildcardIndex] = position | (position << 16); 
  
	CompleteWildcard();
}

char* GetwildcardText(unsigned int i, bool canon)
{
	if (i > MAX_WILDCARDS) return "";
    return canon ? wildcardCanonicalText[i] : wildcardOriginalText[i];
}

char* GetUserVariable(const char* word)
{
	WORDP D = FindWord((char*) word,0,LOWERCASE_LOOKUP);
	if (!D)  return "";	//   no such variable

	char* item = D->w.userValue;
    if (!item)  return ""; // null value
    return (*item == '&') ? (item + 1) : item; //   value is quoted or not
 }

void ClearUserVariableSetFlags()
{
	for (unsigned int i = 0; i < userVariableIndex; ++i) RemoveInternalFlag(userVariableList[i],VAR_CHANGED);
}

void ShowChangedVariables()
{
	for (unsigned int i = 0; i < userVariableIndex; ++i) 
	{
		if (userVariableList[i]->internalBits & VAR_CHANGED)
		{
			char* value = userVariableList[i]->w.userValue;
			if (value && *value) Log(1,"%s = %s\r\n",userVariableList[i]->word,value);
			else Log(1,"%s = null\r\n",userVariableList[i]->word);
		}
	}
}

static WORDP CreateUserVariable(const char* var, char* value)
{
	char word[MAX_WORD_SIZE];
	MakeLowerCopy(word,(char*)var);
    WORDP D = StoreWord(word);				// find or create the var.
	if (!D) return NULL; // ran out of memory
    if (!(D->internalBits & VAR_CHANGED))	// not changed already this volley
    {
        userVariableList[userVariableIndex++] = D;
        if (userVariableIndex == MAX_USER_VARS) // if too many variables, discard one (wont get written)
        {
            --userVariableIndex;
            ReportBug("too many user vars");
        }
		D->w.userValue = NULL; 
		AddInternalFlag(D,VAR_CHANGED);
	}
	if (planning) // handle undoable assignment
	{
		if (D->w.userValue == NULL) SpecialFact(MakeMeaning(D),(MEANING)1,0);
		else SpecialFact(MakeMeaning(D),(MEANING) (D->w.userValue - stringBase ),0);
	}
	D->w.userValue = value; 
	return D;
}

void SetUserVariable(const char* var, char* word)
{
	// adjust value
	if (word) // has a nonnull value?
	{
		if (!*word || !stricmp(word,"null") || !stricmp(word,"nil")) word = NULL; // really is null
		else //   some value 
		{
			while (*word == ' ') ++word; // skip leading blanks
			word = AllocateString(word);
			if (!word) return;
			size_t len = strlen(word);
			if (len > MAX_USERVAR_SIZE) word[MAX_USERVAR_SIZE + 1] = 0; // limit on user vars same as match vars
		}
	}
 
	WORDP D = CreateUserVariable(var,word);
	if (!D) return;
	// tokencontrol changes are noticed by the engine
	if (!strcmp(var,"$token")) 
	{
		int64 val = 0;
		if (word && *word) ReadInt64(word,val);
		else val = (DO_INTERJECTION_SPLITTING|DO_SUBSTITUTE_SYSTEM|DO_NUMBER_MERGE|DO_PROPERNAME_MERGE|DO_SPELLCHECK);
		tokenControl = val;
	}
	if (trace == TRACE_VARIABLESET) Log(STDUSERLOG,"Var: %s -> %s\r\n",D->word,word);
}

void Add2UserVariable(char* var, char* moreValue,char minusflag)
{
	// get original value
	char* oldValue;
    if (*var == '_') oldValue = GetwildcardText(GetWildcardID(var),true); // onto a wildcard
	else if (*var == '$') oldValue = GetUserVariable(var); // onto user variable
	else if (*var == '^') oldValue = callArgumentList[atoi(var+1)+fnVarBase]; // onto function argument
	else return; // illegal

	// get augment value
	if (*moreValue == '_') moreValue = GetwildcardText(GetWildcardID(moreValue),true); 
	else if (*moreValue == '$') moreValue = GetUserVariable(moreValue); 
	else if (*moreValue == '^') moreValue = callArgumentList[atoi(moreValue+1)+fnVarBase];

	// perform numeric op
	bool floating = false;
	if (strchr(oldValue,'.') || strchr(moreValue,'.') ) floating = true; 
	char result[MAX_WORD_SIZE];
	if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"%s %c %s ",var,minusflag,moreValue);

    if (floating)
    {
        float newval = (float)atof(oldValue);
		float more = (float)atof(moreValue);
        if (minusflag == '-') newval -= more;
        else if (minusflag == '*') newval *= more;
        else if (minusflag == '/') newval /= more;
		else if (minusflag == '%') 
		{
			int64 ivalue = (int64) newval;
			int64 morval = (int64) more;
			newval = (float) (ivalue % morval);
		}
        else newval += more;
        sprintf(result,"%.2f",newval);
    }
    else
    {
		int64 newval;
		ReadInt64(oldValue,newval);
		int64 more;
		ReadInt64(moreValue,more);
        if (minusflag == '-') newval -= more;
        else if (minusflag == '*') newval *= more;
        else if (minusflag == '/') 
		{
			if (more == 0) 
				return; // cannot divide by 0
			newval /= more;
		}
        else if (minusflag == '%') newval %= more;
        else if (minusflag == '|') newval |= more;
        else if (minusflag == '&') newval &= more;
        else if (minusflag == '^') newval ^= more;
        else if (minusflag == '<') newval <<= more;
        else if (minusflag == '>') newval >>= more;
       else newval += more;
#ifdef WIN32
		 sprintf(result,"%I64d",newval); 
#else
		 sprintf(result,"%lld",newval); 
#endif        
    }

	// store result back
	if (*var == '_')  SetWildCard(result,result,var,0); 
	else if (*var == '$') SetUserVariable(var,result);
	else if (*var == '^') strcpy(callArgumentList[atoi(var+1)+fnVarBase],result); 
	if (trace & TRACE_OUTPUT) Log(STDUSERLOG,"=> %s ",result);
}

void ReestablishBotVariables() // refresh bot variables
{
	for (unsigned int i = 0; i < botVariableIndex; ++i) botVariableList[i]->w.userValue = baseVariableValues[i];
}

void ClearBotVariables()
{
	botVariableIndex = 0;
}

void NoteBotVariables() // system defined variables
{
	if (userVariableIndex) printf("Read %s Variables\r\n",StdIntOutput(userVariableIndex));
	botVariableIndex = userVariableIndex;
	for (unsigned int i = 0; i < botVariableIndex; ++i)
	{
		botVariableList[i] = userVariableList[i];
		baseVariableValues[i] = botVariableList[i]->w.userValue;
	}
	ClearUserVariables();
}

void ClearUserVariables()
{
	while (userVariableIndex)
	{
		WORDP D = userVariableList[--userVariableIndex];
		D->w.userValue = NULL;
		RemoveInternalFlag(D,VAR_CHANGED);
 	}
}

void DumpVariables()
{
	char* value;
	for (unsigned int i = 0; i < botVariableIndex; ++i) 
	{
		value = botVariableList[i]->w.userValue;
		if (value && *value)  Log(STDUSERLOG,"  bot variable: %s = %s\r\n",botVariableList[i],value);
	}

	for (unsigned int i = 0; i < userVariableIndex; ++i)
	{
		WORDP D = userVariableList[i];
		value = D->w.userValue;
		if (value && *value)  
		{
			if (!stricmp(D->word,"$token"))
			{
				Log(STDUSERLOG,"  variable: decoded %s = ",D->word);
				int64 val;
				ReadInt64(value,val);
				DumpTokenControls(val);
				Log(STDUSERLOG,"\r\n");
			}
			else Log(STDUSERLOG,"  variable: %s = %s\r\n",D->word,value);
		}
	}
}

char* PerformAssignment(char* word,char* ptr,unsigned int &result)
{// assign to and from  $var, _var, ^var, @set, and %sysvar
    char op[MAX_WORD_SIZE];
	ChangeDepth(2,"PerformAssignment");
	char* word1 = AllocateBuffer();
	FACT* F = currentFact;
	currentFact = NULL;					// did createfact  creat OR find
	int oldImpliedSet = impliedSet;		// in case nested calls happen
	int oldImpliedWild = impliedWild;	// in case nested calls happen
    int assignFromWild = ALREADY_HANDLED;
	result = 0;
	impliedSet = (*word == '@') ? GetSetID(word) : ALREADY_HANDLED;			// if a set save location
	impliedWild = (*word == '_') ? GetWildcardID(word) : ALREADY_HANDLED;	// if a wildcard save location
	int setToImply = impliedSet;
	int setToWild = impliedWild;

	if (*word == '^') // function variable must be changed to actual value. can never replace a function variable binding
	{
		ReadShortCommandArg(word,word1,result,OUTPUT_NOTREALBUFFER);
		if (result & ENDCODES) goto exit; // failed
		strcpy(word,word1);
	}

	// Get assignment operator
    ptr = ReadCompiledWord(ptr,op); // assignment operator = += -= /= *= %= 
	if (trace & TRACE_OUTPUT) Log(STDUSERTABLOG,"%s %s ",word,op);
 
	// get the from value
	assignFromWild =  (*ptr == '_' && IsDigit(ptr[1])) ? GetWildcardID(ptr)  : -1;
	if (assignFromWild >= 0 && *word == '_') ptr = ReadCompiledWord(ptr,word1); // assigning from wild to wild. Just copy across
	else
	{
		ptr = ReadCommandArg(ptr,word1,result,OUTPUT_NOTREALBUFFER);
		if (*word1 == '#') // substitute a constant? user type-in :set command for example
		{
			uint64 n = FindValueByName(word1+1);
			if (!n) n = FindValue2ByName(word1+1);
			if (n) sprintf(word1,"%lld",n);
		}
		if (result & ENDCODES) goto exit;
		// A fact was created but not used up by retrieving some field of it. Convert to a reference to fact.
		if (currentFact && setToImply == impliedSet && setToWild == impliedWild) sprintf(word1,"%d",currentFactIndex());
		if (!currentFact) currentFact = F; // revert current fact to what it was before now
	}
   	if (!stricmp(word1,"null") || !stricmp(word1,"nil")) *word1 = 0;

	//   now sort out who we are assigning into and if its arithmetic or simple assign

	if (*word == '@')
	{
		if (!*word1) // null assign to set
		{
			SET_FACTSET_COUNT(impliedSet,0);
			factSetNext[impliedSet] = 0;
		}
		else if (*word1 == '@') // set to set operator
		{
			FACT* F;
			unsigned int rightSet = GetSetID(word1);
			unsigned int rightCount =  FACTSET_COUNT(rightSet);
			unsigned int impliedCount =  FACTSET_COUNT(impliedSet); 
			if (*op == '+') while (rightCount) AddFact(impliedSet,factSet[rightSet][rightCount--]); // add set to set preserving order
			else if (*op == '-') // remove from set
			{
				for (unsigned int i = 1; i <= rightCount; ++i) factSet[rightSet][i]->flags |= MARKED_FACT; // mark right facts
				for (unsigned int i = 1; i <= impliedCount; ++i) // erase from the left side
				{ 
					F = factSet[impliedSet][i];
					if (F->flags & MARKED_FACT)
					{
						memmove(&factSet[impliedSet][i],&factSet[impliedSet][i+1], (impliedCount - i)* sizeof(FACT*));
						--impliedCount; // new end count
						--i; // redo loop at this point
					}
				}
				for (unsigned int i = 1; i <= rightCount; ++i) factSet[rightSet][i]->flags ^= MARKED_FACT; // erase marks
				SET_FACTSET_COUNT(impliedSet,impliedCount);
			}
			else if (*op == '=') memmove(&factSet[impliedSet][0],&factSet[rightSet][0], (rightCount+1) * sizeof(FACT*)); // assigned from set
			else result = FAILRULE_BIT;
		}
		else if (IsDigit(*word1)) // fact index to set operators
		{
			unsigned int index;
			ReadInt(word1,index);
			FACT* F = Index2Fact(index);
			if (!F) ReportBug("Value not a fact id - %s",word1)
			unsigned int impliedCount =  FACTSET_COUNT(impliedSet); 
			if (!F)// failed to find a fact
			{
				if (*op == '=') SET_FACTSET_COUNT(impliedSet,0);
				else result = FAILRULE_BIT;
			}
			else if (*op == '+') AddFact(impliedSet,F); // add to set
			else if (*op == '-') // remove from set
			{
				F->flags |= MARKED_FACT;
				for (unsigned int i = 1; i <= impliedCount; ++i) // erase from the left side
				{ 
					FACT* G = factSet[impliedSet][i];
					if (G->flags & MARKED_FACT)
					{
						memmove(&factSet[impliedSet][i],&factSet[impliedSet][i+1], (impliedCount - i)* sizeof(FACT*) );
						--impliedCount;
						--i;
					}
				}
				SET_FACTSET_COUNT(impliedSet,impliedCount);
				F->flags ^= MARKED_FACT;
			}
			else if (*op == '=') // assign to set
			{
				SET_FACTSET_COUNT(impliedSet,0);
				AddFact(impliedSet,F);
			}
			else result = FAILRULE_BIT;
		}
		if (FACTSET_COUNT(impliedSet) == 0) factSetNext[impliedSet] = 0; // set going empty requires a reset of next ptr
		impliedSet = ALREADY_HANDLED;
	}
	else if (IsArithmeticOperator(op)) Add2UserVariable(word,word1,*op);
	else if (*word == '_') //   assign to wild card
	{
		if (impliedWild != ALREADY_HANDLED) // no one has actually done the assignnment yet
		{
			if (assignFromWild >= 0) // full tranfer of data
			{
				SetWildCard(wildcardOriginalText[assignFromWild],wildcardCanonicalText[assignFromWild],word,0); 
				wildcardPosition[GetWildcardID(word)] =  wildcardPosition[assignFromWild];
			}
			else SetWildCard(word1,word1,word,0); 
		}
	}
	else if (*word == '$') SetUserVariable(word,word1);
	else if (*word == '\'' && word[1] == '$') SetUserVariable(word+1,word1); // '$xx = value  -- like passed thru as argument
	else if (*word == '%') SystemVariable(word,word1); 
	else // if (*word == '^') // cannot touch a function argument, word, or number
	{
		result = FAILRULE_BIT;
		goto exit;
	}

	//  followup arithmetic operators?
	while (ptr && IsArithmeticOperator(ptr))
	{
		ptr = ReadCompiledWord(ptr,op);
		ptr = ReadCommandArg(ptr,word1,result); 
		if (result & ENDCODES) goto exit; // failed next value
		Add2UserVariable(word,word1,*op);
	}

	// debug
	if (trace & TRACE_OUTPUT)
	{
		char* answer = AllocateBuffer();
		unsigned int result;
		logUpdated = false;
		if (*word == '$') strcpy(answer,GetUserVariable(word));
		else if (*word == '_') strcpy(answer,wildcardOriginalText[GetWildcardID(word)]);
		else if (*word == '@') sprintf(answer,"[%d]",FACTSET_COUNT(GetSetID(word))); // show set count
		else FreshOutput(word,answer,result,OUTPUT_SILENT,MAX_WORD_SIZE);
		if (!*answer) 
		{
			if (logUpdated) Log(STDUSERTABLOG,"=> null  end-assign\r\n");
			else Log(1,"null \r\n");
		}
		else if (logUpdated) Log(STDUSERTABLOG,"=> %s  end-assign\r\n",answer);
		else Log(1," %s  \r\n",answer);
		FreeBuffer();
	}

exit:
	FreeBuffer();
	ChangeDepth(-2,"PerformAssignment");
	impliedSet = oldImpliedSet;
	impliedWild = oldImpliedWild;
	return ptr;
}

